var yI = Object.defineProperty;
var bI = (r, e, t) => e in r ? yI(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;
var Da = (r, e, t) => bI(r, typeof e != "symbol" ? e + "" : e, t);
import * as w from "react";
import Ct, { useState as _e, useRef as Ke, useCallback as Se, useEffect as we, isValidElement as _r, Children as go, forwardRef as Kt, useContext as un, createContext as dn, PureComponent as Kr, cloneElement as fn, createElement as Vb, useImperativeHandle as xI, useMemo as Jt, Component as $n, useLayoutEffect as EI } from "react";
import { Card as br, Avatar as ml, Button as xe, ProgressIndicator as Wb, TimeIndicator as SI, StatusDot as TI, Badge as AI, DropdownMenu as Cf, DropdownMenuTrigger as kf, DropdownMenuContent as Mf, DropdownMenuItem as Dn, Icon as er, cn as Hb, Alert as wI, Label as ys, Textarea as gm, Input as II, Modal as PI, useToast as _I } from "@wheel/ui";
import { useInterval as qb, useProgress as LI } from "@wheel/shared";
import { cn as zb } from "@wheel/shared/utils/cn";
import { createPortal as Nf } from "react-dom";
function hn(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
var Ca = { exports: {} }, bs = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var mm;
function OI() {
  if (mm) return bs;
  mm = 1;
  var r = Ct, e = Symbol.for("react.element"), t = Symbol.for("react.fragment"), n = Object.prototype.hasOwnProperty, i = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, s = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(o, c, l) {
    var u, d = {}, f = null, h = null;
    l !== void 0 && (f = "" + l), c.key !== void 0 && (f = "" + c.key), c.ref !== void 0 && (h = c.ref);
    for (u in c) n.call(c, u) && !s.hasOwnProperty(u) && (d[u] = c[u]);
    if (o && o.defaultProps) for (u in c = o.defaultProps, c) d[u] === void 0 && (d[u] = c[u]);
    return { $$typeof: e, type: o, key: f, ref: h, props: d, _owner: i.current };
  }
  return bs.Fragment = t, bs.jsx = a, bs.jsxs = a, bs;
}
var xs = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var pm;
function RI() {
  return pm || (pm = 1, process.env.NODE_ENV !== "production" && function() {
    var r = Ct, e = Symbol.for("react.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), o = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), l = Symbol.for("react.suspense"), u = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), f = Symbol.for("react.lazy"), h = Symbol.for("react.offscreen"), g = Symbol.iterator, m = "@@iterator";
    function p(O) {
      if (O === null || typeof O != "object")
        return null;
      var W = g && O[g] || O[m];
      return typeof W == "function" ? W : null;
    }
    var v = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function y(O) {
      {
        for (var W = arguments.length, Z = new Array(W > 1 ? W - 1 : 0), ce = 1; ce < W; ce++)
          Z[ce - 1] = arguments[ce];
        b("error", O, Z);
      }
    }
    function b(O, W, Z) {
      {
        var ce = v.ReactDebugCurrentFrame, Le = ce.getStackAddendum();
        Le !== "" && (W += "%s", Z = Z.concat([Le]));
        var Be = Z.map(function(be) {
          return String(be);
        });
        Be.unshift("Warning: " + W), Function.prototype.apply.call(console[O], console, Be);
      }
    }
    var x = !1, S = !1, A = !1, T = !1, I = !1, L;
    L = Symbol.for("react.module.reference");
    function _(O) {
      return !!(typeof O == "string" || typeof O == "function" || O === n || O === s || I || O === i || O === l || O === u || T || O === h || x || S || A || typeof O == "object" && O !== null && (O.$$typeof === f || O.$$typeof === d || O.$$typeof === a || O.$$typeof === o || O.$$typeof === c || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      O.$$typeof === L || O.getModuleId !== void 0));
    }
    function R(O, W, Z) {
      var ce = O.displayName;
      if (ce)
        return ce;
      var Le = W.displayName || W.name || "";
      return Le !== "" ? Z + "(" + Le + ")" : Z;
    }
    function D(O) {
      return O.displayName || "Context";
    }
    function F(O) {
      if (O == null)
        return null;
      if (typeof O.tag == "number" && y("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof O == "function")
        return O.displayName || O.name || null;
      if (typeof O == "string")
        return O;
      switch (O) {
        case n:
          return "Fragment";
        case t:
          return "Portal";
        case s:
          return "Profiler";
        case i:
          return "StrictMode";
        case l:
          return "Suspense";
        case u:
          return "SuspenseList";
      }
      if (typeof O == "object")
        switch (O.$$typeof) {
          case o:
            var W = O;
            return D(W) + ".Consumer";
          case a:
            var Z = O;
            return D(Z._context) + ".Provider";
          case c:
            return R(O, O.render, "ForwardRef");
          case d:
            var ce = O.displayName || null;
            return ce !== null ? ce : F(O.type) || "Memo";
          case f: {
            var Le = O, Be = Le._payload, be = Le._init;
            try {
              return F(be(Be));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var B = Object.assign, j = 0, U, K, G, Y, Q, H, N;
    function re() {
    }
    re.__reactDisabledLog = !0;
    function oe() {
      {
        if (j === 0) {
          U = console.log, K = console.info, G = console.warn, Y = console.error, Q = console.group, H = console.groupCollapsed, N = console.groupEnd;
          var O = {
            configurable: !0,
            enumerable: !0,
            value: re,
            writable: !0
          };
          Object.defineProperties(console, {
            info: O,
            log: O,
            warn: O,
            error: O,
            group: O,
            groupCollapsed: O,
            groupEnd: O
          });
        }
        j++;
      }
    }
    function le() {
      {
        if (j--, j === 0) {
          var O = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: B({}, O, {
              value: U
            }),
            info: B({}, O, {
              value: K
            }),
            warn: B({}, O, {
              value: G
            }),
            error: B({}, O, {
              value: Y
            }),
            group: B({}, O, {
              value: Q
            }),
            groupCollapsed: B({}, O, {
              value: H
            }),
            groupEnd: B({}, O, {
              value: N
            })
          });
        }
        j < 0 && y("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var he = v.ReactCurrentDispatcher, Re;
    function et(O, W, Z) {
      {
        if (Re === void 0)
          try {
            throw Error();
          } catch (Le) {
            var ce = Le.stack.trim().match(/\n( *(at )?)/);
            Re = ce && ce[1] || "";
          }
        return `
` + Re + O;
      }
    }
    var q = !1, ie;
    {
      var fe = typeof WeakMap == "function" ? WeakMap : Map;
      ie = new fe();
    }
    function V(O, W) {
      if (!O || q)
        return "";
      {
        var Z = ie.get(O);
        if (Z !== void 0)
          return Z;
      }
      var ce;
      q = !0;
      var Le = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Be;
      Be = he.current, he.current = null, oe();
      try {
        if (W) {
          var be = function() {
            throw Error();
          };
          if (Object.defineProperty(be.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(be, []);
            } catch (kt) {
              ce = kt;
            }
            Reflect.construct(O, [], be);
          } else {
            try {
              be.call();
            } catch (kt) {
              ce = kt;
            }
            O.call(be.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (kt) {
            ce = kt;
          }
          O();
        }
      } catch (kt) {
        if (kt && ce && typeof kt.stack == "string") {
          for (var pe = kt.stack.split(`
`), Ot = ce.stack.split(`
`), Xe = pe.length - 1, rt = Ot.length - 1; Xe >= 1 && rt >= 0 && pe[Xe] !== Ot[rt]; )
            rt--;
          for (; Xe >= 1 && rt >= 0; Xe--, rt--)
            if (pe[Xe] !== Ot[rt]) {
              if (Xe !== 1 || rt !== 1)
                do
                  if (Xe--, rt--, rt < 0 || pe[Xe] !== Ot[rt]) {
                    var sr = `
` + pe[Xe].replace(" at new ", " at ");
                    return O.displayName && sr.includes("<anonymous>") && (sr = sr.replace("<anonymous>", O.displayName)), typeof O == "function" && ie.set(O, sr), sr;
                  }
                while (Xe >= 1 && rt >= 0);
              break;
            }
        }
      } finally {
        q = !1, he.current = Be, le(), Error.prepareStackTrace = Le;
      }
      var Ti = O ? O.displayName || O.name : "", Vn = Ti ? et(Ti) : "";
      return typeof O == "function" && ie.set(O, Vn), Vn;
    }
    function tt(O, W, Z) {
      return V(O, !1);
    }
    function Te(O) {
      var W = O.prototype;
      return !!(W && W.isReactComponent);
    }
    function ot(O, W, Z) {
      if (O == null)
        return "";
      if (typeof O == "function")
        return V(O, Te(O));
      if (typeof O == "string")
        return et(O);
      switch (O) {
        case l:
          return et("Suspense");
        case u:
          return et("SuspenseList");
      }
      if (typeof O == "object")
        switch (O.$$typeof) {
          case c:
            return tt(O.render);
          case d:
            return ot(O.type, W, Z);
          case f: {
            var ce = O, Le = ce._payload, Be = ce._init;
            try {
              return ot(Be(Le), W, Z);
            } catch {
            }
          }
        }
      return "";
    }
    var se = Object.prototype.hasOwnProperty, $e = {}, ft = v.ReactDebugCurrentFrame;
    function ir(O) {
      if (O) {
        var W = O._owner, Z = ot(O.type, O._source, W ? W.type : null);
        ft.setExtraStackFrame(Z);
      } else
        ft.setExtraStackFrame(null);
    }
    function Wt(O, W, Z, ce, Le) {
      {
        var Be = Function.call.bind(se);
        for (var be in O)
          if (Be(O, be)) {
            var pe = void 0;
            try {
              if (typeof O[be] != "function") {
                var Ot = Error((ce || "React class") + ": " + Z + " type `" + be + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof O[be] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Ot.name = "Invariant Violation", Ot;
              }
              pe = O[be](W, be, ce, Z, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Xe) {
              pe = Xe;
            }
            pe && !(pe instanceof Error) && (ir(Le), y("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ce || "React class", Z, be, typeof pe), ir(null)), pe instanceof Error && !(pe.message in $e) && ($e[pe.message] = !0, ir(Le), y("Failed %s type: %s", Z, pe.message), ir(null));
          }
      }
    }
    var xn = Array.isArray;
    function Sr(O) {
      return xn(O);
    }
    function Ra(O) {
      {
        var W = typeof Symbol == "function" && Symbol.toStringTag, Z = W && O[Symbol.toStringTag] || O.constructor.name || "Object";
        return Z;
      }
    }
    function Ei(O) {
      try {
        return gs(O), !1;
      } catch {
        return !0;
      }
    }
    function gs(O) {
      return "" + O;
    }
    function En(O) {
      if (Ei(O))
        return y("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ra(O)), gs(O);
    }
    var ms = v.ReactCurrentOwner, oc = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, ps, vs;
    function Kn(O) {
      if (se.call(O, "ref")) {
        var W = Object.getOwnPropertyDescriptor(O, "ref").get;
        if (W && W.isReactWarning)
          return !1;
      }
      return O.ref !== void 0;
    }
    function rI(O) {
      if (se.call(O, "key")) {
        var W = Object.getOwnPropertyDescriptor(O, "key").get;
        if (W && W.isReactWarning)
          return !1;
      }
      return O.key !== void 0;
    }
    function nI(O, W) {
      typeof O.ref == "string" && ms.current;
    }
    function iI(O, W) {
      {
        var Z = function() {
          ps || (ps = !0, y("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", W));
        };
        Z.isReactWarning = !0, Object.defineProperty(O, "key", {
          get: Z,
          configurable: !0
        });
      }
    }
    function sI(O, W) {
      {
        var Z = function() {
          vs || (vs = !0, y("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", W));
        };
        Z.isReactWarning = !0, Object.defineProperty(O, "ref", {
          get: Z,
          configurable: !0
        });
      }
    }
    var aI = function(O, W, Z, ce, Le, Be, be) {
      var pe = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: O,
        key: W,
        ref: Z,
        props: be,
        // Record the component responsible for creating this element.
        _owner: Be
      };
      return pe._store = {}, Object.defineProperty(pe._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(pe, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ce
      }), Object.defineProperty(pe, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Le
      }), Object.freeze && (Object.freeze(pe.props), Object.freeze(pe)), pe;
    };
    function oI(O, W, Z, ce, Le) {
      {
        var Be, be = {}, pe = null, Ot = null;
        Z !== void 0 && (En(Z), pe = "" + Z), rI(W) && (En(W.key), pe = "" + W.key), Kn(W) && (Ot = W.ref, nI(W, Le));
        for (Be in W)
          se.call(W, Be) && !oc.hasOwnProperty(Be) && (be[Be] = W[Be]);
        if (O && O.defaultProps) {
          var Xe = O.defaultProps;
          for (Be in Xe)
            be[Be] === void 0 && (be[Be] = Xe[Be]);
        }
        if (pe || Ot) {
          var rt = typeof O == "function" ? O.displayName || O.name || "Unknown" : O;
          pe && iI(be, rt), Ot && sI(be, rt);
        }
        return aI(O, pe, Ot, Le, ce, ms.current, be);
      }
    }
    var lc = v.ReactCurrentOwner, om = v.ReactDebugCurrentFrame;
    function Si(O) {
      if (O) {
        var W = O._owner, Z = ot(O.type, O._source, W ? W.type : null);
        om.setExtraStackFrame(Z);
      } else
        om.setExtraStackFrame(null);
    }
    var cc;
    cc = !1;
    function uc(O) {
      return typeof O == "object" && O !== null && O.$$typeof === e;
    }
    function lm() {
      {
        if (lc.current) {
          var O = F(lc.current.type);
          if (O)
            return `

Check the render method of \`` + O + "`.";
        }
        return "";
      }
    }
    function lI(O) {
      return "";
    }
    var cm = {};
    function cI(O) {
      {
        var W = lm();
        if (!W) {
          var Z = typeof O == "string" ? O : O.displayName || O.name;
          Z && (W = `

Check the top-level render call using <` + Z + ">.");
        }
        return W;
      }
    }
    function um(O, W) {
      {
        if (!O._store || O._store.validated || O.key != null)
          return;
        O._store.validated = !0;
        var Z = cI(W);
        if (cm[Z])
          return;
        cm[Z] = !0;
        var ce = "";
        O && O._owner && O._owner !== lc.current && (ce = " It was passed a child from " + F(O._owner.type) + "."), Si(O), y('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Z, ce), Si(null);
      }
    }
    function dm(O, W) {
      {
        if (typeof O != "object")
          return;
        if (Sr(O))
          for (var Z = 0; Z < O.length; Z++) {
            var ce = O[Z];
            uc(ce) && um(ce, W);
          }
        else if (uc(O))
          O._store && (O._store.validated = !0);
        else if (O) {
          var Le = p(O);
          if (typeof Le == "function" && Le !== O.entries)
            for (var Be = Le.call(O), be; !(be = Be.next()).done; )
              uc(be.value) && um(be.value, W);
        }
      }
    }
    function uI(O) {
      {
        var W = O.type;
        if (W == null || typeof W == "string")
          return;
        var Z;
        if (typeof W == "function")
          Z = W.propTypes;
        else if (typeof W == "object" && (W.$$typeof === c || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        W.$$typeof === d))
          Z = W.propTypes;
        else
          return;
        if (Z) {
          var ce = F(W);
          Wt(Z, O.props, "prop", ce, O);
        } else if (W.PropTypes !== void 0 && !cc) {
          cc = !0;
          var Le = F(W);
          y("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Le || "Unknown");
        }
        typeof W.getDefaultProps == "function" && !W.getDefaultProps.isReactClassApproved && y("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function dI(O) {
      {
        for (var W = Object.keys(O.props), Z = 0; Z < W.length; Z++) {
          var ce = W[Z];
          if (ce !== "children" && ce !== "key") {
            Si(O), y("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ce), Si(null);
            break;
          }
        }
        O.ref !== null && (Si(O), y("Invalid attribute `ref` supplied to `React.Fragment`."), Si(null));
      }
    }
    var fm = {};
    function hm(O, W, Z, ce, Le, Be) {
      {
        var be = _(O);
        if (!be) {
          var pe = "";
          (O === void 0 || typeof O == "object" && O !== null && Object.keys(O).length === 0) && (pe += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Ot = lI();
          Ot ? pe += Ot : pe += lm();
          var Xe;
          O === null ? Xe = "null" : Sr(O) ? Xe = "array" : O !== void 0 && O.$$typeof === e ? (Xe = "<" + (F(O.type) || "Unknown") + " />", pe = " Did you accidentally export a JSX literal instead of a component?") : Xe = typeof O, y("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Xe, pe);
        }
        var rt = oI(O, W, Z, Le, Be);
        if (rt == null)
          return rt;
        if (be) {
          var sr = W.children;
          if (sr !== void 0)
            if (ce)
              if (Sr(sr)) {
                for (var Ti = 0; Ti < sr.length; Ti++)
                  dm(sr[Ti], O);
                Object.freeze && Object.freeze(sr);
              } else
                y("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              dm(sr, O);
        }
        if (se.call(W, "key")) {
          var Vn = F(O), kt = Object.keys(W).filter(function(vI) {
            return vI !== "key";
          }), dc = kt.length > 0 ? "{key: someKey, " + kt.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!fm[Vn + dc]) {
            var pI = kt.length > 0 ? "{" + kt.join(": ..., ") + ": ...}" : "{}";
            y(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, dc, Vn, pI, Vn), fm[Vn + dc] = !0;
          }
        }
        return O === n ? dI(rt) : uI(rt), rt;
      }
    }
    function fI(O, W, Z) {
      return hm(O, W, Z, !0);
    }
    function hI(O, W, Z) {
      return hm(O, W, Z, !1);
    }
    var gI = hI, mI = fI;
    xs.Fragment = n, xs.jsx = gI, xs.jsxs = mI;
  }()), xs;
}
var vm;
function DI() {
  return vm || (vm = 1, process.env.NODE_ENV === "production" ? Ca.exports = OI() : Ca.exports = RI()), Ca.exports;
}
var P = DI();
const Yb = ({
  title: r,
  value: e,
  context: t = "neutral",
  trend: n,
  comparison: i,
  format: s = "number",
  formatter: a,
  onClick: o,
  loading: c = !1,
  size: l = "md",
  onUpdate: u,
  updateInterval: d
}) => {
  const [f, h] = _e(e);
  qb(() => {
    const m = typeof f == "number" ? f + Math.floor(Math.random() * 100) : f;
    h(m), u && u(m);
  }, d || null);
  const g = () => {
    if (a)
      return a(f);
    switch (s) {
      case "currency":
        return `$${Number(f).toFixed(2)}`;
      case "percentage":
        return `${f}%`;
      default:
        return f;
    }
  };
  return /* @__PURE__ */ P.jsxs(
    br,
    {
      className: `stat-card--${t} stat-card--${l}`,
      onClick: o,
      children: [
        /* @__PURE__ */ P.jsx("div", { className: "text-lg font-bold", children: r }),
        /* @__PURE__ */ P.jsx("div", { className: "text-3xl", children: c ? "..." : g() }),
        n && /* @__PURE__ */ P.jsxs("div", { children: [
          n.direction === "up" ? "↑" : "↓",
          " ",
          n.value,
          "% vs ",
          n.period
        ] }),
        i && /* @__PURE__ */ P.jsxs("div", { children: [
          "vs ",
          i.label,
          ": ",
          i.value
        ] })
      ]
    }
  );
}, u4 = ({
  client: r,
  context: e = "neutral",
  showProjects: t = !1,
  showMetrics: n = !1,
  showActions: i = !1,
  onClientClick: s,
  onProjectClick: a,
  onActionClick: o,
  permissions: c = [],
  size: l = "md"
}) => {
  var u, d;
  return /* @__PURE__ */ P.jsxs(
    br,
    {
      className: `client-card--${e} client-card--${l}`,
      onClick: () => s == null ? void 0 : s(r),
      children: [
        /* @__PURE__ */ P.jsxs("div", { className: "flex items-center", children: [
          /* @__PURE__ */ P.jsx(ml, { src: r.avatarUrl, alt: r.name }),
          /* @__PURE__ */ P.jsx("div", { className: "ml-4", children: /* @__PURE__ */ P.jsx("div", { className: "text-lg font-bold", children: r.name }) })
        ] }),
        t && /* @__PURE__ */ P.jsxs("div", { className: "mt-4", children: [
          /* @__PURE__ */ P.jsx("h4", { className: "font-bold", children: "Projects" }),
          (u = r.projects) == null ? void 0 : u.map((f) => /* @__PURE__ */ P.jsx("div", { onClick: () => a == null ? void 0 : a(f), children: f.name }, f.id))
        ] }),
        n && /* @__PURE__ */ P.jsxs("div", { className: "mt-4", children: [
          /* @__PURE__ */ P.jsx("h4", { className: "font-bold", children: "Metrics" }),
          (d = r.metrics) == null ? void 0 : d.map((f) => /* @__PURE__ */ P.jsx(Yb, { ...f }, f.title))
        ] }),
        i && /* @__PURE__ */ P.jsx("div", { className: "mt-4", children: c.includes("edit") && /* @__PURE__ */ P.jsx(xe, { onClick: () => o == null ? void 0 : o("edit", r), children: "Edit" }) })
      ]
    }
  );
}, CI = ({
  activities: r,
  context: e = "neutral",
  filters: t = [],
  onActivityClick: n,
  onFilterChange: i,
  realTimeUpdates: s = !1,
  maxItems: a,
  showLoadMore: o = !1,
  onLoadMore: c
}) => {
  const l = r.filter((u) => t.length === 0 ? !0 : t.every((d) => d.type === "user" ? u.user.id === d.id : d.type === "type" ? u.type === d.name : !0));
  return /* @__PURE__ */ P.jsxs(br, { className: `activity-card--${e}`, children: [
    l.slice(0, a).map((u) => /* @__PURE__ */ P.jsxs("div", { onClick: () => n == null ? void 0 : n(u), children: [
      u.description,
      " @ ",
      u.timestamp.toLocaleDateString()
    ] }, u.id)),
    o && /* @__PURE__ */ P.jsx(xe, { onClick: c, children: "Load More" })
  ] });
}, d4 = ({
  workspace: r,
  context: e = "neutral",
  showMembers: t = !1,
  showActivity: n = !1,
  showMetrics: i = !1,
  onWorkspaceClick: s,
  onMemberClick: a,
  onActivityClick: o,
  permissions: c = [],
  size: l = "md"
}) => {
  var u, d;
  return /* @__PURE__ */ P.jsxs(
    br,
    {
      className: `workspace-card--${e} workspace-card--${l}`,
      onClick: () => s == null ? void 0 : s(r),
      children: [
        /* @__PURE__ */ P.jsx("div", { className: "text-lg font-bold", children: r.name }),
        t && /* @__PURE__ */ P.jsxs("div", { className: "mt-4", children: [
          /* @__PURE__ */ P.jsx("h4", { className: "font-bold", children: "Members" }),
          (u = r.members) == null ? void 0 : u.map((f) => /* @__PURE__ */ P.jsxs("div", { onClick: () => a == null ? void 0 : a(f), children: [
            /* @__PURE__ */ P.jsx(ml, { src: f.avatarUrl, alt: f.name }),
            f.name
          ] }, f.id))
        ] }),
        n && r.activity && /* @__PURE__ */ P.jsxs("div", { className: "mt-4", children: [
          /* @__PURE__ */ P.jsx("h4", { className: "font-bold", children: "Activity" }),
          /* @__PURE__ */ P.jsx(CI, { activities: r.activity })
        ] }),
        i && /* @__PURE__ */ P.jsxs("div", { className: "mt-4", children: [
          /* @__PURE__ */ P.jsx("h4", { className: "font-bold", children: "Metrics" }),
          (d = r.metrics) == null ? void 0 : d.map((f) => /* @__PURE__ */ P.jsx(Yb, { ...f }, f.title))
        ] })
      ]
    }
  );
}, kI = ({
  title: r,
  progress: e,
  context: t = "neutral",
  showMilestones: n = !1,
  size: i = "md",
  updateInterval: s
}) => {
  var c;
  const o = LI(e.value, e.target, s || null) / e.target * 100;
  return /* @__PURE__ */ P.jsxs(br, { className: `progress-card--${t} progress-card--${i}`, children: [
    /* @__PURE__ */ P.jsx("div", { className: "text-lg font-bold", children: r }),
    /* @__PURE__ */ P.jsx(Wb, { value: o }),
    n && /* @__PURE__ */ P.jsx("div", { className: "mt-4", children: (c = e.milestones) == null ? void 0 : c.map((l) => /* @__PURE__ */ P.jsx("div", { children: l.name }, l.id)) })
  ] });
}, f4 = ({
  project: r,
  context: e = "neutral",
  showProgress: t = !1,
  showTeam: n = !1,
  showActions: i = !1,
  onProjectClick: s,
  onTeamMemberClick: a,
  onActionClick: o,
  permissions: c = [],
  size: l = "md"
}) => {
  var u;
  return /* @__PURE__ */ P.jsxs(
    br,
    {
      className: `project-card--${e} project-card--${l}`,
      onClick: () => s == null ? void 0 : s(r),
      children: [
        /* @__PURE__ */ P.jsx("div", { className: "text-lg font-bold", children: r.name }),
        t && r.progress && /* @__PURE__ */ P.jsx("div", { className: "mt-4", children: /* @__PURE__ */ P.jsx(kI, { title: "Progress", progress: r.progress }) }),
        n && /* @__PURE__ */ P.jsxs("div", { className: "mt-4", children: [
          /* @__PURE__ */ P.jsx("h4", { className: "font-bold", children: "Team" }),
          (u = r.team) == null ? void 0 : u.map((d) => /* @__PURE__ */ P.jsxs(
            "div",
            {
              onClick: () => a == null ? void 0 : a(d),
              children: [
                /* @__PURE__ */ P.jsx(ml, { src: d.avatarUrl, alt: d.name }),
                d.name
              ]
            },
            d.id
          ))
        ] }),
        i && /* @__PURE__ */ P.jsx("div", { className: "mt-4", children: c.includes("edit") && /* @__PURE__ */ P.jsx(xe, { onClick: () => o == null ? void 0 : o("edit", r), children: "Edit" }) })
      ]
    }
  );
}, h4 = ({
  billing: r,
  context: e = "neutral",
  showPaymentHistory: t = !1,
  showInvoices: n = !1,
  showActions: i = !1,
  onBillingClick: s,
  onInvoiceClick: a,
  onActionClick: o,
  permissions: c = [],
  size: l = "md"
}) => {
  var u, d;
  return /* @__PURE__ */ P.jsxs(
    br,
    {
      className: `billing-card--${e} billing-card--${l}`,
      onClick: () => s == null ? void 0 : s(r),
      children: [
        /* @__PURE__ */ P.jsx("div", { className: "text-lg font-bold", children: r.name }),
        t && /* @__PURE__ */ P.jsxs("div", { className: "mt-4", children: [
          /* @__PURE__ */ P.jsx("h4", { className: "font-bold", children: "Payment History" }),
          (u = r.paymentHistory) == null ? void 0 : u.map((f) => /* @__PURE__ */ P.jsxs("div", { children: [
            f.amount,
            " on ",
            f.date.toLocaleDateString()
          ] }, f.id))
        ] }),
        n && /* @__PURE__ */ P.jsxs("div", { className: "mt-4", children: [
          /* @__PURE__ */ P.jsx("h4", { className: "font-bold", children: "Invoices" }),
          (d = r.invoices) == null ? void 0 : d.map((f) => /* @__PURE__ */ P.jsxs("div", { onClick: () => a == null ? void 0 : a(f), children: [
            f.amount,
            " due on ",
            f.dueDate.toLocaleDateString()
          ] }, f.id))
        ] }),
        i && /* @__PURE__ */ P.jsx("div", { className: "mt-4", children: c.includes("edit") && /* @__PURE__ */ P.jsx(xe, { onClick: () => o == null ? void 0 : o("edit", r), children: "Edit" }) })
      ]
    }
  );
}, g4 = ({
  time: r,
  className: e = ""
}) => /* @__PURE__ */ P.jsx(br, { className: zb("p-4", e), children: /* @__PURE__ */ P.jsxs("div", { className: "flex items-center justify-between", children: [
  /* @__PURE__ */ P.jsx("h3", { className: "text-lg font-semibold", children: "Time" }),
  /* @__PURE__ */ P.jsx(SI, { time: r })
] }) });
let Ht = [], MI = 0;
const m4 = ({
  isOpen: r,
  onClose: e,
  children: t,
  className: n = "",
  preventBackdropClose: i = !1,
  zIndex: s = 9999
}) => {
  const [a] = _e(() => `modal-${++MI}`), o = Ke(null), c = Ke(null), l = Ke(null), [u, d] = _e(!1), f = Se((y) => {
    if (!c.current) return;
    const b = c.current.querySelectorAll(
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
    ), x = b[0], S = b[b.length - 1];
    y.key === "Tab" && (y.shiftKey ? document.activeElement === x && (y.preventDefault(), S == null || S.focus()) : document.activeElement === S && (y.preventDefault(), x == null || x.focus()));
  }, []), h = Se((y) => {
    y.key === "Escape" && (y.preventDefault(), y.stopImmediatePropagation(), Ht[Ht.length - 1] === a && g());
  }, [a]), g = Se(() => {
    if (u) return;
    d(!0);
    const y = Ht.indexOf(a);
    y > -1 && Ht.splice(y, 1), e(), setTimeout(() => d(!1), 100);
  }, [a, e, u]), m = Se((y) => {
    i || y.target === o.current && (y.preventDefault(), y.stopPropagation(), g());
  }, [i, g]), p = Se((y) => {
    y.stopPropagation();
  }, []);
  if (we(() => {
    if (r && !u)
      l.current = document.activeElement, Ht.includes(a) || Ht.push(a), document.body.style.overflow = "hidden", document.addEventListener("keydown", h, !0), document.addEventListener("keydown", f), setTimeout(() => {
        var b;
        const y = (b = c.current) == null ? void 0 : b.querySelector(
          'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
        );
        y == null || y.focus();
      }, 10);
    else {
      const y = Ht.indexOf(a);
      y > -1 && Ht.splice(y, 1), Ht.length === 0 && (document.body.style.overflow = ""), document.removeEventListener("keydown", h, !0), document.removeEventListener("keydown", f), l.current && Ht.length === 0 && (l.current.focus(), l.current = null);
    }
    return () => {
      const y = Ht.indexOf(a);
      y > -1 && Ht.splice(y, 1), Ht.length === 0 && (document.body.style.overflow = ""), document.removeEventListener("keydown", h, !0), document.removeEventListener("keydown", f);
    };
  }, [r, u, a, h, f]), we(() => {
    const b = setTimeout(() => {
      document.querySelectorAll('[data-modal-backdrop="true"]').forEach((S, A) => {
        A > 0 && S.remove();
      });
    }, 100);
    return () => clearTimeout(b);
  }, [r]), !r || u)
    return null;
  const v = /* @__PURE__ */ P.jsx(
    "div",
    {
      ref: o,
      className: `fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center p-4 ${n}`,
      onClick: m,
      "data-modal-backdrop": "true",
      "aria-modal": "true",
      role: "dialog",
      "aria-labelledby": "modal-title",
      children: /* @__PURE__ */ P.jsx(
        "div",
        {
          ref: c,
          className: "relative max-w-full max-h-full overflow-auto",
          onClick: p,
          "data-modal-content": "true",
          children: t
        }
      )
    }
  );
  return Nf(v, document.body);
}, p4 = {
  success: (r, e) => {
    console.log("SUCCESS:", r);
  },
  error: (r, e) => {
    console.error("ERROR:", r);
  },
  warning: (r, e) => {
    console.warn("WARNING:", r);
  },
  info: (r, e) => {
    console.info("INFO:", r);
  }
}, v4 = ({
  content: r,
  position: e = "top",
  delay: t = 300,
  children: n,
  className: i = ""
}) => {
  const [s, a] = _e(!1), [o, c] = _e(null), l = Ke(null), u = () => {
    const g = window.setTimeout(() => {
      a(!0);
    }, t);
    c(g);
  }, d = () => {
    o && (clearTimeout(o), c(null)), a(!1);
  };
  we(() => {
    const g = (m) => {
      l.current && !l.current.contains(m.target) && d();
    };
    return s && document.addEventListener("mousedown", g), () => {
      document.removeEventListener("mousedown", g);
    };
  }, [s]);
  const f = () => {
    switch (e) {
      case "top":
        return {
          bottom: "100%",
          left: "50%",
          transform: "translateX(-50%)",
          marginBottom: "5px"
        };
      case "bottom":
        return {
          top: "100%",
          left: "50%",
          transform: "translateX(-50%)",
          marginTop: "5px"
        };
      case "left":
        return {
          right: "100%",
          top: "50%",
          transform: "translateY(-50%)",
          marginRight: "5px"
        };
      case "right":
        return {
          left: "100%",
          top: "50%",
          transform: "translateY(-50%)",
          marginLeft: "5px"
        };
      default:
        return {
          bottom: "100%",
          left: "50%",
          transform: "translateX(-50%)",
          marginBottom: "5px"
        };
    }
  }, h = Ct.cloneElement(n, {
    onMouseEnter: u,
    onMouseLeave: d,
    onClick: (g) => {
      n.props.onClick && n.props.onClick(g), d();
    }
  });
  return /* @__PURE__ */ P.jsxs("div", { className: "relative inline-block", ref: l, children: [
    h,
    s && /* @__PURE__ */ P.jsx(
      "div",
      {
        className: `absolute z-50 px-2 py-1 text-sm text-slate-50 bg-slate-900 rounded-md shadow-lg whitespace-nowrap transition-opacity duration-150 ${i}`,
        style: f(),
        children: r
      }
    )
  ] });
};
function Xb(r) {
  var e, t, n = "";
  if (typeof r == "string" || typeof r == "number") n += r;
  else if (typeof r == "object") if (Array.isArray(r)) {
    var i = r.length;
    for (e = 0; e < i; e++) r[e] && (t = Xb(r[e])) && (n && (n += " "), n += t);
  } else for (t in r) r[t] && (n && (n += " "), n += t);
  return n;
}
function ve() {
  for (var r, e, t = 0, n = "", i = arguments.length; t < i; t++) (r = arguments[t]) && (e = Xb(r)) && (n && (n += " "), n += e);
  return n;
}
var fc = {}, hc = {}, ym;
function NI() {
  return ym || (ym = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    function e(t) {
      return t === "__proto__";
    }
    r.isUnsafeProperty = e;
  }(hc)), hc;
}
var gc = {}, bm;
function Qb() {
  return bm || (bm = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    function e(t) {
      switch (typeof t) {
        case "number":
        case "symbol":
          return !1;
        case "string":
          return t.includes(".") || t.includes("[") || t.includes("]");
      }
    }
    r.isDeepKey = e;
  }(gc)), gc;
}
var mc = {}, xm;
function Zb() {
  return xm || (xm = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    function e(t) {
      var n;
      return typeof t == "string" || typeof t == "symbol" ? t : Object.is((n = t == null ? void 0 : t.valueOf) == null ? void 0 : n.call(t), -0) ? "-0" : String(t);
    }
    r.toKey = e;
  }(mc)), mc;
}
var pc = {}, Em;
function Ff() {
  return Em || (Em = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    function e(t) {
      const n = [], i = t.length;
      if (i === 0)
        return n;
      let s = 0, a = "", o = "", c = !1;
      for (t.charCodeAt(0) === 46 && (n.push(""), s++); s < i; ) {
        const l = t[s];
        o ? l === "\\" && s + 1 < i ? (s++, a += t[s]) : l === o ? o = "" : a += l : c ? l === '"' || l === "'" ? o = l : l === "]" ? (c = !1, n.push(a), a = "") : a += l : l === "[" ? (c = !0, a && (n.push(a), a = "")) : l === "." ? a && (n.push(a), a = "") : a += l, s++;
      }
      return a && n.push(a), n;
    }
    r.toPath = e;
  }(pc)), pc;
}
var Sm;
function $f() {
  return Sm || (Sm = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    const e = /* @__PURE__ */ NI(), t = /* @__PURE__ */ Qb(), n = /* @__PURE__ */ Zb(), i = /* @__PURE__ */ Ff();
    function s(o, c, l) {
      if (o == null)
        return l;
      switch (typeof c) {
        case "string": {
          if (e.isUnsafeProperty(c))
            return l;
          const u = o[c];
          return u === void 0 ? t.isDeepKey(c) ? s(o, i.toPath(c), l) : l : u;
        }
        case "number":
        case "symbol": {
          typeof c == "number" && (c = n.toKey(c));
          const u = o[c];
          return u === void 0 ? l : u;
        }
        default: {
          if (Array.isArray(c))
            return a(o, c, l);
          if (Object.is(c == null ? void 0 : c.valueOf(), -0) ? c = "-0" : c = String(c), e.isUnsafeProperty(c))
            return l;
          const u = o[c];
          return u === void 0 ? l : u;
        }
      }
    }
    function a(o, c, l) {
      if (c.length === 0)
        return l;
      let u = o;
      for (let d = 0; d < c.length; d++) {
        if (u == null || e.isUnsafeProperty(c[d]))
          return l;
        u = u[c[d]];
      }
      return u === void 0 ? l : u;
    }
    r.get = s;
  }(fc)), fc;
}
var vc, Tm;
function FI() {
  return Tm || (Tm = 1, vc = $f().get), vc;
}
var $I = /* @__PURE__ */ FI();
const Mn = /* @__PURE__ */ hn($I);
var ka = { exports: {} }, ke = {};
/**
 * @license React
 * react-is.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Am;
function BI() {
  if (Am) return ke;
  Am = 1;
  var r = Symbol.for("react.transitional.element"), e = Symbol.for("react.portal"), t = Symbol.for("react.fragment"), n = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), s = Symbol.for("react.consumer"), a = Symbol.for("react.context"), o = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), l = Symbol.for("react.suspense_list"), u = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), f = Symbol.for("react.view_transition"), h = Symbol.for("react.client.reference");
  function g(m) {
    if (typeof m == "object" && m !== null) {
      var p = m.$$typeof;
      switch (p) {
        case r:
          switch (m = m.type, m) {
            case t:
            case i:
            case n:
            case c:
            case l:
            case f:
              return m;
            default:
              switch (m = m && m.$$typeof, m) {
                case a:
                case o:
                case d:
                case u:
                  return m;
                case s:
                  return m;
                default:
                  return p;
              }
          }
        case e:
          return p;
      }
    }
  }
  return ke.ContextConsumer = s, ke.ContextProvider = a, ke.Element = r, ke.ForwardRef = o, ke.Fragment = t, ke.Lazy = d, ke.Memo = u, ke.Portal = e, ke.Profiler = i, ke.StrictMode = n, ke.Suspense = c, ke.SuspenseList = l, ke.isContextConsumer = function(m) {
    return g(m) === s;
  }, ke.isContextProvider = function(m) {
    return g(m) === a;
  }, ke.isElement = function(m) {
    return typeof m == "object" && m !== null && m.$$typeof === r;
  }, ke.isForwardRef = function(m) {
    return g(m) === o;
  }, ke.isFragment = function(m) {
    return g(m) === t;
  }, ke.isLazy = function(m) {
    return g(m) === d;
  }, ke.isMemo = function(m) {
    return g(m) === u;
  }, ke.isPortal = function(m) {
    return g(m) === e;
  }, ke.isProfiler = function(m) {
    return g(m) === i;
  }, ke.isStrictMode = function(m) {
    return g(m) === n;
  }, ke.isSuspense = function(m) {
    return g(m) === c;
  }, ke.isSuspenseList = function(m) {
    return g(m) === l;
  }, ke.isValidElementType = function(m) {
    return typeof m == "string" || typeof m == "function" || m === t || m === i || m === n || m === c || m === l || typeof m == "object" && m !== null && (m.$$typeof === d || m.$$typeof === u || m.$$typeof === a || m.$$typeof === s || m.$$typeof === o || m.$$typeof === h || m.getModuleId !== void 0);
  }, ke.typeOf = g, ke;
}
var Me = {};
/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var wm;
function jI() {
  return wm || (wm = 1, process.env.NODE_ENV !== "production" && function() {
    function r(m) {
      if (typeof m == "object" && m !== null) {
        var p = m.$$typeof;
        switch (p) {
          case e:
            switch (m = m.type, m) {
              case n:
              case s:
              case i:
              case l:
              case u:
              case h:
                return m;
              default:
                switch (m = m && m.$$typeof, m) {
                  case o:
                  case c:
                  case f:
                  case d:
                    return m;
                  case a:
                    return m;
                  default:
                    return p;
                }
            }
          case t:
            return p;
        }
      }
    }
    var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), a = Symbol.for("react.consumer"), o = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), l = Symbol.for("react.suspense"), u = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), f = Symbol.for("react.lazy"), h = Symbol.for("react.view_transition"), g = Symbol.for("react.client.reference");
    Me.ContextConsumer = a, Me.ContextProvider = o, Me.Element = e, Me.ForwardRef = c, Me.Fragment = n, Me.Lazy = f, Me.Memo = d, Me.Portal = t, Me.Profiler = s, Me.StrictMode = i, Me.Suspense = l, Me.SuspenseList = u, Me.isContextConsumer = function(m) {
      return r(m) === a;
    }, Me.isContextProvider = function(m) {
      return r(m) === o;
    }, Me.isElement = function(m) {
      return typeof m == "object" && m !== null && m.$$typeof === e;
    }, Me.isForwardRef = function(m) {
      return r(m) === c;
    }, Me.isFragment = function(m) {
      return r(m) === n;
    }, Me.isLazy = function(m) {
      return r(m) === f;
    }, Me.isMemo = function(m) {
      return r(m) === d;
    }, Me.isPortal = function(m) {
      return r(m) === t;
    }, Me.isProfiler = function(m) {
      return r(m) === s;
    }, Me.isStrictMode = function(m) {
      return r(m) === i;
    }, Me.isSuspense = function(m) {
      return r(m) === l;
    }, Me.isSuspenseList = function(m) {
      return r(m) === u;
    }, Me.isValidElementType = function(m) {
      return typeof m == "string" || typeof m == "function" || m === n || m === s || m === i || m === l || m === u || typeof m == "object" && m !== null && (m.$$typeof === f || m.$$typeof === d || m.$$typeof === o || m.$$typeof === a || m.$$typeof === c || m.$$typeof === g || m.getModuleId !== void 0);
    }, Me.typeOf = r;
  }()), Me;
}
var Im;
function UI() {
  return Im || (Im = 1, process.env.NODE_ENV === "production" ? ka.exports = /* @__PURE__ */ BI() : ka.exports = /* @__PURE__ */ jI()), ka.exports;
}
var GI = /* @__PURE__ */ UI(), pt = (r) => r === 0 ? 0 : r > 0 ? 1 : -1, Ut = (r) => typeof r == "number" && r != +r, Qn = (r) => typeof r == "string" && r.indexOf("%") === r.length - 1, z = (r) => (typeof r == "number" || r instanceof Number) && !Ut(r), Br = (r) => z(r) || typeof r == "string", KI = 0, nn = (r) => {
  var e = ++KI;
  return "".concat(r || "").concat(e);
}, Dt = function(e, t) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  if (!z(e) && typeof e != "string")
    return n;
  var s;
  if (Qn(e)) {
    if (t == null)
      return n;
    var a = e.indexOf("%");
    s = t * parseFloat(e.slice(0, a)) / 100;
  } else
    s = +e;
  return Ut(s) && (s = n), i && t != null && s > t && (s = t), s;
}, Jb = (r) => {
  if (!Array.isArray(r))
    return !1;
  for (var e = r.length, t = {}, n = 0; n < e; n++)
    if (!t[r[n]])
      t[r[n]] = !0;
    else
      return !0;
  return !1;
}, Et = (r, e) => z(r) && z(e) ? (t) => r + t * (e - r) : () => e;
function Ai(r, e, t) {
  return z(r) && z(e) ? r + t * (e - r) : e;
}
function ex(r, e, t) {
  if (!(!r || !r.length))
    return r.find((n) => n && (typeof e == "function" ? e(n) : Mn(n, e)) === t);
}
var VI = (r) => {
  if (!r || !r.length)
    return null;
  for (var e = r.length, t = 0, n = 0, i = 0, s = 0, a = 1 / 0, o = -1 / 0, c = 0, l = 0, u = 0; u < e; u++)
    c = r[u].cx || 0, l = r[u].cy || 0, t += c, n += l, i += c * l, s += c * c, a = Math.min(a, c), o = Math.max(o, c);
  var d = e * s !== t * t ? (e * i - t * n) / (e * s - t * t) : 0;
  return {
    xmin: a,
    xmax: o,
    a: d,
    b: (n - d * t) / e
  };
}, ye = (r) => r === null || typeof r > "u", la = (r) => ye(r) ? r : "".concat(r.charAt(0).toUpperCase()).concat(r.slice(1)), WI = ["viewBox", "children"], HI = [
  "aria-activedescendant",
  "aria-atomic",
  "aria-autocomplete",
  "aria-busy",
  "aria-checked",
  "aria-colcount",
  "aria-colindex",
  "aria-colspan",
  "aria-controls",
  "aria-current",
  "aria-describedby",
  "aria-details",
  "aria-disabled",
  "aria-errormessage",
  "aria-expanded",
  "aria-flowto",
  "aria-haspopup",
  "aria-hidden",
  "aria-invalid",
  "aria-keyshortcuts",
  "aria-label",
  "aria-labelledby",
  "aria-level",
  "aria-live",
  "aria-modal",
  "aria-multiline",
  "aria-multiselectable",
  "aria-orientation",
  "aria-owns",
  "aria-placeholder",
  "aria-posinset",
  "aria-pressed",
  "aria-readonly",
  "aria-relevant",
  "aria-required",
  "aria-roledescription",
  "aria-rowcount",
  "aria-rowindex",
  "aria-rowspan",
  "aria-selected",
  "aria-setsize",
  "aria-sort",
  "aria-valuemax",
  "aria-valuemin",
  "aria-valuenow",
  "aria-valuetext",
  "className",
  "color",
  "height",
  "id",
  "lang",
  "max",
  "media",
  "method",
  "min",
  "name",
  "style",
  /*
   * removed 'type' SVGElementPropKey because we do not currently use any SVG elements
   * that can use it, and it conflicts with the recharts prop 'type'
   * https://github.com/recharts/recharts/pull/3327
   * https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/type
   */
  // 'type',
  "target",
  "width",
  "role",
  "tabIndex",
  "accentHeight",
  "accumulate",
  "additive",
  "alignmentBaseline",
  "allowReorder",
  "alphabetic",
  "amplitude",
  "arabicForm",
  "ascent",
  "attributeName",
  "attributeType",
  "autoReverse",
  "azimuth",
  "baseFrequency",
  "baselineShift",
  "baseProfile",
  "bbox",
  "begin",
  "bias",
  "by",
  "calcMode",
  "capHeight",
  "clip",
  "clipPath",
  "clipPathUnits",
  "clipRule",
  "colorInterpolation",
  "colorInterpolationFilters",
  "colorProfile",
  "colorRendering",
  "contentScriptType",
  "contentStyleType",
  "cursor",
  "cx",
  "cy",
  "d",
  "decelerate",
  "descent",
  "diffuseConstant",
  "direction",
  "display",
  "divisor",
  "dominantBaseline",
  "dur",
  "dx",
  "dy",
  "edgeMode",
  "elevation",
  "enableBackground",
  "end",
  "exponent",
  "externalResourcesRequired",
  "fill",
  "fillOpacity",
  "fillRule",
  "filter",
  "filterRes",
  "filterUnits",
  "floodColor",
  "floodOpacity",
  "focusable",
  "fontFamily",
  "fontSize",
  "fontSizeAdjust",
  "fontStretch",
  "fontStyle",
  "fontVariant",
  "fontWeight",
  "format",
  "from",
  "fx",
  "fy",
  "g1",
  "g2",
  "glyphName",
  "glyphOrientationHorizontal",
  "glyphOrientationVertical",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "hanging",
  "horizAdvX",
  "horizOriginX",
  "href",
  "ideographic",
  "imageRendering",
  "in2",
  "in",
  "intercept",
  "k1",
  "k2",
  "k3",
  "k4",
  "k",
  "kernelMatrix",
  "kernelUnitLength",
  "kerning",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "letterSpacing",
  "lightingColor",
  "limitingConeAngle",
  "local",
  "markerEnd",
  "markerHeight",
  "markerMid",
  "markerStart",
  "markerUnits",
  "markerWidth",
  "mask",
  "maskContentUnits",
  "maskUnits",
  "mathematical",
  "mode",
  "numOctaves",
  "offset",
  "opacity",
  "operator",
  "order",
  "orient",
  "orientation",
  "origin",
  "overflow",
  "overlinePosition",
  "overlineThickness",
  "paintOrder",
  "panose1",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointerEvents",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "r",
  "radius",
  "refX",
  "refY",
  "renderingIntent",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "restart",
  "result",
  "rotate",
  "rx",
  "ry",
  "seed",
  "shapeRendering",
  "slope",
  "spacing",
  "specularConstant",
  "specularExponent",
  "speed",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stemh",
  "stemv",
  "stitchTiles",
  "stopColor",
  "stopOpacity",
  "strikethroughPosition",
  "strikethroughThickness",
  "string",
  "stroke",
  "strokeDasharray",
  "strokeDashoffset",
  "strokeLinecap",
  "strokeLinejoin",
  "strokeMiterlimit",
  "strokeOpacity",
  "strokeWidth",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textAnchor",
  "textDecoration",
  "textLength",
  "textRendering",
  "to",
  "transform",
  "u1",
  "u2",
  "underlinePosition",
  "underlineThickness",
  "unicode",
  "unicodeBidi",
  "unicodeRange",
  "unitsPerEm",
  "vAlphabetic",
  "values",
  "vectorEffect",
  "version",
  "vertAdvY",
  "vertOriginX",
  "vertOriginY",
  "vHanging",
  "vIdeographic",
  "viewTarget",
  "visibility",
  "vMathematical",
  "widths",
  "wordSpacing",
  "writingMode",
  "x1",
  "x2",
  "x",
  "xChannelSelector",
  "xHeight",
  "xlinkActuate",
  "xlinkArcrole",
  "xlinkHref",
  "xlinkRole",
  "xlinkShow",
  "xlinkTitle",
  "xlinkType",
  "xmlBase",
  "xmlLang",
  "xmlns",
  "xmlnsXlink",
  "xmlSpace",
  "y1",
  "y2",
  "y",
  "yChannelSelector",
  "z",
  "zoomAndPan",
  "ref",
  "key",
  "angle"
], Pm = ["points", "pathLength"], yc = {
  svg: WI,
  polygon: Pm,
  polyline: Pm
}, Bf = ["dangerouslySetInnerHTML", "onCopy", "onCopyCapture", "onCut", "onCutCapture", "onPaste", "onPasteCapture", "onCompositionEnd", "onCompositionEndCapture", "onCompositionStart", "onCompositionStartCapture", "onCompositionUpdate", "onCompositionUpdateCapture", "onFocus", "onFocusCapture", "onBlur", "onBlurCapture", "onChange", "onChangeCapture", "onBeforeInput", "onBeforeInputCapture", "onInput", "onInputCapture", "onReset", "onResetCapture", "onSubmit", "onSubmitCapture", "onInvalid", "onInvalidCapture", "onLoad", "onLoadCapture", "onError", "onErrorCapture", "onKeyDown", "onKeyDownCapture", "onKeyPress", "onKeyPressCapture", "onKeyUp", "onKeyUpCapture", "onAbort", "onAbortCapture", "onCanPlay", "onCanPlayCapture", "onCanPlayThrough", "onCanPlayThroughCapture", "onDurationChange", "onDurationChangeCapture", "onEmptied", "onEmptiedCapture", "onEncrypted", "onEncryptedCapture", "onEnded", "onEndedCapture", "onLoadedData", "onLoadedDataCapture", "onLoadedMetadata", "onLoadedMetadataCapture", "onLoadStart", "onLoadStartCapture", "onPause", "onPauseCapture", "onPlay", "onPlayCapture", "onPlaying", "onPlayingCapture", "onProgress", "onProgressCapture", "onRateChange", "onRateChangeCapture", "onSeeked", "onSeekedCapture", "onSeeking", "onSeekingCapture", "onStalled", "onStalledCapture", "onSuspend", "onSuspendCapture", "onTimeUpdate", "onTimeUpdateCapture", "onVolumeChange", "onVolumeChangeCapture", "onWaiting", "onWaitingCapture", "onAuxClick", "onAuxClickCapture", "onClick", "onClickCapture", "onContextMenu", "onContextMenuCapture", "onDoubleClick", "onDoubleClickCapture", "onDrag", "onDragCapture", "onDragEnd", "onDragEndCapture", "onDragEnter", "onDragEnterCapture", "onDragExit", "onDragExitCapture", "onDragLeave", "onDragLeaveCapture", "onDragOver", "onDragOverCapture", "onDragStart", "onDragStartCapture", "onDrop", "onDropCapture", "onMouseDown", "onMouseDownCapture", "onMouseEnter", "onMouseLeave", "onMouseMove", "onMouseMoveCapture", "onMouseOut", "onMouseOutCapture", "onMouseOver", "onMouseOverCapture", "onMouseUp", "onMouseUpCapture", "onSelect", "onSelectCapture", "onTouchCancel", "onTouchCancelCapture", "onTouchEnd", "onTouchEndCapture", "onTouchMove", "onTouchMoveCapture", "onTouchStart", "onTouchStartCapture", "onPointerDown", "onPointerDownCapture", "onPointerMove", "onPointerMoveCapture", "onPointerUp", "onPointerUpCapture", "onPointerCancel", "onPointerCancelCapture", "onPointerEnter", "onPointerEnterCapture", "onPointerLeave", "onPointerLeaveCapture", "onPointerOver", "onPointerOverCapture", "onPointerOut", "onPointerOutCapture", "onGotPointerCapture", "onGotPointerCaptureCapture", "onLostPointerCapture", "onLostPointerCaptureCapture", "onScroll", "onScrollCapture", "onWheel", "onWheelCapture", "onAnimationStart", "onAnimationStartCapture", "onAnimationEnd", "onAnimationEndCapture", "onAnimationIteration", "onAnimationIterationCapture", "onTransitionEnd", "onTransitionEndCapture"], jf = (r, e) => {
  if (!r || typeof r == "function" || typeof r == "boolean")
    return null;
  var t = r;
  if (/* @__PURE__ */ _r(r) && (t = r.props), typeof t != "object" && typeof t != "function")
    return null;
  var n = {};
  return Object.keys(t).forEach((i) => {
    Bf.includes(i) && (n[i] = (s) => t[i](t, s));
  }), n;
}, qI = (r, e, t) => (n) => (r(e, t, n), null), ns = (r, e, t) => {
  if (r === null || typeof r != "object" && typeof r != "function")
    return null;
  var n = null;
  return Object.keys(r).forEach((i) => {
    var s = r[i];
    Bf.includes(i) && typeof s == "function" && (n || (n = {}), n[i] = qI(s, e, t));
  }), n;
}, _m = (r) => typeof r == "string" ? r : r ? r.displayName || r.name || "Component" : "", Lm = null, bc = null, tx = (r) => {
  if (r === Lm && Array.isArray(bc))
    return bc;
  var e = [];
  return go.forEach(r, (t) => {
    ye(t) || (GI.isFragment(t) ? e = e.concat(tx(t.props.children)) : e.push(t));
  }), bc = e, Lm = r, e;
};
function is(r, e) {
  var t = [], n = [];
  return Array.isArray(e) ? n = e.map((i) => _m(i)) : n = [_m(e)], tx(r).forEach((i) => {
    var s = Mn(i, "type.displayName") || Mn(i, "type.name");
    n.indexOf(s) !== -1 && t.push(i);
  }), t;
}
var pl = (r) => r && typeof r == "object" && "clipDot" in r ? !!r.clipDot : !0, zI = (r, e, t, n) => {
  var i, s = (i = n && (yc == null ? void 0 : yc[n])) !== null && i !== void 0 ? i : [];
  return e.startsWith("data-") || typeof r != "function" && (n && s.includes(e) || HI.includes(e)) || t && Bf.includes(e);
}, de = (r, e, t) => {
  if (!r || typeof r == "function" || typeof r == "boolean")
    return null;
  var n = r;
  if (/* @__PURE__ */ _r(r) && (n = r.props), typeof n != "object" && typeof n != "function")
    return null;
  var i = {};
  return Object.keys(n).forEach((s) => {
    var a;
    zI((a = n) === null || a === void 0 ? void 0 : a[s], s, e, t) && (i[s] = n[s]);
  }), i;
}, YI = ["children", "width", "height", "viewBox", "className", "style", "title", "desc"];
function md() {
  return md = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t) ({}).hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, md.apply(null, arguments);
}
function XI(r, e) {
  if (r == null) return {};
  var t, n, i = QI(r, e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(r);
    for (n = 0; n < s.length; n++) t = s[n], e.indexOf(t) === -1 && {}.propertyIsEnumerable.call(r, t) && (i[t] = r[t]);
  }
  return i;
}
function QI(r, e) {
  if (r == null) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.indexOf(n) !== -1) continue;
    t[n] = r[n];
  }
  return t;
}
var Uf = /* @__PURE__ */ Kt((r, e) => {
  var {
    children: t,
    width: n,
    height: i,
    viewBox: s,
    className: a,
    style: o,
    title: c,
    desc: l
  } = r, u = XI(r, YI), d = s || {
    width: n,
    height: i,
    x: 0,
    y: 0
  }, f = ve("recharts-surface", a);
  return /* @__PURE__ */ w.createElement("svg", md({}, de(u, !0, "svg"), {
    className: f,
    width: n,
    height: i,
    style: o,
    viewBox: "".concat(d.x, " ").concat(d.y, " ").concat(d.width, " ").concat(d.height),
    ref: e
  }), /* @__PURE__ */ w.createElement("title", null, c), /* @__PURE__ */ w.createElement("desc", null, l), t);
}), ZI = ["children", "className"];
function pd() {
  return pd = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t) ({}).hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, pd.apply(null, arguments);
}
function JI(r, e) {
  if (r == null) return {};
  var t, n, i = eP(r, e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(r);
    for (n = 0; n < s.length; n++) t = s[n], e.indexOf(t) === -1 && {}.propertyIsEnumerable.call(r, t) && (i[t] = r[t]);
  }
  return i;
}
function eP(r, e) {
  if (r == null) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.indexOf(n) !== -1) continue;
    t[n] = r[n];
  }
  return t;
}
var Fe = /* @__PURE__ */ w.forwardRef((r, e) => {
  var {
    children: t,
    className: n
  } = r, i = JI(r, ZI), s = ve("recharts-layer", n);
  return /* @__PURE__ */ w.createElement("g", pd({
    className: s
  }, de(i, !0), {
    ref: e
  }), t);
}), rx = /* @__PURE__ */ dn(null), tP = () => un(rx);
function Ge(r) {
  return function() {
    return r;
  };
}
const nx = Math.cos, Ao = Math.sin, Lr = Math.sqrt, wo = Math.PI, vl = 2 * wo, vd = Math.PI, yd = 2 * vd, Hn = 1e-6, rP = yd - Hn;
function ix(r) {
  this._ += r[0];
  for (let e = 1, t = r.length; e < t; ++e)
    this._ += arguments[e] + r[e];
}
function nP(r) {
  let e = Math.floor(r);
  if (!(e >= 0)) throw new Error(`invalid digits: ${r}`);
  if (e > 15) return ix;
  const t = 10 ** e;
  return function(n) {
    this._ += n[0];
    for (let i = 1, s = n.length; i < s; ++i)
      this._ += Math.round(arguments[i] * t) / t + n[i];
  };
}
class iP {
  constructor(e) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = e == null ? ix : nP(e);
  }
  moveTo(e, t) {
    this._append`M${this._x0 = this._x1 = +e},${this._y0 = this._y1 = +t}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(e, t) {
    this._append`L${this._x1 = +e},${this._y1 = +t}`;
  }
  quadraticCurveTo(e, t, n, i) {
    this._append`Q${+e},${+t},${this._x1 = +n},${this._y1 = +i}`;
  }
  bezierCurveTo(e, t, n, i, s, a) {
    this._append`C${+e},${+t},${+n},${+i},${this._x1 = +s},${this._y1 = +a}`;
  }
  arcTo(e, t, n, i, s) {
    if (e = +e, t = +t, n = +n, i = +i, s = +s, s < 0) throw new Error(`negative radius: ${s}`);
    let a = this._x1, o = this._y1, c = n - e, l = i - t, u = a - e, d = o - t, f = u * u + d * d;
    if (this._x1 === null)
      this._append`M${this._x1 = e},${this._y1 = t}`;
    else if (f > Hn) if (!(Math.abs(d * c - l * u) > Hn) || !s)
      this._append`L${this._x1 = e},${this._y1 = t}`;
    else {
      let h = n - a, g = i - o, m = c * c + l * l, p = h * h + g * g, v = Math.sqrt(m), y = Math.sqrt(f), b = s * Math.tan((vd - Math.acos((m + f - p) / (2 * v * y))) / 2), x = b / y, S = b / v;
      Math.abs(x - 1) > Hn && this._append`L${e + x * u},${t + x * d}`, this._append`A${s},${s},0,0,${+(d * h > u * g)},${this._x1 = e + S * c},${this._y1 = t + S * l}`;
    }
  }
  arc(e, t, n, i, s, a) {
    if (e = +e, t = +t, n = +n, a = !!a, n < 0) throw new Error(`negative radius: ${n}`);
    let o = n * Math.cos(i), c = n * Math.sin(i), l = e + o, u = t + c, d = 1 ^ a, f = a ? i - s : s - i;
    this._x1 === null ? this._append`M${l},${u}` : (Math.abs(this._x1 - l) > Hn || Math.abs(this._y1 - u) > Hn) && this._append`L${l},${u}`, n && (f < 0 && (f = f % yd + yd), f > rP ? this._append`A${n},${n},0,1,${d},${e - o},${t - c}A${n},${n},0,1,${d},${this._x1 = l},${this._y1 = u}` : f > Hn && this._append`A${n},${n},0,${+(f >= vd)},${d},${this._x1 = e + n * Math.cos(s)},${this._y1 = t + n * Math.sin(s)}`);
  }
  rect(e, t, n, i) {
    this._append`M${this._x0 = this._x1 = +e},${this._y0 = this._y1 = +t}h${n = +n}v${+i}h${-n}Z`;
  }
  toString() {
    return this._;
  }
}
function Gf(r) {
  let e = 3;
  return r.digits = function(t) {
    if (!arguments.length) return e;
    if (t == null)
      e = null;
    else {
      const n = Math.floor(t);
      if (!(n >= 0)) throw new RangeError(`invalid digits: ${t}`);
      e = n;
    }
    return r;
  }, () => new iP(e);
}
function Kf(r) {
  return typeof r == "object" && "length" in r ? r : Array.from(r);
}
function sx(r) {
  this._context = r;
}
sx.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(r, e) {
    switch (r = +r, e = +e, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(r, e) : this._context.moveTo(r, e);
        break;
      case 1:
        this._point = 2;
      // falls through
      default:
        this._context.lineTo(r, e);
        break;
    }
  }
};
function yl(r) {
  return new sx(r);
}
function ax(r) {
  return r[0];
}
function ox(r) {
  return r[1];
}
function lx(r, e) {
  var t = Ge(!0), n = null, i = yl, s = null, a = Gf(o);
  r = typeof r == "function" ? r : r === void 0 ? ax : Ge(r), e = typeof e == "function" ? e : e === void 0 ? ox : Ge(e);
  function o(c) {
    var l, u = (c = Kf(c)).length, d, f = !1, h;
    for (n == null && (s = i(h = a())), l = 0; l <= u; ++l)
      !(l < u && t(d = c[l], l, c)) === f && ((f = !f) ? s.lineStart() : s.lineEnd()), f && s.point(+r(d, l, c), +e(d, l, c));
    if (h) return s = null, h + "" || null;
  }
  return o.x = function(c) {
    return arguments.length ? (r = typeof c == "function" ? c : Ge(+c), o) : r;
  }, o.y = function(c) {
    return arguments.length ? (e = typeof c == "function" ? c : Ge(+c), o) : e;
  }, o.defined = function(c) {
    return arguments.length ? (t = typeof c == "function" ? c : Ge(!!c), o) : t;
  }, o.curve = function(c) {
    return arguments.length ? (i = c, n != null && (s = i(n)), o) : i;
  }, o.context = function(c) {
    return arguments.length ? (c == null ? n = s = null : s = i(n = c), o) : n;
  }, o;
}
function Ma(r, e, t) {
  var n = null, i = Ge(!0), s = null, a = yl, o = null, c = Gf(l);
  r = typeof r == "function" ? r : r === void 0 ? ax : Ge(+r), e = typeof e == "function" ? e : Ge(e === void 0 ? 0 : +e), t = typeof t == "function" ? t : t === void 0 ? ox : Ge(+t);
  function l(d) {
    var f, h, g, m = (d = Kf(d)).length, p, v = !1, y, b = new Array(m), x = new Array(m);
    for (s == null && (o = a(y = c())), f = 0; f <= m; ++f) {
      if (!(f < m && i(p = d[f], f, d)) === v)
        if (v = !v)
          h = f, o.areaStart(), o.lineStart();
        else {
          for (o.lineEnd(), o.lineStart(), g = f - 1; g >= h; --g)
            o.point(b[g], x[g]);
          o.lineEnd(), o.areaEnd();
        }
      v && (b[f] = +r(p, f, d), x[f] = +e(p, f, d), o.point(n ? +n(p, f, d) : b[f], t ? +t(p, f, d) : x[f]));
    }
    if (y) return o = null, y + "" || null;
  }
  function u() {
    return lx().defined(i).curve(a).context(s);
  }
  return l.x = function(d) {
    return arguments.length ? (r = typeof d == "function" ? d : Ge(+d), n = null, l) : r;
  }, l.x0 = function(d) {
    return arguments.length ? (r = typeof d == "function" ? d : Ge(+d), l) : r;
  }, l.x1 = function(d) {
    return arguments.length ? (n = d == null ? null : typeof d == "function" ? d : Ge(+d), l) : n;
  }, l.y = function(d) {
    return arguments.length ? (e = typeof d == "function" ? d : Ge(+d), t = null, l) : e;
  }, l.y0 = function(d) {
    return arguments.length ? (e = typeof d == "function" ? d : Ge(+d), l) : e;
  }, l.y1 = function(d) {
    return arguments.length ? (t = d == null ? null : typeof d == "function" ? d : Ge(+d), l) : t;
  }, l.lineX0 = l.lineY0 = function() {
    return u().x(r).y(e);
  }, l.lineY1 = function() {
    return u().x(r).y(t);
  }, l.lineX1 = function() {
    return u().x(n).y(e);
  }, l.defined = function(d) {
    return arguments.length ? (i = typeof d == "function" ? d : Ge(!!d), l) : i;
  }, l.curve = function(d) {
    return arguments.length ? (a = d, s != null && (o = a(s)), l) : a;
  }, l.context = function(d) {
    return arguments.length ? (d == null ? s = o = null : o = a(s = d), l) : s;
  }, l;
}
class cx {
  constructor(e, t) {
    this._context = e, this._x = t;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  }
  point(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0: {
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      }
      case 1:
        this._point = 2;
      // falls through
      default: {
        this._x ? this._context.bezierCurveTo(this._x0 = (this._x0 + e) / 2, this._y0, this._x0, t, e, t) : this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + t) / 2, e, this._y0, e, t);
        break;
      }
    }
    this._x0 = e, this._y0 = t;
  }
}
function sP(r) {
  return new cx(r, !0);
}
function aP(r) {
  return new cx(r, !1);
}
const Vf = {
  draw(r, e) {
    const t = Lr(e / wo);
    r.moveTo(t, 0), r.arc(0, 0, t, 0, vl);
  }
}, oP = {
  draw(r, e) {
    const t = Lr(e / 5) / 2;
    r.moveTo(-3 * t, -t), r.lineTo(-t, -t), r.lineTo(-t, -3 * t), r.lineTo(t, -3 * t), r.lineTo(t, -t), r.lineTo(3 * t, -t), r.lineTo(3 * t, t), r.lineTo(t, t), r.lineTo(t, 3 * t), r.lineTo(-t, 3 * t), r.lineTo(-t, t), r.lineTo(-3 * t, t), r.closePath();
  }
}, ux = Lr(1 / 3), lP = ux * 2, cP = {
  draw(r, e) {
    const t = Lr(e / lP), n = t * ux;
    r.moveTo(0, -t), r.lineTo(n, 0), r.lineTo(0, t), r.lineTo(-n, 0), r.closePath();
  }
}, uP = {
  draw(r, e) {
    const t = Lr(e), n = -t / 2;
    r.rect(n, n, t, t);
  }
}, dP = 0.8908130915292852, dx = Ao(wo / 10) / Ao(7 * wo / 10), fP = Ao(vl / 10) * dx, hP = -nx(vl / 10) * dx, gP = {
  draw(r, e) {
    const t = Lr(e * dP), n = fP * t, i = hP * t;
    r.moveTo(0, -t), r.lineTo(n, i);
    for (let s = 1; s < 5; ++s) {
      const a = vl * s / 5, o = nx(a), c = Ao(a);
      r.lineTo(c * t, -o * t), r.lineTo(o * n - c * i, c * n + o * i);
    }
    r.closePath();
  }
}, xc = Lr(3), mP = {
  draw(r, e) {
    const t = -Lr(e / (xc * 3));
    r.moveTo(0, t * 2), r.lineTo(-xc * t, -t), r.lineTo(xc * t, -t), r.closePath();
  }
}, ar = -0.5, or = Lr(3) / 2, bd = 1 / Lr(12), pP = (bd / 2 + 1) * 3, vP = {
  draw(r, e) {
    const t = Lr(e / pP), n = t / 2, i = t * bd, s = n, a = t * bd + t, o = -s, c = a;
    r.moveTo(n, i), r.lineTo(s, a), r.lineTo(o, c), r.lineTo(ar * n - or * i, or * n + ar * i), r.lineTo(ar * s - or * a, or * s + ar * a), r.lineTo(ar * o - or * c, or * o + ar * c), r.lineTo(ar * n + or * i, ar * i - or * n), r.lineTo(ar * s + or * a, ar * a - or * s), r.lineTo(ar * o + or * c, ar * c - or * o), r.closePath();
  }
};
function yP(r, e) {
  let t = null, n = Gf(i);
  r = typeof r == "function" ? r : Ge(r || Vf), e = typeof e == "function" ? e : Ge(e === void 0 ? 64 : +e);
  function i() {
    let s;
    if (t || (t = s = n()), r.apply(this, arguments).draw(t, +e.apply(this, arguments)), s) return t = null, s + "" || null;
  }
  return i.type = function(s) {
    return arguments.length ? (r = typeof s == "function" ? s : Ge(s), i) : r;
  }, i.size = function(s) {
    return arguments.length ? (e = typeof s == "function" ? s : Ge(+s), i) : e;
  }, i.context = function(s) {
    return arguments.length ? (t = s ?? null, i) : t;
  }, i;
}
function Io() {
}
function Po(r, e, t) {
  r._context.bezierCurveTo(
    (2 * r._x0 + r._x1) / 3,
    (2 * r._y0 + r._y1) / 3,
    (r._x0 + 2 * r._x1) / 3,
    (r._y0 + 2 * r._y1) / 3,
    (r._x0 + 4 * r._x1 + e) / 6,
    (r._y0 + 4 * r._y1 + t) / 6
  );
}
function fx(r) {
  this._context = r;
}
fx.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        Po(this, this._x1, this._y1);
      // falls through
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(r, e) {
    switch (r = +r, e = +e, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(r, e) : this._context.moveTo(r, e);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      // falls through
      default:
        Po(this, r, e);
        break;
    }
    this._x0 = this._x1, this._x1 = r, this._y0 = this._y1, this._y1 = e;
  }
};
function bP(r) {
  return new fx(r);
}
function hx(r) {
  this._context = r;
}
hx.prototype = {
  areaStart: Io,
  areaEnd: Io,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2), this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(r, e) {
    switch (r = +r, e = +e, this._point) {
      case 0:
        this._point = 1, this._x2 = r, this._y2 = e;
        break;
      case 1:
        this._point = 2, this._x3 = r, this._y3 = e;
        break;
      case 2:
        this._point = 3, this._x4 = r, this._y4 = e, this._context.moveTo((this._x0 + 4 * this._x1 + r) / 6, (this._y0 + 4 * this._y1 + e) / 6);
        break;
      default:
        Po(this, r, e);
        break;
    }
    this._x0 = this._x1, this._x1 = r, this._y0 = this._y1, this._y1 = e;
  }
};
function xP(r) {
  return new hx(r);
}
function gx(r) {
  this._context = r;
}
gx.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(r, e) {
    switch (r = +r, e = +e, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var t = (this._x0 + 4 * this._x1 + r) / 6, n = (this._y0 + 4 * this._y1 + e) / 6;
        this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        Po(this, r, e);
        break;
    }
    this._x0 = this._x1, this._x1 = r, this._y0 = this._y1, this._y1 = e;
  }
};
function EP(r) {
  return new gx(r);
}
function mx(r) {
  this._context = r;
}
mx.prototype = {
  areaStart: Io,
  areaEnd: Io,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._point && this._context.closePath();
  },
  point: function(r, e) {
    r = +r, e = +e, this._point ? this._context.lineTo(r, e) : (this._point = 1, this._context.moveTo(r, e));
  }
};
function SP(r) {
  return new mx(r);
}
function Om(r) {
  return r < 0 ? -1 : 1;
}
function Rm(r, e, t) {
  var n = r._x1 - r._x0, i = e - r._x1, s = (r._y1 - r._y0) / (n || i < 0 && -0), a = (t - r._y1) / (i || n < 0 && -0), o = (s * i + a * n) / (n + i);
  return (Om(s) + Om(a)) * Math.min(Math.abs(s), Math.abs(a), 0.5 * Math.abs(o)) || 0;
}
function Dm(r, e) {
  var t = r._x1 - r._x0;
  return t ? (3 * (r._y1 - r._y0) / t - e) / 2 : e;
}
function Ec(r, e, t) {
  var n = r._x0, i = r._y0, s = r._x1, a = r._y1, o = (s - n) / 3;
  r._context.bezierCurveTo(n + o, i + o * e, s - o, a - o * t, s, a);
}
function _o(r) {
  this._context = r;
}
_o.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        Ec(this, this._t0, Dm(this, this._t0));
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(r, e) {
    var t = NaN;
    if (r = +r, e = +e, !(r === this._x1 && e === this._y1)) {
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(r, e) : this._context.moveTo(r, e);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, Ec(this, Dm(this, t = Rm(this, r, e)), t);
          break;
        default:
          Ec(this, this._t0, t = Rm(this, r, e));
          break;
      }
      this._x0 = this._x1, this._x1 = r, this._y0 = this._y1, this._y1 = e, this._t0 = t;
    }
  }
};
function px(r) {
  this._context = new vx(r);
}
(px.prototype = Object.create(_o.prototype)).point = function(r, e) {
  _o.prototype.point.call(this, e, r);
};
function vx(r) {
  this._context = r;
}
vx.prototype = {
  moveTo: function(r, e) {
    this._context.moveTo(e, r);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(r, e) {
    this._context.lineTo(e, r);
  },
  bezierCurveTo: function(r, e, t, n, i, s) {
    this._context.bezierCurveTo(e, r, n, t, s, i);
  }
};
function TP(r) {
  return new _o(r);
}
function AP(r) {
  return new px(r);
}
function yx(r) {
  this._context = r;
}
yx.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [], this._y = [];
  },
  lineEnd: function() {
    var r = this._x, e = this._y, t = r.length;
    if (t)
      if (this._line ? this._context.lineTo(r[0], e[0]) : this._context.moveTo(r[0], e[0]), t === 2)
        this._context.lineTo(r[1], e[1]);
      else
        for (var n = Cm(r), i = Cm(e), s = 0, a = 1; a < t; ++s, ++a)
          this._context.bezierCurveTo(n[0][s], i[0][s], n[1][s], i[1][s], r[a], e[a]);
    (this._line || this._line !== 0 && t === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;
  },
  point: function(r, e) {
    this._x.push(+r), this._y.push(+e);
  }
};
function Cm(r) {
  var e, t = r.length - 1, n, i = new Array(t), s = new Array(t), a = new Array(t);
  for (i[0] = 0, s[0] = 2, a[0] = r[0] + 2 * r[1], e = 1; e < t - 1; ++e) i[e] = 1, s[e] = 4, a[e] = 4 * r[e] + 2 * r[e + 1];
  for (i[t - 1] = 2, s[t - 1] = 7, a[t - 1] = 8 * r[t - 1] + r[t], e = 1; e < t; ++e) n = i[e] / s[e - 1], s[e] -= n, a[e] -= n * a[e - 1];
  for (i[t - 1] = a[t - 1] / s[t - 1], e = t - 2; e >= 0; --e) i[e] = (a[e] - i[e + 1]) / s[e];
  for (s[t - 1] = (r[t] + i[t - 1]) / 2, e = 0; e < t - 1; ++e) s[e] = 2 * r[e + 1] - i[e + 1];
  return [i, s];
}
function wP(r) {
  return new yx(r);
}
function bl(r, e) {
  this._context = r, this._t = e;
}
bl.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN, this._point = 0;
  },
  lineEnd: function() {
    0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  },
  point: function(r, e) {
    switch (r = +r, e = +e, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(r, e) : this._context.moveTo(r, e);
        break;
      case 1:
        this._point = 2;
      // falls through
      default: {
        if (this._t <= 0)
          this._context.lineTo(this._x, e), this._context.lineTo(r, e);
        else {
          var t = this._x * (1 - this._t) + r * this._t;
          this._context.lineTo(t, this._y), this._context.lineTo(t, e);
        }
        break;
      }
    }
    this._x = r, this._y = e;
  }
};
function IP(r) {
  return new bl(r, 0.5);
}
function PP(r) {
  return new bl(r, 0);
}
function _P(r) {
  return new bl(r, 1);
}
function Gi(r, e) {
  if ((a = r.length) > 1)
    for (var t = 1, n, i, s = r[e[0]], a, o = s.length; t < a; ++t)
      for (i = s, s = r[e[t]], n = 0; n < o; ++n)
        s[n][1] += s[n][0] = isNaN(i[n][1]) ? i[n][0] : i[n][1];
}
function xd(r) {
  for (var e = r.length, t = new Array(e); --e >= 0; ) t[e] = e;
  return t;
}
function LP(r, e) {
  return r[e];
}
function OP(r) {
  const e = [];
  return e.key = r, e;
}
function RP() {
  var r = Ge([]), e = xd, t = Gi, n = LP;
  function i(s) {
    var a = Array.from(r.apply(this, arguments), OP), o, c = a.length, l = -1, u;
    for (const d of s)
      for (o = 0, ++l; o < c; ++o)
        (a[o][l] = [0, +n(d, a[o].key, l, s)]).data = d;
    for (o = 0, u = Kf(e(a)); o < c; ++o)
      a[u[o]].index = o;
    return t(a, u), a;
  }
  return i.keys = function(s) {
    return arguments.length ? (r = typeof s == "function" ? s : Ge(Array.from(s)), i) : r;
  }, i.value = function(s) {
    return arguments.length ? (n = typeof s == "function" ? s : Ge(+s), i) : n;
  }, i.order = function(s) {
    return arguments.length ? (e = s == null ? xd : typeof s == "function" ? s : Ge(Array.from(s)), i) : e;
  }, i.offset = function(s) {
    return arguments.length ? (t = s ?? Gi, i) : t;
  }, i;
}
function DP(r, e) {
  if ((n = r.length) > 0) {
    for (var t, n, i = 0, s = r[0].length, a; i < s; ++i) {
      for (a = t = 0; t < n; ++t) a += r[t][i][1] || 0;
      if (a) for (t = 0; t < n; ++t) r[t][i][1] /= a;
    }
    Gi(r, e);
  }
}
function CP(r, e) {
  if ((i = r.length) > 0) {
    for (var t = 0, n = r[e[0]], i, s = n.length; t < s; ++t) {
      for (var a = 0, o = 0; a < i; ++a) o += r[a][t][1] || 0;
      n[t][1] += n[t][0] = -o / 2;
    }
    Gi(r, e);
  }
}
function kP(r, e) {
  if (!(!((a = r.length) > 0) || !((s = (i = r[e[0]]).length) > 0))) {
    for (var t = 0, n = 1, i, s, a; n < s; ++n) {
      for (var o = 0, c = 0, l = 0; o < a; ++o) {
        for (var u = r[e[o]], d = u[n][1] || 0, f = u[n - 1][1] || 0, h = (d - f) / 2, g = 0; g < o; ++g) {
          var m = r[e[g]], p = m[n][1] || 0, v = m[n - 1][1] || 0;
          h += p - v;
        }
        c += d, l += h * d;
      }
      i[n - 1][1] += i[n - 1][0] = t, c && (t -= l / c);
    }
    i[n - 1][1] += i[n - 1][0] = t, Gi(r, e);
  }
}
var MP = ["type", "size", "sizeType"];
function Ed() {
  return Ed = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t) ({}).hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, Ed.apply(null, arguments);
}
function km(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function Mm(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? km(Object(t), !0).forEach(function(n) {
      NP(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : km(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function NP(r, e, t) {
  return (e = FP(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function FP(r) {
  var e = $P(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function $P(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function BP(r, e) {
  if (r == null) return {};
  var t, n, i = jP(r, e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(r);
    for (n = 0; n < s.length; n++) t = s[n], e.indexOf(t) === -1 && {}.propertyIsEnumerable.call(r, t) && (i[t] = r[t]);
  }
  return i;
}
function jP(r, e) {
  if (r == null) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.indexOf(n) !== -1) continue;
    t[n] = r[n];
  }
  return t;
}
var bx = {
  symbolCircle: Vf,
  symbolCross: oP,
  symbolDiamond: cP,
  symbolSquare: uP,
  symbolStar: gP,
  symbolTriangle: mP,
  symbolWye: vP
}, UP = Math.PI / 180, GP = (r) => {
  var e = "symbol".concat(la(r));
  return bx[e] || Vf;
}, KP = (r, e, t) => {
  if (e === "area")
    return r;
  switch (t) {
    case "cross":
      return 5 * r * r / 9;
    case "diamond":
      return 0.5 * r * r / Math.sqrt(3);
    case "square":
      return r * r;
    case "star": {
      var n = 18 * UP;
      return 1.25 * r * r * (Math.tan(n) - Math.tan(n * 2) * Math.tan(n) ** 2);
    }
    case "triangle":
      return Math.sqrt(3) * r * r / 4;
    case "wye":
      return (21 - 10 * Math.sqrt(3)) * r * r / 8;
    default:
      return Math.PI * r * r / 4;
  }
}, VP = (r, e) => {
  bx["symbol".concat(la(r))] = e;
}, xl = (r) => {
  var {
    type: e = "circle",
    size: t = 64,
    sizeType: n = "area"
  } = r, i = BP(r, MP), s = Mm(Mm({}, i), {}, {
    type: e,
    size: t,
    sizeType: n
  }), a = () => {
    var d = GP(e), f = yP().type(d).size(KP(t, n, e));
    return f();
  }, {
    className: o,
    cx: c,
    cy: l
  } = s, u = de(s, !0);
  return c === +c && l === +l && t === +t ? /* @__PURE__ */ w.createElement("path", Ed({}, u, {
    className: ve("recharts-symbols", o),
    transform: "translate(".concat(c, ", ").concat(l, ")"),
    d: a()
  })) : null;
};
xl.registerSymbol = VP;
function Sd() {
  return Sd = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t) ({}).hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, Sd.apply(null, arguments);
}
function Nm(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function WP(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Nm(Object(t), !0).forEach(function(n) {
      Wf(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : Nm(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function Wf(r, e, t) {
  return (e = HP(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function HP(r) {
  var e = qP(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function qP(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
var lr = 32;
class Hf extends Kr {
  /**
   * Render the path of icon
   * @param data Data of each legend item
   * @param iconType if defined, it will always render this icon. If undefined then it uses icon from data.type
   * @return Path element
   */
  renderIcon(e, t) {
    var {
      inactiveColor: n
    } = this.props, i = lr / 2, s = lr / 6, a = lr / 3, o = e.inactive ? n : e.color, c = t ?? e.type;
    if (c === "none")
      return null;
    if (c === "plainline")
      return /* @__PURE__ */ w.createElement("line", {
        strokeWidth: 4,
        fill: "none",
        stroke: o,
        strokeDasharray: e.payload.strokeDasharray,
        x1: 0,
        y1: i,
        x2: lr,
        y2: i,
        className: "recharts-legend-icon"
      });
    if (c === "line")
      return /* @__PURE__ */ w.createElement("path", {
        strokeWidth: 4,
        fill: "none",
        stroke: o,
        d: "M0,".concat(i, "h").concat(a, `
            A`).concat(s, ",").concat(s, ",0,1,1,").concat(2 * a, ",").concat(i, `
            H`).concat(lr, "M").concat(2 * a, ",").concat(i, `
            A`).concat(s, ",").concat(s, ",0,1,1,").concat(a, ",").concat(i),
        className: "recharts-legend-icon"
      });
    if (c === "rect")
      return /* @__PURE__ */ w.createElement("path", {
        stroke: "none",
        fill: o,
        d: "M0,".concat(lr / 8, "h").concat(lr, "v").concat(lr * 3 / 4, "h").concat(-lr, "z"),
        className: "recharts-legend-icon"
      });
    if (/* @__PURE__ */ w.isValidElement(e.legendIcon)) {
      var l = WP({}, e);
      return delete l.legendIcon, /* @__PURE__ */ w.cloneElement(e.legendIcon, l);
    }
    return /* @__PURE__ */ w.createElement(xl, {
      fill: o,
      cx: i,
      cy: i,
      size: lr,
      sizeType: "diameter",
      type: c
    });
  }
  /**
   * Draw items of legend
   * @return Items
   */
  renderItems() {
    var {
      payload: e,
      iconSize: t,
      layout: n,
      formatter: i,
      inactiveColor: s,
      iconType: a
    } = this.props, o = {
      x: 0,
      y: 0,
      width: lr,
      height: lr
    }, c = {
      display: n === "horizontal" ? "inline-block" : "block",
      marginRight: 10
    }, l = {
      display: "inline-block",
      verticalAlign: "middle",
      marginRight: 4
    };
    return e.map((u, d) => {
      var f = u.formatter || i, h = ve({
        "recharts-legend-item": !0,
        ["legend-item-".concat(d)]: !0,
        inactive: u.inactive
      });
      if (u.type === "none")
        return null;
      var g = u.inactive ? s : u.color, m = f ? f(u.value, u, d) : u.value;
      return /* @__PURE__ */ w.createElement("li", Sd({
        className: h,
        style: c,
        key: "legend-item-".concat(d)
      }, ns(this.props, u, d)), /* @__PURE__ */ w.createElement(Uf, {
        width: t,
        height: t,
        viewBox: o,
        style: l,
        "aria-label": "".concat(m, " legend icon")
      }, this.renderIcon(u, a)), /* @__PURE__ */ w.createElement("span", {
        className: "recharts-legend-item-text",
        style: {
          color: g
        }
      }, m));
    });
  }
  render() {
    var {
      payload: e,
      layout: t,
      align: n
    } = this.props;
    if (!e || !e.length)
      return null;
    var i = {
      padding: 0,
      margin: 0,
      textAlign: t === "horizontal" ? n : "left"
    };
    return /* @__PURE__ */ w.createElement("ul", {
      className: "recharts-default-legend",
      style: i
    }, this.renderItems());
  }
}
Wf(Hf, "displayName", "Legend");
Wf(Hf, "defaultProps", {
  align: "center",
  iconSize: 14,
  inactiveColor: "#ccc",
  layout: "horizontal",
  verticalAlign: "middle"
});
var Sc = {}, Tc = {}, Fm;
function zP() {
  return Fm || (Fm = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    function e(t, n) {
      const i = /* @__PURE__ */ new Map();
      for (let s = 0; s < t.length; s++) {
        const a = t[s], o = n(a);
        i.has(o) || i.set(o, a);
      }
      return Array.from(i.values());
    }
    r.uniqBy = e;
  }(Tc)), Tc;
}
var Ac = {}, $m;
function xx() {
  return $m || ($m = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    function e(t) {
      return t;
    }
    r.identity = e;
  }(Ac)), Ac;
}
var wc = {}, Ic = {}, Pc = {}, Bm;
function YP() {
  return Bm || (Bm = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    function e(t) {
      return Number.isSafeInteger(t) && t >= 0;
    }
    r.isLength = e;
  }(Pc)), Pc;
}
var jm;
function qf() {
  return jm || (jm = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    const e = /* @__PURE__ */ YP();
    function t(n) {
      return n != null && typeof n != "function" && e.isLength(n.length);
    }
    r.isArrayLike = t;
  }(Ic)), Ic;
}
var _c = {}, Um;
function XP() {
  return Um || (Um = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    function e(t) {
      return typeof t == "object" && t !== null;
    }
    r.isObjectLike = e;
  }(_c)), _c;
}
var Gm;
function QP() {
  return Gm || (Gm = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    const e = /* @__PURE__ */ qf(), t = /* @__PURE__ */ XP();
    function n(i) {
      return t.isObjectLike(i) && e.isArrayLike(i);
    }
    r.isArrayLikeObject = n;
  }(wc)), wc;
}
var Lc = {}, Oc = {}, Km;
function ZP() {
  return Km || (Km = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    const e = /* @__PURE__ */ $f();
    function t(n) {
      return function(i) {
        return e.get(i, n);
      };
    }
    r.property = t;
  }(Oc)), Oc;
}
var Rc = {}, Dc = {}, Cc = {}, kc = {}, Vm;
function Ex() {
  return Vm || (Vm = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    function e(t) {
      return t !== null && (typeof t == "object" || typeof t == "function");
    }
    r.isObject = e;
  }(kc)), kc;
}
var Mc = {}, Wm;
function Sx() {
  return Wm || (Wm = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    function e(t) {
      return t == null || typeof t != "object" && typeof t != "function";
    }
    r.isPrimitive = e;
  }(Mc)), Mc;
}
var Nc = {}, Hm;
function zf() {
  return Hm || (Hm = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    function e(t, n) {
      return t === n || Number.isNaN(t) && Number.isNaN(n);
    }
    r.eq = e;
  }(Nc)), Nc;
}
var qm;
function JP() {
  return qm || (qm = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    const e = /* @__PURE__ */ Yf(), t = /* @__PURE__ */ Ex(), n = /* @__PURE__ */ Sx(), i = /* @__PURE__ */ zf();
    function s(d, f, h) {
      return typeof h != "function" ? e.isMatch(d, f) : a(d, f, function g(m, p, v, y, b, x) {
        const S = h(m, p, v, y, b, x);
        return S !== void 0 ? !!S : a(m, p, g, x);
      }, /* @__PURE__ */ new Map());
    }
    function a(d, f, h, g) {
      if (f === d)
        return !0;
      switch (typeof f) {
        case "object":
          return o(d, f, h, g);
        case "function":
          return Object.keys(f).length > 0 ? a(d, { ...f }, h, g) : i.eq(d, f);
        default:
          return t.isObject(d) ? typeof f == "string" ? f === "" : !0 : i.eq(d, f);
      }
    }
    function o(d, f, h, g) {
      if (f == null)
        return !0;
      if (Array.isArray(f))
        return l(d, f, h, g);
      if (f instanceof Map)
        return c(d, f, h, g);
      if (f instanceof Set)
        return u(d, f, h, g);
      const m = Object.keys(f);
      if (d == null)
        return m.length === 0;
      if (m.length === 0)
        return !0;
      if (g && g.has(f))
        return g.get(f) === d;
      g && g.set(f, d);
      try {
        for (let p = 0; p < m.length; p++) {
          const v = m[p];
          if (!n.isPrimitive(d) && !(v in d) || f[v] === void 0 && d[v] !== void 0 || f[v] === null && d[v] !== null || !h(d[v], f[v], v, d, f, g))
            return !1;
        }
        return !0;
      } finally {
        g && g.delete(f);
      }
    }
    function c(d, f, h, g) {
      if (f.size === 0)
        return !0;
      if (!(d instanceof Map))
        return !1;
      for (const [m, p] of f.entries()) {
        const v = d.get(m);
        if (h(v, p, m, d, f, g) === !1)
          return !1;
      }
      return !0;
    }
    function l(d, f, h, g) {
      if (f.length === 0)
        return !0;
      if (!Array.isArray(d))
        return !1;
      const m = /* @__PURE__ */ new Set();
      for (let p = 0; p < f.length; p++) {
        const v = f[p];
        let y = !1;
        for (let b = 0; b < d.length; b++) {
          if (m.has(b))
            continue;
          const x = d[b];
          let S = !1;
          if (h(x, v, p, d, f, g) && (S = !0), S) {
            m.add(b), y = !0;
            break;
          }
        }
        if (!y)
          return !1;
      }
      return !0;
    }
    function u(d, f, h, g) {
      return f.size === 0 ? !0 : d instanceof Set ? l([...d], [...f], h, g) : !1;
    }
    r.isMatchWith = s, r.isSetMatch = u;
  }(Cc)), Cc;
}
var zm;
function Yf() {
  return zm || (zm = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    const e = /* @__PURE__ */ JP();
    function t(n, i) {
      return e.isMatchWith(n, i, () => {
      });
    }
    r.isMatch = t;
  }(Dc)), Dc;
}
var Fc = {}, $c = {}, Bc = {}, Ym;
function Tx() {
  return Ym || (Ym = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    function e(t) {
      return Object.getOwnPropertySymbols(t).filter((n) => Object.prototype.propertyIsEnumerable.call(t, n));
    }
    r.getSymbols = e;
  }(Bc)), Bc;
}
var jc = {}, Xm;
function Xf() {
  return Xm || (Xm = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    function e(t) {
      return t == null ? t === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(t);
    }
    r.getTag = e;
  }(jc)), jc;
}
var Uc = {}, Qm;
function Qf() {
  return Qm || (Qm = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    const e = "[object RegExp]", t = "[object String]", n = "[object Number]", i = "[object Boolean]", s = "[object Arguments]", a = "[object Symbol]", o = "[object Date]", c = "[object Map]", l = "[object Set]", u = "[object Array]", d = "[object Function]", f = "[object ArrayBuffer]", h = "[object Object]", g = "[object Error]", m = "[object DataView]", p = "[object Uint8Array]", v = "[object Uint8ClampedArray]", y = "[object Uint16Array]", b = "[object Uint32Array]", x = "[object BigUint64Array]", S = "[object Int8Array]", A = "[object Int16Array]", T = "[object Int32Array]", I = "[object BigInt64Array]", L = "[object Float32Array]", _ = "[object Float64Array]";
    r.argumentsTag = s, r.arrayBufferTag = f, r.arrayTag = u, r.bigInt64ArrayTag = I, r.bigUint64ArrayTag = x, r.booleanTag = i, r.dataViewTag = m, r.dateTag = o, r.errorTag = g, r.float32ArrayTag = L, r.float64ArrayTag = _, r.functionTag = d, r.int16ArrayTag = A, r.int32ArrayTag = T, r.int8ArrayTag = S, r.mapTag = c, r.numberTag = n, r.objectTag = h, r.regexpTag = e, r.setTag = l, r.stringTag = t, r.symbolTag = a, r.uint16ArrayTag = y, r.uint32ArrayTag = b, r.uint8ArrayTag = p, r.uint8ClampedArrayTag = v;
  }(Uc)), Uc;
}
var Gc = {}, Zm;
function e_() {
  return Zm || (Zm = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    function e(t) {
      return ArrayBuffer.isView(t) && !(t instanceof DataView);
    }
    r.isTypedArray = e;
  }(Gc)), Gc;
}
var Jm;
function Ax() {
  return Jm || (Jm = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    const e = /* @__PURE__ */ Tx(), t = /* @__PURE__ */ Xf(), n = /* @__PURE__ */ Qf(), i = /* @__PURE__ */ Sx(), s = /* @__PURE__ */ e_();
    function a(u, d) {
      return o(u, void 0, u, /* @__PURE__ */ new Map(), d);
    }
    function o(u, d, f, h = /* @__PURE__ */ new Map(), g = void 0) {
      const m = g == null ? void 0 : g(u, d, f, h);
      if (m != null)
        return m;
      if (i.isPrimitive(u))
        return u;
      if (h.has(u))
        return h.get(u);
      if (Array.isArray(u)) {
        const p = new Array(u.length);
        h.set(u, p);
        for (let v = 0; v < u.length; v++)
          p[v] = o(u[v], v, f, h, g);
        return Object.hasOwn(u, "index") && (p.index = u.index), Object.hasOwn(u, "input") && (p.input = u.input), p;
      }
      if (u instanceof Date)
        return new Date(u.getTime());
      if (u instanceof RegExp) {
        const p = new RegExp(u.source, u.flags);
        return p.lastIndex = u.lastIndex, p;
      }
      if (u instanceof Map) {
        const p = /* @__PURE__ */ new Map();
        h.set(u, p);
        for (const [v, y] of u)
          p.set(v, o(y, v, f, h, g));
        return p;
      }
      if (u instanceof Set) {
        const p = /* @__PURE__ */ new Set();
        h.set(u, p);
        for (const v of u)
          p.add(o(v, void 0, f, h, g));
        return p;
      }
      if (typeof Buffer < "u" && Buffer.isBuffer(u))
        return u.subarray();
      if (s.isTypedArray(u)) {
        const p = new (Object.getPrototypeOf(u)).constructor(u.length);
        h.set(u, p);
        for (let v = 0; v < u.length; v++)
          p[v] = o(u[v], v, f, h, g);
        return p;
      }
      if (u instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && u instanceof SharedArrayBuffer)
        return u.slice(0);
      if (u instanceof DataView) {
        const p = new DataView(u.buffer.slice(0), u.byteOffset, u.byteLength);
        return h.set(u, p), c(p, u, f, h, g), p;
      }
      if (typeof File < "u" && u instanceof File) {
        const p = new File([u], u.name, {
          type: u.type
        });
        return h.set(u, p), c(p, u, f, h, g), p;
      }
      if (u instanceof Blob) {
        const p = new Blob([u], { type: u.type });
        return h.set(u, p), c(p, u, f, h, g), p;
      }
      if (u instanceof Error) {
        const p = new u.constructor();
        return h.set(u, p), p.message = u.message, p.name = u.name, p.stack = u.stack, p.cause = u.cause, c(p, u, f, h, g), p;
      }
      if (typeof u == "object" && l(u)) {
        const p = Object.create(Object.getPrototypeOf(u));
        return h.set(u, p), c(p, u, f, h, g), p;
      }
      return u;
    }
    function c(u, d, f = u, h, g) {
      const m = [...Object.keys(d), ...e.getSymbols(d)];
      for (let p = 0; p < m.length; p++) {
        const v = m[p], y = Object.getOwnPropertyDescriptor(u, v);
        (y == null || y.writable) && (u[v] = o(d[v], v, f, h, g));
      }
    }
    function l(u) {
      switch (t.getTag(u)) {
        case n.argumentsTag:
        case n.arrayTag:
        case n.arrayBufferTag:
        case n.dataViewTag:
        case n.booleanTag:
        case n.dateTag:
        case n.float32ArrayTag:
        case n.float64ArrayTag:
        case n.int8ArrayTag:
        case n.int16ArrayTag:
        case n.int32ArrayTag:
        case n.mapTag:
        case n.numberTag:
        case n.objectTag:
        case n.regexpTag:
        case n.setTag:
        case n.stringTag:
        case n.symbolTag:
        case n.uint8ArrayTag:
        case n.uint8ClampedArrayTag:
        case n.uint16ArrayTag:
        case n.uint32ArrayTag:
          return !0;
        default:
          return !1;
      }
    }
    r.cloneDeepWith = a, r.cloneDeepWithImpl = o, r.copyProperties = c;
  }($c)), $c;
}
var ep;
function t_() {
  return ep || (ep = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    const e = /* @__PURE__ */ Ax();
    function t(n) {
      return e.cloneDeepWithImpl(n, void 0, n, /* @__PURE__ */ new Map(), void 0);
    }
    r.cloneDeep = t;
  }(Fc)), Fc;
}
var tp;
function r_() {
  return tp || (tp = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    const e = /* @__PURE__ */ Yf(), t = /* @__PURE__ */ t_();
    function n(i) {
      return i = t.cloneDeep(i), (s) => e.isMatch(s, i);
    }
    r.matches = n;
  }(Rc)), Rc;
}
var Kc = {}, Vc = {}, Wc = {}, rp;
function n_() {
  return rp || (rp = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    const e = /* @__PURE__ */ Ax(), t = /* @__PURE__ */ Qf();
    function n(i, s) {
      return e.cloneDeepWith(i, (a, o, c, l) => {
        const u = s == null ? void 0 : s(a, o, c, l);
        if (u != null)
          return u;
        if (typeof i == "object")
          switch (Object.prototype.toString.call(i)) {
            case t.numberTag:
            case t.stringTag:
            case t.booleanTag: {
              const d = new i.constructor(i == null ? void 0 : i.valueOf());
              return e.copyProperties(d, i), d;
            }
            case t.argumentsTag: {
              const d = {};
              return e.copyProperties(d, i), d.length = i.length, d[Symbol.iterator] = i[Symbol.iterator], d;
            }
            default:
              return;
          }
      });
    }
    r.cloneDeepWith = n;
  }(Wc)), Wc;
}
var np;
function i_() {
  return np || (np = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    const e = /* @__PURE__ */ n_();
    function t(n) {
      return e.cloneDeepWith(n);
    }
    r.cloneDeep = t;
  }(Vc)), Vc;
}
var Hc = {}, qc = {}, ip;
function wx() {
  return ip || (ip = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    const e = /^(?:0|[1-9]\d*)$/;
    function t(n, i = Number.MAX_SAFE_INTEGER) {
      switch (typeof n) {
        case "number":
          return Number.isInteger(n) && n >= 0 && n < i;
        case "symbol":
          return !1;
        case "string":
          return e.test(n);
      }
    }
    r.isIndex = t;
  }(qc)), qc;
}
var zc = {}, sp;
function s_() {
  return sp || (sp = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    const e = /* @__PURE__ */ Xf();
    function t(n) {
      return n !== null && typeof n == "object" && e.getTag(n) === "[object Arguments]";
    }
    r.isArguments = t;
  }(zc)), zc;
}
var ap;
function a_() {
  return ap || (ap = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    const e = /* @__PURE__ */ Qb(), t = /* @__PURE__ */ wx(), n = /* @__PURE__ */ s_(), i = /* @__PURE__ */ Ff();
    function s(a, o) {
      let c;
      if (Array.isArray(o) ? c = o : typeof o == "string" && e.isDeepKey(o) && (a == null ? void 0 : a[o]) == null ? c = i.toPath(o) : c = [o], c.length === 0)
        return !1;
      let l = a;
      for (let u = 0; u < c.length; u++) {
        const d = c[u];
        if ((l == null || !Object.hasOwn(l, d)) && !((Array.isArray(l) || n.isArguments(l)) && t.isIndex(d) && d < l.length))
          return !1;
        l = l[d];
      }
      return !0;
    }
    r.has = s;
  }(Hc)), Hc;
}
var op;
function o_() {
  return op || (op = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    const e = /* @__PURE__ */ Yf(), t = /* @__PURE__ */ Zb(), n = /* @__PURE__ */ i_(), i = /* @__PURE__ */ $f(), s = /* @__PURE__ */ a_();
    function a(o, c) {
      switch (typeof o) {
        case "object": {
          Object.is(o == null ? void 0 : o.valueOf(), -0) && (o = "-0");
          break;
        }
        case "number": {
          o = t.toKey(o);
          break;
        }
      }
      return c = n.cloneDeep(c), function(l) {
        const u = i.get(l, o);
        return u === void 0 ? s.has(l, o) : c === void 0 ? u === void 0 : e.isMatch(u, c);
      };
    }
    r.matchesProperty = a;
  }(Kc)), Kc;
}
var lp;
function l_() {
  return lp || (lp = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    const e = /* @__PURE__ */ xx(), t = /* @__PURE__ */ ZP(), n = /* @__PURE__ */ r_(), i = /* @__PURE__ */ o_();
    function s(a) {
      if (a == null)
        return e.identity;
      switch (typeof a) {
        case "function":
          return a;
        case "object":
          return Array.isArray(a) && a.length === 2 ? i.matchesProperty(a[0], a[1]) : n.matches(a);
        case "string":
        case "symbol":
        case "number":
          return t.property(a);
      }
    }
    r.iteratee = s;
  }(Lc)), Lc;
}
var cp;
function c_() {
  return cp || (cp = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    const e = /* @__PURE__ */ zP(), t = /* @__PURE__ */ xx(), n = /* @__PURE__ */ QP(), i = /* @__PURE__ */ l_();
    function s(a, o = t.identity) {
      return n.isArrayLikeObject(a) ? e.uniqBy(Array.from(a), i.iteratee(o)) : [];
    }
    r.uniqBy = s;
  }(Sc)), Sc;
}
var Yc, up;
function u_() {
  return up || (up = 1, Yc = c_().uniqBy), Yc;
}
var d_ = /* @__PURE__ */ u_();
const dp = /* @__PURE__ */ hn(d_);
function Ix(r, e, t) {
  return e === !0 ? dp(r, t) : typeof e == "function" ? dp(r, e) : r;
}
var Na = { exports: {} }, Xc = {}, Fa = { exports: {} }, Qc = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var fp;
function f_() {
  if (fp) return Qc;
  fp = 1;
  var r = Ct;
  function e(d, f) {
    return d === f && (d !== 0 || 1 / d === 1 / f) || d !== d && f !== f;
  }
  var t = typeof Object.is == "function" ? Object.is : e, n = r.useState, i = r.useEffect, s = r.useLayoutEffect, a = r.useDebugValue;
  function o(d, f) {
    var h = f(), g = n({ inst: { value: h, getSnapshot: f } }), m = g[0].inst, p = g[1];
    return s(
      function() {
        m.value = h, m.getSnapshot = f, c(m) && p({ inst: m });
      },
      [d, h, f]
    ), i(
      function() {
        return c(m) && p({ inst: m }), d(function() {
          c(m) && p({ inst: m });
        });
      },
      [d]
    ), a(h), h;
  }
  function c(d) {
    var f = d.getSnapshot;
    d = d.value;
    try {
      var h = f();
      return !t(d, h);
    } catch {
      return !0;
    }
  }
  function l(d, f) {
    return f();
  }
  var u = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? l : o;
  return Qc.useSyncExternalStore = r.useSyncExternalStore !== void 0 ? r.useSyncExternalStore : u, Qc;
}
var Zc = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hp;
function h_() {
  return hp || (hp = 1, process.env.NODE_ENV !== "production" && function() {
    function r(h, g) {
      return h === g && (h !== 0 || 1 / h === 1 / g) || h !== h && g !== g;
    }
    function e(h, g) {
      u || i.startTransition === void 0 || (u = !0, console.error(
        "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
      ));
      var m = g();
      if (!d) {
        var p = g();
        s(m, p) || (console.error(
          "The result of getSnapshot should be cached to avoid an infinite loop"
        ), d = !0);
      }
      p = a({
        inst: { value: m, getSnapshot: g }
      });
      var v = p[0].inst, y = p[1];
      return c(
        function() {
          v.value = m, v.getSnapshot = g, t(v) && y({ inst: v });
        },
        [h, m, g]
      ), o(
        function() {
          return t(v) && y({ inst: v }), h(function() {
            t(v) && y({ inst: v });
          });
        },
        [h]
      ), l(m), m;
    }
    function t(h) {
      var g = h.getSnapshot;
      h = h.value;
      try {
        var m = g();
        return !s(h, m);
      } catch {
        return !0;
      }
    }
    function n(h, g) {
      return g();
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var i = Ct, s = typeof Object.is == "function" ? Object.is : r, a = i.useState, o = i.useEffect, c = i.useLayoutEffect, l = i.useDebugValue, u = !1, d = !1, f = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? n : e;
    Zc.useSyncExternalStore = i.useSyncExternalStore !== void 0 ? i.useSyncExternalStore : f, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }()), Zc;
}
var gp;
function Px() {
  return gp || (gp = 1, process.env.NODE_ENV === "production" ? Fa.exports = f_() : Fa.exports = h_()), Fa.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var mp;
function g_() {
  if (mp) return Xc;
  mp = 1;
  var r = Ct, e = Px();
  function t(l, u) {
    return l === u && (l !== 0 || 1 / l === 1 / u) || l !== l && u !== u;
  }
  var n = typeof Object.is == "function" ? Object.is : t, i = e.useSyncExternalStore, s = r.useRef, a = r.useEffect, o = r.useMemo, c = r.useDebugValue;
  return Xc.useSyncExternalStoreWithSelector = function(l, u, d, f, h) {
    var g = s(null);
    if (g.current === null) {
      var m = { hasValue: !1, value: null };
      g.current = m;
    } else m = g.current;
    g = o(
      function() {
        function v(A) {
          if (!y) {
            if (y = !0, b = A, A = f(A), h !== void 0 && m.hasValue) {
              var T = m.value;
              if (h(T, A))
                return x = T;
            }
            return x = A;
          }
          if (T = x, n(b, A)) return T;
          var I = f(A);
          return h !== void 0 && h(T, I) ? (b = A, T) : (b = A, x = I);
        }
        var y = !1, b, x, S = d === void 0 ? null : d;
        return [
          function() {
            return v(u());
          },
          S === null ? void 0 : function() {
            return v(S());
          }
        ];
      },
      [u, d, f, h]
    );
    var p = i(l, g[0], g[1]);
    return a(
      function() {
        m.hasValue = !0, m.value = p;
      },
      [p]
    ), c(p), p;
  }, Xc;
}
var Jc = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var pp;
function m_() {
  return pp || (pp = 1, process.env.NODE_ENV !== "production" && function() {
    function r(l, u) {
      return l === u && (l !== 0 || 1 / l === 1 / u) || l !== l && u !== u;
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var e = Ct, t = Px(), n = typeof Object.is == "function" ? Object.is : r, i = t.useSyncExternalStore, s = e.useRef, a = e.useEffect, o = e.useMemo, c = e.useDebugValue;
    Jc.useSyncExternalStoreWithSelector = function(l, u, d, f, h) {
      var g = s(null);
      if (g.current === null) {
        var m = { hasValue: !1, value: null };
        g.current = m;
      } else m = g.current;
      g = o(
        function() {
          function v(A) {
            if (!y) {
              if (y = !0, b = A, A = f(A), h !== void 0 && m.hasValue) {
                var T = m.value;
                if (h(T, A))
                  return x = T;
              }
              return x = A;
            }
            if (T = x, n(b, A))
              return T;
            var I = f(A);
            return h !== void 0 && h(T, I) ? (b = A, T) : (b = A, x = I);
          }
          var y = !1, b, x, S = d === void 0 ? null : d;
          return [
            function() {
              return v(u());
            },
            S === null ? void 0 : function() {
              return v(S());
            }
          ];
        },
        [u, d, f, h]
      );
      var p = i(l, g[0], g[1]);
      return a(
        function() {
          m.hasValue = !0, m.value = p;
        },
        [p]
      ), c(p), p;
    }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }()), Jc;
}
var vp;
function p_() {
  return vp || (vp = 1, process.env.NODE_ENV === "production" ? Na.exports = g_() : Na.exports = m_()), Na.exports;
}
var v_ = p_(), Zf = /* @__PURE__ */ dn(null), y_ = (r) => r, He = () => {
  var r = un(Zf);
  return r ? r.store.dispatch : y_;
}, mo = () => {
}, b_ = () => mo, x_ = (r, e) => r === e;
function te(r) {
  var e = un(Zf);
  return v_.useSyncExternalStoreWithSelector(e ? e.subscription.addNestedSub : b_, e ? e.store.getState : mo, e ? e.store.getState : mo, e ? r : mo, x_);
}
var E_ = (r, e, t) => {
  if (e.length === 1 && e[0] === t) {
    let n = !1;
    try {
      const i = {};
      r(i) === i && (n = !0);
    } catch {
    }
    if (n) {
      let i;
      try {
        throw new Error();
      } catch (s) {
        ({ stack: i } = s);
      }
      console.warn(
        `The result function returned its own inputs without modification. e.g
\`createSelector([state => state.todos], todos => todos)\`
This could lead to inefficient memoization and unnecessary re-renders.
Ensure transformation logic is in the result function, and extraction logic is in the input selectors.`,
        { stack: i }
      );
    }
  }
}, S_ = (r, e, t) => {
  const { memoize: n, memoizeOptions: i } = e, { inputSelectorResults: s, inputSelectorResultsCopy: a } = r, o = n(() => ({}), ...i);
  if (!(o.apply(null, s) === o.apply(null, a))) {
    let l;
    try {
      throw new Error();
    } catch (u) {
      ({ stack: l } = u);
    }
    console.warn(
      `An input selector returned a different result when passed same arguments.
This means your output selector will likely run more frequently than intended.
Avoid returning a new reference inside your input selector, e.g.
\`createSelector([state => state.todos.map(todo => todo.id)], todoIds => todoIds.length)\``,
      {
        arguments: t,
        firstInputs: s,
        secondInputs: a,
        stack: l
      }
    );
  }
}, T_ = {
  inputStabilityCheck: "once",
  identityFunctionCheck: "once"
};
function A_(r, e = `expected a function, instead received ${typeof r}`) {
  if (typeof r != "function")
    throw new TypeError(e);
}
function w_(r, e = `expected an object, instead received ${typeof r}`) {
  if (typeof r != "object")
    throw new TypeError(e);
}
function I_(r, e = "expected all items to be functions, instead received the following types: ") {
  if (!r.every((t) => typeof t == "function")) {
    const t = r.map(
      (n) => typeof n == "function" ? `function ${n.name || "unnamed"}()` : typeof n
    ).join(", ");
    throw new TypeError(`${e}[${t}]`);
  }
}
var yp = (r) => Array.isArray(r) ? r : [r];
function P_(r) {
  const e = Array.isArray(r[0]) ? r[0] : r;
  return I_(
    e,
    "createSelector expects all input-selectors to be functions, but received the following types: "
  ), e;
}
function bp(r, e) {
  const t = [], { length: n } = r;
  for (let i = 0; i < n; i++)
    t.push(r[i].apply(null, e));
  return t;
}
var __ = (r, e) => {
  const { identityFunctionCheck: t, inputStabilityCheck: n } = {
    ...T_,
    ...e
  };
  return {
    identityFunctionCheck: {
      shouldRun: t === "always" || t === "once" && r,
      run: E_
    },
    inputStabilityCheck: {
      shouldRun: n === "always" || n === "once" && r,
      run: S_
    }
  };
}, L_ = class {
  constructor(r) {
    this.value = r;
  }
  deref() {
    return this.value;
  }
}, O_ = typeof WeakRef < "u" ? WeakRef : L_, R_ = 0, xp = 1;
function $a() {
  return {
    s: R_,
    v: void 0,
    o: null,
    p: null
  };
}
function _x(r, e = {}) {
  let t = $a();
  const { resultEqualityCheck: n } = e;
  let i, s = 0;
  function a() {
    var d;
    let o = t;
    const { length: c } = arguments;
    for (let f = 0, h = c; f < h; f++) {
      const g = arguments[f];
      if (typeof g == "function" || typeof g == "object" && g !== null) {
        let m = o.o;
        m === null && (o.o = m = /* @__PURE__ */ new WeakMap());
        const p = m.get(g);
        p === void 0 ? (o = $a(), m.set(g, o)) : o = p;
      } else {
        let m = o.p;
        m === null && (o.p = m = /* @__PURE__ */ new Map());
        const p = m.get(g);
        p === void 0 ? (o = $a(), m.set(g, o)) : o = p;
      }
    }
    const l = o;
    let u;
    if (o.s === xp)
      u = o.v;
    else if (u = r.apply(null, arguments), s++, n) {
      const f = ((d = i == null ? void 0 : i.deref) == null ? void 0 : d.call(i)) ?? i;
      f != null && n(f, u) && (u = f, s !== 0 && s--), i = typeof u == "object" && u !== null || typeof u == "function" ? new O_(u) : u;
    }
    return l.s = xp, l.v = u, u;
  }
  return a.clearCache = () => {
    t = $a(), a.resetResultsCount();
  }, a.resultsCount = () => s, a.resetResultsCount = () => {
    s = 0;
  }, a;
}
function D_(r, ...e) {
  const t = typeof r == "function" ? {
    memoize: r,
    memoizeOptions: e
  } : r, n = (...i) => {
    let s = 0, a = 0, o, c = {}, l = i.pop();
    typeof l == "object" && (c = l, l = i.pop()), A_(
      l,
      `createSelector expects an output function after the inputs, but received: [${typeof l}]`
    );
    const u = {
      ...t,
      ...c
    }, {
      memoize: d,
      memoizeOptions: f = [],
      argsMemoize: h = _x,
      argsMemoizeOptions: g = [],
      devModeChecks: m = {}
    } = u, p = yp(f), v = yp(g), y = P_(i), b = d(function() {
      return s++, l.apply(
        null,
        arguments
      );
    }, ...p);
    let x = !0;
    const S = h(function() {
      a++;
      const T = bp(
        y,
        arguments
      );
      if (o = b.apply(null, T), process.env.NODE_ENV !== "production") {
        const { identityFunctionCheck: I, inputStabilityCheck: L } = __(x, m);
        if (I.shouldRun && I.run(
          l,
          T,
          o
        ), L.shouldRun) {
          const _ = bp(
            y,
            arguments
          );
          L.run(
            { inputSelectorResults: T, inputSelectorResultsCopy: _ },
            { memoize: d, memoizeOptions: p },
            arguments
          );
        }
        x && (x = !1);
      }
      return o;
    }, ...v);
    return Object.assign(S, {
      resultFunc: l,
      memoizedResultFunc: b,
      dependencies: y,
      dependencyRecomputations: () => a,
      resetDependencyRecomputations: () => {
        a = 0;
      },
      lastResult: () => o,
      recomputations: () => s,
      resetRecomputations: () => {
        s = 0;
      },
      memoize: d,
      argsMemoize: h
    });
  };
  return Object.assign(n, {
    withTypes: () => n
  }), n;
}
var M = /* @__PURE__ */ D_(_x), C_ = Object.assign(
  (r, e = M) => {
    w_(
      r,
      `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof r}`
    );
    const t = Object.keys(r), n = t.map(
      (s) => r[s]
    );
    return e(
      n,
      (...s) => s.reduce((a, o, c) => (a[t[c]] = o, a), {})
    );
  },
  { withTypes: () => C_ }
), eu = {}, tu = {}, ru = {}, Ep;
function k_() {
  return Ep || (Ep = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    function e(n) {
      return typeof n == "symbol" ? 1 : n === null ? 2 : n === void 0 ? 3 : n !== n ? 4 : 0;
    }
    const t = (n, i, s) => {
      if (n !== i) {
        const a = e(n), o = e(i);
        if (a === o && a === 0) {
          if (n < i)
            return s === "desc" ? 1 : -1;
          if (n > i)
            return s === "desc" ? -1 : 1;
        }
        return s === "desc" ? o - a : a - o;
      }
      return 0;
    };
    r.compareValues = t;
  }(ru)), ru;
}
var nu = {}, iu = {}, Sp;
function Lx() {
  return Sp || (Sp = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    function e(t) {
      return typeof t == "symbol" || t instanceof Symbol;
    }
    r.isSymbol = e;
  }(iu)), iu;
}
var Tp;
function M_() {
  return Tp || (Tp = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    const e = /* @__PURE__ */ Lx(), t = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, n = /^\w*$/;
    function i(s, a) {
      return Array.isArray(s) ? !1 : typeof s == "number" || typeof s == "boolean" || s == null || e.isSymbol(s) ? !0 : typeof s == "string" && (n.test(s) || !t.test(s)) || a != null && Object.hasOwn(a, s);
    }
    r.isKey = i;
  }(nu)), nu;
}
var Ap;
function N_() {
  return Ap || (Ap = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    const e = /* @__PURE__ */ k_(), t = /* @__PURE__ */ M_(), n = /* @__PURE__ */ Ff();
    function i(s, a, o, c) {
      if (s == null)
        return [];
      o = c ? void 0 : o, Array.isArray(s) || (s = Object.values(s)), Array.isArray(a) || (a = a == null ? [null] : [a]), a.length === 0 && (a = [null]), Array.isArray(o) || (o = o == null ? [] : [o]), o = o.map((h) => String(h));
      const l = (h, g) => {
        let m = h;
        for (let p = 0; p < g.length && m != null; ++p)
          m = m[g[p]];
        return m;
      }, u = (h, g) => g == null || h == null ? g : typeof h == "object" && "key" in h ? Object.hasOwn(g, h.key) ? g[h.key] : l(g, h.path) : typeof h == "function" ? h(g) : Array.isArray(h) ? l(g, h) : typeof g == "object" ? g[h] : g, d = a.map((h) => (Array.isArray(h) && h.length === 1 && (h = h[0]), h == null || typeof h == "function" || Array.isArray(h) || t.isKey(h) ? h : { key: h, path: n.toPath(h) }));
      return s.map((h) => ({
        original: h,
        criteria: d.map((g) => u(g, h))
      })).slice().sort((h, g) => {
        for (let m = 0; m < d.length; m++) {
          const p = e.compareValues(h.criteria[m], g.criteria[m], o[m]);
          if (p !== 0)
            return p;
        }
        return 0;
      }).map((h) => h.original);
    }
    r.orderBy = i;
  }(tu)), tu;
}
var su = {}, wp;
function F_() {
  return wp || (wp = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    function e(t, n = 1) {
      const i = [], s = Math.floor(n), a = (o, c) => {
        for (let l = 0; l < o.length; l++) {
          const u = o[l];
          Array.isArray(u) && c < s ? a(u, c + 1) : i.push(u);
        }
      };
      return a(t, 0), i;
    }
    r.flatten = e;
  }(su)), su;
}
var au = {}, Ip;
function Ox() {
  return Ip || (Ip = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    const e = /* @__PURE__ */ wx(), t = /* @__PURE__ */ qf(), n = /* @__PURE__ */ Ex(), i = /* @__PURE__ */ zf();
    function s(a, o, c) {
      return n.isObject(c) && (typeof o == "number" && t.isArrayLike(c) && e.isIndex(o) && o < c.length || typeof o == "string" && o in c) ? i.eq(c[o], a) : !1;
    }
    r.isIterateeCall = s;
  }(au)), au;
}
var Pp;
function $_() {
  return Pp || (Pp = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    const e = /* @__PURE__ */ N_(), t = /* @__PURE__ */ F_(), n = /* @__PURE__ */ Ox();
    function i(s, ...a) {
      const o = a.length;
      return o > 1 && n.isIterateeCall(s, a[0], a[1]) ? a = [] : o > 2 && n.isIterateeCall(a[0], a[1], a[2]) && (a = [a[0]]), e.orderBy(s, t.flatten(a), ["asc"]);
    }
    r.sortBy = i;
  }(eu)), eu;
}
var ou, _p;
function B_() {
  return _p || (_p = 1, ou = $_().sortBy), ou;
}
var j_ = /* @__PURE__ */ B_();
const El = /* @__PURE__ */ hn(j_);
var Rx = (r) => r.legend.settings, U_ = (r) => r.legend.size, G_ = (r) => r.legend.payload, K_ = M([G_, Rx], (r, e) => {
  var {
    itemSorter: t
  } = e, n = r.flat(1);
  return t ? El(n, t) : n;
});
function V_() {
  return te(K_);
}
var Ba = 1;
function Dx() {
  var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], [e, t] = _e({
    height: 0,
    left: 0,
    top: 0,
    width: 0
  }), n = Se((i) => {
    if (i != null) {
      var s = i.getBoundingClientRect(), a = {
        height: s.height,
        left: s.left,
        top: s.top,
        width: s.width
      };
      (Math.abs(a.height - e.height) > Ba || Math.abs(a.left - e.left) > Ba || Math.abs(a.top - e.top) > Ba || Math.abs(a.width - e.width) > Ba) && t({
        height: a.height,
        left: a.left,
        top: a.top,
        width: a.width
      });
    }
  }, [e.width, e.height, e.top, e.left, ...r]);
  return [e, n];
}
function bt(r) {
  return `Minified Redux error #${r}; visit https://redux.js.org/Errors?code=${r} for the full message or use the non-minified dev environment for full errors. `;
}
var W_ = typeof Symbol == "function" && Symbol.observable || "@@observable", Lp = W_, lu = () => Math.random().toString(36).substring(7).split("").join("."), H_ = {
  INIT: `@@redux/INIT${/* @__PURE__ */ lu()}`,
  REPLACE: `@@redux/REPLACE${/* @__PURE__ */ lu()}`,
  PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${lu()}`
}, ni = H_;
function ca(r) {
  if (typeof r != "object" || r === null)
    return !1;
  let e = r;
  for (; Object.getPrototypeOf(e) !== null; )
    e = Object.getPrototypeOf(e);
  return Object.getPrototypeOf(r) === e || Object.getPrototypeOf(r) === null;
}
function q_(r) {
  if (r === void 0)
    return "undefined";
  if (r === null)
    return "null";
  const e = typeof r;
  switch (e) {
    case "boolean":
    case "string":
    case "number":
    case "symbol":
    case "function":
      return e;
  }
  if (Array.isArray(r))
    return "array";
  if (X_(r))
    return "date";
  if (Y_(r))
    return "error";
  const t = z_(r);
  switch (t) {
    case "Symbol":
    case "Promise":
    case "WeakMap":
    case "WeakSet":
    case "Map":
    case "Set":
      return t;
  }
  return Object.prototype.toString.call(r).slice(8, -1).toLowerCase().replace(/\s/g, "");
}
function z_(r) {
  return typeof r.constructor == "function" ? r.constructor.name : null;
}
function Y_(r) {
  return r instanceof Error || typeof r.message == "string" && r.constructor && typeof r.constructor.stackTraceLimit == "number";
}
function X_(r) {
  return r instanceof Date ? !0 : typeof r.toDateString == "function" && typeof r.getDate == "function" && typeof r.setDate == "function";
}
function In(r) {
  let e = typeof r;
  return process.env.NODE_ENV !== "production" && (e = q_(r)), e;
}
function Cx(r, e, t) {
  if (typeof r != "function")
    throw new Error(process.env.NODE_ENV === "production" ? bt(2) : `Expected the root reducer to be a function. Instead, received: '${In(r)}'`);
  if (typeof e == "function" && typeof t == "function" || typeof t == "function" && typeof arguments[3] == "function")
    throw new Error(process.env.NODE_ENV === "production" ? bt(0) : "It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.");
  if (typeof e == "function" && typeof t > "u" && (t = e, e = void 0), typeof t < "u") {
    if (typeof t != "function")
      throw new Error(process.env.NODE_ENV === "production" ? bt(1) : `Expected the enhancer to be a function. Instead, received: '${In(t)}'`);
    return t(Cx)(r, e);
  }
  let n = r, i = e, s = /* @__PURE__ */ new Map(), a = s, o = 0, c = !1;
  function l() {
    a === s && (a = /* @__PURE__ */ new Map(), s.forEach((p, v) => {
      a.set(v, p);
    }));
  }
  function u() {
    if (c)
      throw new Error(process.env.NODE_ENV === "production" ? bt(3) : "You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
    return i;
  }
  function d(p) {
    if (typeof p != "function")
      throw new Error(process.env.NODE_ENV === "production" ? bt(4) : `Expected the listener to be a function. Instead, received: '${In(p)}'`);
    if (c)
      throw new Error(process.env.NODE_ENV === "production" ? bt(5) : "You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.");
    let v = !0;
    l();
    const y = o++;
    return a.set(y, p), function() {
      if (v) {
        if (c)
          throw new Error(process.env.NODE_ENV === "production" ? bt(6) : "You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.");
        v = !1, l(), a.delete(y), s = null;
      }
    };
  }
  function f(p) {
    if (!ca(p))
      throw new Error(process.env.NODE_ENV === "production" ? bt(7) : `Actions must be plain objects. Instead, the actual type was: '${In(p)}'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.`);
    if (typeof p.type > "u")
      throw new Error(process.env.NODE_ENV === "production" ? bt(8) : 'Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
    if (typeof p.type != "string")
      throw new Error(process.env.NODE_ENV === "production" ? bt(17) : `Action "type" property must be a string. Instead, the actual type was: '${In(p.type)}'. Value was: '${p.type}' (stringified)`);
    if (c)
      throw new Error(process.env.NODE_ENV === "production" ? bt(9) : "Reducers may not dispatch actions.");
    try {
      c = !0, i = n(i, p);
    } finally {
      c = !1;
    }
    return (s = a).forEach((y) => {
      y();
    }), p;
  }
  function h(p) {
    if (typeof p != "function")
      throw new Error(process.env.NODE_ENV === "production" ? bt(10) : `Expected the nextReducer to be a function. Instead, received: '${In(p)}`);
    n = p, f({
      type: ni.REPLACE
    });
  }
  function g() {
    const p = d;
    return {
      /**
       * The minimal observable subscription method.
       * @param observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe(v) {
        if (typeof v != "object" || v === null)
          throw new Error(process.env.NODE_ENV === "production" ? bt(11) : `Expected the observer to be an object. Instead, received: '${In(v)}'`);
        function y() {
          const x = v;
          x.next && x.next(u());
        }
        return y(), {
          unsubscribe: p(y)
        };
      },
      [Lp]() {
        return this;
      }
    };
  }
  return f({
    type: ni.INIT
  }), {
    dispatch: f,
    subscribe: d,
    getState: u,
    replaceReducer: h,
    [Lp]: g
  };
}
function Op(r) {
  typeof console < "u" && typeof console.error == "function" && console.error(r);
  try {
    throw new Error(r);
  } catch {
  }
}
function Q_(r, e, t, n) {
  const i = Object.keys(e), s = t && t.type === ni.INIT ? "preloadedState argument passed to createStore" : "previous state received by the reducer";
  if (i.length === 0)
    return "Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.";
  if (!ca(r))
    return `The ${s} has unexpected type of "${In(r)}". Expected argument to be an object with the following keys: "${i.join('", "')}"`;
  const a = Object.keys(r).filter((o) => !e.hasOwnProperty(o) && !n[o]);
  if (a.forEach((o) => {
    n[o] = !0;
  }), !(t && t.type === ni.REPLACE) && a.length > 0)
    return `Unexpected ${a.length > 1 ? "keys" : "key"} "${a.join('", "')}" found in ${s}. Expected to find one of the known reducer keys instead: "${i.join('", "')}". Unexpected keys will be ignored.`;
}
function Z_(r) {
  Object.keys(r).forEach((e) => {
    const t = r[e];
    if (typeof t(void 0, {
      type: ni.INIT
    }) > "u")
      throw new Error(process.env.NODE_ENV === "production" ? bt(12) : `The slice reducer for key "${e}" returned undefined during initialization. If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);
    if (typeof t(void 0, {
      type: ni.PROBE_UNKNOWN_ACTION()
    }) > "u")
      throw new Error(process.env.NODE_ENV === "production" ? bt(13) : `The slice reducer for key "${e}" returned undefined when probed with a random type. Don't try to handle '${ni.INIT}' or other actions in "redux/*" namespace. They are considered private. Instead, you must return the current state for any unknown actions, unless it is undefined, in which case you must return the initial state, regardless of the action type. The initial state may not be undefined, but can be null.`);
  });
}
function kx(r) {
  const e = Object.keys(r), t = {};
  for (let a = 0; a < e.length; a++) {
    const o = e[a];
    process.env.NODE_ENV !== "production" && typeof r[o] > "u" && Op(`No reducer provided for key "${o}"`), typeof r[o] == "function" && (t[o] = r[o]);
  }
  const n = Object.keys(t);
  let i;
  process.env.NODE_ENV !== "production" && (i = {});
  let s;
  try {
    Z_(t);
  } catch (a) {
    s = a;
  }
  return function(o = {}, c) {
    if (s)
      throw s;
    if (process.env.NODE_ENV !== "production") {
      const d = Q_(o, t, c, i);
      d && Op(d);
    }
    let l = !1;
    const u = {};
    for (let d = 0; d < n.length; d++) {
      const f = n[d], h = t[f], g = o[f], m = h(g, c);
      if (typeof m > "u") {
        const p = c && c.type;
        throw new Error(process.env.NODE_ENV === "production" ? bt(14) : `When called with an action of type ${p ? `"${String(p)}"` : "(unknown type)"}, the slice reducer for key "${f}" returned undefined. To ignore an action, you must explicitly return the previous state. If you want this reducer to hold no value, you can return null instead of undefined.`);
      }
      u[f] = m, l = l || m !== g;
    }
    return l = l || n.length !== Object.keys(o).length, l ? u : o;
  };
}
function Lo(...r) {
  return r.length === 0 ? (e) => e : r.length === 1 ? r[0] : r.reduce((e, t) => (...n) => e(t(...n)));
}
function J_(...r) {
  return (e) => (t, n) => {
    const i = e(t, n);
    let s = () => {
      throw new Error(process.env.NODE_ENV === "production" ? bt(15) : "Dispatching while constructing your middleware is not allowed. Other middleware would not be applied to this dispatch.");
    };
    const a = {
      getState: i.getState,
      dispatch: (c, ...l) => s(c, ...l)
    }, o = r.map((c) => c(a));
    return s = Lo(...o)(i.dispatch), {
      ...i,
      dispatch: s
    };
  };
}
function Jf(r) {
  return ca(r) && "type" in r && typeof r.type == "string";
}
var Mx = Symbol.for("immer-nothing"), Rp = Symbol.for("immer-draftable"), rr = Symbol.for("immer-state"), eL = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(r) {
    return `The plugin for '${r}' has not been loaded into Immer. To enable the plugin, import and call \`enable${r}()\` when initializing your application.`;
  },
  function(r) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${r}'`;
  },
  "This object has been frozen and should not be mutated",
  function(r) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + r;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(r) {
    return `'current' expects a draft, got: ${r}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(r) {
    return `'original' expects a draft, got: ${r}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function $t(r, ...e) {
  if (process.env.NODE_ENV !== "production") {
    const t = eL[r], n = typeof t == "function" ? t.apply(null, e) : t;
    throw new Error(`[Immer] ${n}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${r}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var Ki = Object.getPrototypeOf;
function ui(r) {
  return !!r && !!r[rr];
}
function sn(r) {
  var e;
  return r ? Nx(r) || Array.isArray(r) || !!r[Rp] || !!((e = r.constructor) != null && e[Rp]) || Tl(r) || Al(r) : !1;
}
var tL = Object.prototype.constructor.toString();
function Nx(r) {
  if (!r || typeof r != "object")
    return !1;
  const e = Ki(r);
  if (e === null)
    return !0;
  const t = Object.hasOwnProperty.call(e, "constructor") && e.constructor;
  return t === Object ? !0 : typeof t == "function" && Function.toString.call(t) === tL;
}
function Oo(r, e) {
  Sl(r) === 0 ? Reflect.ownKeys(r).forEach((t) => {
    e(t, r[t], r);
  }) : r.forEach((t, n) => e(n, t, r));
}
function Sl(r) {
  const e = r[rr];
  return e ? e.type_ : Array.isArray(r) ? 1 : Tl(r) ? 2 : Al(r) ? 3 : 0;
}
function Td(r, e) {
  return Sl(r) === 2 ? r.has(e) : Object.prototype.hasOwnProperty.call(r, e);
}
function Fx(r, e, t) {
  const n = Sl(r);
  n === 2 ? r.set(e, t) : n === 3 ? r.add(t) : r[e] = t;
}
function rL(r, e) {
  return r === e ? r !== 0 || 1 / r === 1 / e : r !== r && e !== e;
}
function Tl(r) {
  return r instanceof Map;
}
function Al(r) {
  return r instanceof Set;
}
function qn(r) {
  return r.copy_ || r.base_;
}
function Ad(r, e) {
  if (Tl(r))
    return new Map(r);
  if (Al(r))
    return new Set(r);
  if (Array.isArray(r))
    return Array.prototype.slice.call(r);
  const t = Nx(r);
  if (e === !0 || e === "class_only" && !t) {
    const n = Object.getOwnPropertyDescriptors(r);
    delete n[rr];
    let i = Reflect.ownKeys(n);
    for (let s = 0; s < i.length; s++) {
      const a = i[s], o = n[a];
      o.writable === !1 && (o.writable = !0, o.configurable = !0), (o.get || o.set) && (n[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: o.enumerable,
        value: r[a]
      });
    }
    return Object.create(Ki(r), n);
  } else {
    const n = Ki(r);
    if (n !== null && t)
      return { ...r };
    const i = Object.create(n);
    return Object.assign(i, r);
  }
}
function eh(r, e = !1) {
  return wl(r) || ui(r) || !sn(r) || (Sl(r) > 1 && (r.set = r.add = r.clear = r.delete = nL), Object.freeze(r), e && Object.entries(r).forEach(([t, n]) => eh(n, !0))), r;
}
function nL() {
  $t(2);
}
function wl(r) {
  return Object.isFrozen(r);
}
var iL = {};
function di(r) {
  const e = iL[r];
  return e || $t(0, r), e;
}
var Us;
function $x() {
  return Us;
}
function sL(r, e) {
  return {
    drafts_: [],
    parent_: r,
    immer_: e,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function Dp(r, e) {
  e && (di("Patches"), r.patches_ = [], r.inversePatches_ = [], r.patchListener_ = e);
}
function wd(r) {
  Id(r), r.drafts_.forEach(aL), r.drafts_ = null;
}
function Id(r) {
  r === Us && (Us = r.parent_);
}
function Cp(r) {
  return Us = sL(Us, r);
}
function aL(r) {
  const e = r[rr];
  e.type_ === 0 || e.type_ === 1 ? e.revoke_() : e.revoked_ = !0;
}
function kp(r, e) {
  e.unfinalizedDrafts_ = e.drafts_.length;
  const t = e.drafts_[0];
  return r !== void 0 && r !== t ? (t[rr].modified_ && (wd(e), $t(4)), sn(r) && (r = Ro(e, r), e.parent_ || Do(e, r)), e.patches_ && di("Patches").generateReplacementPatches_(
    t[rr].base_,
    r,
    e.patches_,
    e.inversePatches_
  )) : r = Ro(e, t, []), wd(e), e.patches_ && e.patchListener_(e.patches_, e.inversePatches_), r !== Mx ? r : void 0;
}
function Ro(r, e, t) {
  if (wl(e))
    return e;
  const n = e[rr];
  if (!n)
    return Oo(
      e,
      (i, s) => Mp(r, n, e, i, s, t)
    ), e;
  if (n.scope_ !== r)
    return e;
  if (!n.modified_)
    return Do(r, n.base_, !0), n.base_;
  if (!n.finalized_) {
    n.finalized_ = !0, n.scope_.unfinalizedDrafts_--;
    const i = n.copy_;
    let s = i, a = !1;
    n.type_ === 3 && (s = new Set(i), i.clear(), a = !0), Oo(
      s,
      (o, c) => Mp(r, n, i, o, c, t, a)
    ), Do(r, i, !1), t && r.patches_ && di("Patches").generatePatches_(
      n,
      t,
      r.patches_,
      r.inversePatches_
    );
  }
  return n.copy_;
}
function Mp(r, e, t, n, i, s, a) {
  if (process.env.NODE_ENV !== "production" && i === t && $t(5), ui(i)) {
    const o = s && e && e.type_ !== 3 && // Set objects are atomic since they have no keys.
    !Td(e.assigned_, n) ? s.concat(n) : void 0, c = Ro(r, i, o);
    if (Fx(t, n, c), ui(c))
      r.canAutoFreeze_ = !1;
    else
      return;
  } else a && t.add(i);
  if (sn(i) && !wl(i)) {
    if (!r.immer_.autoFreeze_ && r.unfinalizedDrafts_ < 1)
      return;
    Ro(r, i), (!e || !e.scope_.parent_) && typeof n != "symbol" && Object.prototype.propertyIsEnumerable.call(t, n) && Do(r, i);
  }
}
function Do(r, e, t = !1) {
  !r.parent_ && r.immer_.autoFreeze_ && r.canAutoFreeze_ && eh(e, t);
}
function oL(r, e) {
  const t = Array.isArray(r), n = {
    type_: t ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: e ? e.scope_ : $x(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: e,
    // The base state.
    base_: r,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let i = n, s = th;
  t && (i = [n], s = Gs);
  const { revoke: a, proxy: o } = Proxy.revocable(i, s);
  return n.draft_ = o, n.revoke_ = a, o;
}
var th = {
  get(r, e) {
    if (e === rr)
      return r;
    const t = qn(r);
    if (!Td(t, e))
      return lL(r, t, e);
    const n = t[e];
    return r.finalized_ || !sn(n) ? n : n === cu(r.base_, e) ? (uu(r), r.copy_[e] = _d(n, r)) : n;
  },
  has(r, e) {
    return e in qn(r);
  },
  ownKeys(r) {
    return Reflect.ownKeys(qn(r));
  },
  set(r, e, t) {
    const n = Bx(qn(r), e);
    if (n != null && n.set)
      return n.set.call(r.draft_, t), !0;
    if (!r.modified_) {
      const i = cu(qn(r), e), s = i == null ? void 0 : i[rr];
      if (s && s.base_ === t)
        return r.copy_[e] = t, r.assigned_[e] = !1, !0;
      if (rL(t, i) && (t !== void 0 || Td(r.base_, e)))
        return !0;
      uu(r), Pd(r);
    }
    return r.copy_[e] === t && // special case: handle new props with value 'undefined'
    (t !== void 0 || e in r.copy_) || // special case: NaN
    Number.isNaN(t) && Number.isNaN(r.copy_[e]) || (r.copy_[e] = t, r.assigned_[e] = !0), !0;
  },
  deleteProperty(r, e) {
    return cu(r.base_, e) !== void 0 || e in r.base_ ? (r.assigned_[e] = !1, uu(r), Pd(r)) : delete r.assigned_[e], r.copy_ && delete r.copy_[e], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(r, e) {
    const t = qn(r), n = Reflect.getOwnPropertyDescriptor(t, e);
    return n && {
      writable: !0,
      configurable: r.type_ !== 1 || e !== "length",
      enumerable: n.enumerable,
      value: t[e]
    };
  },
  defineProperty() {
    $t(11);
  },
  getPrototypeOf(r) {
    return Ki(r.base_);
  },
  setPrototypeOf() {
    $t(12);
  }
}, Gs = {};
Oo(th, (r, e) => {
  Gs[r] = function() {
    return arguments[0] = arguments[0][0], e.apply(this, arguments);
  };
});
Gs.deleteProperty = function(r, e) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(e)) && $t(13), Gs.set.call(this, r, e, void 0);
};
Gs.set = function(r, e, t) {
  return process.env.NODE_ENV !== "production" && e !== "length" && isNaN(parseInt(e)) && $t(14), th.set.call(this, r[0], e, t, r[0]);
};
function cu(r, e) {
  const t = r[rr];
  return (t ? qn(t) : r)[e];
}
function lL(r, e, t) {
  var i;
  const n = Bx(e, t);
  return n ? "value" in n ? n.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (i = n.get) == null ? void 0 : i.call(r.draft_)
  ) : void 0;
}
function Bx(r, e) {
  if (!(e in r))
    return;
  let t = Ki(r);
  for (; t; ) {
    const n = Object.getOwnPropertyDescriptor(t, e);
    if (n)
      return n;
    t = Ki(t);
  }
}
function Pd(r) {
  r.modified_ || (r.modified_ = !0, r.parent_ && Pd(r.parent_));
}
function uu(r) {
  r.copy_ || (r.copy_ = Ad(
    r.base_,
    r.scope_.immer_.useStrictShallowCopy_
  ));
}
var cL = class {
  constructor(r) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (e, t, n) => {
      if (typeof e == "function" && typeof t != "function") {
        const s = t;
        t = e;
        const a = this;
        return function(c = s, ...l) {
          return a.produce(c, (u) => t.call(this, u, ...l));
        };
      }
      typeof t != "function" && $t(6), n !== void 0 && typeof n != "function" && $t(7);
      let i;
      if (sn(e)) {
        const s = Cp(this), a = _d(e, void 0);
        let o = !0;
        try {
          i = t(a), o = !1;
        } finally {
          o ? wd(s) : Id(s);
        }
        return Dp(s, n), kp(i, s);
      } else if (!e || typeof e != "object") {
        if (i = t(e), i === void 0 && (i = e), i === Mx && (i = void 0), this.autoFreeze_ && eh(i, !0), n) {
          const s = [], a = [];
          di("Patches").generateReplacementPatches_(e, i, s, a), n(s, a);
        }
        return i;
      } else
        $t(1, e);
    }, this.produceWithPatches = (e, t) => {
      if (typeof e == "function")
        return (a, ...o) => this.produceWithPatches(a, (c) => e(c, ...o));
      let n, i;
      return [this.produce(e, t, (a, o) => {
        n = a, i = o;
      }), n, i];
    }, typeof (r == null ? void 0 : r.autoFreeze) == "boolean" && this.setAutoFreeze(r.autoFreeze), typeof (r == null ? void 0 : r.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(r.useStrictShallowCopy);
  }
  createDraft(r) {
    sn(r) || $t(8), ui(r) && (r = tn(r));
    const e = Cp(this), t = _d(r, void 0);
    return t[rr].isManual_ = !0, Id(e), t;
  }
  finishDraft(r, e) {
    const t = r && r[rr];
    (!t || !t.isManual_) && $t(9);
    const { scope_: n } = t;
    return Dp(n, e), kp(void 0, n);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(r) {
    this.autoFreeze_ = r;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(r) {
    this.useStrictShallowCopy_ = r;
  }
  applyPatches(r, e) {
    let t;
    for (t = e.length - 1; t >= 0; t--) {
      const i = e[t];
      if (i.path.length === 0 && i.op === "replace") {
        r = i.value;
        break;
      }
    }
    t > -1 && (e = e.slice(t + 1));
    const n = di("Patches").applyPatches_;
    return ui(r) ? n(r, e) : this.produce(
      r,
      (i) => n(i, e)
    );
  }
};
function _d(r, e) {
  const t = Tl(r) ? di("MapSet").proxyMap_(r, e) : Al(r) ? di("MapSet").proxySet_(r, e) : oL(r, e);
  return (e ? e.scope_ : $x()).drafts_.push(t), t;
}
function tn(r) {
  return ui(r) || $t(10, r), jx(r);
}
function jx(r) {
  if (!sn(r) || wl(r))
    return r;
  const e = r[rr];
  let t;
  if (e) {
    if (!e.modified_)
      return e.base_;
    e.finalized_ = !0, t = Ad(r, e.scope_.immer_.useStrictShallowCopy_);
  } else
    t = Ad(r, !0);
  return Oo(t, (n, i) => {
    Fx(t, n, jx(i));
  }), e && (e.finalized_ = !1), t;
}
var nr = new cL(), Ux = nr.produce;
nr.produceWithPatches.bind(
  nr
);
nr.setAutoFreeze.bind(nr);
nr.setUseStrictShallowCopy.bind(nr);
nr.applyPatches.bind(nr);
nr.createDraft.bind(nr);
nr.finishDraft.bind(nr);
function Gx(r) {
  return ({ dispatch: t, getState: n }) => (i) => (s) => typeof s == "function" ? s(t, n, r) : i(s);
}
var uL = Gx(), dL = Gx, fL = typeof window < "u" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
  if (arguments.length !== 0)
    return typeof arguments[0] == "object" ? Lo : Lo.apply(null, arguments);
}, hL = (r) => r && typeof r.match == "function";
function mr(r, e) {
  function t(...n) {
    if (e) {
      let i = e(...n);
      if (!i)
        throw new Error(process.env.NODE_ENV === "production" ? Oe(0) : "prepareAction did not return an object");
      return {
        type: r,
        payload: i.payload,
        ..."meta" in i && {
          meta: i.meta
        },
        ..."error" in i && {
          error: i.error
        }
      };
    }
    return {
      type: r,
      payload: n[0]
    };
  }
  return t.toString = () => `${r}`, t.type = r, t.match = (n) => Jf(n) && n.type === r, t;
}
function gL(r) {
  return typeof r == "function" && "type" in r && // hasMatchFunction only wants Matchers but I don't see the point in rewriting it
  hL(r);
}
function mL(r) {
  const e = r ? `${r}`.split("/") : [], t = e[e.length - 1] || "actionCreator";
  return `Detected an action creator with type "${r || "unknown"}" being dispatched. 
Make sure you're calling the action creator before dispatching, i.e. \`dispatch(${t}())\` instead of \`dispatch(${t})\`. This is necessary even if the action has no payload.`;
}
function pL(r = {}) {
  if (process.env.NODE_ENV === "production")
    return () => (t) => (n) => t(n);
  const {
    isActionCreator: e = gL
  } = r;
  return () => (t) => (n) => (e(n) && console.warn(mL(n.type)), t(n));
}
function Kx(r, e) {
  let t = 0;
  return {
    measureTime(n) {
      const i = Date.now();
      try {
        return n();
      } finally {
        const s = Date.now();
        t += s - i;
      }
    },
    warnIfExceeded() {
      t > r && console.warn(`${e} took ${t}ms, which is more than the warning threshold of ${r}ms. 
If your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.
It is disabled in production builds, so you don't need to worry about that.`);
    }
  };
}
var Vx = class Rs extends Array {
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, Rs.prototype);
  }
  static get [Symbol.species]() {
    return Rs;
  }
  concat(...e) {
    return super.concat.apply(this, e);
  }
  prepend(...e) {
    return e.length === 1 && Array.isArray(e[0]) ? new Rs(...e[0].concat(this)) : new Rs(...e.concat(this));
  }
};
function Np(r) {
  return sn(r) ? Ux(r, () => {
  }) : r;
}
function ja(r, e, t) {
  return r.has(e) ? r.get(e) : r.set(e, t(e)).get(e);
}
function vL(r) {
  return typeof r != "object" || r == null || Object.isFrozen(r);
}
function yL(r, e, t) {
  const n = Wx(r, e, t);
  return {
    detectMutations() {
      return Hx(r, e, n, t);
    }
  };
}
function Wx(r, e = [], t, n = "", i = /* @__PURE__ */ new Set()) {
  const s = {
    value: t
  };
  if (!r(t) && !i.has(t)) {
    i.add(t), s.children = {};
    for (const a in t) {
      const o = n ? n + "." + a : a;
      e.length && e.indexOf(o) !== -1 || (s.children[a] = Wx(r, e, t[a], o));
    }
  }
  return s;
}
function Hx(r, e = [], t, n, i = !1, s = "") {
  const a = t ? t.value : void 0, o = a === n;
  if (i && !o && !Number.isNaN(n))
    return {
      wasMutated: !0,
      path: s
    };
  if (r(a) || r(n))
    return {
      wasMutated: !1
    };
  const c = {};
  for (let u in t.children)
    c[u] = !0;
  for (let u in n)
    c[u] = !0;
  const l = e.length > 0;
  for (let u in c) {
    const d = s ? s + "." + u : u;
    if (l && e.some((g) => g instanceof RegExp ? g.test(d) : d === g))
      continue;
    const f = Hx(r, e, t.children[u], n[u], o, d);
    if (f.wasMutated)
      return f;
  }
  return {
    wasMutated: !1
  };
}
function bL(r = {}) {
  if (process.env.NODE_ENV === "production")
    return () => (e) => (t) => e(t);
  {
    let e = function(o, c, l, u) {
      return JSON.stringify(o, t(c, u), l);
    }, t = function(o, c) {
      let l = [], u = [];
      return c || (c = function(d, f) {
        return l[0] === f ? "[Circular ~]" : "[Circular ~." + u.slice(0, l.indexOf(f)).join(".") + "]";
      }), function(d, f) {
        if (l.length > 0) {
          var h = l.indexOf(this);
          ~h ? l.splice(h + 1) : l.push(this), ~h ? u.splice(h, 1 / 0, d) : u.push(d), ~l.indexOf(f) && (f = c.call(this, d, f));
        } else l.push(f);
        return o == null ? f : o.call(this, d, f);
      };
    }, {
      isImmutable: n = vL,
      ignoredPaths: i,
      warnAfter: s = 32
    } = r;
    const a = yL.bind(null, n, i);
    return ({
      getState: o
    }) => {
      let c = o(), l = a(c), u;
      return (d) => (f) => {
        const h = Kx(s, "ImmutableStateInvariantMiddleware");
        h.measureTime(() => {
          if (c = o(), u = l.detectMutations(), l = a(c), u.wasMutated)
            throw new Error(process.env.NODE_ENV === "production" ? Oe(19) : `A state mutation was detected between dispatches, in the path '${u.path || ""}'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);
        });
        const g = d(f);
        return h.measureTime(() => {
          if (c = o(), u = l.detectMutations(), l = a(c), u.wasMutated)
            throw new Error(process.env.NODE_ENV === "production" ? Oe(20) : `A state mutation was detected inside a dispatch, in the path: ${u.path || ""}. Take a look at the reducer(s) handling the action ${e(f)}. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);
        }), h.warnIfExceeded(), g;
      };
    };
  }
}
function qx(r) {
  const e = typeof r;
  return r == null || e === "string" || e === "boolean" || e === "number" || Array.isArray(r) || ca(r);
}
function Ld(r, e = "", t = qx, n, i = [], s) {
  let a;
  if (!t(r))
    return {
      keyPath: e || "<root>",
      value: r
    };
  if (typeof r != "object" || r === null || s != null && s.has(r)) return !1;
  const o = n != null ? n(r) : Object.entries(r), c = i.length > 0;
  for (const [l, u] of o) {
    const d = e ? e + "." + l : l;
    if (!(c && i.some((h) => h instanceof RegExp ? h.test(d) : d === h))) {
      if (!t(u))
        return {
          keyPath: d,
          value: u
        };
      if (typeof u == "object" && (a = Ld(u, d, t, n, i, s), a))
        return a;
    }
  }
  return s && zx(r) && s.add(r), !1;
}
function zx(r) {
  if (!Object.isFrozen(r)) return !1;
  for (const e of Object.values(r))
    if (!(typeof e != "object" || e === null) && !zx(e))
      return !1;
  return !0;
}
function xL(r = {}) {
  if (process.env.NODE_ENV === "production")
    return () => (e) => (t) => e(t);
  {
    const {
      isSerializable: e = qx,
      getEntries: t,
      ignoredActions: n = [],
      ignoredActionPaths: i = ["meta.arg", "meta.baseQueryMeta"],
      ignoredPaths: s = [],
      warnAfter: a = 32,
      ignoreState: o = !1,
      ignoreActions: c = !1,
      disableCache: l = !1
    } = r, u = !l && WeakSet ? /* @__PURE__ */ new WeakSet() : void 0;
    return (d) => (f) => (h) => {
      if (!Jf(h))
        return f(h);
      const g = f(h), m = Kx(a, "SerializableStateInvariantMiddleware");
      return !c && !(n.length && n.indexOf(h.type) !== -1) && m.measureTime(() => {
        const p = Ld(h, "", e, t, i, u);
        if (p) {
          const {
            keyPath: v,
            value: y
          } = p;
          console.error(`A non-serializable value was detected in an action, in the path: \`${v}\`. Value:`, y, `
Take a look at the logic that dispatched this action: `, h, `
(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)`, `
(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)`);
        }
      }), o || (m.measureTime(() => {
        const p = d.getState(), v = Ld(p, "", e, t, s, u);
        if (v) {
          const {
            keyPath: y,
            value: b
          } = v;
          console.error(`A non-serializable value was detected in the state, in the path: \`${y}\`. Value:`, b, `
Take a look at the reducer(s) handling this action type: ${h.type}.
(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`);
        }
      }), m.warnIfExceeded()), g;
    };
  }
}
function Ua(r) {
  return typeof r == "boolean";
}
var EL = () => function(e) {
  const {
    thunk: t = !0,
    immutableCheck: n = !0,
    serializableCheck: i = !0,
    actionCreatorCheck: s = !0
  } = e ?? {};
  let a = new Vx();
  if (t && (Ua(t) ? a.push(uL) : a.push(dL(t.extraArgument))), process.env.NODE_ENV !== "production") {
    if (n) {
      let o = {};
      Ua(n) || (o = n), a.unshift(bL(o));
    }
    if (i) {
      let o = {};
      Ua(i) || (o = i), a.push(xL(o));
    }
    if (s) {
      let o = {};
      Ua(s) || (o = s), a.unshift(pL(o));
    }
  }
  return a;
}, SL = "RTK_autoBatch", Fp = (r) => (e) => {
  setTimeout(e, r);
}, TL = (r = {
  type: "raf"
}) => (e) => (...t) => {
  const n = e(...t);
  let i = !0, s = !1, a = !1;
  const o = /* @__PURE__ */ new Set(), c = r.type === "tick" ? queueMicrotask : r.type === "raf" ? (
    // requestAnimationFrame won't exist in SSR environments. Fall back to a vague approximation just to keep from erroring.
    typeof window < "u" && window.requestAnimationFrame ? window.requestAnimationFrame : Fp(10)
  ) : r.type === "callback" ? r.queueNotification : Fp(r.timeout), l = () => {
    a = !1, s && (s = !1, o.forEach((u) => u()));
  };
  return Object.assign({}, n, {
    // Override the base `store.subscribe` method to keep original listeners
    // from running if we're delaying notifications
    subscribe(u) {
      const d = () => i && u(), f = n.subscribe(d);
      return o.add(u), () => {
        f(), o.delete(u);
      };
    },
    // Override the base `store.dispatch` method so that we can check actions
    // for the `shouldAutoBatch` flag and determine if batching is active
    dispatch(u) {
      var d;
      try {
        return i = !((d = u == null ? void 0 : u.meta) != null && d[SL]), s = !i, s && (a || (a = !0, c(l))), n.dispatch(u);
      } finally {
        i = !0;
      }
    }
  });
}, AL = (r) => function(t) {
  const {
    autoBatch: n = !0
  } = t ?? {};
  let i = new Vx(r);
  return n && i.push(TL(typeof n == "object" ? n : void 0)), i;
};
function wL(r) {
  const e = EL(), {
    reducer: t = void 0,
    middleware: n,
    devTools: i = !0,
    duplicateMiddlewareCheck: s = !0,
    preloadedState: a = void 0,
    enhancers: o = void 0
  } = r || {};
  let c;
  if (typeof t == "function")
    c = t;
  else if (ca(t))
    c = kx(t);
  else
    throw new Error(process.env.NODE_ENV === "production" ? Oe(1) : "`reducer` is a required argument, and must be a function or an object of functions that can be passed to combineReducers");
  if (process.env.NODE_ENV !== "production" && n && typeof n != "function")
    throw new Error(process.env.NODE_ENV === "production" ? Oe(2) : "`middleware` field must be a callback");
  let l;
  if (typeof n == "function") {
    if (l = n(e), process.env.NODE_ENV !== "production" && !Array.isArray(l))
      throw new Error(process.env.NODE_ENV === "production" ? Oe(3) : "when using a middleware builder function, an array of middleware must be returned");
  } else
    l = e();
  if (process.env.NODE_ENV !== "production" && l.some((m) => typeof m != "function"))
    throw new Error(process.env.NODE_ENV === "production" ? Oe(4) : "each middleware provided to configureStore must be a function");
  if (process.env.NODE_ENV !== "production" && s) {
    let m = /* @__PURE__ */ new Set();
    l.forEach((p) => {
      if (m.has(p))
        throw new Error(process.env.NODE_ENV === "production" ? Oe(42) : "Duplicate middleware references found when creating the store. Ensure that each middleware is only included once.");
      m.add(p);
    });
  }
  let u = Lo;
  i && (u = fL({
    // Enable capture of stack traces for dispatched Redux actions
    trace: process.env.NODE_ENV !== "production",
    ...typeof i == "object" && i
  }));
  const d = J_(...l), f = AL(d);
  if (process.env.NODE_ENV !== "production" && o && typeof o != "function")
    throw new Error(process.env.NODE_ENV === "production" ? Oe(5) : "`enhancers` field must be a callback");
  let h = typeof o == "function" ? o(f) : f();
  if (process.env.NODE_ENV !== "production" && !Array.isArray(h))
    throw new Error(process.env.NODE_ENV === "production" ? Oe(6) : "`enhancers` callback must return an array");
  if (process.env.NODE_ENV !== "production" && h.some((m) => typeof m != "function"))
    throw new Error(process.env.NODE_ENV === "production" ? Oe(7) : "each enhancer provided to configureStore must be a function");
  process.env.NODE_ENV !== "production" && l.length && !h.includes(d) && console.error("middlewares were provided, but middleware enhancer was not included in final enhancers - make sure to call `getDefaultEnhancers`");
  const g = u(...h);
  return Cx(c, a, g);
}
function Yx(r) {
  const e = {}, t = [];
  let n;
  const i = {
    addCase(s, a) {
      if (process.env.NODE_ENV !== "production") {
        if (t.length > 0)
          throw new Error(process.env.NODE_ENV === "production" ? Oe(26) : "`builder.addCase` should only be called before calling `builder.addMatcher`");
        if (n)
          throw new Error(process.env.NODE_ENV === "production" ? Oe(27) : "`builder.addCase` should only be called before calling `builder.addDefaultCase`");
      }
      const o = typeof s == "string" ? s : s.type;
      if (!o)
        throw new Error(process.env.NODE_ENV === "production" ? Oe(28) : "`builder.addCase` cannot be called with an empty action type");
      if (o in e)
        throw new Error(process.env.NODE_ENV === "production" ? Oe(29) : `\`builder.addCase\` cannot be called with two reducers for the same action type '${o}'`);
      return e[o] = a, i;
    },
    addMatcher(s, a) {
      if (process.env.NODE_ENV !== "production" && n)
        throw new Error(process.env.NODE_ENV === "production" ? Oe(30) : "`builder.addMatcher` should only be called before calling `builder.addDefaultCase`");
      return t.push({
        matcher: s,
        reducer: a
      }), i;
    },
    addDefaultCase(s) {
      if (process.env.NODE_ENV !== "production" && n)
        throw new Error(process.env.NODE_ENV === "production" ? Oe(31) : "`builder.addDefaultCase` can only be called once");
      return n = s, i;
    }
  };
  return r(i), [e, t, n];
}
function IL(r) {
  return typeof r == "function";
}
function PL(r, e) {
  if (process.env.NODE_ENV !== "production" && typeof e == "object")
    throw new Error(process.env.NODE_ENV === "production" ? Oe(8) : "The object notation for `createReducer` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createReducer");
  let [t, n, i] = Yx(e), s;
  if (IL(r))
    s = () => Np(r());
  else {
    const o = Np(r);
    s = () => o;
  }
  function a(o = s(), c) {
    let l = [t[c.type], ...n.filter(({
      matcher: u
    }) => u(c)).map(({
      reducer: u
    }) => u)];
    return l.filter((u) => !!u).length === 0 && (l = [i]), l.reduce((u, d) => {
      if (d)
        if (ui(u)) {
          const h = d(u, c);
          return h === void 0 ? u : h;
        } else {
          if (sn(u))
            return Ux(u, (f) => d(f, c));
          {
            const f = d(u, c);
            if (f === void 0) {
              if (u === null)
                return u;
              throw Error("A case reducer on a non-draftable value must not return undefined");
            }
            return f;
          }
        }
      return u;
    }, o);
  }
  return a.getInitialState = s, a;
}
var _L = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW", LL = (r = 21) => {
  let e = "", t = r;
  for (; t--; )
    e += _L[Math.random() * 64 | 0];
  return e;
}, OL = /* @__PURE__ */ Symbol.for("rtk-slice-createasyncthunk");
function RL(r, e) {
  return `${r}/${e}`;
}
function DL({
  creators: r
} = {}) {
  var t;
  const e = (t = r == null ? void 0 : r.asyncThunk) == null ? void 0 : t[OL];
  return function(i) {
    const {
      name: s,
      reducerPath: a = s
    } = i;
    if (!s)
      throw new Error(process.env.NODE_ENV === "production" ? Oe(11) : "`name` is a required option for createSlice");
    typeof process < "u" && process.env.NODE_ENV === "development" && i.initialState === void 0 && console.error("You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`");
    const o = (typeof i.reducers == "function" ? i.reducers(kL()) : i.reducers) || {}, c = Object.keys(o), l = {
      sliceCaseReducersByName: {},
      sliceCaseReducersByType: {},
      actionCreators: {},
      sliceMatchers: []
    }, u = {
      addCase(x, S) {
        const A = typeof x == "string" ? x : x.type;
        if (!A)
          throw new Error(process.env.NODE_ENV === "production" ? Oe(12) : "`context.addCase` cannot be called with an empty action type");
        if (A in l.sliceCaseReducersByType)
          throw new Error(process.env.NODE_ENV === "production" ? Oe(13) : "`context.addCase` cannot be called with two reducers for the same action type: " + A);
        return l.sliceCaseReducersByType[A] = S, u;
      },
      addMatcher(x, S) {
        return l.sliceMatchers.push({
          matcher: x,
          reducer: S
        }), u;
      },
      exposeAction(x, S) {
        return l.actionCreators[x] = S, u;
      },
      exposeCaseReducer(x, S) {
        return l.sliceCaseReducersByName[x] = S, u;
      }
    };
    c.forEach((x) => {
      const S = o[x], A = {
        reducerName: x,
        type: RL(s, x),
        createNotation: typeof i.reducers == "function"
      };
      NL(S) ? $L(A, S, u, e) : ML(A, S, u);
    });
    function d() {
      if (process.env.NODE_ENV !== "production" && typeof i.extraReducers == "object")
        throw new Error(process.env.NODE_ENV === "production" ? Oe(14) : "The object notation for `createSlice.extraReducers` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createSlice");
      const [x = {}, S = [], A = void 0] = typeof i.extraReducers == "function" ? Yx(i.extraReducers) : [i.extraReducers], T = {
        ...x,
        ...l.sliceCaseReducersByType
      };
      return PL(i.initialState, (I) => {
        for (let L in T)
          I.addCase(L, T[L]);
        for (let L of l.sliceMatchers)
          I.addMatcher(L.matcher, L.reducer);
        for (let L of S)
          I.addMatcher(L.matcher, L.reducer);
        A && I.addDefaultCase(A);
      });
    }
    const f = (x) => x, h = /* @__PURE__ */ new Map(), g = /* @__PURE__ */ new WeakMap();
    let m;
    function p(x, S) {
      return m || (m = d()), m(x, S);
    }
    function v() {
      return m || (m = d()), m.getInitialState();
    }
    function y(x, S = !1) {
      function A(I) {
        let L = I[x];
        if (typeof L > "u") {
          if (S)
            L = ja(g, A, v);
          else if (process.env.NODE_ENV !== "production")
            throw new Error(process.env.NODE_ENV === "production" ? Oe(15) : "selectSlice returned undefined for an uninjected slice reducer");
        }
        return L;
      }
      function T(I = f) {
        const L = ja(h, S, () => /* @__PURE__ */ new WeakMap());
        return ja(L, I, () => {
          const _ = {};
          for (const [R, D] of Object.entries(i.selectors ?? {}))
            _[R] = CL(D, I, () => ja(g, I, v), S);
          return _;
        });
      }
      return {
        reducerPath: x,
        getSelectors: T,
        get selectors() {
          return T(A);
        },
        selectSlice: A
      };
    }
    const b = {
      name: s,
      reducer: p,
      actions: l.actionCreators,
      caseReducers: l.sliceCaseReducersByName,
      getInitialState: v,
      ...y(a),
      injectInto(x, {
        reducerPath: S,
        ...A
      } = {}) {
        const T = S ?? a;
        return x.inject({
          reducerPath: T,
          reducer: p
        }, A), {
          ...b,
          ...y(T, !0)
        };
      }
    };
    return b;
  };
}
function CL(r, e, t, n) {
  function i(s, ...a) {
    let o = e(s);
    if (typeof o > "u") {
      if (n)
        o = t();
      else if (process.env.NODE_ENV !== "production")
        throw new Error(process.env.NODE_ENV === "production" ? Oe(16) : "selectState returned undefined for an uninjected slice reducer");
    }
    return r(o, ...a);
  }
  return i.unwrapped = r, i;
}
var xr = /* @__PURE__ */ DL();
function kL() {
  function r(e, t) {
    return {
      _reducerDefinitionType: "asyncThunk",
      payloadCreator: e,
      ...t
    };
  }
  return r.withTypes = () => r, {
    reducer(e) {
      return Object.assign({
        // hack so the wrapping function has the same name as the original
        // we need to create a wrapper so the `reducerDefinitionType` is not assigned to the original
        [e.name](...t) {
          return e(...t);
        }
      }[e.name], {
        _reducerDefinitionType: "reducer"
        /* reducer */
      });
    },
    preparedReducer(e, t) {
      return {
        _reducerDefinitionType: "reducerWithPrepare",
        prepare: e,
        reducer: t
      };
    },
    asyncThunk: r
  };
}
function ML({
  type: r,
  reducerName: e,
  createNotation: t
}, n, i) {
  let s, a;
  if ("reducer" in n) {
    if (t && !FL(n))
      throw new Error(process.env.NODE_ENV === "production" ? Oe(17) : "Please use the `create.preparedReducer` notation for prepared action creators with the `create` notation.");
    s = n.reducer, a = n.prepare;
  } else
    s = n;
  i.addCase(r, s).exposeCaseReducer(e, s).exposeAction(e, a ? mr(r, a) : mr(r));
}
function NL(r) {
  return r._reducerDefinitionType === "asyncThunk";
}
function FL(r) {
  return r._reducerDefinitionType === "reducerWithPrepare";
}
function $L({
  type: r,
  reducerName: e
}, t, n, i) {
  if (!i)
    throw new Error(process.env.NODE_ENV === "production" ? Oe(18) : "Cannot use `create.asyncThunk` in the built-in `createSlice`. Use `buildCreateSlice({ creators: { asyncThunk: asyncThunkCreator } })` to create a customised version of `createSlice`.");
  const {
    payloadCreator: s,
    fulfilled: a,
    pending: o,
    rejected: c,
    settled: l,
    options: u
  } = t, d = i(r, s, u);
  n.exposeAction(e, d), a && n.addCase(d.fulfilled, a), o && n.addCase(d.pending, o), c && n.addCase(d.rejected, c), l && n.addMatcher(d.settled, l), n.exposeCaseReducer(e, {
    fulfilled: a || Ga,
    pending: o || Ga,
    rejected: c || Ga,
    settled: l || Ga
  });
}
function Ga() {
}
var BL = "task", Xx = "listener", Qx = "completed", rh = "cancelled", jL = `task-${rh}`, UL = `task-${Qx}`, Od = `${Xx}-${rh}`, GL = `${Xx}-${Qx}`, Il = class {
  constructor(r) {
    Da(this, "name", "TaskAbortError");
    Da(this, "message");
    this.code = r, this.message = `${BL} ${rh} (reason: ${r})`;
  }
}, nh = (r, e) => {
  if (typeof r != "function")
    throw new TypeError(process.env.NODE_ENV === "production" ? Oe(32) : `${e} is not a function`);
}, Co = () => {
}, Zx = (r, e = Co) => (r.catch(e), r), Jx = (r, e) => (r.addEventListener("abort", e, {
  once: !0
}), () => r.removeEventListener("abort", e)), ii = (r, e) => {
  const t = r.signal;
  t.aborted || ("reason" in t || Object.defineProperty(t, "reason", {
    enumerable: !0,
    value: e,
    configurable: !0,
    writable: !0
  }), r.abort(e));
}, si = (r) => {
  if (r.aborted) {
    const {
      reason: e
    } = r;
    throw new Il(e);
  }
};
function eE(r, e) {
  let t = Co;
  return new Promise((n, i) => {
    const s = () => i(new Il(r.reason));
    if (r.aborted) {
      s();
      return;
    }
    t = Jx(r, s), e.finally(() => t()).then(n, i);
  }).finally(() => {
    t = Co;
  });
}
var KL = async (r, e) => {
  try {
    return await Promise.resolve(), {
      status: "ok",
      value: await r()
    };
  } catch (t) {
    return {
      status: t instanceof Il ? "cancelled" : "rejected",
      error: t
    };
  } finally {
    e == null || e();
  }
}, ko = (r) => (e) => Zx(eE(r, e).then((t) => (si(r), t))), tE = (r) => {
  const e = ko(r);
  return (t) => e(new Promise((n) => setTimeout(n, t)));
}, {
  assign: Fi
} = Object, $p = {}, ua = "listenerMiddleware", VL = (r, e) => {
  const t = (n) => Jx(r, () => ii(n, r.reason));
  return (n, i) => {
    nh(n, "taskExecutor");
    const s = new AbortController();
    t(s);
    const a = KL(async () => {
      si(r), si(s.signal);
      const o = await n({
        pause: ko(s.signal),
        delay: tE(s.signal),
        signal: s.signal
      });
      return si(s.signal), o;
    }, () => ii(s, UL));
    return i != null && i.autoJoin && e.push(a.catch(Co)), {
      result: ko(r)(a),
      cancel() {
        ii(s, jL);
      }
    };
  };
}, WL = (r, e) => {
  const t = async (n, i) => {
    si(e);
    let s = () => {
    };
    const o = [new Promise((c, l) => {
      let u = r({
        predicate: n,
        effect: (d, f) => {
          f.unsubscribe(), c([d, f.getState(), f.getOriginalState()]);
        }
      });
      s = () => {
        u(), l();
      };
    })];
    i != null && o.push(new Promise((c) => setTimeout(c, i, null)));
    try {
      const c = await eE(e, Promise.race(o));
      return si(e), c;
    } finally {
      s();
    }
  };
  return (n, i) => Zx(t(n, i));
}, rE = (r) => {
  let {
    type: e,
    actionCreator: t,
    matcher: n,
    predicate: i,
    effect: s
  } = r;
  if (e)
    i = mr(e).match;
  else if (t)
    e = t.type, i = t.match;
  else if (n)
    i = n;
  else if (!i) throw new Error(process.env.NODE_ENV === "production" ? Oe(21) : "Creating or removing a listener requires one of the known fields for matching an action");
  return nh(s, "options.listener"), {
    predicate: i,
    type: e,
    effect: s
  };
}, nE = /* @__PURE__ */ Fi((r) => {
  const {
    type: e,
    predicate: t,
    effect: n
  } = rE(r);
  return {
    id: LL(),
    effect: n,
    type: e,
    predicate: t,
    pending: /* @__PURE__ */ new Set(),
    unsubscribe: () => {
      throw new Error(process.env.NODE_ENV === "production" ? Oe(22) : "Unsubscribe not initialized");
    }
  };
}, {
  withTypes: () => nE
}), Bp = (r, e) => {
  const {
    type: t,
    effect: n,
    predicate: i
  } = rE(e);
  return Array.from(r.values()).find((s) => (typeof t == "string" ? s.type === t : s.predicate === i) && s.effect === n);
}, Rd = (r) => {
  r.pending.forEach((e) => {
    ii(e, Od);
  });
}, HL = (r) => () => {
  r.forEach(Rd), r.clear();
}, jp = (r, e, t) => {
  try {
    r(e, t);
  } catch (n) {
    setTimeout(() => {
      throw n;
    }, 0);
  }
}, iE = /* @__PURE__ */ Fi(/* @__PURE__ */ mr(`${ua}/add`), {
  withTypes: () => iE
}), qL = /* @__PURE__ */ mr(`${ua}/removeAll`), sE = /* @__PURE__ */ Fi(/* @__PURE__ */ mr(`${ua}/remove`), {
  withTypes: () => sE
}), zL = (...r) => {
  console.error(`${ua}/error`, ...r);
}, da = (r = {}) => {
  const e = /* @__PURE__ */ new Map(), {
    extra: t,
    onError: n = zL
  } = r;
  nh(n, "onError");
  const i = (u) => (u.unsubscribe = () => e.delete(u.id), e.set(u.id, u), (d) => {
    u.unsubscribe(), d != null && d.cancelActive && Rd(u);
  }), s = (u) => {
    const d = Bp(e, u) ?? nE(u);
    return i(d);
  };
  Fi(s, {
    withTypes: () => s
  });
  const a = (u) => {
    const d = Bp(e, u);
    return d && (d.unsubscribe(), u.cancelActive && Rd(d)), !!d;
  };
  Fi(a, {
    withTypes: () => a
  });
  const o = async (u, d, f, h) => {
    const g = new AbortController(), m = WL(s, g.signal), p = [];
    try {
      u.pending.add(g), await Promise.resolve(u.effect(
        d,
        // Use assign() rather than ... to avoid extra helper functions added to bundle
        Fi({}, f, {
          getOriginalState: h,
          condition: (v, y) => m(v, y).then(Boolean),
          take: m,
          delay: tE(g.signal),
          pause: ko(g.signal),
          extra: t,
          signal: g.signal,
          fork: VL(g.signal, p),
          unsubscribe: u.unsubscribe,
          subscribe: () => {
            e.set(u.id, u);
          },
          cancelActiveListeners: () => {
            u.pending.forEach((v, y, b) => {
              v !== g && (ii(v, Od), b.delete(v));
            });
          },
          cancel: () => {
            ii(g, Od), u.pending.delete(g);
          },
          throwIfCancelled: () => {
            si(g.signal);
          }
        })
      ));
    } catch (v) {
      v instanceof Il || jp(n, v, {
        raisedBy: "effect"
      });
    } finally {
      await Promise.all(p), ii(g, GL), u.pending.delete(g);
    }
  }, c = HL(e);
  return {
    middleware: (u) => (d) => (f) => {
      if (!Jf(f))
        return d(f);
      if (iE.match(f))
        return s(f.payload);
      if (qL.match(f)) {
        c();
        return;
      }
      if (sE.match(f))
        return a(f.payload);
      let h = u.getState();
      const g = () => {
        if (h === $p)
          throw new Error(process.env.NODE_ENV === "production" ? Oe(23) : `${ua}: getOriginalState can only be called synchronously`);
        return h;
      };
      let m;
      try {
        if (m = d(f), e.size > 0) {
          const p = u.getState(), v = Array.from(e.values());
          for (const y of v) {
            let b = !1;
            try {
              b = y.predicate(f, p, h);
            } catch (x) {
              b = !1, jp(n, x, {
                raisedBy: "predicate"
              });
            }
            b && o(y, f, u, g);
          }
        }
      } finally {
        h = $p;
      }
      return m;
    },
    startListening: s,
    stopListening: a,
    clearListeners: c
  };
};
function Oe(r) {
  return `Minified Redux Toolkit error #${r}; visit https://redux-toolkit.js.org/Errors?code=${r} for the full message or use the non-minified dev environment for full errors. `;
}
var YL = {
  layoutType: "horizontal",
  width: 0,
  height: 0,
  margin: {
    top: 5,
    right: 5,
    bottom: 5,
    left: 5
  },
  scale: 1
}, aE = xr({
  name: "chartLayout",
  initialState: YL,
  reducers: {
    setLayout(r, e) {
      r.layoutType = e.payload;
    },
    setChartSize(r, e) {
      r.width = e.payload.width, r.height = e.payload.height;
    },
    setMargin(r, e) {
      r.margin.top = e.payload.top, r.margin.right = e.payload.right, r.margin.bottom = e.payload.bottom, r.margin.left = e.payload.left;
    },
    setScale(r, e) {
      r.scale = e.payload;
    }
  }
}), {
  setMargin: XL,
  setLayout: QL,
  setChartSize: ZL,
  setScale: JL
} = aE.actions, e1 = aE.reducer;
function Up(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function Gp(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Up(Object(t), !0).forEach(function(n) {
      t1(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : Up(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function t1(r, e, t) {
  return (e = r1(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function r1(r) {
  var e = n1(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function n1(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
var Mo = Math.PI / 180, i1 = (r) => r * 180 / Math.PI, st = (r, e, t, n) => ({
  x: r + Math.cos(-Mo * n) * t,
  y: e + Math.sin(-Mo * n) * t
}), oE = function(e, t) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
  return Math.min(Math.abs(e - (n.left || 0) - (n.right || 0)), Math.abs(t - (n.top || 0) - (n.bottom || 0))) / 2;
}, s1 = (r, e) => {
  var {
    x: t,
    y: n
  } = r, {
    x: i,
    y: s
  } = e;
  return Math.sqrt((t - i) ** 2 + (n - s) ** 2);
}, a1 = (r, e) => {
  var {
    x: t,
    y: n
  } = r, {
    cx: i,
    cy: s
  } = e, a = s1({
    x: t,
    y: n
  }, {
    x: i,
    y: s
  });
  if (a <= 0)
    return {
      radius: a,
      angle: 0
    };
  var o = (t - i) / a, c = Math.acos(o);
  return n > s && (c = 2 * Math.PI - c), {
    radius: a,
    angle: i1(c),
    angleInRadian: c
  };
}, o1 = (r) => {
  var {
    startAngle: e,
    endAngle: t
  } = r, n = Math.floor(e / 360), i = Math.floor(t / 360), s = Math.min(n, i);
  return {
    startAngle: e - s * 360,
    endAngle: t - s * 360
  };
}, l1 = (r, e) => {
  var {
    startAngle: t,
    endAngle: n
  } = e, i = Math.floor(t / 360), s = Math.floor(n / 360), a = Math.min(i, s);
  return r + a * 360;
}, c1 = (r, e) => {
  var {
    x: t,
    y: n
  } = r, {
    radius: i,
    angle: s
  } = a1({
    x: t,
    y: n
  }, e), {
    innerRadius: a,
    outerRadius: o
  } = e;
  if (i < a || i > o || i === 0)
    return null;
  var {
    startAngle: c,
    endAngle: l
  } = o1(e), u = s, d;
  if (c <= l) {
    for (; u > l; )
      u -= 360;
    for (; u < c; )
      u += 360;
    d = u >= c && u <= l;
  } else {
    for (; u > c; )
      u -= 360;
    for (; u < l; )
      u += 360;
    d = u >= l && u <= c;
  }
  return d ? Gp(Gp({}, e), {}, {
    radius: i,
    angle: l1(u, e)
  }) : null;
};
function Kp(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function fr(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Kp(Object(t), !0).forEach(function(n) {
      u1(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : Kp(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function u1(r, e, t) {
  return (e = d1(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function d1(r) {
  var e = f1(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function f1(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function Pe(r, e, t) {
  return ye(r) || ye(e) ? t : Br(e) ? Mn(r, e, t) : typeof e == "function" ? e(r) : t;
}
var h1 = (r, e, t, n, i) => {
  var s, a = -1, o = (s = e == null ? void 0 : e.length) !== null && s !== void 0 ? s : 0;
  if (o <= 1 || r == null)
    return 0;
  if (n === "angleAxis" && i != null && Math.abs(Math.abs(i[1] - i[0]) - 360) <= 1e-6)
    for (var c = 0; c < o; c++) {
      var l = c > 0 ? t[c - 1].coordinate : t[o - 1].coordinate, u = t[c].coordinate, d = c >= o - 1 ? t[0].coordinate : t[c + 1].coordinate, f = void 0;
      if (pt(u - l) !== pt(d - u)) {
        var h = [];
        if (pt(d - u) === pt(i[1] - i[0])) {
          f = d;
          var g = u + i[1] - i[0];
          h[0] = Math.min(g, (g + l) / 2), h[1] = Math.max(g, (g + l) / 2);
        } else {
          f = l;
          var m = d + i[1] - i[0];
          h[0] = Math.min(u, (m + u) / 2), h[1] = Math.max(u, (m + u) / 2);
        }
        var p = [Math.min(u, (f + u) / 2), Math.max(u, (f + u) / 2)];
        if (r > p[0] && r <= p[1] || r >= h[0] && r <= h[1]) {
          ({
            index: a
          } = t[c]);
          break;
        }
      } else {
        var v = Math.min(l, d), y = Math.max(l, d);
        if (r > (v + u) / 2 && r <= (y + u) / 2) {
          ({
            index: a
          } = t[c]);
          break;
        }
      }
    }
  else if (e) {
    for (var b = 0; b < o; b++)
      if (b === 0 && r <= (e[b].coordinate + e[b + 1].coordinate) / 2 || b > 0 && b < o - 1 && r > (e[b].coordinate + e[b - 1].coordinate) / 2 && r <= (e[b].coordinate + e[b + 1].coordinate) / 2 || b === o - 1 && r > (e[b].coordinate + e[b - 1].coordinate) / 2) {
        ({
          index: a
        } = e[b]);
        break;
      }
  }
  return a;
}, g1 = (r, e, t) => {
  if (e && t) {
    var {
      width: n,
      height: i
    } = t, {
      align: s,
      verticalAlign: a,
      layout: o
    } = e;
    if ((o === "vertical" || o === "horizontal" && a === "middle") && s !== "center" && z(r[s]))
      return fr(fr({}, r), {}, {
        [s]: r[s] + (n || 0)
      });
    if ((o === "horizontal" || o === "vertical" && s === "center") && a !== "middle" && z(r[a]))
      return fr(fr({}, r), {}, {
        [a]: r[a] + (i || 0)
      });
  }
  return r;
}, Vr = (r, e) => r === "horizontal" && e === "xAxis" || r === "vertical" && e === "yAxis" || r === "centric" && e === "angleAxis" || r === "radial" && e === "radiusAxis", lE = (r, e, t, n) => {
  if (n)
    return r.map((o) => o.coordinate);
  var i, s, a = r.map((o) => (o.coordinate === e && (i = !0), o.coordinate === t && (s = !0), o.coordinate));
  return i || a.push(e), s || a.push(t), a;
}, cE = (r, e, t) => {
  if (!r)
    return null;
  var {
    duplicateDomain: n,
    type: i,
    range: s,
    scale: a,
    realScaleType: o,
    isCategorical: c,
    categoricalDomain: l,
    tickCount: u,
    ticks: d,
    niceTicks: f,
    axisType: h
  } = r;
  if (!a)
    return null;
  var g = o === "scaleBand" && a.bandwidth ? a.bandwidth() / 2 : 2, m = i === "category" && a.bandwidth ? a.bandwidth() / g : 0;
  if (m = h === "angleAxis" && s && s.length >= 2 ? pt(s[0] - s[1]) * 2 * m : m, d || f) {
    var p = (d || f || []).map((v, y) => {
      var b = n ? n.indexOf(v) : v;
      return {
        // If the scaleContent is not a number, the coordinate will be NaN.
        // That could be the case for example with a PointScale and a string as domain.
        coordinate: a(b) + m,
        value: v,
        offset: m,
        index: y
      };
    });
    return p.filter((v) => !Ut(v.coordinate));
  }
  return c && l ? l.map((v, y) => ({
    coordinate: a(v) + m,
    value: v,
    index: y,
    offset: m
  })) : a.ticks && u != null ? a.ticks(u).map((v, y) => ({
    coordinate: a(v) + m,
    value: v,
    offset: m,
    index: y
  })) : a.domain().map((v, y) => ({
    coordinate: a(v) + m,
    value: n ? n[v] : v,
    index: y,
    offset: m
  }));
}, Vp = 1e-4, m1 = (r) => {
  var e = r.domain();
  if (!(!e || e.length <= 2)) {
    var t = e.length, n = r.range(), i = Math.min(n[0], n[1]) - Vp, s = Math.max(n[0], n[1]) + Vp, a = r(e[0]), o = r(e[t - 1]);
    (a < i || a > s || o < i || o > s) && r.domain([e[0], e[t - 1]]);
  }
}, p1 = (r, e) => {
  if (!e || e.length !== 2 || !z(e[0]) || !z(e[1]))
    return r;
  var t = Math.min(e[0], e[1]), n = Math.max(e[0], e[1]), i = [r[0], r[1]];
  return (!z(r[0]) || r[0] < t) && (i[0] = t), (!z(r[1]) || r[1] > n) && (i[1] = n), i[0] > n && (i[0] = n), i[1] < t && (i[1] = t), i;
}, v1 = (r) => {
  var e = r.length;
  if (!(e <= 0))
    for (var t = 0, n = r[0].length; t < n; ++t)
      for (var i = 0, s = 0, a = 0; a < e; ++a) {
        var o = Ut(r[a][t][1]) ? r[a][t][0] : r[a][t][1];
        o >= 0 ? (r[a][t][0] = i, r[a][t][1] = i + o, i = r[a][t][1]) : (r[a][t][0] = s, r[a][t][1] = s + o, s = r[a][t][1]);
      }
}, y1 = (r) => {
  var e = r.length;
  if (!(e <= 0))
    for (var t = 0, n = r[0].length; t < n; ++t)
      for (var i = 0, s = 0; s < e; ++s) {
        var a = Ut(r[s][t][1]) ? r[s][t][0] : r[s][t][1];
        a >= 0 ? (r[s][t][0] = i, r[s][t][1] = i + a, i = r[s][t][1]) : (r[s][t][0] = 0, r[s][t][1] = 0);
      }
}, b1 = {
  sign: v1,
  // @ts-expect-error definitelytyped types are incorrect
  expand: DP,
  // @ts-expect-error definitelytyped types are incorrect
  none: Gi,
  // @ts-expect-error definitelytyped types are incorrect
  silhouette: CP,
  // @ts-expect-error definitelytyped types are incorrect
  wiggle: kP,
  positive: y1
}, x1 = (r, e, t) => {
  var n = b1[t], i = RP().keys(e).value((s, a) => +Pe(s, a, 0)).order(xd).offset(n);
  return i(r);
};
function ih(r) {
  return r == null ? void 0 : String(r);
}
function Vi(r) {
  var {
    axis: e,
    ticks: t,
    bandSize: n,
    entry: i,
    index: s,
    dataKey: a
  } = r;
  if (e.type === "category") {
    if (!e.allowDuplicatedCategory && e.dataKey && !ye(i[e.dataKey])) {
      var o = ex(t, "value", i[e.dataKey]);
      if (o)
        return o.coordinate + n / 2;
    }
    return t[s] ? t[s].coordinate + n / 2 : null;
  }
  var c = Pe(i, ye(a) ? e.dataKey : a);
  return ye(c) ? null : e.scale(c);
}
var Wp = (r) => {
  var {
    axis: e,
    ticks: t,
    offset: n,
    bandSize: i,
    entry: s,
    index: a
  } = r;
  if (e.type === "category")
    return t[a] ? t[a].coordinate + n : null;
  var o = Pe(s, e.dataKey, e.scale.domain()[a]);
  return ye(o) ? null : e.scale(o) - i / 2 + n;
}, E1 = (r) => {
  var {
    numericAxis: e
  } = r, t = e.scale.domain();
  if (e.type === "number") {
    var n = Math.min(t[0], t[1]), i = Math.max(t[0], t[1]);
    return n <= 0 && i >= 0 ? 0 : i < 0 ? i : n;
  }
  return t[0];
}, S1 = (r) => {
  var e = r.flat(2).filter(z);
  return [Math.min(...e), Math.max(...e)];
}, T1 = (r) => [r[0] === 1 / 0 ? 0 : r[0], r[1] === -1 / 0 ? 0 : r[1]], A1 = (r, e, t) => {
  if (r != null)
    return T1(Object.keys(r).reduce((n, i) => {
      var s = r[i], {
        stackedData: a
      } = s, o = a.reduce((c, l) => {
        var u = S1(l.slice(e, t + 1));
        return [Math.min(c[0], u[0]), Math.max(c[1], u[1])];
      }, [1 / 0, -1 / 0]);
      return [Math.min(o[0], n[0]), Math.max(o[1], n[1])];
    }, [1 / 0, -1 / 0]));
}, Hp = /^dataMin[\s]*-[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/, qp = /^dataMax[\s]*\+[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/, fi = (r, e, t) => {
  if (r && r.scale && r.scale.bandwidth) {
    var n = r.scale.bandwidth();
    if (!t || n > 0)
      return n;
  }
  if (r && e && e.length >= 2) {
    for (var i = El(e, (u) => u.coordinate), s = 1 / 0, a = 1, o = i.length; a < o; a++) {
      var c = i[a], l = i[a - 1];
      s = Math.min((c.coordinate || 0) - (l.coordinate || 0), s);
    }
    return s === 1 / 0 ? 0 : s;
  }
  return t ? void 0 : 0;
};
function zp(r) {
  var {
    tooltipEntrySettings: e,
    dataKey: t,
    payload: n,
    value: i,
    name: s
  } = r;
  return fr(fr({}, e), {}, {
    dataKey: t,
    payload: n,
    value: i,
    name: s
  });
}
function Wr(r, e) {
  if (r)
    return String(r);
  if (typeof e == "string")
    return e;
}
function w1(r, e, t, n, i) {
  if (t === "horizontal" || t === "vertical") {
    var s = r >= i.left && r <= i.left + i.width && e >= i.top && e <= i.top + i.height;
    return s ? {
      x: r,
      y: e
    } : null;
  }
  return n ? c1({
    x: r,
    y: e
  }, n) : null;
}
var I1 = (r, e, t, n) => {
  var i = e.find((l) => l && l.index === t);
  if (i) {
    if (r === "horizontal")
      return {
        x: i.coordinate,
        y: n.y
      };
    if (r === "vertical")
      return {
        x: n.x,
        y: i.coordinate
      };
    if (r === "centric") {
      var s = i.coordinate, {
        radius: a
      } = n;
      return fr(fr(fr({}, n), st(n.cx, n.cy, a, s)), {}, {
        angle: s,
        radius: a
      });
    }
    var o = i.coordinate, {
      angle: c
    } = n;
    return fr(fr(fr({}, n), st(n.cx, n.cy, o, c)), {}, {
      angle: c,
      radius: o
    });
  }
  return {
    x: 0,
    y: 0
  };
}, P1 = (r, e) => e === "horizontal" ? r.x : e === "vertical" ? r.y : e === "centric" ? r.angle : r.radius, gn = (r) => r.layout.width, mn = (r) => r.layout.height, _1 = (r) => r.layout.scale, uE = (r) => r.layout.margin, sh = M((r) => r.cartesianAxis.xAxis, (r) => Object.values(r)), ah = M((r) => r.cartesianAxis.yAxis, (r) => Object.values(r)), oh = "data-recharts-item-index", lh = "data-recharts-item-data-key", Pl = 60;
function Yp(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function Sn(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Yp(Object(t), !0).forEach(function(n) {
      L1(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : Yp(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function L1(r, e, t) {
  return (e = O1(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function O1(r) {
  var e = R1(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function R1(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
var D1 = (r) => r.brush.height, ut = M([gn, mn, uE, D1, sh, ah, Rx, U_], (r, e, t, n, i, s, a, o) => {
  var c = s.reduce((g, m) => {
    var {
      orientation: p
    } = m;
    if (!m.mirror && !m.hide) {
      var v = typeof m.width == "number" ? m.width : Pl;
      return Sn(Sn({}, g), {}, {
        [p]: g[p] + v
      });
    }
    return g;
  }, {
    left: t.left || 0,
    right: t.right || 0
  }), l = i.reduce((g, m) => {
    var {
      orientation: p
    } = m;
    return !m.mirror && !m.hide ? Sn(Sn({}, g), {}, {
      [p]: Mn(g, "".concat(p)) + m.height
    }) : g;
  }, {
    top: t.top || 0,
    bottom: t.bottom || 0
  }), u = Sn(Sn({}, l), c), d = u.bottom;
  u.bottom += n, u = g1(u, a, o);
  var f = r - u.left - u.right, h = e - u.top - u.bottom;
  return Sn(Sn({
    brushBottom: d
  }, u), {}, {
    // never return negative values for height and width
    width: Math.max(f, 0),
    height: Math.max(h, 0)
  });
}), C1 = M(ut, (r) => ({
  x: r.left,
  y: r.top,
  width: r.width,
  height: r.height
})), dE = M(gn, mn, (r, e) => ({
  x: 0,
  y: 0,
  width: r,
  height: e
})), k1 = /* @__PURE__ */ dn(null), At = () => un(k1) != null, _l = (r) => r.brush, Ll = M([_l, ut, uE], (r, e, t) => ({
  height: r.height,
  x: z(r.x) ? r.x : e.left,
  y: z(r.y) ? r.y : e.top + e.height + e.brushBottom - ((t == null ? void 0 : t.bottom) || 0),
  width: z(r.width) ? r.width : e.width
})), ch = () => {
  var r, e = At(), t = te(C1), n = te(Ll), i = (r = te(_l)) === null || r === void 0 ? void 0 : r.padding;
  return !e || !n || !i ? t : {
    width: n.width - i.left - i.right,
    height: n.height - i.top - i.bottom,
    x: i.left,
    y: i.top
  };
}, M1 = {
  top: 0,
  bottom: 0,
  left: 0,
  right: 0,
  width: 0,
  height: 0,
  brushBottom: 0
}, fE = () => {
  var r;
  return (r = te(ut)) !== null && r !== void 0 ? r : M1;
}, uh = () => te(gn), dh = () => te(mn), N1 = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0
}, F1 = () => {
  var r;
  return (r = te((e) => e.layout.margin)) !== null && r !== void 0 ? r : N1;
}, Ee = (r) => r.layout.layoutType, fa = () => te(Ee), $1 = {
  settings: {
    layout: "horizontal",
    align: "center",
    verticalAlign: "middle",
    itemSorter: "value"
  },
  size: {
    width: 0,
    height: 0
  },
  payload: []
}, hE = xr({
  name: "legend",
  initialState: $1,
  reducers: {
    setLegendSize(r, e) {
      r.size.width = e.payload.width, r.size.height = e.payload.height;
    },
    setLegendSettings(r, e) {
      r.settings.align = e.payload.align, r.settings.layout = e.payload.layout, r.settings.verticalAlign = e.payload.verticalAlign, r.settings.itemSorter = e.payload.itemSorter;
    },
    addLegendPayload(r, e) {
      r.payload.push(e.payload);
    },
    removeLegendPayload(r, e) {
      var t = tn(r).payload.indexOf(e.payload);
      t > -1 && r.payload.splice(t, 1);
    }
  }
}), {
  setLegendSize: Xp,
  setLegendSettings: B1,
  addLegendPayload: gE,
  removeLegendPayload: mE
} = hE.actions, j1 = hE.reducer, U1 = ["contextPayload"];
function Dd() {
  return Dd = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t) ({}).hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, Dd.apply(null, arguments);
}
function Qp(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function Wi(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Qp(Object(t), !0).forEach(function(n) {
      fh(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : Qp(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function fh(r, e, t) {
  return (e = G1(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function G1(r) {
  var e = K1(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function K1(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function V1(r, e) {
  if (r == null) return {};
  var t, n, i = W1(r, e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(r);
    for (n = 0; n < s.length; n++) t = s[n], e.indexOf(t) === -1 && {}.propertyIsEnumerable.call(r, t) && (i[t] = r[t]);
  }
  return i;
}
function W1(r, e) {
  if (r == null) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.indexOf(n) !== -1) continue;
    t[n] = r[n];
  }
  return t;
}
function H1(r) {
  return r.value;
}
function q1(r) {
  var {
    contextPayload: e
  } = r, t = V1(r, U1), n = Ix(e, r.payloadUniqBy, H1), i = Wi(Wi({}, t), {}, {
    payload: n
  });
  return /* @__PURE__ */ w.isValidElement(r.content) ? /* @__PURE__ */ w.cloneElement(r.content, i) : typeof r.content == "function" ? /* @__PURE__ */ w.createElement(r.content, i) : /* @__PURE__ */ w.createElement(Hf, i);
}
function z1(r, e, t, n, i, s) {
  var {
    layout: a,
    align: o,
    verticalAlign: c
  } = e, l, u;
  return (!r || (r.left === void 0 || r.left === null) && (r.right === void 0 || r.right === null)) && (o === "center" && a === "vertical" ? l = {
    left: ((n || 0) - s.width) / 2
  } : l = o === "right" ? {
    right: t && t.right || 0
  } : {
    left: t && t.left || 0
  }), (!r || (r.top === void 0 || r.top === null) && (r.bottom === void 0 || r.bottom === null)) && (c === "middle" ? u = {
    top: ((i || 0) - s.height) / 2
  } : u = c === "bottom" ? {
    bottom: t && t.bottom || 0
  } : {
    top: t && t.top || 0
  }), Wi(Wi({}, l), u);
}
function Y1(r) {
  var e = He();
  return we(() => {
    e(B1(r));
  }, [e, r]), null;
}
function X1(r) {
  var e = He();
  return we(() => (e(Xp(r)), () => {
    e(Xp({
      width: 0,
      height: 0
    }));
  }), [e, r]), null;
}
function Q1(r) {
  var e = V_(), t = tP(), n = F1(), {
    width: i,
    height: s,
    wrapperStyle: a,
    portal: o
  } = r, [c, l] = Dx([e]), u = uh(), d = dh(), f = u - (n.left || 0) - (n.right || 0), h = Ks.getWidthOrHeight(r.layout, s, i, f), g = o ? a : Wi(Wi({
    position: "absolute",
    width: (h == null ? void 0 : h.width) || i || "auto",
    height: (h == null ? void 0 : h.height) || s || "auto"
  }, z1(a, r, n, u, d, c)), a), m = o ?? t;
  if (m == null)
    return null;
  var p = /* @__PURE__ */ w.createElement("div", {
    className: "recharts-legend-wrapper",
    style: g,
    ref: l
  }, /* @__PURE__ */ w.createElement(Y1, {
    layout: r.layout,
    align: r.align,
    verticalAlign: r.verticalAlign,
    itemSorter: r.itemSorter
  }), /* @__PURE__ */ w.createElement(X1, {
    width: c.width,
    height: c.height
  }), /* @__PURE__ */ w.createElement(q1, Dd({}, r, h, {
    margin: n,
    chartWidth: u,
    chartHeight: d,
    contextPayload: e
  })));
  return /* @__PURE__ */ Nf(p, m);
}
class Ks extends Kr {
  static getWidthOrHeight(e, t, n, i) {
    return e === "vertical" && z(t) ? {
      height: t
    } : e === "horizontal" ? {
      width: n || i
    } : null;
  }
  render() {
    return /* @__PURE__ */ w.createElement(Q1, this.props);
  }
}
fh(Ks, "displayName", "Legend");
fh(Ks, "defaultProps", {
  align: "center",
  iconSize: 14,
  itemSorter: "value",
  layout: "horizontal",
  verticalAlign: "bottom"
});
function Cd() {
  return Cd = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t) ({}).hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, Cd.apply(null, arguments);
}
function Zp(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function du(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Zp(Object(t), !0).forEach(function(n) {
      Z1(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : Zp(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function Z1(r, e, t) {
  return (e = J1(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function J1(r) {
  var e = eO(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function eO(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function tO(r) {
  return Array.isArray(r) && Br(r[0]) && Br(r[1]) ? r.join(" ~ ") : r;
}
var rO = (r) => {
  var {
    separator: e = " : ",
    contentStyle: t = {},
    itemStyle: n = {},
    labelStyle: i = {},
    payload: s,
    formatter: a,
    itemSorter: o,
    wrapperClassName: c,
    labelClassName: l,
    label: u,
    labelFormatter: d,
    accessibilityLayer: f = !1
  } = r, h = () => {
    if (s && s.length) {
      var S = {
        padding: 0,
        margin: 0
      }, A = (o ? El(s, o) : s).map((T, I) => {
        if (T.type === "none")
          return null;
        var L = T.formatter || a || tO, {
          value: _,
          name: R
        } = T, D = _, F = R;
        if (L) {
          var B = L(_, R, T, I, s);
          if (Array.isArray(B))
            [D, F] = B;
          else if (B != null)
            D = B;
          else
            return null;
        }
        var j = du({
          display: "block",
          paddingTop: 4,
          paddingBottom: 4,
          color: T.color || "#000"
        }, n);
        return (
          // eslint-disable-next-line react/no-array-index-key
          /* @__PURE__ */ w.createElement("li", {
            className: "recharts-tooltip-item",
            key: "tooltip-item-".concat(I),
            style: j
          }, Br(F) ? /* @__PURE__ */ w.createElement("span", {
            className: "recharts-tooltip-item-name"
          }, F) : null, Br(F) ? /* @__PURE__ */ w.createElement("span", {
            className: "recharts-tooltip-item-separator"
          }, e) : null, /* @__PURE__ */ w.createElement("span", {
            className: "recharts-tooltip-item-value"
          }, D), /* @__PURE__ */ w.createElement("span", {
            className: "recharts-tooltip-item-unit"
          }, T.unit || ""))
        );
      });
      return /* @__PURE__ */ w.createElement("ul", {
        className: "recharts-tooltip-item-list",
        style: S
      }, A);
    }
    return null;
  }, g = du({
    margin: 0,
    padding: 10,
    backgroundColor: "#fff",
    border: "1px solid #ccc",
    whiteSpace: "nowrap"
  }, t), m = du({
    margin: 0
  }, i), p = !ye(u), v = p ? u : "", y = ve("recharts-default-tooltip", c), b = ve("recharts-tooltip-label", l);
  p && d && s !== void 0 && s !== null && (v = d(u, s));
  var x = f ? {
    role: "status",
    "aria-live": "assertive"
  } : {};
  return /* @__PURE__ */ w.createElement("div", Cd({
    className: y,
    style: g
  }, x), /* @__PURE__ */ w.createElement("p", {
    className: b,
    style: m
  }, /* @__PURE__ */ w.isValidElement(v) ? v : "".concat(v)), h());
}, Es = "recharts-tooltip-wrapper", nO = {
  visibility: "hidden"
};
function iO(r) {
  var {
    coordinate: e,
    translateX: t,
    translateY: n
  } = r;
  return ve(Es, {
    ["".concat(Es, "-right")]: z(t) && e && z(e.x) && t >= e.x,
    ["".concat(Es, "-left")]: z(t) && e && z(e.x) && t < e.x,
    ["".concat(Es, "-bottom")]: z(n) && e && z(e.y) && n >= e.y,
    ["".concat(Es, "-top")]: z(n) && e && z(e.y) && n < e.y
  });
}
function Jp(r) {
  var {
    allowEscapeViewBox: e,
    coordinate: t,
    key: n,
    offsetTopLeft: i,
    position: s,
    reverseDirection: a,
    tooltipDimension: o,
    viewBox: c,
    viewBoxDimension: l
  } = r;
  if (s && z(s[n]))
    return s[n];
  var u = t[n] - o - (i > 0 ? i : 0), d = t[n] + i;
  if (e[n])
    return a[n] ? u : d;
  var f = c[n];
  if (f == null)
    return 0;
  if (a[n]) {
    var h = u, g = f;
    return h < g ? Math.max(d, f) : Math.max(u, f);
  }
  if (l == null)
    return 0;
  var m = d + o, p = f + l;
  return m > p ? Math.max(u, f) : Math.max(d, f);
}
function sO(r) {
  var {
    translateX: e,
    translateY: t,
    useTranslate3d: n
  } = r;
  return {
    transform: n ? "translate3d(".concat(e, "px, ").concat(t, "px, 0)") : "translate(".concat(e, "px, ").concat(t, "px)")
  };
}
function aO(r) {
  var {
    allowEscapeViewBox: e,
    coordinate: t,
    offsetTopLeft: n,
    position: i,
    reverseDirection: s,
    tooltipBox: a,
    useTranslate3d: o,
    viewBox: c
  } = r, l, u, d;
  return a.height > 0 && a.width > 0 && t ? (u = Jp({
    allowEscapeViewBox: e,
    coordinate: t,
    key: "x",
    offsetTopLeft: n,
    position: i,
    reverseDirection: s,
    tooltipDimension: a.width,
    viewBox: c,
    viewBoxDimension: c.width
  }), d = Jp({
    allowEscapeViewBox: e,
    coordinate: t,
    key: "y",
    offsetTopLeft: n,
    position: i,
    reverseDirection: s,
    tooltipDimension: a.height,
    viewBox: c,
    viewBoxDimension: c.height
  }), l = sO({
    translateX: u,
    translateY: d,
    useTranslate3d: o
  })) : l = nO, {
    cssProperties: l,
    cssClasses: iO({
      translateX: u,
      translateY: d,
      coordinate: t
    })
  };
}
function ev(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function Ka(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ev(Object(t), !0).forEach(function(n) {
      kd(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : ev(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function kd(r, e, t) {
  return (e = oO(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function oO(r) {
  var e = lO(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function lO(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
class cO extends Kr {
  constructor() {
    super(...arguments), kd(this, "state", {
      dismissed: !1,
      dismissedAtCoordinate: {
        x: 0,
        y: 0
      }
    }), kd(this, "handleKeyDown", (e) => {
      if (e.key === "Escape") {
        var t, n, i, s;
        this.setState({
          dismissed: !0,
          dismissedAtCoordinate: {
            x: (t = (n = this.props.coordinate) === null || n === void 0 ? void 0 : n.x) !== null && t !== void 0 ? t : 0,
            y: (i = (s = this.props.coordinate) === null || s === void 0 ? void 0 : s.y) !== null && i !== void 0 ? i : 0
          }
        });
      }
    });
  }
  componentDidMount() {
    document.addEventListener("keydown", this.handleKeyDown);
  }
  componentWillUnmount() {
    document.removeEventListener("keydown", this.handleKeyDown);
  }
  componentDidUpdate() {
    var e, t;
    this.state.dismissed && (((e = this.props.coordinate) === null || e === void 0 ? void 0 : e.x) !== this.state.dismissedAtCoordinate.x || ((t = this.props.coordinate) === null || t === void 0 ? void 0 : t.y) !== this.state.dismissedAtCoordinate.y) && (this.state.dismissed = !1);
  }
  render() {
    var {
      active: e,
      allowEscapeViewBox: t,
      animationDuration: n,
      animationEasing: i,
      children: s,
      coordinate: a,
      hasPayload: o,
      isAnimationActive: c,
      offset: l,
      position: u,
      reverseDirection: d,
      useTranslate3d: f,
      viewBox: h,
      wrapperStyle: g,
      lastBoundingBox: m,
      innerRef: p,
      hasPortalFromProps: v
    } = this.props, {
      cssClasses: y,
      cssProperties: b
    } = aO({
      allowEscapeViewBox: t,
      coordinate: a,
      offsetTopLeft: l,
      position: u,
      reverseDirection: d,
      tooltipBox: {
        height: m.height,
        width: m.width
      },
      useTranslate3d: f,
      viewBox: h
    }), x = v ? {} : Ka(Ka({
      transition: c && e ? "transform ".concat(n, "ms ").concat(i) : void 0
    }, b), {}, {
      pointerEvents: "none",
      visibility: !this.state.dismissed && e && o ? "visible" : "hidden",
      position: "absolute",
      top: 0,
      left: 0
    }), S = Ka(Ka({}, x), {}, {
      visibility: !this.state.dismissed && e && o ? "visible" : "hidden"
    }, g);
    return (
      // This element allow listening to the `Escape` key. See https://github.com/recharts/recharts/pull/2925
      /* @__PURE__ */ w.createElement("div", {
        // @ts-expect-error typescript library does not recognize xmlns attribute, but it's required for an HTML chunk inside SVG.
        xmlns: "http://www.w3.org/1999/xhtml",
        tabIndex: -1,
        className: y,
        style: S,
        ref: p
      }, s)
    );
  }
}
var uO = () => !(typeof window < "u" && window.document && window.document.createElement && window.setTimeout), pn = {
  isSsr: uO()
}, pE = () => te((r) => r.rootProps.accessibilityLayer);
function Tt(r) {
  return Number.isFinite(r);
}
function Hi(r) {
  return typeof r == "number" && r > 0 && Number.isFinite(r);
}
function Md() {
  return Md = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t) ({}).hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, Md.apply(null, arguments);
}
function tv(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function rv(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? tv(Object(t), !0).forEach(function(n) {
      dO(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : tv(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function dO(r, e, t) {
  return (e = fO(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function fO(r) {
  var e = hO(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function hO(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
var nv = {
  curveBasisClosed: xP,
  curveBasisOpen: EP,
  curveBasis: bP,
  curveBumpX: sP,
  curveBumpY: aP,
  curveLinearClosed: SP,
  curveLinear: yl,
  curveMonotoneX: TP,
  curveMonotoneY: AP,
  curveNatural: wP,
  curveStep: IP,
  curveStepAfter: _P,
  curveStepBefore: PP
}, Va = (r) => Tt(r.x) && Tt(r.y), Ss = (r) => r.x, Ts = (r) => r.y, gO = (r, e) => {
  if (typeof r == "function")
    return r;
  var t = "curve".concat(la(r));
  return (t === "curveMonotone" || t === "curveBump") && e ? nv["".concat(t).concat(e === "vertical" ? "Y" : "X")] : nv[t] || yl;
}, mO = (r) => {
  var {
    type: e = "linear",
    points: t = [],
    baseLine: n,
    layout: i,
    connectNulls: s = !1
  } = r, a = gO(e, i), o = s ? t.filter(Va) : t, c;
  if (Array.isArray(n)) {
    var l = s ? n.filter((d) => Va(d)) : n, u = o.map((d, f) => rv(rv({}, d), {}, {
      base: l[f]
    }));
    return i === "vertical" ? c = Ma().y(Ts).x1(Ss).x0((d) => d.base.x) : c = Ma().x(Ss).y1(Ts).y0((d) => d.base.y), c.defined(Va).curve(a), c(u);
  }
  return i === "vertical" && z(n) ? c = Ma().y(Ts).x1(Ss).x0(n) : z(n) ? c = Ma().x(Ss).y1(Ts).y0(n) : c = lx().x(Ss).y(Ts), c.defined(Va).curve(a), c(o);
}, ai = (r) => {
  var {
    className: e,
    points: t,
    path: n,
    pathRef: i
  } = r;
  if ((!t || !t.length) && !n)
    return null;
  var s = t && t.length ? mO(r) : n;
  return /* @__PURE__ */ w.createElement("path", Md({}, de(r, !1), jf(r), {
    className: ve("recharts-curve", e),
    d: s === null ? void 0 : s,
    ref: i
  }));
}, pO = ["x", "y", "top", "left", "width", "height", "className"];
function Nd() {
  return Nd = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t) ({}).hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, Nd.apply(null, arguments);
}
function iv(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function vO(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? iv(Object(t), !0).forEach(function(n) {
      yO(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : iv(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function yO(r, e, t) {
  return (e = bO(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function bO(r) {
  var e = xO(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function xO(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function EO(r, e) {
  if (r == null) return {};
  var t, n, i = SO(r, e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(r);
    for (n = 0; n < s.length; n++) t = s[n], e.indexOf(t) === -1 && {}.propertyIsEnumerable.call(r, t) && (i[t] = r[t]);
  }
  return i;
}
function SO(r, e) {
  if (r == null) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.indexOf(n) !== -1) continue;
    t[n] = r[n];
  }
  return t;
}
var TO = (r, e, t, n, i, s) => "M".concat(r, ",").concat(i, "v").concat(n, "M").concat(s, ",").concat(e, "h").concat(t), AO = (r) => {
  var {
    x: e = 0,
    y: t = 0,
    top: n = 0,
    left: i = 0,
    width: s = 0,
    height: a = 0,
    className: o
  } = r, c = EO(r, pO), l = vO({
    x: e,
    y: t,
    top: n,
    left: i,
    width: s,
    height: a
  }, c);
  return !z(e) || !z(t) || !z(s) || !z(a) || !z(n) || !z(i) ? null : /* @__PURE__ */ w.createElement("path", Nd({}, de(l, !0), {
    className: ve("recharts-cross", o),
    d: TO(e, t, s, a, n, i)
  }));
};
function wO(r, e, t, n) {
  var i = n / 2;
  return {
    stroke: "none",
    fill: "#ccc",
    x: r === "horizontal" ? e.x - i : t.left + 0.5,
    y: r === "horizontal" ? t.top + 0.5 : e.y - i,
    width: r === "horizontal" ? n : t.width - 1,
    height: r === "horizontal" ? t.height - 1 : n
  };
}
function sv(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function IO(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? sv(Object(t), !0).forEach(function(n) {
      PO(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : sv(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function PO(r, e, t) {
  return (e = _O(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function _O(r) {
  var e = LO(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function LO(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function Vt(r, e) {
  var t = IO({}, r), n = e, i = Object.keys(e), s = i.reduce((a, o) => (a[o] === void 0 && n[o] !== void 0 && (a[o] = n[o]), a), t);
  return s;
}
var fu = {}, hu = {}, gu = {}, av;
function OO() {
  return av || (av = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    function e(t) {
      if (!t || typeof t != "object")
        return !1;
      const n = Object.getPrototypeOf(t);
      return n === null || n === Object.prototype || Object.getPrototypeOf(n) === null ? Object.prototype.toString.call(t) === "[object Object]" : !1;
    }
    r.isPlainObject = e;
  }(gu)), gu;
}
var ov;
function RO() {
  return ov || (ov = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    const e = /* @__PURE__ */ OO(), t = /* @__PURE__ */ Tx(), n = /* @__PURE__ */ Xf(), i = /* @__PURE__ */ Qf(), s = /* @__PURE__ */ zf();
    function a(l, u, d) {
      return o(l, u, void 0, void 0, void 0, void 0, d);
    }
    function o(l, u, d, f, h, g, m) {
      const p = m(l, u, d, f, h, g);
      if (p !== void 0)
        return p;
      if (typeof l == typeof u)
        switch (typeof l) {
          case "bigint":
          case "string":
          case "boolean":
          case "symbol":
          case "undefined":
            return l === u;
          case "number":
            return l === u || Object.is(l, u);
          case "function":
            return l === u;
          case "object":
            return c(l, u, g, m);
        }
      return c(l, u, g, m);
    }
    function c(l, u, d, f) {
      if (Object.is(l, u))
        return !0;
      let h = n.getTag(l), g = n.getTag(u);
      if (h === i.argumentsTag && (h = i.objectTag), g === i.argumentsTag && (g = i.objectTag), h !== g)
        return !1;
      switch (h) {
        case i.stringTag:
          return l.toString() === u.toString();
        case i.numberTag: {
          const v = l.valueOf(), y = u.valueOf();
          return s.eq(v, y);
        }
        case i.booleanTag:
        case i.dateTag:
        case i.symbolTag:
          return Object.is(l.valueOf(), u.valueOf());
        case i.regexpTag:
          return l.source === u.source && l.flags === u.flags;
        case i.functionTag:
          return l === u;
      }
      d = d ?? /* @__PURE__ */ new Map();
      const m = d.get(l), p = d.get(u);
      if (m != null && p != null)
        return m === u;
      d.set(l, u), d.set(u, l);
      try {
        switch (h) {
          case i.mapTag: {
            if (l.size !== u.size)
              return !1;
            for (const [v, y] of l.entries())
              if (!u.has(v) || !o(y, u.get(v), v, l, u, d, f))
                return !1;
            return !0;
          }
          case i.setTag: {
            if (l.size !== u.size)
              return !1;
            const v = Array.from(l.values()), y = Array.from(u.values());
            for (let b = 0; b < v.length; b++) {
              const x = v[b], S = y.findIndex((A) => o(x, A, void 0, l, u, d, f));
              if (S === -1)
                return !1;
              y.splice(S, 1);
            }
            return !0;
          }
          case i.arrayTag:
          case i.uint8ArrayTag:
          case i.uint8ClampedArrayTag:
          case i.uint16ArrayTag:
          case i.uint32ArrayTag:
          case i.bigUint64ArrayTag:
          case i.int8ArrayTag:
          case i.int16ArrayTag:
          case i.int32ArrayTag:
          case i.bigInt64ArrayTag:
          case i.float32ArrayTag:
          case i.float64ArrayTag: {
            if (typeof Buffer < "u" && Buffer.isBuffer(l) !== Buffer.isBuffer(u) || l.length !== u.length)
              return !1;
            for (let v = 0; v < l.length; v++)
              if (!o(l[v], u[v], v, l, u, d, f))
                return !1;
            return !0;
          }
          case i.arrayBufferTag:
            return l.byteLength !== u.byteLength ? !1 : c(new Uint8Array(l), new Uint8Array(u), d, f);
          case i.dataViewTag:
            return l.byteLength !== u.byteLength || l.byteOffset !== u.byteOffset ? !1 : c(new Uint8Array(l), new Uint8Array(u), d, f);
          case i.errorTag:
            return l.name === u.name && l.message === u.message;
          case i.objectTag: {
            if (!(c(l.constructor, u.constructor, d, f) || e.isPlainObject(l) && e.isPlainObject(u)))
              return !1;
            const y = [...Object.keys(l), ...t.getSymbols(l)], b = [...Object.keys(u), ...t.getSymbols(u)];
            if (y.length !== b.length)
              return !1;
            for (let x = 0; x < y.length; x++) {
              const S = y[x], A = l[S];
              if (!Object.hasOwn(u, S))
                return !1;
              const T = u[S];
              if (!o(A, T, S, l, u, d, f))
                return !1;
            }
            return !0;
          }
          default:
            return !1;
        }
      } finally {
        d.delete(l), d.delete(u);
      }
    }
    r.isEqualWith = a;
  }(hu)), hu;
}
var mu = {}, lv;
function DO() {
  return lv || (lv = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    function e() {
    }
    r.noop = e;
  }(mu)), mu;
}
var cv;
function CO() {
  return cv || (cv = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    const e = /* @__PURE__ */ RO(), t = /* @__PURE__ */ DO();
    function n(i, s) {
      return e.isEqualWith(i, s, t.noop);
    }
    r.isEqual = n;
  }(fu)), fu;
}
var pu, uv;
function kO() {
  return uv || (uv = 1, pu = CO().isEqual), pu;
}
var MO = /* @__PURE__ */ kO();
const NO = /* @__PURE__ */ hn(MO);
function FO(r) {
  var e = {}, t = () => null, n = !1, i = null, s = (a) => {
    if (!n) {
      if (Array.isArray(a)) {
        if (!a.length)
          return;
        var o = a, [c, ...l] = o;
        if (typeof c == "number") {
          i = r.setTimeout(s.bind(null, l), c);
          return;
        }
        s(c), i = r.setTimeout(s.bind(null, l));
        return;
      }
      typeof a == "object" && (e = a, t(e)), typeof a == "function" && a();
    }
  };
  return {
    stop: () => {
      n = !0;
    },
    start: (a) => {
      n = !1, i && (i(), i = null), s(a);
    },
    subscribe: (a) => (t = a, () => {
      t = () => null;
    }),
    getTimeoutController: () => r
  };
}
var No = 1e-4, vE = (r, e) => [0, 3 * r, 3 * e - 6 * r, 3 * r - 3 * e + 1], yE = (r, e) => r.map((t, n) => t * e ** n).reduce((t, n) => t + n), dv = (r, e) => (t) => {
  var n = vE(r, e);
  return yE(n, t);
}, $O = (r, e) => (t) => {
  var n = vE(r, e), i = [...n.map((s, a) => s * a).slice(1), 0];
  return yE(i, t);
}, fv = function() {
  for (var e, t, n, i, s = arguments.length, a = new Array(s), o = 0; o < s; o++)
    a[o] = arguments[o];
  if (a.length === 1)
    switch (a[0]) {
      case "linear":
        [e, n, t, i] = [0, 0, 1, 1];
        break;
      case "ease":
        [e, n, t, i] = [0.25, 0.1, 0.25, 1];
        break;
      case "ease-in":
        [e, n, t, i] = [0.42, 0, 1, 1];
        break;
      case "ease-out":
        [e, n, t, i] = [0.42, 0, 0.58, 1];
        break;
      case "ease-in-out":
        [e, n, t, i] = [0, 0, 0.58, 1];
        break;
      default: {
        var c = a[0].split("(");
        c[0] === "cubic-bezier" && c[1].split(")")[0].split(",").length === 4 && ([e, n, t, i] = c[1].split(")")[0].split(",").map((g) => parseFloat(g)));
      }
    }
  else a.length === 4 && ([e, n, t, i] = a);
  var l = dv(e, t), u = dv(n, i), d = $O(e, t), f = (g) => g > 1 ? 1 : g < 0 ? 0 : g, h = (g) => {
    for (var m = g > 1 ? 1 : g, p = m, v = 0; v < 8; ++v) {
      var y = l(p) - m, b = d(p);
      if (Math.abs(y - m) < No || b < No)
        return u(p);
      p = f(p - y / b);
    }
    return u(p);
  };
  return h.isStepper = !1, h;
}, BO = function() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, {
    stiff: t = 100,
    damping: n = 8,
    dt: i = 17
  } = e, s = (a, o, c) => {
    var l = -(a - o) * t, u = c * n, d = c + (l - u) * i / 1e3, f = c * i / 1e3 + a;
    return Math.abs(f - o) < No && Math.abs(d) < No ? [o, 0] : [f, d];
  };
  return s.isStepper = !0, s.dt = i, s;
}, jO = (r) => {
  if (typeof r == "string")
    switch (r) {
      case "ease":
      case "ease-in-out":
      case "ease-out":
      case "ease-in":
      case "linear":
        return fv(r);
      case "spring":
        return BO();
      default:
        if (r.split("(")[0] === "cubic-bezier")
          return fv(r);
    }
  return typeof r == "function" ? r : null;
};
function hv(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function gv(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? hv(Object(t), !0).forEach(function(n) {
      UO(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : hv(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function UO(r, e, t) {
  return (e = GO(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function GO(r) {
  var e = KO(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function KO(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
var VO = (r) => r.replace(/([A-Z])/g, (e) => "-".concat(e.toLowerCase())), WO = (r, e, t) => r.map((n) => "".concat(VO(n), " ").concat(e, "ms ").concat(t)).join(","), HO = (r, e) => [Object.keys(r), Object.keys(e)].reduce((t, n) => t.filter((i) => n.includes(i))), Vs = (r, e) => Object.keys(e).reduce((t, n) => gv(gv({}, t), {}, {
  [n]: r(n, e[n])
}), {});
function mv(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function xt(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? mv(Object(t), !0).forEach(function(n) {
      qO(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : mv(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function qO(r, e, t) {
  return (e = zO(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function zO(r) {
  var e = YO(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function YO(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
var Fo = (r, e, t) => r + (e - r) * t, Fd = (r) => {
  var {
    from: e,
    to: t
  } = r;
  return e !== t;
}, bE = (r, e, t) => {
  var n = Vs((i, s) => {
    if (Fd(s)) {
      var [a, o] = r(s.from, s.to, s.velocity);
      return xt(xt({}, s), {}, {
        from: a,
        velocity: o
      });
    }
    return s;
  }, e);
  return t < 1 ? Vs((i, s) => Fd(s) ? xt(xt({}, s), {}, {
    velocity: Fo(s.velocity, n[i].velocity, t),
    from: Fo(s.from, n[i].from, t)
  }) : s, e) : bE(r, n, t - 1);
};
function XO(r, e, t, n, i, s) {
  var a, o = n.reduce((f, h) => xt(xt({}, f), {}, {
    [h]: {
      from: r[h],
      velocity: 0,
      to: e[h]
    }
  }), {}), c = () => Vs((f, h) => h.from, o), l = () => !Object.values(o).filter(Fd).length, u = null, d = (f) => {
    a || (a = f);
    var h = f - a, g = h / t.dt;
    o = bE(t, o, g), i(xt(xt(xt({}, r), e), c())), a = f, l() || (u = s.setTimeout(d));
  };
  return () => (u = s.setTimeout(d), () => {
    u();
  });
}
function QO(r, e, t, n, i, s, a) {
  var o = null, c = i.reduce((d, f) => xt(xt({}, d), {}, {
    [f]: [r[f], e[f]]
  }), {}), l, u = (d) => {
    l || (l = d);
    var f = (d - l) / n, h = Vs((m, p) => Fo(...p, t(f)), c);
    if (s(xt(xt(xt({}, r), e), h)), f < 1)
      o = a.setTimeout(u);
    else {
      var g = Vs((m, p) => Fo(...p, t(1)), c);
      s(xt(xt(xt({}, r), e), g));
    }
  };
  return () => (o = a.setTimeout(u), () => {
    o();
  });
}
const ZO = (r, e, t, n, i, s) => {
  var a = HO(r, e);
  return t.isStepper === !0 ? XO(r, e, t, a, i, s) : QO(r, e, t, n, a, i, s);
};
class JO {
  setTimeout(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = performance.now(), i = null, s = (a) => {
      a - n >= t ? e(a) : typeof requestAnimationFrame == "function" && (i = requestAnimationFrame(s));
    };
    return i = requestAnimationFrame(s), () => {
      cancelAnimationFrame(i);
    };
  }
}
var eR = ["children", "begin", "duration", "attributeName", "easing", "isActive", "from", "to", "canBegin", "onAnimationEnd", "shouldReAnimate", "onAnimationReStart", "animationManager"];
function $d() {
  return $d = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t) ({}).hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, $d.apply(null, arguments);
}
function tR(r, e) {
  if (r == null) return {};
  var t, n, i = rR(r, e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(r);
    for (n = 0; n < s.length; n++) t = s[n], e.indexOf(t) === -1 && {}.propertyIsEnumerable.call(r, t) && (i[t] = r[t]);
  }
  return i;
}
function rR(r, e) {
  if (r == null) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.indexOf(n) !== -1) continue;
    t[n] = r[n];
  }
  return t;
}
function pv(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function Tn(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? pv(Object(t), !0).forEach(function(n) {
      Zn(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : pv(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function Zn(r, e, t) {
  return (e = nR(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function nR(r) {
  var e = iR(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function iR(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function sR() {
  return FO(new JO());
}
class hh extends Kr {
  constructor(e, t) {
    super(e, t), Zn(this, "mounted", !1), Zn(this, "manager", null), Zn(this, "stopJSAnimation", null), Zn(this, "unSubscribe", null);
    var {
      isActive: n,
      attributeName: i,
      from: s,
      to: a,
      children: o,
      duration: c,
      animationManager: l
    } = this.props;
    if (this.manager = l, this.handleStyleChange = this.handleStyleChange.bind(this), this.changeStyle = this.changeStyle.bind(this), !n || c <= 0) {
      this.state = {
        style: {}
      }, typeof o == "function" && (this.state = {
        style: a
      });
      return;
    }
    if (s) {
      if (typeof o == "function") {
        this.state = {
          style: s
        };
        return;
      }
      this.state = {
        style: i ? {
          [i]: s
        } : s
      };
    } else
      this.state = {
        style: {}
      };
  }
  componentDidMount() {
    var {
      isActive: e,
      canBegin: t
    } = this.props;
    this.mounted = !0, !(!e || !t) && this.runAnimation(this.props);
  }
  componentDidUpdate(e) {
    var {
      isActive: t,
      canBegin: n,
      attributeName: i,
      shouldReAnimate: s,
      to: a,
      from: o
    } = this.props, {
      style: c
    } = this.state;
    if (n) {
      if (!t) {
        var l = {
          style: i ? {
            [i]: a
          } : a
        };
        this.state && c && (i && c[i] !== a || !i && c !== a) && this.setState(l);
        return;
      }
      if (!(NO(e.to, a) && e.canBegin && e.isActive)) {
        var u = !e.canBegin || !e.isActive;
        this.manager.stop(), this.stopJSAnimation && this.stopJSAnimation();
        var d = u || s ? o : e.to;
        if (this.state && c) {
          var f = {
            style: i ? {
              [i]: d
            } : d
          };
          (i && c[i] !== d || !i && c !== d) && this.setState(f);
        }
        this.runAnimation(Tn(Tn({}, this.props), {}, {
          from: d,
          begin: 0
        }));
      }
    }
  }
  componentWillUnmount() {
    this.mounted = !1;
    var {
      onAnimationEnd: e
    } = this.props;
    this.unSubscribe && this.unSubscribe(), this.manager.stop(), this.stopJSAnimation && this.stopJSAnimation(), e && e();
  }
  handleStyleChange(e) {
    this.changeStyle(e);
  }
  changeStyle(e) {
    this.mounted && this.setState({
      style: e
    });
  }
  runJSAnimation(e) {
    var {
      from: t,
      to: n,
      duration: i,
      easing: s,
      begin: a,
      onAnimationEnd: o,
      onAnimationStart: c
    } = e, l = ZO(t, n, jO(s), i, this.changeStyle, this.manager.getTimeoutController()), u = () => {
      this.stopJSAnimation = l();
    };
    this.manager.start([c, a, u, i, o]);
  }
  runAnimation(e) {
    var {
      begin: t,
      duration: n,
      attributeName: i,
      to: s,
      easing: a,
      onAnimationStart: o,
      onAnimationEnd: c,
      children: l
    } = e;
    if (this.unSubscribe = this.manager.subscribe(this.handleStyleChange), typeof a == "function" || typeof l == "function" || a === "spring") {
      this.runJSAnimation(e);
      return;
    }
    var u = i ? {
      [i]: s
    } : s, d = WO(Object.keys(u), n, a);
    this.manager.start([o, t, Tn(Tn({}, u), {}, {
      transition: d
    }), n, c]);
  }
  render() {
    var e = this.props, {
      children: t,
      begin: n,
      duration: i,
      attributeName: s,
      easing: a,
      isActive: o,
      from: c,
      to: l,
      canBegin: u,
      onAnimationEnd: d,
      shouldReAnimate: f,
      onAnimationReStart: h,
      animationManager: g
    } = e, m = tR(e, eR), p = go.count(t), v = this.state.style;
    if (typeof t == "function")
      return t(v);
    if (!o || p === 0 || i <= 0)
      return t;
    var y = (b) => {
      var {
        style: x = {},
        className: S
      } = b.props, A = /* @__PURE__ */ fn(b, Tn(Tn({}, m), {}, {
        style: Tn(Tn({}, x), v),
        className: S
      }));
      return A;
    };
    return p === 1 ? y(go.only(t)) : /* @__PURE__ */ w.createElement("div", null, go.map(t, (b) => y(b)));
  }
}
Zn(hh, "displayName", "Animate");
Zn(hh, "defaultProps", {
  begin: 0,
  duration: 1e3,
  attributeName: "",
  easing: "ease",
  isActive: !0,
  canBegin: !0,
  onAnimationEnd: () => {
  },
  onAnimationStart: () => {
  }
});
var aR = /* @__PURE__ */ dn(null);
function jr(r) {
  var e, t, n = un(aR);
  return /* @__PURE__ */ w.createElement(hh, $d({}, r, {
    animationManager: (e = (t = r.animationManager) !== null && t !== void 0 ? t : n) !== null && e !== void 0 ? e : sR()
  }));
}
function $o() {
  return $o = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t) ({}).hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, $o.apply(null, arguments);
}
var vv = (r, e, t, n, i) => {
  var s = Math.min(Math.abs(t) / 2, Math.abs(n) / 2), a = n >= 0 ? 1 : -1, o = t >= 0 ? 1 : -1, c = n >= 0 && t >= 0 || n < 0 && t < 0 ? 1 : 0, l;
  if (s > 0 && i instanceof Array) {
    for (var u = [0, 0, 0, 0], d = 0, f = 4; d < f; d++)
      u[d] = i[d] > s ? s : i[d];
    l = "M".concat(r, ",").concat(e + a * u[0]), u[0] > 0 && (l += "A ".concat(u[0], ",").concat(u[0], ",0,0,").concat(c, ",").concat(r + o * u[0], ",").concat(e)), l += "L ".concat(r + t - o * u[1], ",").concat(e), u[1] > 0 && (l += "A ".concat(u[1], ",").concat(u[1], ",0,0,").concat(c, `,
        `).concat(r + t, ",").concat(e + a * u[1])), l += "L ".concat(r + t, ",").concat(e + n - a * u[2]), u[2] > 0 && (l += "A ".concat(u[2], ",").concat(u[2], ",0,0,").concat(c, `,
        `).concat(r + t - o * u[2], ",").concat(e + n)), l += "L ".concat(r + o * u[3], ",").concat(e + n), u[3] > 0 && (l += "A ".concat(u[3], ",").concat(u[3], ",0,0,").concat(c, `,
        `).concat(r, ",").concat(e + n - a * u[3])), l += "Z";
  } else if (s > 0 && i === +i && i > 0) {
    var h = Math.min(s, i);
    l = "M ".concat(r, ",").concat(e + a * h, `
            A `).concat(h, ",").concat(h, ",0,0,").concat(c, ",").concat(r + o * h, ",").concat(e, `
            L `).concat(r + t - o * h, ",").concat(e, `
            A `).concat(h, ",").concat(h, ",0,0,").concat(c, ",").concat(r + t, ",").concat(e + a * h, `
            L `).concat(r + t, ",").concat(e + n - a * h, `
            A `).concat(h, ",").concat(h, ",0,0,").concat(c, ",").concat(r + t - o * h, ",").concat(e + n, `
            L `).concat(r + o * h, ",").concat(e + n, `
            A `).concat(h, ",").concat(h, ",0,0,").concat(c, ",").concat(r, ",").concat(e + n - a * h, " Z");
  } else
    l = "M ".concat(r, ",").concat(e, " h ").concat(t, " v ").concat(n, " h ").concat(-t, " Z");
  return l;
}, oR = {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  // The radius of border
  // The radius of four corners when radius is a number
  // The radius of left-top, right-top, right-bottom, left-bottom when radius is an array
  radius: 0,
  isAnimationActive: !1,
  isUpdateAnimationActive: !1,
  animationBegin: 0,
  animationDuration: 1500,
  animationEasing: "ease"
}, xE = (r) => {
  var e = Vt(r, oR), t = Ke(null), [n, i] = _e(-1);
  we(() => {
    if (t.current && t.current.getTotalLength)
      try {
        var v = t.current.getTotalLength();
        v && i(v);
      } catch {
      }
  }, []);
  var {
    x: s,
    y: a,
    width: o,
    height: c,
    radius: l,
    className: u
  } = e, {
    animationEasing: d,
    animationDuration: f,
    animationBegin: h,
    isAnimationActive: g,
    isUpdateAnimationActive: m
  } = e;
  if (s !== +s || a !== +a || o !== +o || c !== +c || o === 0 || c === 0)
    return null;
  var p = ve("recharts-rectangle", u);
  return m ? /* @__PURE__ */ w.createElement(jr, {
    canBegin: n > 0,
    from: {
      width: o,
      height: c,
      x: s,
      y: a
    },
    to: {
      width: o,
      height: c,
      x: s,
      y: a
    },
    duration: f,
    animationEasing: d,
    isActive: m
  }, (v) => {
    var {
      width: y,
      height: b,
      x,
      y: S
    } = v;
    return /* @__PURE__ */ w.createElement(jr, {
      canBegin: n > 0,
      from: "0px ".concat(n === -1 ? 1 : n, "px"),
      to: "".concat(n, "px 0px"),
      attributeName: "strokeDasharray",
      begin: h,
      duration: f,
      isActive: g,
      easing: d
    }, /* @__PURE__ */ w.createElement("path", $o({}, de(e, !0), {
      className: p,
      d: vv(x, S, y, b, l),
      ref: t
    })));
  }) : /* @__PURE__ */ w.createElement("path", $o({}, de(e, !0), {
    className: p,
    d: vv(s, a, o, c, l)
  }));
};
function EE(r) {
  var {
    cx: e,
    cy: t,
    radius: n,
    startAngle: i,
    endAngle: s
  } = r, a = st(e, t, n, i), o = st(e, t, n, s);
  return {
    points: [a, o],
    cx: e,
    cy: t,
    radius: n,
    startAngle: i,
    endAngle: s
  };
}
function Bd() {
  return Bd = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t) ({}).hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, Bd.apply(null, arguments);
}
var lR = (r, e) => {
  var t = pt(e - r), n = Math.min(Math.abs(e - r), 359.999);
  return t * n;
}, Wa = (r) => {
  var {
    cx: e,
    cy: t,
    radius: n,
    angle: i,
    sign: s,
    isExternal: a,
    cornerRadius: o,
    cornerIsExternal: c
  } = r, l = o * (a ? 1 : -1) + n, u = Math.asin(o / l) / Mo, d = c ? i : i + s * u, f = st(e, t, l, d), h = st(e, t, n, d), g = c ? i - s * u : i, m = st(e, t, l * Math.cos(u * Mo), g);
  return {
    center: f,
    circleTangency: h,
    lineTangency: m,
    theta: u
  };
}, SE = (r) => {
  var {
    cx: e,
    cy: t,
    innerRadius: n,
    outerRadius: i,
    startAngle: s,
    endAngle: a
  } = r, o = lR(s, a), c = s + o, l = st(e, t, i, s), u = st(e, t, i, c), d = "M ".concat(l.x, ",").concat(l.y, `
    A `).concat(i, ",").concat(i, `,0,
    `).concat(+(Math.abs(o) > 180), ",").concat(+(s > c), `,
    `).concat(u.x, ",").concat(u.y, `
  `);
  if (n > 0) {
    var f = st(e, t, n, s), h = st(e, t, n, c);
    d += "L ".concat(h.x, ",").concat(h.y, `
            A `).concat(n, ",").concat(n, `,0,
            `).concat(+(Math.abs(o) > 180), ",").concat(+(s <= c), `,
            `).concat(f.x, ",").concat(f.y, " Z");
  } else
    d += "L ".concat(e, ",").concat(t, " Z");
  return d;
}, cR = (r) => {
  var {
    cx: e,
    cy: t,
    innerRadius: n,
    outerRadius: i,
    cornerRadius: s,
    forceCornerRadius: a,
    cornerIsExternal: o,
    startAngle: c,
    endAngle: l
  } = r, u = pt(l - c), {
    circleTangency: d,
    lineTangency: f,
    theta: h
  } = Wa({
    cx: e,
    cy: t,
    radius: i,
    angle: c,
    sign: u,
    cornerRadius: s,
    cornerIsExternal: o
  }), {
    circleTangency: g,
    lineTangency: m,
    theta: p
  } = Wa({
    cx: e,
    cy: t,
    radius: i,
    angle: l,
    sign: -u,
    cornerRadius: s,
    cornerIsExternal: o
  }), v = o ? Math.abs(c - l) : Math.abs(c - l) - h - p;
  if (v < 0)
    return a ? "M ".concat(f.x, ",").concat(f.y, `
        a`).concat(s, ",").concat(s, ",0,0,1,").concat(s * 2, `,0
        a`).concat(s, ",").concat(s, ",0,0,1,").concat(-s * 2, `,0
      `) : SE({
      cx: e,
      cy: t,
      innerRadius: n,
      outerRadius: i,
      startAngle: c,
      endAngle: l
    });
  var y = "M ".concat(f.x, ",").concat(f.y, `
    A`).concat(s, ",").concat(s, ",0,0,").concat(+(u < 0), ",").concat(d.x, ",").concat(d.y, `
    A`).concat(i, ",").concat(i, ",0,").concat(+(v > 180), ",").concat(+(u < 0), ",").concat(g.x, ",").concat(g.y, `
    A`).concat(s, ",").concat(s, ",0,0,").concat(+(u < 0), ",").concat(m.x, ",").concat(m.y, `
  `);
  if (n > 0) {
    var {
      circleTangency: b,
      lineTangency: x,
      theta: S
    } = Wa({
      cx: e,
      cy: t,
      radius: n,
      angle: c,
      sign: u,
      isExternal: !0,
      cornerRadius: s,
      cornerIsExternal: o
    }), {
      circleTangency: A,
      lineTangency: T,
      theta: I
    } = Wa({
      cx: e,
      cy: t,
      radius: n,
      angle: l,
      sign: -u,
      isExternal: !0,
      cornerRadius: s,
      cornerIsExternal: o
    }), L = o ? Math.abs(c - l) : Math.abs(c - l) - S - I;
    if (L < 0 && s === 0)
      return "".concat(y, "L").concat(e, ",").concat(t, "Z");
    y += "L".concat(T.x, ",").concat(T.y, `
      A`).concat(s, ",").concat(s, ",0,0,").concat(+(u < 0), ",").concat(A.x, ",").concat(A.y, `
      A`).concat(n, ",").concat(n, ",0,").concat(+(L > 180), ",").concat(+(u > 0), ",").concat(b.x, ",").concat(b.y, `
      A`).concat(s, ",").concat(s, ",0,0,").concat(+(u < 0), ",").concat(x.x, ",").concat(x.y, "Z");
  } else
    y += "L".concat(e, ",").concat(t, "Z");
  return y;
}, uR = {
  cx: 0,
  cy: 0,
  innerRadius: 0,
  outerRadius: 0,
  startAngle: 0,
  endAngle: 0,
  cornerRadius: 0,
  forceCornerRadius: !1,
  cornerIsExternal: !1
}, TE = (r) => {
  var e = Vt(r, uR), {
    cx: t,
    cy: n,
    innerRadius: i,
    outerRadius: s,
    cornerRadius: a,
    forceCornerRadius: o,
    cornerIsExternal: c,
    startAngle: l,
    endAngle: u,
    className: d
  } = e;
  if (s < i || l === u)
    return null;
  var f = ve("recharts-sector", d), h = s - i, g = Dt(a, h, 0, !0), m;
  return g > 0 && Math.abs(l - u) < 360 ? m = cR({
    cx: t,
    cy: n,
    innerRadius: i,
    outerRadius: s,
    cornerRadius: Math.min(g, h / 2),
    forceCornerRadius: o,
    cornerIsExternal: c,
    startAngle: l,
    endAngle: u
  }) : m = SE({
    cx: t,
    cy: n,
    innerRadius: i,
    outerRadius: s,
    startAngle: l,
    endAngle: u
  }), /* @__PURE__ */ w.createElement("path", Bd({}, de(e, !0), {
    className: f,
    d: m
  }));
};
function dR(r, e, t) {
  var n, i, s, a;
  if (r === "horizontal")
    n = e.x, s = n, i = t.top, a = t.top + t.height;
  else if (r === "vertical")
    i = e.y, a = i, n = t.left, s = t.left + t.width;
  else if (e.cx != null && e.cy != null)
    if (r === "centric") {
      var {
        cx: o,
        cy: c,
        innerRadius: l,
        outerRadius: u,
        angle: d
      } = e, f = st(o, c, l, d), h = st(o, c, u, d);
      n = f.x, i = f.y, s = h.x, a = h.y;
    } else
      return EE(e);
  return [{
    x: n,
    y: i
  }, {
    x: s,
    y: a
  }];
}
var vu = {}, yu = {}, bu = {}, yv;
function fR() {
  return yv || (yv = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    const e = /* @__PURE__ */ Lx();
    function t(n) {
      return e.isSymbol(n) ? NaN : Number(n);
    }
    r.toNumber = t;
  }(bu)), bu;
}
var bv;
function hR() {
  return bv || (bv = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    const e = /* @__PURE__ */ fR();
    function t(n) {
      return n ? (n = e.toNumber(n), n === 1 / 0 || n === -1 / 0 ? (n < 0 ? -1 : 1) * Number.MAX_VALUE : n === n ? n : 0) : n === 0 ? n : 0;
    }
    r.toFinite = t;
  }(yu)), yu;
}
var xv;
function gR() {
  return xv || (xv = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    const e = /* @__PURE__ */ Ox(), t = /* @__PURE__ */ hR();
    function n(i, s, a) {
      a && typeof a != "number" && e.isIterateeCall(i, s, a) && (s = a = void 0), i = t.toFinite(i), s === void 0 ? (s = i, i = 0) : s = t.toFinite(s), a = a === void 0 ? i < s ? 1 : -1 : t.toFinite(a);
      const o = Math.max(Math.ceil((s - i) / (a || 1)), 0), c = new Array(o);
      for (let l = 0; l < o; l++)
        c[l] = i, i += a;
      return c;
    }
    r.range = n;
  }(vu)), vu;
}
var xu, Ev;
function mR() {
  return Ev || (Ev = 1, xu = gR().range), xu;
}
var pR = /* @__PURE__ */ mR();
const AE = /* @__PURE__ */ hn(pR);
function Cn(r, e) {
  return r == null || e == null ? NaN : r < e ? -1 : r > e ? 1 : r >= e ? 0 : NaN;
}
function vR(r, e) {
  return r == null || e == null ? NaN : e < r ? -1 : e > r ? 1 : e >= r ? 0 : NaN;
}
function gh(r) {
  let e, t, n;
  r.length !== 2 ? (e = Cn, t = (o, c) => Cn(r(o), c), n = (o, c) => r(o) - c) : (e = r === Cn || r === vR ? r : yR, t = r, n = r);
  function i(o, c, l = 0, u = o.length) {
    if (l < u) {
      if (e(c, c) !== 0) return u;
      do {
        const d = l + u >>> 1;
        t(o[d], c) < 0 ? l = d + 1 : u = d;
      } while (l < u);
    }
    return l;
  }
  function s(o, c, l = 0, u = o.length) {
    if (l < u) {
      if (e(c, c) !== 0) return u;
      do {
        const d = l + u >>> 1;
        t(o[d], c) <= 0 ? l = d + 1 : u = d;
      } while (l < u);
    }
    return l;
  }
  function a(o, c, l = 0, u = o.length) {
    const d = i(o, c, l, u - 1);
    return d > l && n(o[d - 1], c) > -n(o[d], c) ? d - 1 : d;
  }
  return { left: i, center: a, right: s };
}
function yR() {
  return 0;
}
function wE(r) {
  return r === null ? NaN : +r;
}
function* bR(r, e) {
  for (let t of r)
    t != null && (t = +t) >= t && (yield t);
}
const xR = gh(Cn), ha = xR.right;
gh(wE).center;
class Sv extends Map {
  constructor(e, t = TR) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: t } }), e != null) for (const [n, i] of e) this.set(n, i);
  }
  get(e) {
    return super.get(Tv(this, e));
  }
  has(e) {
    return super.has(Tv(this, e));
  }
  set(e, t) {
    return super.set(ER(this, e), t);
  }
  delete(e) {
    return super.delete(SR(this, e));
  }
}
function Tv({ _intern: r, _key: e }, t) {
  const n = e(t);
  return r.has(n) ? r.get(n) : t;
}
function ER({ _intern: r, _key: e }, t) {
  const n = e(t);
  return r.has(n) ? r.get(n) : (r.set(n, t), t);
}
function SR({ _intern: r, _key: e }, t) {
  const n = e(t);
  return r.has(n) && (t = r.get(n), r.delete(n)), t;
}
function TR(r) {
  return r !== null && typeof r == "object" ? r.valueOf() : r;
}
function AR(r = Cn) {
  if (r === Cn) return IE;
  if (typeof r != "function") throw new TypeError("compare is not a function");
  return (e, t) => {
    const n = r(e, t);
    return n || n === 0 ? n : (r(t, t) === 0) - (r(e, e) === 0);
  };
}
function IE(r, e) {
  return (r == null || !(r >= r)) - (e == null || !(e >= e)) || (r < e ? -1 : r > e ? 1 : 0);
}
const wR = Math.sqrt(50), IR = Math.sqrt(10), PR = Math.sqrt(2);
function Bo(r, e, t) {
  const n = (e - r) / Math.max(0, t), i = Math.floor(Math.log10(n)), s = n / Math.pow(10, i), a = s >= wR ? 10 : s >= IR ? 5 : s >= PR ? 2 : 1;
  let o, c, l;
  return i < 0 ? (l = Math.pow(10, -i) / a, o = Math.round(r * l), c = Math.round(e * l), o / l < r && ++o, c / l > e && --c, l = -l) : (l = Math.pow(10, i) * a, o = Math.round(r / l), c = Math.round(e / l), o * l < r && ++o, c * l > e && --c), c < o && 0.5 <= t && t < 2 ? Bo(r, e, t * 2) : [o, c, l];
}
function jd(r, e, t) {
  if (e = +e, r = +r, t = +t, !(t > 0)) return [];
  if (r === e) return [r];
  const n = e < r, [i, s, a] = n ? Bo(e, r, t) : Bo(r, e, t);
  if (!(s >= i)) return [];
  const o = s - i + 1, c = new Array(o);
  if (n)
    if (a < 0) for (let l = 0; l < o; ++l) c[l] = (s - l) / -a;
    else for (let l = 0; l < o; ++l) c[l] = (s - l) * a;
  else if (a < 0) for (let l = 0; l < o; ++l) c[l] = (i + l) / -a;
  else for (let l = 0; l < o; ++l) c[l] = (i + l) * a;
  return c;
}
function Ud(r, e, t) {
  return e = +e, r = +r, t = +t, Bo(r, e, t)[2];
}
function Gd(r, e, t) {
  e = +e, r = +r, t = +t;
  const n = e < r, i = n ? Ud(e, r, t) : Ud(r, e, t);
  return (n ? -1 : 1) * (i < 0 ? 1 / -i : i);
}
function Av(r, e) {
  let t;
  for (const n of r)
    n != null && (t < n || t === void 0 && n >= n) && (t = n);
  return t;
}
function wv(r, e) {
  let t;
  for (const n of r)
    n != null && (t > n || t === void 0 && n >= n) && (t = n);
  return t;
}
function PE(r, e, t = 0, n = 1 / 0, i) {
  if (e = Math.floor(e), t = Math.floor(Math.max(0, t)), n = Math.floor(Math.min(r.length - 1, n)), !(t <= e && e <= n)) return r;
  for (i = i === void 0 ? IE : AR(i); n > t; ) {
    if (n - t > 600) {
      const c = n - t + 1, l = e - t + 1, u = Math.log(c), d = 0.5 * Math.exp(2 * u / 3), f = 0.5 * Math.sqrt(u * d * (c - d) / c) * (l - c / 2 < 0 ? -1 : 1), h = Math.max(t, Math.floor(e - l * d / c + f)), g = Math.min(n, Math.floor(e + (c - l) * d / c + f));
      PE(r, e, h, g, i);
    }
    const s = r[e];
    let a = t, o = n;
    for (As(r, t, e), i(r[n], s) > 0 && As(r, t, n); a < o; ) {
      for (As(r, a, o), ++a, --o; i(r[a], s) < 0; ) ++a;
      for (; i(r[o], s) > 0; ) --o;
    }
    i(r[t], s) === 0 ? As(r, t, o) : (++o, As(r, o, n)), o <= e && (t = o + 1), e <= o && (n = o - 1);
  }
  return r;
}
function As(r, e, t) {
  const n = r[e];
  r[e] = r[t], r[t] = n;
}
function _R(r, e, t) {
  if (r = Float64Array.from(bR(r)), !(!(n = r.length) || isNaN(e = +e))) {
    if (e <= 0 || n < 2) return wv(r);
    if (e >= 1) return Av(r);
    var n, i = (n - 1) * e, s = Math.floor(i), a = Av(PE(r, s).subarray(0, s + 1)), o = wv(r.subarray(s + 1));
    return a + (o - a) * (i - s);
  }
}
function LR(r, e, t = wE) {
  if (!(!(n = r.length) || isNaN(e = +e))) {
    if (e <= 0 || n < 2) return +t(r[0], 0, r);
    if (e >= 1) return +t(r[n - 1], n - 1, r);
    var n, i = (n - 1) * e, s = Math.floor(i), a = +t(r[s], s, r), o = +t(r[s + 1], s + 1, r);
    return a + (o - a) * (i - s);
  }
}
function OR(r, e, t) {
  r = +r, e = +e, t = (i = arguments.length) < 2 ? (e = r, r = 0, 1) : i < 3 ? 1 : +t;
  for (var n = -1, i = Math.max(0, Math.ceil((e - r) / t)) | 0, s = new Array(i); ++n < i; )
    s[n] = r + n * t;
  return s;
}
function Er(r, e) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(r);
      break;
    default:
      this.range(e).domain(r);
      break;
  }
  return this;
}
function vn(r, e) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      typeof r == "function" ? this.interpolator(r) : this.range(r);
      break;
    }
    default: {
      this.domain(r), typeof e == "function" ? this.interpolator(e) : this.range(e);
      break;
    }
  }
  return this;
}
const Kd = Symbol("implicit");
function mh() {
  var r = new Sv(), e = [], t = [], n = Kd;
  function i(s) {
    let a = r.get(s);
    if (a === void 0) {
      if (n !== Kd) return n;
      r.set(s, a = e.push(s) - 1);
    }
    return t[a % t.length];
  }
  return i.domain = function(s) {
    if (!arguments.length) return e.slice();
    e = [], r = new Sv();
    for (const a of s)
      r.has(a) || r.set(a, e.push(a) - 1);
    return i;
  }, i.range = function(s) {
    return arguments.length ? (t = Array.from(s), i) : t.slice();
  }, i.unknown = function(s) {
    return arguments.length ? (n = s, i) : n;
  }, i.copy = function() {
    return mh(e, t).unknown(n);
  }, Er.apply(i, arguments), i;
}
function ph() {
  var r = mh().unknown(void 0), e = r.domain, t = r.range, n = 0, i = 1, s, a, o = !1, c = 0, l = 0, u = 0.5;
  delete r.unknown;
  function d() {
    var f = e().length, h = i < n, g = h ? i : n, m = h ? n : i;
    s = (m - g) / Math.max(1, f - c + l * 2), o && (s = Math.floor(s)), g += (m - g - s * (f - c)) * u, a = s * (1 - c), o && (g = Math.round(g), a = Math.round(a));
    var p = OR(f).map(function(v) {
      return g + s * v;
    });
    return t(h ? p.reverse() : p);
  }
  return r.domain = function(f) {
    return arguments.length ? (e(f), d()) : e();
  }, r.range = function(f) {
    return arguments.length ? ([n, i] = f, n = +n, i = +i, d()) : [n, i];
  }, r.rangeRound = function(f) {
    return [n, i] = f, n = +n, i = +i, o = !0, d();
  }, r.bandwidth = function() {
    return a;
  }, r.step = function() {
    return s;
  }, r.round = function(f) {
    return arguments.length ? (o = !!f, d()) : o;
  }, r.padding = function(f) {
    return arguments.length ? (c = Math.min(1, l = +f), d()) : c;
  }, r.paddingInner = function(f) {
    return arguments.length ? (c = Math.min(1, f), d()) : c;
  }, r.paddingOuter = function(f) {
    return arguments.length ? (l = +f, d()) : l;
  }, r.align = function(f) {
    return arguments.length ? (u = Math.max(0, Math.min(1, f)), d()) : u;
  }, r.copy = function() {
    return ph(e(), [n, i]).round(o).paddingInner(c).paddingOuter(l).align(u);
  }, Er.apply(d(), arguments);
}
function _E(r) {
  var e = r.copy;
  return r.padding = r.paddingOuter, delete r.paddingInner, delete r.paddingOuter, r.copy = function() {
    return _E(e());
  }, r;
}
function RR() {
  return _E(ph.apply(null, arguments).paddingInner(1));
}
function vh(r, e, t) {
  r.prototype = e.prototype = t, t.constructor = r;
}
function LE(r, e) {
  var t = Object.create(r.prototype);
  for (var n in e) t[n] = e[n];
  return t;
}
function ga() {
}
var Ws = 0.7, jo = 1 / Ws, $i = "\\s*([+-]?\\d+)\\s*", Hs = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", Fr = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", DR = /^#([0-9a-f]{3,8})$/, CR = new RegExp(`^rgb\\(${$i},${$i},${$i}\\)$`), kR = new RegExp(`^rgb\\(${Fr},${Fr},${Fr}\\)$`), MR = new RegExp(`^rgba\\(${$i},${$i},${$i},${Hs}\\)$`), NR = new RegExp(`^rgba\\(${Fr},${Fr},${Fr},${Hs}\\)$`), FR = new RegExp(`^hsl\\(${Hs},${Fr},${Fr}\\)$`), $R = new RegExp(`^hsla\\(${Hs},${Fr},${Fr},${Hs}\\)$`), Iv = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
vh(ga, qs, {
  copy(r) {
    return Object.assign(new this.constructor(), this, r);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: Pv,
  // Deprecated! Use color.formatHex.
  formatHex: Pv,
  formatHex8: BR,
  formatHsl: jR,
  formatRgb: _v,
  toString: _v
});
function Pv() {
  return this.rgb().formatHex();
}
function BR() {
  return this.rgb().formatHex8();
}
function jR() {
  return OE(this).formatHsl();
}
function _v() {
  return this.rgb().formatRgb();
}
function qs(r) {
  var e, t;
  return r = (r + "").trim().toLowerCase(), (e = DR.exec(r)) ? (t = e[1].length, e = parseInt(e[1], 16), t === 6 ? Lv(e) : t === 3 ? new Bt(e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, (e & 15) << 4 | e & 15, 1) : t === 8 ? Ha(e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, (e & 255) / 255) : t === 4 ? Ha(e >> 12 & 15 | e >> 8 & 240, e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, ((e & 15) << 4 | e & 15) / 255) : null) : (e = CR.exec(r)) ? new Bt(e[1], e[2], e[3], 1) : (e = kR.exec(r)) ? new Bt(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, 1) : (e = MR.exec(r)) ? Ha(e[1], e[2], e[3], e[4]) : (e = NR.exec(r)) ? Ha(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, e[4]) : (e = FR.exec(r)) ? Dv(e[1], e[2] / 100, e[3] / 100, 1) : (e = $R.exec(r)) ? Dv(e[1], e[2] / 100, e[3] / 100, e[4]) : Iv.hasOwnProperty(r) ? Lv(Iv[r]) : r === "transparent" ? new Bt(NaN, NaN, NaN, 0) : null;
}
function Lv(r) {
  return new Bt(r >> 16 & 255, r >> 8 & 255, r & 255, 1);
}
function Ha(r, e, t, n) {
  return n <= 0 && (r = e = t = NaN), new Bt(r, e, t, n);
}
function UR(r) {
  return r instanceof ga || (r = qs(r)), r ? (r = r.rgb(), new Bt(r.r, r.g, r.b, r.opacity)) : new Bt();
}
function Vd(r, e, t, n) {
  return arguments.length === 1 ? UR(r) : new Bt(r, e, t, n ?? 1);
}
function Bt(r, e, t, n) {
  this.r = +r, this.g = +e, this.b = +t, this.opacity = +n;
}
vh(Bt, Vd, LE(ga, {
  brighter(r) {
    return r = r == null ? jo : Math.pow(jo, r), new Bt(this.r * r, this.g * r, this.b * r, this.opacity);
  },
  darker(r) {
    return r = r == null ? Ws : Math.pow(Ws, r), new Bt(this.r * r, this.g * r, this.b * r, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Bt(oi(this.r), oi(this.g), oi(this.b), Uo(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: Ov,
  // Deprecated! Use color.formatHex.
  formatHex: Ov,
  formatHex8: GR,
  formatRgb: Rv,
  toString: Rv
}));
function Ov() {
  return `#${Jn(this.r)}${Jn(this.g)}${Jn(this.b)}`;
}
function GR() {
  return `#${Jn(this.r)}${Jn(this.g)}${Jn(this.b)}${Jn((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function Rv() {
  const r = Uo(this.opacity);
  return `${r === 1 ? "rgb(" : "rgba("}${oi(this.r)}, ${oi(this.g)}, ${oi(this.b)}${r === 1 ? ")" : `, ${r})`}`;
}
function Uo(r) {
  return isNaN(r) ? 1 : Math.max(0, Math.min(1, r));
}
function oi(r) {
  return Math.max(0, Math.min(255, Math.round(r) || 0));
}
function Jn(r) {
  return r = oi(r), (r < 16 ? "0" : "") + r.toString(16);
}
function Dv(r, e, t, n) {
  return n <= 0 ? r = e = t = NaN : t <= 0 || t >= 1 ? r = e = NaN : e <= 0 && (r = NaN), new Ir(r, e, t, n);
}
function OE(r) {
  if (r instanceof Ir) return new Ir(r.h, r.s, r.l, r.opacity);
  if (r instanceof ga || (r = qs(r)), !r) return new Ir();
  if (r instanceof Ir) return r;
  r = r.rgb();
  var e = r.r / 255, t = r.g / 255, n = r.b / 255, i = Math.min(e, t, n), s = Math.max(e, t, n), a = NaN, o = s - i, c = (s + i) / 2;
  return o ? (e === s ? a = (t - n) / o + (t < n) * 6 : t === s ? a = (n - e) / o + 2 : a = (e - t) / o + 4, o /= c < 0.5 ? s + i : 2 - s - i, a *= 60) : o = c > 0 && c < 1 ? 0 : a, new Ir(a, o, c, r.opacity);
}
function KR(r, e, t, n) {
  return arguments.length === 1 ? OE(r) : new Ir(r, e, t, n ?? 1);
}
function Ir(r, e, t, n) {
  this.h = +r, this.s = +e, this.l = +t, this.opacity = +n;
}
vh(Ir, KR, LE(ga, {
  brighter(r) {
    return r = r == null ? jo : Math.pow(jo, r), new Ir(this.h, this.s, this.l * r, this.opacity);
  },
  darker(r) {
    return r = r == null ? Ws : Math.pow(Ws, r), new Ir(this.h, this.s, this.l * r, this.opacity);
  },
  rgb() {
    var r = this.h % 360 + (this.h < 0) * 360, e = isNaN(r) || isNaN(this.s) ? 0 : this.s, t = this.l, n = t + (t < 0.5 ? t : 1 - t) * e, i = 2 * t - n;
    return new Bt(
      Eu(r >= 240 ? r - 240 : r + 120, i, n),
      Eu(r, i, n),
      Eu(r < 120 ? r + 240 : r - 120, i, n),
      this.opacity
    );
  },
  clamp() {
    return new Ir(Cv(this.h), qa(this.s), qa(this.l), Uo(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const r = Uo(this.opacity);
    return `${r === 1 ? "hsl(" : "hsla("}${Cv(this.h)}, ${qa(this.s) * 100}%, ${qa(this.l) * 100}%${r === 1 ? ")" : `, ${r})`}`;
  }
}));
function Cv(r) {
  return r = (r || 0) % 360, r < 0 ? r + 360 : r;
}
function qa(r) {
  return Math.max(0, Math.min(1, r || 0));
}
function Eu(r, e, t) {
  return (r < 60 ? e + (t - e) * r / 60 : r < 180 ? t : r < 240 ? e + (t - e) * (240 - r) / 60 : e) * 255;
}
const yh = (r) => () => r;
function VR(r, e) {
  return function(t) {
    return r + t * e;
  };
}
function WR(r, e, t) {
  return r = Math.pow(r, t), e = Math.pow(e, t) - r, t = 1 / t, function(n) {
    return Math.pow(r + n * e, t);
  };
}
function HR(r) {
  return (r = +r) == 1 ? RE : function(e, t) {
    return t - e ? WR(e, t, r) : yh(isNaN(e) ? t : e);
  };
}
function RE(r, e) {
  var t = e - r;
  return t ? VR(r, t) : yh(isNaN(r) ? e : r);
}
const kv = function r(e) {
  var t = HR(e);
  function n(i, s) {
    var a = t((i = Vd(i)).r, (s = Vd(s)).r), o = t(i.g, s.g), c = t(i.b, s.b), l = RE(i.opacity, s.opacity);
    return function(u) {
      return i.r = a(u), i.g = o(u), i.b = c(u), i.opacity = l(u), i + "";
    };
  }
  return n.gamma = r, n;
}(1);
function qR(r, e) {
  e || (e = []);
  var t = r ? Math.min(e.length, r.length) : 0, n = e.slice(), i;
  return function(s) {
    for (i = 0; i < t; ++i) n[i] = r[i] * (1 - s) + e[i] * s;
    return n;
  };
}
function zR(r) {
  return ArrayBuffer.isView(r) && !(r instanceof DataView);
}
function YR(r, e) {
  var t = e ? e.length : 0, n = r ? Math.min(t, r.length) : 0, i = new Array(n), s = new Array(t), a;
  for (a = 0; a < n; ++a) i[a] = ss(r[a], e[a]);
  for (; a < t; ++a) s[a] = e[a];
  return function(o) {
    for (a = 0; a < n; ++a) s[a] = i[a](o);
    return s;
  };
}
function XR(r, e) {
  var t = /* @__PURE__ */ new Date();
  return r = +r, e = +e, function(n) {
    return t.setTime(r * (1 - n) + e * n), t;
  };
}
function Go(r, e) {
  return r = +r, e = +e, function(t) {
    return r * (1 - t) + e * t;
  };
}
function QR(r, e) {
  var t = {}, n = {}, i;
  (r === null || typeof r != "object") && (r = {}), (e === null || typeof e != "object") && (e = {});
  for (i in e)
    i in r ? t[i] = ss(r[i], e[i]) : n[i] = e[i];
  return function(s) {
    for (i in t) n[i] = t[i](s);
    return n;
  };
}
var Wd = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, Su = new RegExp(Wd.source, "g");
function ZR(r) {
  return function() {
    return r;
  };
}
function JR(r) {
  return function(e) {
    return r(e) + "";
  };
}
function eD(r, e) {
  var t = Wd.lastIndex = Su.lastIndex = 0, n, i, s, a = -1, o = [], c = [];
  for (r = r + "", e = e + ""; (n = Wd.exec(r)) && (i = Su.exec(e)); )
    (s = i.index) > t && (s = e.slice(t, s), o[a] ? o[a] += s : o[++a] = s), (n = n[0]) === (i = i[0]) ? o[a] ? o[a] += i : o[++a] = i : (o[++a] = null, c.push({ i: a, x: Go(n, i) })), t = Su.lastIndex;
  return t < e.length && (s = e.slice(t), o[a] ? o[a] += s : o[++a] = s), o.length < 2 ? c[0] ? JR(c[0].x) : ZR(e) : (e = c.length, function(l) {
    for (var u = 0, d; u < e; ++u) o[(d = c[u]).i] = d.x(l);
    return o.join("");
  });
}
function ss(r, e) {
  var t = typeof e, n;
  return e == null || t === "boolean" ? yh(e) : (t === "number" ? Go : t === "string" ? (n = qs(e)) ? (e = n, kv) : eD : e instanceof qs ? kv : e instanceof Date ? XR : zR(e) ? qR : Array.isArray(e) ? YR : typeof e.valueOf != "function" && typeof e.toString != "function" || isNaN(e) ? QR : Go)(r, e);
}
function bh(r, e) {
  return r = +r, e = +e, function(t) {
    return Math.round(r * (1 - t) + e * t);
  };
}
function tD(r, e) {
  e === void 0 && (e = r, r = ss);
  for (var t = 0, n = e.length - 1, i = e[0], s = new Array(n < 0 ? 0 : n); t < n; ) s[t] = r(i, i = e[++t]);
  return function(a) {
    var o = Math.max(0, Math.min(n - 1, Math.floor(a *= n)));
    return s[o](a - o);
  };
}
function rD(r) {
  return function() {
    return r;
  };
}
function Ko(r) {
  return +r;
}
var Mv = [0, 1];
function Rt(r) {
  return r;
}
function Hd(r, e) {
  return (e -= r = +r) ? function(t) {
    return (t - r) / e;
  } : rD(isNaN(e) ? NaN : 0.5);
}
function nD(r, e) {
  var t;
  return r > e && (t = r, r = e, e = t), function(n) {
    return Math.max(r, Math.min(e, n));
  };
}
function iD(r, e, t) {
  var n = r[0], i = r[1], s = e[0], a = e[1];
  return i < n ? (n = Hd(i, n), s = t(a, s)) : (n = Hd(n, i), s = t(s, a)), function(o) {
    return s(n(o));
  };
}
function sD(r, e, t) {
  var n = Math.min(r.length, e.length) - 1, i = new Array(n), s = new Array(n), a = -1;
  for (r[n] < r[0] && (r = r.slice().reverse(), e = e.slice().reverse()); ++a < n; )
    i[a] = Hd(r[a], r[a + 1]), s[a] = t(e[a], e[a + 1]);
  return function(o) {
    var c = ha(r, o, 1, n) - 1;
    return s[c](i[c](o));
  };
}
function ma(r, e) {
  return e.domain(r.domain()).range(r.range()).interpolate(r.interpolate()).clamp(r.clamp()).unknown(r.unknown());
}
function Ol() {
  var r = Mv, e = Mv, t = ss, n, i, s, a = Rt, o, c, l;
  function u() {
    var f = Math.min(r.length, e.length);
    return a !== Rt && (a = nD(r[0], r[f - 1])), o = f > 2 ? sD : iD, c = l = null, d;
  }
  function d(f) {
    return f == null || isNaN(f = +f) ? s : (c || (c = o(r.map(n), e, t)))(n(a(f)));
  }
  return d.invert = function(f) {
    return a(i((l || (l = o(e, r.map(n), Go)))(f)));
  }, d.domain = function(f) {
    return arguments.length ? (r = Array.from(f, Ko), u()) : r.slice();
  }, d.range = function(f) {
    return arguments.length ? (e = Array.from(f), u()) : e.slice();
  }, d.rangeRound = function(f) {
    return e = Array.from(f), t = bh, u();
  }, d.clamp = function(f) {
    return arguments.length ? (a = f ? !0 : Rt, u()) : a !== Rt;
  }, d.interpolate = function(f) {
    return arguments.length ? (t = f, u()) : t;
  }, d.unknown = function(f) {
    return arguments.length ? (s = f, d) : s;
  }, function(f, h) {
    return n = f, i = h, u();
  };
}
function xh() {
  return Ol()(Rt, Rt);
}
function aD(r) {
  return Math.abs(r = Math.round(r)) >= 1e21 ? r.toLocaleString("en").replace(/,/g, "") : r.toString(10);
}
function Vo(r, e) {
  if ((t = (r = e ? r.toExponential(e - 1) : r.toExponential()).indexOf("e")) < 0) return null;
  var t, n = r.slice(0, t);
  return [
    n.length > 1 ? n[0] + n.slice(2) : n,
    +r.slice(t + 1)
  ];
}
function qi(r) {
  return r = Vo(Math.abs(r)), r ? r[1] : NaN;
}
function oD(r, e) {
  return function(t, n) {
    for (var i = t.length, s = [], a = 0, o = r[0], c = 0; i > 0 && o > 0 && (c + o + 1 > n && (o = Math.max(1, n - c)), s.push(t.substring(i -= o, i + o)), !((c += o + 1) > n)); )
      o = r[a = (a + 1) % r.length];
    return s.reverse().join(e);
  };
}
function lD(r) {
  return function(e) {
    return e.replace(/[0-9]/g, function(t) {
      return r[+t];
    });
  };
}
var cD = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function zs(r) {
  if (!(e = cD.exec(r))) throw new Error("invalid format: " + r);
  var e;
  return new Eh({
    fill: e[1],
    align: e[2],
    sign: e[3],
    symbol: e[4],
    zero: e[5],
    width: e[6],
    comma: e[7],
    precision: e[8] && e[8].slice(1),
    trim: e[9],
    type: e[10]
  });
}
zs.prototype = Eh.prototype;
function Eh(r) {
  this.fill = r.fill === void 0 ? " " : r.fill + "", this.align = r.align === void 0 ? ">" : r.align + "", this.sign = r.sign === void 0 ? "-" : r.sign + "", this.symbol = r.symbol === void 0 ? "" : r.symbol + "", this.zero = !!r.zero, this.width = r.width === void 0 ? void 0 : +r.width, this.comma = !!r.comma, this.precision = r.precision === void 0 ? void 0 : +r.precision, this.trim = !!r.trim, this.type = r.type === void 0 ? "" : r.type + "";
}
Eh.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function uD(r) {
  e: for (var e = r.length, t = 1, n = -1, i; t < e; ++t)
    switch (r[t]) {
      case ".":
        n = i = t;
        break;
      case "0":
        n === 0 && (n = t), i = t;
        break;
      default:
        if (!+r[t]) break e;
        n > 0 && (n = 0);
        break;
    }
  return n > 0 ? r.slice(0, n) + r.slice(i + 1) : r;
}
var DE;
function dD(r, e) {
  var t = Vo(r, e);
  if (!t) return r + "";
  var n = t[0], i = t[1], s = i - (DE = Math.max(-8, Math.min(8, Math.floor(i / 3))) * 3) + 1, a = n.length;
  return s === a ? n : s > a ? n + new Array(s - a + 1).join("0") : s > 0 ? n.slice(0, s) + "." + n.slice(s) : "0." + new Array(1 - s).join("0") + Vo(r, Math.max(0, e + s - 1))[0];
}
function Nv(r, e) {
  var t = Vo(r, e);
  if (!t) return r + "";
  var n = t[0], i = t[1];
  return i < 0 ? "0." + new Array(-i).join("0") + n : n.length > i + 1 ? n.slice(0, i + 1) + "." + n.slice(i + 1) : n + new Array(i - n.length + 2).join("0");
}
const Fv = {
  "%": (r, e) => (r * 100).toFixed(e),
  b: (r) => Math.round(r).toString(2),
  c: (r) => r + "",
  d: aD,
  e: (r, e) => r.toExponential(e),
  f: (r, e) => r.toFixed(e),
  g: (r, e) => r.toPrecision(e),
  o: (r) => Math.round(r).toString(8),
  p: (r, e) => Nv(r * 100, e),
  r: Nv,
  s: dD,
  X: (r) => Math.round(r).toString(16).toUpperCase(),
  x: (r) => Math.round(r).toString(16)
};
function $v(r) {
  return r;
}
var Bv = Array.prototype.map, jv = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function fD(r) {
  var e = r.grouping === void 0 || r.thousands === void 0 ? $v : oD(Bv.call(r.grouping, Number), r.thousands + ""), t = r.currency === void 0 ? "" : r.currency[0] + "", n = r.currency === void 0 ? "" : r.currency[1] + "", i = r.decimal === void 0 ? "." : r.decimal + "", s = r.numerals === void 0 ? $v : lD(Bv.call(r.numerals, String)), a = r.percent === void 0 ? "%" : r.percent + "", o = r.minus === void 0 ? "−" : r.minus + "", c = r.nan === void 0 ? "NaN" : r.nan + "";
  function l(d) {
    d = zs(d);
    var f = d.fill, h = d.align, g = d.sign, m = d.symbol, p = d.zero, v = d.width, y = d.comma, b = d.precision, x = d.trim, S = d.type;
    S === "n" ? (y = !0, S = "g") : Fv[S] || (b === void 0 && (b = 12), x = !0, S = "g"), (p || f === "0" && h === "=") && (p = !0, f = "0", h = "=");
    var A = m === "$" ? t : m === "#" && /[boxX]/.test(S) ? "0" + S.toLowerCase() : "", T = m === "$" ? n : /[%p]/.test(S) ? a : "", I = Fv[S], L = /[defgprs%]/.test(S);
    b = b === void 0 ? 6 : /[gprs]/.test(S) ? Math.max(1, Math.min(21, b)) : Math.max(0, Math.min(20, b));
    function _(R) {
      var D = A, F = T, B, j, U;
      if (S === "c")
        F = I(R) + F, R = "";
      else {
        R = +R;
        var K = R < 0 || 1 / R < 0;
        if (R = isNaN(R) ? c : I(Math.abs(R), b), x && (R = uD(R)), K && +R == 0 && g !== "+" && (K = !1), D = (K ? g === "(" ? g : o : g === "-" || g === "(" ? "" : g) + D, F = (S === "s" ? jv[8 + DE / 3] : "") + F + (K && g === "(" ? ")" : ""), L) {
          for (B = -1, j = R.length; ++B < j; )
            if (U = R.charCodeAt(B), 48 > U || U > 57) {
              F = (U === 46 ? i + R.slice(B + 1) : R.slice(B)) + F, R = R.slice(0, B);
              break;
            }
        }
      }
      y && !p && (R = e(R, 1 / 0));
      var G = D.length + R.length + F.length, Y = G < v ? new Array(v - G + 1).join(f) : "";
      switch (y && p && (R = e(Y + R, Y.length ? v - F.length : 1 / 0), Y = ""), h) {
        case "<":
          R = D + R + F + Y;
          break;
        case "=":
          R = D + Y + R + F;
          break;
        case "^":
          R = Y.slice(0, G = Y.length >> 1) + D + R + F + Y.slice(G);
          break;
        default:
          R = Y + D + R + F;
          break;
      }
      return s(R);
    }
    return _.toString = function() {
      return d + "";
    }, _;
  }
  function u(d, f) {
    var h = l((d = zs(d), d.type = "f", d)), g = Math.max(-8, Math.min(8, Math.floor(qi(f) / 3))) * 3, m = Math.pow(10, -g), p = jv[8 + g / 3];
    return function(v) {
      return h(m * v) + p;
    };
  }
  return {
    format: l,
    formatPrefix: u
  };
}
var za, Sh, CE;
hD({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function hD(r) {
  return za = fD(r), Sh = za.format, CE = za.formatPrefix, za;
}
function gD(r) {
  return Math.max(0, -qi(Math.abs(r)));
}
function mD(r, e) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(qi(e) / 3))) * 3 - qi(Math.abs(r)));
}
function pD(r, e) {
  return r = Math.abs(r), e = Math.abs(e) - r, Math.max(0, qi(e) - qi(r)) + 1;
}
function kE(r, e, t, n) {
  var i = Gd(r, e, t), s;
  switch (n = zs(n ?? ",f"), n.type) {
    case "s": {
      var a = Math.max(Math.abs(r), Math.abs(e));
      return n.precision == null && !isNaN(s = mD(i, a)) && (n.precision = s), CE(n, a);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      n.precision == null && !isNaN(s = pD(i, Math.max(Math.abs(r), Math.abs(e)))) && (n.precision = s - (n.type === "e"));
      break;
    }
    case "f":
    case "%": {
      n.precision == null && !isNaN(s = gD(i)) && (n.precision = s - (n.type === "%") * 2);
      break;
    }
  }
  return Sh(n);
}
function Bn(r) {
  var e = r.domain;
  return r.ticks = function(t) {
    var n = e();
    return jd(n[0], n[n.length - 1], t ?? 10);
  }, r.tickFormat = function(t, n) {
    var i = e();
    return kE(i[0], i[i.length - 1], t ?? 10, n);
  }, r.nice = function(t) {
    t == null && (t = 10);
    var n = e(), i = 0, s = n.length - 1, a = n[i], o = n[s], c, l, u = 10;
    for (o < a && (l = a, a = o, o = l, l = i, i = s, s = l); u-- > 0; ) {
      if (l = Ud(a, o, t), l === c)
        return n[i] = a, n[s] = o, e(n);
      if (l > 0)
        a = Math.floor(a / l) * l, o = Math.ceil(o / l) * l;
      else if (l < 0)
        a = Math.ceil(a * l) / l, o = Math.floor(o * l) / l;
      else
        break;
      c = l;
    }
    return r;
  }, r;
}
function ME() {
  var r = xh();
  return r.copy = function() {
    return ma(r, ME());
  }, Er.apply(r, arguments), Bn(r);
}
function NE(r) {
  var e;
  function t(n) {
    return n == null || isNaN(n = +n) ? e : n;
  }
  return t.invert = t, t.domain = t.range = function(n) {
    return arguments.length ? (r = Array.from(n, Ko), t) : r.slice();
  }, t.unknown = function(n) {
    return arguments.length ? (e = n, t) : e;
  }, t.copy = function() {
    return NE(r).unknown(e);
  }, r = arguments.length ? Array.from(r, Ko) : [0, 1], Bn(t);
}
function FE(r, e) {
  r = r.slice();
  var t = 0, n = r.length - 1, i = r[t], s = r[n], a;
  return s < i && (a = t, t = n, n = a, a = i, i = s, s = a), r[t] = e.floor(i), r[n] = e.ceil(s), r;
}
function Uv(r) {
  return Math.log(r);
}
function Gv(r) {
  return Math.exp(r);
}
function vD(r) {
  return -Math.log(-r);
}
function yD(r) {
  return -Math.exp(-r);
}
function bD(r) {
  return isFinite(r) ? +("1e" + r) : r < 0 ? 0 : r;
}
function xD(r) {
  return r === 10 ? bD : r === Math.E ? Math.exp : (e) => Math.pow(r, e);
}
function ED(r) {
  return r === Math.E ? Math.log : r === 10 && Math.log10 || r === 2 && Math.log2 || (r = Math.log(r), (e) => Math.log(e) / r);
}
function Kv(r) {
  return (e, t) => -r(-e, t);
}
function Th(r) {
  const e = r(Uv, Gv), t = e.domain;
  let n = 10, i, s;
  function a() {
    return i = ED(n), s = xD(n), t()[0] < 0 ? (i = Kv(i), s = Kv(s), r(vD, yD)) : r(Uv, Gv), e;
  }
  return e.base = function(o) {
    return arguments.length ? (n = +o, a()) : n;
  }, e.domain = function(o) {
    return arguments.length ? (t(o), a()) : t();
  }, e.ticks = (o) => {
    const c = t();
    let l = c[0], u = c[c.length - 1];
    const d = u < l;
    d && ([l, u] = [u, l]);
    let f = i(l), h = i(u), g, m;
    const p = o == null ? 10 : +o;
    let v = [];
    if (!(n % 1) && h - f < p) {
      if (f = Math.floor(f), h = Math.ceil(h), l > 0) {
        for (; f <= h; ++f)
          for (g = 1; g < n; ++g)
            if (m = f < 0 ? g / s(-f) : g * s(f), !(m < l)) {
              if (m > u) break;
              v.push(m);
            }
      } else for (; f <= h; ++f)
        for (g = n - 1; g >= 1; --g)
          if (m = f > 0 ? g / s(-f) : g * s(f), !(m < l)) {
            if (m > u) break;
            v.push(m);
          }
      v.length * 2 < p && (v = jd(l, u, p));
    } else
      v = jd(f, h, Math.min(h - f, p)).map(s);
    return d ? v.reverse() : v;
  }, e.tickFormat = (o, c) => {
    if (o == null && (o = 10), c == null && (c = n === 10 ? "s" : ","), typeof c != "function" && (!(n % 1) && (c = zs(c)).precision == null && (c.trim = !0), c = Sh(c)), o === 1 / 0) return c;
    const l = Math.max(1, n * o / e.ticks().length);
    return (u) => {
      let d = u / s(Math.round(i(u)));
      return d * n < n - 0.5 && (d *= n), d <= l ? c(u) : "";
    };
  }, e.nice = () => t(FE(t(), {
    floor: (o) => s(Math.floor(i(o))),
    ceil: (o) => s(Math.ceil(i(o)))
  })), e;
}
function $E() {
  const r = Th(Ol()).domain([1, 10]);
  return r.copy = () => ma(r, $E()).base(r.base()), Er.apply(r, arguments), r;
}
function Vv(r) {
  return function(e) {
    return Math.sign(e) * Math.log1p(Math.abs(e / r));
  };
}
function Wv(r) {
  return function(e) {
    return Math.sign(e) * Math.expm1(Math.abs(e)) * r;
  };
}
function Ah(r) {
  var e = 1, t = r(Vv(e), Wv(e));
  return t.constant = function(n) {
    return arguments.length ? r(Vv(e = +n), Wv(e)) : e;
  }, Bn(t);
}
function BE() {
  var r = Ah(Ol());
  return r.copy = function() {
    return ma(r, BE()).constant(r.constant());
  }, Er.apply(r, arguments);
}
function Hv(r) {
  return function(e) {
    return e < 0 ? -Math.pow(-e, r) : Math.pow(e, r);
  };
}
function SD(r) {
  return r < 0 ? -Math.sqrt(-r) : Math.sqrt(r);
}
function TD(r) {
  return r < 0 ? -r * r : r * r;
}
function wh(r) {
  var e = r(Rt, Rt), t = 1;
  function n() {
    return t === 1 ? r(Rt, Rt) : t === 0.5 ? r(SD, TD) : r(Hv(t), Hv(1 / t));
  }
  return e.exponent = function(i) {
    return arguments.length ? (t = +i, n()) : t;
  }, Bn(e);
}
function Ih() {
  var r = wh(Ol());
  return r.copy = function() {
    return ma(r, Ih()).exponent(r.exponent());
  }, Er.apply(r, arguments), r;
}
function AD() {
  return Ih.apply(null, arguments).exponent(0.5);
}
function qv(r) {
  return Math.sign(r) * r * r;
}
function wD(r) {
  return Math.sign(r) * Math.sqrt(Math.abs(r));
}
function jE() {
  var r = xh(), e = [0, 1], t = !1, n;
  function i(s) {
    var a = wD(r(s));
    return isNaN(a) ? n : t ? Math.round(a) : a;
  }
  return i.invert = function(s) {
    return r.invert(qv(s));
  }, i.domain = function(s) {
    return arguments.length ? (r.domain(s), i) : r.domain();
  }, i.range = function(s) {
    return arguments.length ? (r.range((e = Array.from(s, Ko)).map(qv)), i) : e.slice();
  }, i.rangeRound = function(s) {
    return i.range(s).round(!0);
  }, i.round = function(s) {
    return arguments.length ? (t = !!s, i) : t;
  }, i.clamp = function(s) {
    return arguments.length ? (r.clamp(s), i) : r.clamp();
  }, i.unknown = function(s) {
    return arguments.length ? (n = s, i) : n;
  }, i.copy = function() {
    return jE(r.domain(), e).round(t).clamp(r.clamp()).unknown(n);
  }, Er.apply(i, arguments), Bn(i);
}
function UE() {
  var r = [], e = [], t = [], n;
  function i() {
    var a = 0, o = Math.max(1, e.length);
    for (t = new Array(o - 1); ++a < o; ) t[a - 1] = LR(r, a / o);
    return s;
  }
  function s(a) {
    return a == null || isNaN(a = +a) ? n : e[ha(t, a)];
  }
  return s.invertExtent = function(a) {
    var o = e.indexOf(a);
    return o < 0 ? [NaN, NaN] : [
      o > 0 ? t[o - 1] : r[0],
      o < t.length ? t[o] : r[r.length - 1]
    ];
  }, s.domain = function(a) {
    if (!arguments.length) return r.slice();
    r = [];
    for (let o of a) o != null && !isNaN(o = +o) && r.push(o);
    return r.sort(Cn), i();
  }, s.range = function(a) {
    return arguments.length ? (e = Array.from(a), i()) : e.slice();
  }, s.unknown = function(a) {
    return arguments.length ? (n = a, s) : n;
  }, s.quantiles = function() {
    return t.slice();
  }, s.copy = function() {
    return UE().domain(r).range(e).unknown(n);
  }, Er.apply(s, arguments);
}
function GE() {
  var r = 0, e = 1, t = 1, n = [0.5], i = [0, 1], s;
  function a(c) {
    return c != null && c <= c ? i[ha(n, c, 0, t)] : s;
  }
  function o() {
    var c = -1;
    for (n = new Array(t); ++c < t; ) n[c] = ((c + 1) * e - (c - t) * r) / (t + 1);
    return a;
  }
  return a.domain = function(c) {
    return arguments.length ? ([r, e] = c, r = +r, e = +e, o()) : [r, e];
  }, a.range = function(c) {
    return arguments.length ? (t = (i = Array.from(c)).length - 1, o()) : i.slice();
  }, a.invertExtent = function(c) {
    var l = i.indexOf(c);
    return l < 0 ? [NaN, NaN] : l < 1 ? [r, n[0]] : l >= t ? [n[t - 1], e] : [n[l - 1], n[l]];
  }, a.unknown = function(c) {
    return arguments.length && (s = c), a;
  }, a.thresholds = function() {
    return n.slice();
  }, a.copy = function() {
    return GE().domain([r, e]).range(i).unknown(s);
  }, Er.apply(Bn(a), arguments);
}
function KE() {
  var r = [0.5], e = [0, 1], t, n = 1;
  function i(s) {
    return s != null && s <= s ? e[ha(r, s, 0, n)] : t;
  }
  return i.domain = function(s) {
    return arguments.length ? (r = Array.from(s), n = Math.min(r.length, e.length - 1), i) : r.slice();
  }, i.range = function(s) {
    return arguments.length ? (e = Array.from(s), n = Math.min(r.length, e.length - 1), i) : e.slice();
  }, i.invertExtent = function(s) {
    var a = e.indexOf(s);
    return [r[a - 1], r[a]];
  }, i.unknown = function(s) {
    return arguments.length ? (t = s, i) : t;
  }, i.copy = function() {
    return KE().domain(r).range(e).unknown(t);
  }, Er.apply(i, arguments);
}
const Tu = /* @__PURE__ */ new Date(), Au = /* @__PURE__ */ new Date();
function dt(r, e, t, n) {
  function i(s) {
    return r(s = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+s)), s;
  }
  return i.floor = (s) => (r(s = /* @__PURE__ */ new Date(+s)), s), i.ceil = (s) => (r(s = new Date(s - 1)), e(s, 1), r(s), s), i.round = (s) => {
    const a = i(s), o = i.ceil(s);
    return s - a < o - s ? a : o;
  }, i.offset = (s, a) => (e(s = /* @__PURE__ */ new Date(+s), a == null ? 1 : Math.floor(a)), s), i.range = (s, a, o) => {
    const c = [];
    if (s = i.ceil(s), o = o == null ? 1 : Math.floor(o), !(s < a) || !(o > 0)) return c;
    let l;
    do
      c.push(l = /* @__PURE__ */ new Date(+s)), e(s, o), r(s);
    while (l < s && s < a);
    return c;
  }, i.filter = (s) => dt((a) => {
    if (a >= a) for (; r(a), !s(a); ) a.setTime(a - 1);
  }, (a, o) => {
    if (a >= a)
      if (o < 0) for (; ++o <= 0; )
        for (; e(a, -1), !s(a); )
          ;
      else for (; --o >= 0; )
        for (; e(a, 1), !s(a); )
          ;
  }), t && (i.count = (s, a) => (Tu.setTime(+s), Au.setTime(+a), r(Tu), r(Au), Math.floor(t(Tu, Au))), i.every = (s) => (s = Math.floor(s), !isFinite(s) || !(s > 0) ? null : s > 1 ? i.filter(n ? (a) => n(a) % s === 0 : (a) => i.count(0, a) % s === 0) : i)), i;
}
const Wo = dt(() => {
}, (r, e) => {
  r.setTime(+r + e);
}, (r, e) => e - r);
Wo.every = (r) => (r = Math.floor(r), !isFinite(r) || !(r > 0) ? null : r > 1 ? dt((e) => {
  e.setTime(Math.floor(e / r) * r);
}, (e, t) => {
  e.setTime(+e + t * r);
}, (e, t) => (t - e) / r) : Wo);
Wo.range;
const Jr = 1e3, hr = Jr * 60, en = hr * 60, an = en * 24, Ph = an * 7, zv = an * 30, wu = an * 365, ei = dt((r) => {
  r.setTime(r - r.getMilliseconds());
}, (r, e) => {
  r.setTime(+r + e * Jr);
}, (r, e) => (e - r) / Jr, (r) => r.getUTCSeconds());
ei.range;
const _h = dt((r) => {
  r.setTime(r - r.getMilliseconds() - r.getSeconds() * Jr);
}, (r, e) => {
  r.setTime(+r + e * hr);
}, (r, e) => (e - r) / hr, (r) => r.getMinutes());
_h.range;
const Lh = dt((r) => {
  r.setUTCSeconds(0, 0);
}, (r, e) => {
  r.setTime(+r + e * hr);
}, (r, e) => (e - r) / hr, (r) => r.getUTCMinutes());
Lh.range;
const Oh = dt((r) => {
  r.setTime(r - r.getMilliseconds() - r.getSeconds() * Jr - r.getMinutes() * hr);
}, (r, e) => {
  r.setTime(+r + e * en);
}, (r, e) => (e - r) / en, (r) => r.getHours());
Oh.range;
const Rh = dt((r) => {
  r.setUTCMinutes(0, 0, 0);
}, (r, e) => {
  r.setTime(+r + e * en);
}, (r, e) => (e - r) / en, (r) => r.getUTCHours());
Rh.range;
const pa = dt(
  (r) => r.setHours(0, 0, 0, 0),
  (r, e) => r.setDate(r.getDate() + e),
  (r, e) => (e - r - (e.getTimezoneOffset() - r.getTimezoneOffset()) * hr) / an,
  (r) => r.getDate() - 1
);
pa.range;
const Rl = dt((r) => {
  r.setUTCHours(0, 0, 0, 0);
}, (r, e) => {
  r.setUTCDate(r.getUTCDate() + e);
}, (r, e) => (e - r) / an, (r) => r.getUTCDate() - 1);
Rl.range;
const VE = dt((r) => {
  r.setUTCHours(0, 0, 0, 0);
}, (r, e) => {
  r.setUTCDate(r.getUTCDate() + e);
}, (r, e) => (e - r) / an, (r) => Math.floor(r / an));
VE.range;
function pi(r) {
  return dt((e) => {
    e.setDate(e.getDate() - (e.getDay() + 7 - r) % 7), e.setHours(0, 0, 0, 0);
  }, (e, t) => {
    e.setDate(e.getDate() + t * 7);
  }, (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * hr) / Ph);
}
const Dl = pi(0), Ho = pi(1), ID = pi(2), PD = pi(3), zi = pi(4), _D = pi(5), LD = pi(6);
Dl.range;
Ho.range;
ID.range;
PD.range;
zi.range;
_D.range;
LD.range;
function vi(r) {
  return dt((e) => {
    e.setUTCDate(e.getUTCDate() - (e.getUTCDay() + 7 - r) % 7), e.setUTCHours(0, 0, 0, 0);
  }, (e, t) => {
    e.setUTCDate(e.getUTCDate() + t * 7);
  }, (e, t) => (t - e) / Ph);
}
const Cl = vi(0), qo = vi(1), OD = vi(2), RD = vi(3), Yi = vi(4), DD = vi(5), CD = vi(6);
Cl.range;
qo.range;
OD.range;
RD.range;
Yi.range;
DD.range;
CD.range;
const Dh = dt((r) => {
  r.setDate(1), r.setHours(0, 0, 0, 0);
}, (r, e) => {
  r.setMonth(r.getMonth() + e);
}, (r, e) => e.getMonth() - r.getMonth() + (e.getFullYear() - r.getFullYear()) * 12, (r) => r.getMonth());
Dh.range;
const Ch = dt((r) => {
  r.setUTCDate(1), r.setUTCHours(0, 0, 0, 0);
}, (r, e) => {
  r.setUTCMonth(r.getUTCMonth() + e);
}, (r, e) => e.getUTCMonth() - r.getUTCMonth() + (e.getUTCFullYear() - r.getUTCFullYear()) * 12, (r) => r.getUTCMonth());
Ch.range;
const on = dt((r) => {
  r.setMonth(0, 1), r.setHours(0, 0, 0, 0);
}, (r, e) => {
  r.setFullYear(r.getFullYear() + e);
}, (r, e) => e.getFullYear() - r.getFullYear(), (r) => r.getFullYear());
on.every = (r) => !isFinite(r = Math.floor(r)) || !(r > 0) ? null : dt((e) => {
  e.setFullYear(Math.floor(e.getFullYear() / r) * r), e.setMonth(0, 1), e.setHours(0, 0, 0, 0);
}, (e, t) => {
  e.setFullYear(e.getFullYear() + t * r);
});
on.range;
const ln = dt((r) => {
  r.setUTCMonth(0, 1), r.setUTCHours(0, 0, 0, 0);
}, (r, e) => {
  r.setUTCFullYear(r.getUTCFullYear() + e);
}, (r, e) => e.getUTCFullYear() - r.getUTCFullYear(), (r) => r.getUTCFullYear());
ln.every = (r) => !isFinite(r = Math.floor(r)) || !(r > 0) ? null : dt((e) => {
  e.setUTCFullYear(Math.floor(e.getUTCFullYear() / r) * r), e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCFullYear(e.getUTCFullYear() + t * r);
});
ln.range;
function WE(r, e, t, n, i, s) {
  const a = [
    [ei, 1, Jr],
    [ei, 5, 5 * Jr],
    [ei, 15, 15 * Jr],
    [ei, 30, 30 * Jr],
    [s, 1, hr],
    [s, 5, 5 * hr],
    [s, 15, 15 * hr],
    [s, 30, 30 * hr],
    [i, 1, en],
    [i, 3, 3 * en],
    [i, 6, 6 * en],
    [i, 12, 12 * en],
    [n, 1, an],
    [n, 2, 2 * an],
    [t, 1, Ph],
    [e, 1, zv],
    [e, 3, 3 * zv],
    [r, 1, wu]
  ];
  function o(l, u, d) {
    const f = u < l;
    f && ([l, u] = [u, l]);
    const h = d && typeof d.range == "function" ? d : c(l, u, d), g = h ? h.range(l, +u + 1) : [];
    return f ? g.reverse() : g;
  }
  function c(l, u, d) {
    const f = Math.abs(u - l) / d, h = gh(([, , p]) => p).right(a, f);
    if (h === a.length) return r.every(Gd(l / wu, u / wu, d));
    if (h === 0) return Wo.every(Math.max(Gd(l, u, d), 1));
    const [g, m] = a[f / a[h - 1][2] < a[h][2] / f ? h - 1 : h];
    return g.every(m);
  }
  return [o, c];
}
const [kD, MD] = WE(ln, Ch, Cl, VE, Rh, Lh), [ND, FD] = WE(on, Dh, Dl, pa, Oh, _h);
function Iu(r) {
  if (0 <= r.y && r.y < 100) {
    var e = new Date(-1, r.m, r.d, r.H, r.M, r.S, r.L);
    return e.setFullYear(r.y), e;
  }
  return new Date(r.y, r.m, r.d, r.H, r.M, r.S, r.L);
}
function Pu(r) {
  if (0 <= r.y && r.y < 100) {
    var e = new Date(Date.UTC(-1, r.m, r.d, r.H, r.M, r.S, r.L));
    return e.setUTCFullYear(r.y), e;
  }
  return new Date(Date.UTC(r.y, r.m, r.d, r.H, r.M, r.S, r.L));
}
function ws(r, e, t) {
  return { y: r, m: e, d: t, H: 0, M: 0, S: 0, L: 0 };
}
function $D(r) {
  var e = r.dateTime, t = r.date, n = r.time, i = r.periods, s = r.days, a = r.shortDays, o = r.months, c = r.shortMonths, l = Is(i), u = Ps(i), d = Is(s), f = Ps(s), h = Is(a), g = Ps(a), m = Is(o), p = Ps(o), v = Is(c), y = Ps(c), b = {
    a: K,
    A: G,
    b: Y,
    B: Q,
    c: null,
    d: e0,
    e: e0,
    f: oC,
    g: vC,
    G: bC,
    H: iC,
    I: sC,
    j: aC,
    L: HE,
    m: lC,
    M: cC,
    p: H,
    q: N,
    Q: n0,
    s: i0,
    S: uC,
    u: dC,
    U: fC,
    V: hC,
    w: gC,
    W: mC,
    x: null,
    X: null,
    y: pC,
    Y: yC,
    Z: xC,
    "%": r0
  }, x = {
    a: re,
    A: oe,
    b: le,
    B: he,
    c: null,
    d: t0,
    e: t0,
    f: AC,
    g: kC,
    G: NC,
    H: EC,
    I: SC,
    j: TC,
    L: zE,
    m: wC,
    M: IC,
    p: Re,
    q: et,
    Q: n0,
    s: i0,
    S: PC,
    u: _C,
    U: LC,
    V: OC,
    w: RC,
    W: DC,
    x: null,
    X: null,
    y: CC,
    Y: MC,
    Z: FC,
    "%": r0
  }, S = {
    a: _,
    A: R,
    b: D,
    B: F,
    c: B,
    d: Zv,
    e: Zv,
    f: eC,
    g: Qv,
    G: Xv,
    H: Jv,
    I: Jv,
    j: XD,
    L: JD,
    m: YD,
    M: QD,
    p: L,
    q: zD,
    Q: rC,
    s: nC,
    S: ZD,
    u: KD,
    U: VD,
    V: WD,
    w: GD,
    W: HD,
    x: j,
    X: U,
    y: Qv,
    Y: Xv,
    Z: qD,
    "%": tC
  };
  b.x = A(t, b), b.X = A(n, b), b.c = A(e, b), x.x = A(t, x), x.X = A(n, x), x.c = A(e, x);
  function A(q, ie) {
    return function(fe) {
      var V = [], tt = -1, Te = 0, ot = q.length, se, $e, ft;
      for (fe instanceof Date || (fe = /* @__PURE__ */ new Date(+fe)); ++tt < ot; )
        q.charCodeAt(tt) === 37 && (V.push(q.slice(Te, tt)), ($e = Yv[se = q.charAt(++tt)]) != null ? se = q.charAt(++tt) : $e = se === "e" ? " " : "0", (ft = ie[se]) && (se = ft(fe, $e)), V.push(se), Te = tt + 1);
      return V.push(q.slice(Te, tt)), V.join("");
    };
  }
  function T(q, ie) {
    return function(fe) {
      var V = ws(1900, void 0, 1), tt = I(V, q, fe += "", 0), Te, ot;
      if (tt != fe.length) return null;
      if ("Q" in V) return new Date(V.Q);
      if ("s" in V) return new Date(V.s * 1e3 + ("L" in V ? V.L : 0));
      if (ie && !("Z" in V) && (V.Z = 0), "p" in V && (V.H = V.H % 12 + V.p * 12), V.m === void 0 && (V.m = "q" in V ? V.q : 0), "V" in V) {
        if (V.V < 1 || V.V > 53) return null;
        "w" in V || (V.w = 1), "Z" in V ? (Te = Pu(ws(V.y, 0, 1)), ot = Te.getUTCDay(), Te = ot > 4 || ot === 0 ? qo.ceil(Te) : qo(Te), Te = Rl.offset(Te, (V.V - 1) * 7), V.y = Te.getUTCFullYear(), V.m = Te.getUTCMonth(), V.d = Te.getUTCDate() + (V.w + 6) % 7) : (Te = Iu(ws(V.y, 0, 1)), ot = Te.getDay(), Te = ot > 4 || ot === 0 ? Ho.ceil(Te) : Ho(Te), Te = pa.offset(Te, (V.V - 1) * 7), V.y = Te.getFullYear(), V.m = Te.getMonth(), V.d = Te.getDate() + (V.w + 6) % 7);
      } else ("W" in V || "U" in V) && ("w" in V || (V.w = "u" in V ? V.u % 7 : "W" in V ? 1 : 0), ot = "Z" in V ? Pu(ws(V.y, 0, 1)).getUTCDay() : Iu(ws(V.y, 0, 1)).getDay(), V.m = 0, V.d = "W" in V ? (V.w + 6) % 7 + V.W * 7 - (ot + 5) % 7 : V.w + V.U * 7 - (ot + 6) % 7);
      return "Z" in V ? (V.H += V.Z / 100 | 0, V.M += V.Z % 100, Pu(V)) : Iu(V);
    };
  }
  function I(q, ie, fe, V) {
    for (var tt = 0, Te = ie.length, ot = fe.length, se, $e; tt < Te; ) {
      if (V >= ot) return -1;
      if (se = ie.charCodeAt(tt++), se === 37) {
        if (se = ie.charAt(tt++), $e = S[se in Yv ? ie.charAt(tt++) : se], !$e || (V = $e(q, fe, V)) < 0) return -1;
      } else if (se != fe.charCodeAt(V++))
        return -1;
    }
    return V;
  }
  function L(q, ie, fe) {
    var V = l.exec(ie.slice(fe));
    return V ? (q.p = u.get(V[0].toLowerCase()), fe + V[0].length) : -1;
  }
  function _(q, ie, fe) {
    var V = h.exec(ie.slice(fe));
    return V ? (q.w = g.get(V[0].toLowerCase()), fe + V[0].length) : -1;
  }
  function R(q, ie, fe) {
    var V = d.exec(ie.slice(fe));
    return V ? (q.w = f.get(V[0].toLowerCase()), fe + V[0].length) : -1;
  }
  function D(q, ie, fe) {
    var V = v.exec(ie.slice(fe));
    return V ? (q.m = y.get(V[0].toLowerCase()), fe + V[0].length) : -1;
  }
  function F(q, ie, fe) {
    var V = m.exec(ie.slice(fe));
    return V ? (q.m = p.get(V[0].toLowerCase()), fe + V[0].length) : -1;
  }
  function B(q, ie, fe) {
    return I(q, e, ie, fe);
  }
  function j(q, ie, fe) {
    return I(q, t, ie, fe);
  }
  function U(q, ie, fe) {
    return I(q, n, ie, fe);
  }
  function K(q) {
    return a[q.getDay()];
  }
  function G(q) {
    return s[q.getDay()];
  }
  function Y(q) {
    return c[q.getMonth()];
  }
  function Q(q) {
    return o[q.getMonth()];
  }
  function H(q) {
    return i[+(q.getHours() >= 12)];
  }
  function N(q) {
    return 1 + ~~(q.getMonth() / 3);
  }
  function re(q) {
    return a[q.getUTCDay()];
  }
  function oe(q) {
    return s[q.getUTCDay()];
  }
  function le(q) {
    return c[q.getUTCMonth()];
  }
  function he(q) {
    return o[q.getUTCMonth()];
  }
  function Re(q) {
    return i[+(q.getUTCHours() >= 12)];
  }
  function et(q) {
    return 1 + ~~(q.getUTCMonth() / 3);
  }
  return {
    format: function(q) {
      var ie = A(q += "", b);
      return ie.toString = function() {
        return q;
      }, ie;
    },
    parse: function(q) {
      var ie = T(q += "", !1);
      return ie.toString = function() {
        return q;
      }, ie;
    },
    utcFormat: function(q) {
      var ie = A(q += "", x);
      return ie.toString = function() {
        return q;
      }, ie;
    },
    utcParse: function(q) {
      var ie = T(q += "", !0);
      return ie.toString = function() {
        return q;
      }, ie;
    }
  };
}
var Yv = { "-": "", _: " ", 0: "0" }, vt = /^\s*\d+/, BD = /^%/, jD = /[\\^$*+?|[\]().{}]/g;
function Ie(r, e, t) {
  var n = r < 0 ? "-" : "", i = (n ? -r : r) + "", s = i.length;
  return n + (s < t ? new Array(t - s + 1).join(e) + i : i);
}
function UD(r) {
  return r.replace(jD, "\\$&");
}
function Is(r) {
  return new RegExp("^(?:" + r.map(UD).join("|") + ")", "i");
}
function Ps(r) {
  return new Map(r.map((e, t) => [e.toLowerCase(), t]));
}
function GD(r, e, t) {
  var n = vt.exec(e.slice(t, t + 1));
  return n ? (r.w = +n[0], t + n[0].length) : -1;
}
function KD(r, e, t) {
  var n = vt.exec(e.slice(t, t + 1));
  return n ? (r.u = +n[0], t + n[0].length) : -1;
}
function VD(r, e, t) {
  var n = vt.exec(e.slice(t, t + 2));
  return n ? (r.U = +n[0], t + n[0].length) : -1;
}
function WD(r, e, t) {
  var n = vt.exec(e.slice(t, t + 2));
  return n ? (r.V = +n[0], t + n[0].length) : -1;
}
function HD(r, e, t) {
  var n = vt.exec(e.slice(t, t + 2));
  return n ? (r.W = +n[0], t + n[0].length) : -1;
}
function Xv(r, e, t) {
  var n = vt.exec(e.slice(t, t + 4));
  return n ? (r.y = +n[0], t + n[0].length) : -1;
}
function Qv(r, e, t) {
  var n = vt.exec(e.slice(t, t + 2));
  return n ? (r.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), t + n[0].length) : -1;
}
function qD(r, e, t) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(e.slice(t, t + 6));
  return n ? (r.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), t + n[0].length) : -1;
}
function zD(r, e, t) {
  var n = vt.exec(e.slice(t, t + 1));
  return n ? (r.q = n[0] * 3 - 3, t + n[0].length) : -1;
}
function YD(r, e, t) {
  var n = vt.exec(e.slice(t, t + 2));
  return n ? (r.m = n[0] - 1, t + n[0].length) : -1;
}
function Zv(r, e, t) {
  var n = vt.exec(e.slice(t, t + 2));
  return n ? (r.d = +n[0], t + n[0].length) : -1;
}
function XD(r, e, t) {
  var n = vt.exec(e.slice(t, t + 3));
  return n ? (r.m = 0, r.d = +n[0], t + n[0].length) : -1;
}
function Jv(r, e, t) {
  var n = vt.exec(e.slice(t, t + 2));
  return n ? (r.H = +n[0], t + n[0].length) : -1;
}
function QD(r, e, t) {
  var n = vt.exec(e.slice(t, t + 2));
  return n ? (r.M = +n[0], t + n[0].length) : -1;
}
function ZD(r, e, t) {
  var n = vt.exec(e.slice(t, t + 2));
  return n ? (r.S = +n[0], t + n[0].length) : -1;
}
function JD(r, e, t) {
  var n = vt.exec(e.slice(t, t + 3));
  return n ? (r.L = +n[0], t + n[0].length) : -1;
}
function eC(r, e, t) {
  var n = vt.exec(e.slice(t, t + 6));
  return n ? (r.L = Math.floor(n[0] / 1e3), t + n[0].length) : -1;
}
function tC(r, e, t) {
  var n = BD.exec(e.slice(t, t + 1));
  return n ? t + n[0].length : -1;
}
function rC(r, e, t) {
  var n = vt.exec(e.slice(t));
  return n ? (r.Q = +n[0], t + n[0].length) : -1;
}
function nC(r, e, t) {
  var n = vt.exec(e.slice(t));
  return n ? (r.s = +n[0], t + n[0].length) : -1;
}
function e0(r, e) {
  return Ie(r.getDate(), e, 2);
}
function iC(r, e) {
  return Ie(r.getHours(), e, 2);
}
function sC(r, e) {
  return Ie(r.getHours() % 12 || 12, e, 2);
}
function aC(r, e) {
  return Ie(1 + pa.count(on(r), r), e, 3);
}
function HE(r, e) {
  return Ie(r.getMilliseconds(), e, 3);
}
function oC(r, e) {
  return HE(r, e) + "000";
}
function lC(r, e) {
  return Ie(r.getMonth() + 1, e, 2);
}
function cC(r, e) {
  return Ie(r.getMinutes(), e, 2);
}
function uC(r, e) {
  return Ie(r.getSeconds(), e, 2);
}
function dC(r) {
  var e = r.getDay();
  return e === 0 ? 7 : e;
}
function fC(r, e) {
  return Ie(Dl.count(on(r) - 1, r), e, 2);
}
function qE(r) {
  var e = r.getDay();
  return e >= 4 || e === 0 ? zi(r) : zi.ceil(r);
}
function hC(r, e) {
  return r = qE(r), Ie(zi.count(on(r), r) + (on(r).getDay() === 4), e, 2);
}
function gC(r) {
  return r.getDay();
}
function mC(r, e) {
  return Ie(Ho.count(on(r) - 1, r), e, 2);
}
function pC(r, e) {
  return Ie(r.getFullYear() % 100, e, 2);
}
function vC(r, e) {
  return r = qE(r), Ie(r.getFullYear() % 100, e, 2);
}
function yC(r, e) {
  return Ie(r.getFullYear() % 1e4, e, 4);
}
function bC(r, e) {
  var t = r.getDay();
  return r = t >= 4 || t === 0 ? zi(r) : zi.ceil(r), Ie(r.getFullYear() % 1e4, e, 4);
}
function xC(r) {
  var e = r.getTimezoneOffset();
  return (e > 0 ? "-" : (e *= -1, "+")) + Ie(e / 60 | 0, "0", 2) + Ie(e % 60, "0", 2);
}
function t0(r, e) {
  return Ie(r.getUTCDate(), e, 2);
}
function EC(r, e) {
  return Ie(r.getUTCHours(), e, 2);
}
function SC(r, e) {
  return Ie(r.getUTCHours() % 12 || 12, e, 2);
}
function TC(r, e) {
  return Ie(1 + Rl.count(ln(r), r), e, 3);
}
function zE(r, e) {
  return Ie(r.getUTCMilliseconds(), e, 3);
}
function AC(r, e) {
  return zE(r, e) + "000";
}
function wC(r, e) {
  return Ie(r.getUTCMonth() + 1, e, 2);
}
function IC(r, e) {
  return Ie(r.getUTCMinutes(), e, 2);
}
function PC(r, e) {
  return Ie(r.getUTCSeconds(), e, 2);
}
function _C(r) {
  var e = r.getUTCDay();
  return e === 0 ? 7 : e;
}
function LC(r, e) {
  return Ie(Cl.count(ln(r) - 1, r), e, 2);
}
function YE(r) {
  var e = r.getUTCDay();
  return e >= 4 || e === 0 ? Yi(r) : Yi.ceil(r);
}
function OC(r, e) {
  return r = YE(r), Ie(Yi.count(ln(r), r) + (ln(r).getUTCDay() === 4), e, 2);
}
function RC(r) {
  return r.getUTCDay();
}
function DC(r, e) {
  return Ie(qo.count(ln(r) - 1, r), e, 2);
}
function CC(r, e) {
  return Ie(r.getUTCFullYear() % 100, e, 2);
}
function kC(r, e) {
  return r = YE(r), Ie(r.getUTCFullYear() % 100, e, 2);
}
function MC(r, e) {
  return Ie(r.getUTCFullYear() % 1e4, e, 4);
}
function NC(r, e) {
  var t = r.getUTCDay();
  return r = t >= 4 || t === 0 ? Yi(r) : Yi.ceil(r), Ie(r.getUTCFullYear() % 1e4, e, 4);
}
function FC() {
  return "+0000";
}
function r0() {
  return "%";
}
function n0(r) {
  return +r;
}
function i0(r) {
  return Math.floor(+r / 1e3);
}
var wi, XE, QE;
$C({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function $C(r) {
  return wi = $D(r), XE = wi.format, wi.parse, QE = wi.utcFormat, wi.utcParse, wi;
}
function BC(r) {
  return new Date(r);
}
function jC(r) {
  return r instanceof Date ? +r : +/* @__PURE__ */ new Date(+r);
}
function kh(r, e, t, n, i, s, a, o, c, l) {
  var u = xh(), d = u.invert, f = u.domain, h = l(".%L"), g = l(":%S"), m = l("%I:%M"), p = l("%I %p"), v = l("%a %d"), y = l("%b %d"), b = l("%B"), x = l("%Y");
  function S(A) {
    return (c(A) < A ? h : o(A) < A ? g : a(A) < A ? m : s(A) < A ? p : n(A) < A ? i(A) < A ? v : y : t(A) < A ? b : x)(A);
  }
  return u.invert = function(A) {
    return new Date(d(A));
  }, u.domain = function(A) {
    return arguments.length ? f(Array.from(A, jC)) : f().map(BC);
  }, u.ticks = function(A) {
    var T = f();
    return r(T[0], T[T.length - 1], A ?? 10);
  }, u.tickFormat = function(A, T) {
    return T == null ? S : l(T);
  }, u.nice = function(A) {
    var T = f();
    return (!A || typeof A.range != "function") && (A = e(T[0], T[T.length - 1], A ?? 10)), A ? f(FE(T, A)) : u;
  }, u.copy = function() {
    return ma(u, kh(r, e, t, n, i, s, a, o, c, l));
  }, u;
}
function UC() {
  return Er.apply(kh(ND, FD, on, Dh, Dl, pa, Oh, _h, ei, XE).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
function GC() {
  return Er.apply(kh(kD, MD, ln, Ch, Cl, Rl, Rh, Lh, ei, QE).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}
function kl() {
  var r = 0, e = 1, t, n, i, s, a = Rt, o = !1, c;
  function l(d) {
    return d == null || isNaN(d = +d) ? c : a(i === 0 ? 0.5 : (d = (s(d) - t) * i, o ? Math.max(0, Math.min(1, d)) : d));
  }
  l.domain = function(d) {
    return arguments.length ? ([r, e] = d, t = s(r = +r), n = s(e = +e), i = t === n ? 0 : 1 / (n - t), l) : [r, e];
  }, l.clamp = function(d) {
    return arguments.length ? (o = !!d, l) : o;
  }, l.interpolator = function(d) {
    return arguments.length ? (a = d, l) : a;
  };
  function u(d) {
    return function(f) {
      var h, g;
      return arguments.length ? ([h, g] = f, a = d(h, g), l) : [a(0), a(1)];
    };
  }
  return l.range = u(ss), l.rangeRound = u(bh), l.unknown = function(d) {
    return arguments.length ? (c = d, l) : c;
  }, function(d) {
    return s = d, t = d(r), n = d(e), i = t === n ? 0 : 1 / (n - t), l;
  };
}
function jn(r, e) {
  return e.domain(r.domain()).interpolator(r.interpolator()).clamp(r.clamp()).unknown(r.unknown());
}
function ZE() {
  var r = Bn(kl()(Rt));
  return r.copy = function() {
    return jn(r, ZE());
  }, vn.apply(r, arguments);
}
function JE() {
  var r = Th(kl()).domain([1, 10]);
  return r.copy = function() {
    return jn(r, JE()).base(r.base());
  }, vn.apply(r, arguments);
}
function eS() {
  var r = Ah(kl());
  return r.copy = function() {
    return jn(r, eS()).constant(r.constant());
  }, vn.apply(r, arguments);
}
function Mh() {
  var r = wh(kl());
  return r.copy = function() {
    return jn(r, Mh()).exponent(r.exponent());
  }, vn.apply(r, arguments);
}
function KC() {
  return Mh.apply(null, arguments).exponent(0.5);
}
function tS() {
  var r = [], e = Rt;
  function t(n) {
    if (n != null && !isNaN(n = +n)) return e((ha(r, n, 1) - 1) / (r.length - 1));
  }
  return t.domain = function(n) {
    if (!arguments.length) return r.slice();
    r = [];
    for (let i of n) i != null && !isNaN(i = +i) && r.push(i);
    return r.sort(Cn), t;
  }, t.interpolator = function(n) {
    return arguments.length ? (e = n, t) : e;
  }, t.range = function() {
    return r.map((n, i) => e(i / (r.length - 1)));
  }, t.quantiles = function(n) {
    return Array.from({ length: n + 1 }, (i, s) => _R(r, s / n));
  }, t.copy = function() {
    return tS(e).domain(r);
  }, vn.apply(t, arguments);
}
function Ml() {
  var r = 0, e = 0.5, t = 1, n = 1, i, s, a, o, c, l = Rt, u, d = !1, f;
  function h(m) {
    return isNaN(m = +m) ? f : (m = 0.5 + ((m = +u(m)) - s) * (n * m < n * s ? o : c), l(d ? Math.max(0, Math.min(1, m)) : m));
  }
  h.domain = function(m) {
    return arguments.length ? ([r, e, t] = m, i = u(r = +r), s = u(e = +e), a = u(t = +t), o = i === s ? 0 : 0.5 / (s - i), c = s === a ? 0 : 0.5 / (a - s), n = s < i ? -1 : 1, h) : [r, e, t];
  }, h.clamp = function(m) {
    return arguments.length ? (d = !!m, h) : d;
  }, h.interpolator = function(m) {
    return arguments.length ? (l = m, h) : l;
  };
  function g(m) {
    return function(p) {
      var v, y, b;
      return arguments.length ? ([v, y, b] = p, l = tD(m, [v, y, b]), h) : [l(0), l(0.5), l(1)];
    };
  }
  return h.range = g(ss), h.rangeRound = g(bh), h.unknown = function(m) {
    return arguments.length ? (f = m, h) : f;
  }, function(m) {
    return u = m, i = m(r), s = m(e), a = m(t), o = i === s ? 0 : 0.5 / (s - i), c = s === a ? 0 : 0.5 / (a - s), n = s < i ? -1 : 1, h;
  };
}
function rS() {
  var r = Bn(Ml()(Rt));
  return r.copy = function() {
    return jn(r, rS());
  }, vn.apply(r, arguments);
}
function nS() {
  var r = Th(Ml()).domain([0.1, 1, 10]);
  return r.copy = function() {
    return jn(r, nS()).base(r.base());
  }, vn.apply(r, arguments);
}
function iS() {
  var r = Ah(Ml());
  return r.copy = function() {
    return jn(r, iS()).constant(r.constant());
  }, vn.apply(r, arguments);
}
function Nh() {
  var r = wh(Ml());
  return r.copy = function() {
    return jn(r, Nh()).exponent(r.exponent());
  }, vn.apply(r, arguments);
}
function VC() {
  return Nh.apply(null, arguments).exponent(0.5);
}
const Ds = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  scaleBand: ph,
  scaleDiverging: rS,
  scaleDivergingLog: nS,
  scaleDivergingPow: Nh,
  scaleDivergingSqrt: VC,
  scaleDivergingSymlog: iS,
  scaleIdentity: NE,
  scaleImplicit: Kd,
  scaleLinear: ME,
  scaleLog: $E,
  scaleOrdinal: mh,
  scalePoint: RR,
  scalePow: Ih,
  scaleQuantile: UE,
  scaleQuantize: GE,
  scaleRadial: jE,
  scaleSequential: ZE,
  scaleSequentialLog: JE,
  scaleSequentialPow: Mh,
  scaleSequentialQuantile: tS,
  scaleSequentialSqrt: KC,
  scaleSequentialSymlog: eS,
  scaleSqrt: AD,
  scaleSymlog: BE,
  scaleThreshold: KE,
  scaleTime: UC,
  scaleUtc: GC,
  tickFormat: kE
}, Symbol.toStringTag, { value: "Module" }));
var yi = (r) => r.chartData, Fh = M([yi], (r) => {
  var e = r.chartData != null ? r.chartData.length - 1 : 0;
  return {
    chartData: r.chartData,
    computedData: r.computedData,
    dataEndIndex: e,
    dataStartIndex: 0
  };
}), va = (r, e, t, n) => n ? Fh(r) : yi(r);
function Xi(r) {
  if (Array.isArray(r) && r.length === 2) {
    var [e, t] = r;
    if (Tt(e) && Tt(t))
      return !0;
  }
  return !1;
}
function s0(r, e, t) {
  return t ? r : [Math.min(r[0], e[0]), Math.max(r[1], e[1])];
}
function WC(r, e) {
  if (e && typeof r != "function" && Array.isArray(r) && r.length === 2) {
    var [t, n] = r, i, s;
    if (Tt(t))
      i = t;
    else if (typeof t == "function")
      return;
    if (Tt(n))
      s = n;
    else if (typeof n == "function")
      return;
    var a = [i, s];
    if (Xi(a))
      return a;
  }
}
function HC(r, e, t) {
  if (!(!t && e == null)) {
    if (typeof r == "function" && e != null)
      try {
        var n = r(e, t);
        if (Xi(n))
          return s0(n, e, t);
      } catch {
      }
    if (Array.isArray(r) && r.length === 2) {
      var [i, s] = r, a, o;
      if (i === "auto")
        e != null && (a = Math.min(...e));
      else if (z(i))
        a = i;
      else if (typeof i == "function")
        try {
          e != null && (a = i(e == null ? void 0 : e[0]));
        } catch {
        }
      else if (typeof i == "string" && Hp.test(i)) {
        var c = Hp.exec(i);
        if (c == null || e == null)
          a = void 0;
        else {
          var l = +c[1];
          a = e[0] - l;
        }
      } else
        a = e == null ? void 0 : e[0];
      if (s === "auto")
        e != null && (o = Math.max(...e));
      else if (z(s))
        o = s;
      else if (typeof s == "function")
        try {
          e != null && (o = s(e == null ? void 0 : e[1]));
        } catch {
        }
      else if (typeof s == "string" && qp.test(s)) {
        var u = qp.exec(s);
        if (u == null || e == null)
          o = void 0;
        else {
          var d = +u[1];
          o = e[1] + d;
        }
      } else
        o = e == null ? void 0 : e[1];
      var f = [a, o];
      if (Xi(f))
        return e == null ? f : s0(f, e, t);
    }
  }
}
var as = 1e9, qC = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed during run-time using `Decimal.config`.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used by default by `toInteger`, `toDecimalPlaces`, `toExponential`,
  // `toFixed`, `toPrecision` and `toSignificantDigits`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -MAX_E
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to MAX_E
  // The natural logarithm of 10.
  // 115 digits
  LN10: "2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286"
}, Bh, qe = !0, pr = "[DecimalError] ", li = pr + "Invalid argument: ", $h = pr + "Exponent out of range: ", os = Math.floor, zn = Math.pow, zC = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, Zt, mt = 1e7, Ve = 7, sS = 9007199254740991, zo = os(sS / Ve), J = {};
J.absoluteValue = J.abs = function() {
  var r = new this.constructor(this);
  return r.s && (r.s = 1), r;
};
J.comparedTo = J.cmp = function(r) {
  var e, t, n, i, s = this;
  if (r = new s.constructor(r), s.s !== r.s) return s.s || -r.s;
  if (s.e !== r.e) return s.e > r.e ^ s.s < 0 ? 1 : -1;
  for (n = s.d.length, i = r.d.length, e = 0, t = n < i ? n : i; e < t; ++e)
    if (s.d[e] !== r.d[e]) return s.d[e] > r.d[e] ^ s.s < 0 ? 1 : -1;
  return n === i ? 0 : n > i ^ s.s < 0 ? 1 : -1;
};
J.decimalPlaces = J.dp = function() {
  var r = this, e = r.d.length - 1, t = (e - r.e) * Ve;
  if (e = r.d[e], e) for (; e % 10 == 0; e /= 10) t--;
  return t < 0 ? 0 : t;
};
J.dividedBy = J.div = function(r) {
  return rn(this, new this.constructor(r));
};
J.dividedToIntegerBy = J.idiv = function(r) {
  var e = this, t = e.constructor;
  return Ue(rn(e, new t(r), 0, 1), t.precision);
};
J.equals = J.eq = function(r) {
  return !this.cmp(r);
};
J.exponent = function() {
  return at(this);
};
J.greaterThan = J.gt = function(r) {
  return this.cmp(r) > 0;
};
J.greaterThanOrEqualTo = J.gte = function(r) {
  return this.cmp(r) >= 0;
};
J.isInteger = J.isint = function() {
  return this.e > this.d.length - 2;
};
J.isNegative = J.isneg = function() {
  return this.s < 0;
};
J.isPositive = J.ispos = function() {
  return this.s > 0;
};
J.isZero = function() {
  return this.s === 0;
};
J.lessThan = J.lt = function(r) {
  return this.cmp(r) < 0;
};
J.lessThanOrEqualTo = J.lte = function(r) {
  return this.cmp(r) < 1;
};
J.logarithm = J.log = function(r) {
  var e, t = this, n = t.constructor, i = n.precision, s = i + 5;
  if (r === void 0)
    r = new n(10);
  else if (r = new n(r), r.s < 1 || r.eq(Zt)) throw Error(pr + "NaN");
  if (t.s < 1) throw Error(pr + (t.s ? "NaN" : "-Infinity"));
  return t.eq(Zt) ? new n(0) : (qe = !1, e = rn(Ys(t, s), Ys(r, s), s), qe = !0, Ue(e, i));
};
J.minus = J.sub = function(r) {
  var e = this;
  return r = new e.constructor(r), e.s == r.s ? lS(e, r) : aS(e, (r.s = -r.s, r));
};
J.modulo = J.mod = function(r) {
  var e, t = this, n = t.constructor, i = n.precision;
  if (r = new n(r), !r.s) throw Error(pr + "NaN");
  return t.s ? (qe = !1, e = rn(t, r, 0, 1).times(r), qe = !0, t.minus(e)) : Ue(new n(t), i);
};
J.naturalExponential = J.exp = function() {
  return oS(this);
};
J.naturalLogarithm = J.ln = function() {
  return Ys(this);
};
J.negated = J.neg = function() {
  var r = new this.constructor(this);
  return r.s = -r.s || 0, r;
};
J.plus = J.add = function(r) {
  var e = this;
  return r = new e.constructor(r), e.s == r.s ? aS(e, r) : lS(e, (r.s = -r.s, r));
};
J.precision = J.sd = function(r) {
  var e, t, n, i = this;
  if (r !== void 0 && r !== !!r && r !== 1 && r !== 0) throw Error(li + r);
  if (e = at(i) + 1, n = i.d.length - 1, t = n * Ve + 1, n = i.d[n], n) {
    for (; n % 10 == 0; n /= 10) t--;
    for (n = i.d[0]; n >= 10; n /= 10) t++;
  }
  return r && e > t ? e : t;
};
J.squareRoot = J.sqrt = function() {
  var r, e, t, n, i, s, a, o = this, c = o.constructor;
  if (o.s < 1) {
    if (!o.s) return new c(0);
    throw Error(pr + "NaN");
  }
  for (r = at(o), qe = !1, i = Math.sqrt(+o), i == 0 || i == 1 / 0 ? (e = kr(o.d), (e.length + r) % 2 == 0 && (e += "0"), i = Math.sqrt(e), r = os((r + 1) / 2) - (r < 0 || r % 2), i == 1 / 0 ? e = "5e" + r : (e = i.toExponential(), e = e.slice(0, e.indexOf("e") + 1) + r), n = new c(e)) : n = new c(i.toString()), t = c.precision, i = a = t + 3; ; )
    if (s = n, n = s.plus(rn(o, s, a + 2)).times(0.5), kr(s.d).slice(0, a) === (e = kr(n.d)).slice(0, a)) {
      if (e = e.slice(a - 3, a + 1), i == a && e == "4999") {
        if (Ue(s, t + 1, 0), s.times(s).eq(o)) {
          n = s;
          break;
        }
      } else if (e != "9999")
        break;
      a += 4;
    }
  return qe = !0, Ue(n, t);
};
J.times = J.mul = function(r) {
  var e, t, n, i, s, a, o, c, l, u = this, d = u.constructor, f = u.d, h = (r = new d(r)).d;
  if (!u.s || !r.s) return new d(0);
  for (r.s *= u.s, t = u.e + r.e, c = f.length, l = h.length, c < l && (s = f, f = h, h = s, a = c, c = l, l = a), s = [], a = c + l, n = a; n--; ) s.push(0);
  for (n = l; --n >= 0; ) {
    for (e = 0, i = c + n; i > n; )
      o = s[i] + h[n] * f[i - n - 1] + e, s[i--] = o % mt | 0, e = o / mt | 0;
    s[i] = (s[i] + e) % mt | 0;
  }
  for (; !s[--a]; ) s.pop();
  return e ? ++t : s.shift(), r.d = s, r.e = t, qe ? Ue(r, d.precision) : r;
};
J.toDecimalPlaces = J.todp = function(r, e) {
  var t = this, n = t.constructor;
  return t = new n(t), r === void 0 ? t : (Ur(r, 0, as), e === void 0 ? e = n.rounding : Ur(e, 0, 8), Ue(t, r + at(t) + 1, e));
};
J.toExponential = function(r, e) {
  var t, n = this, i = n.constructor;
  return r === void 0 ? t = hi(n, !0) : (Ur(r, 0, as), e === void 0 ? e = i.rounding : Ur(e, 0, 8), n = Ue(new i(n), r + 1, e), t = hi(n, !0, r + 1)), t;
};
J.toFixed = function(r, e) {
  var t, n, i = this, s = i.constructor;
  return r === void 0 ? hi(i) : (Ur(r, 0, as), e === void 0 ? e = s.rounding : Ur(e, 0, 8), n = Ue(new s(i), r + at(i) + 1, e), t = hi(n.abs(), !1, r + at(n) + 1), i.isneg() && !i.isZero() ? "-" + t : t);
};
J.toInteger = J.toint = function() {
  var r = this, e = r.constructor;
  return Ue(new e(r), at(r) + 1, e.rounding);
};
J.toNumber = function() {
  return +this;
};
J.toPower = J.pow = function(r) {
  var e, t, n, i, s, a, o = this, c = o.constructor, l = 12, u = +(r = new c(r));
  if (!r.s) return new c(Zt);
  if (o = new c(o), !o.s) {
    if (r.s < 1) throw Error(pr + "Infinity");
    return o;
  }
  if (o.eq(Zt)) return o;
  if (n = c.precision, r.eq(Zt)) return Ue(o, n);
  if (e = r.e, t = r.d.length - 1, a = e >= t, s = o.s, a) {
    if ((t = u < 0 ? -u : u) <= sS) {
      for (i = new c(Zt), e = Math.ceil(n / Ve + 4), qe = !1; t % 2 && (i = i.times(o), o0(i.d, e)), t = os(t / 2), t !== 0; )
        o = o.times(o), o0(o.d, e);
      return qe = !0, r.s < 0 ? new c(Zt).div(i) : Ue(i, n);
    }
  } else if (s < 0) throw Error(pr + "NaN");
  return s = s < 0 && r.d[Math.max(e, t)] & 1 ? -1 : 1, o.s = 1, qe = !1, i = r.times(Ys(o, n + l)), qe = !0, i = oS(i), i.s = s, i;
};
J.toPrecision = function(r, e) {
  var t, n, i = this, s = i.constructor;
  return r === void 0 ? (t = at(i), n = hi(i, t <= s.toExpNeg || t >= s.toExpPos)) : (Ur(r, 1, as), e === void 0 ? e = s.rounding : Ur(e, 0, 8), i = Ue(new s(i), r, e), t = at(i), n = hi(i, r <= t || t <= s.toExpNeg, r)), n;
};
J.toSignificantDigits = J.tosd = function(r, e) {
  var t = this, n = t.constructor;
  return r === void 0 ? (r = n.precision, e = n.rounding) : (Ur(r, 1, as), e === void 0 ? e = n.rounding : Ur(e, 0, 8)), Ue(new n(t), r, e);
};
J.toString = J.valueOf = J.val = J.toJSON = J[Symbol.for("nodejs.util.inspect.custom")] = function() {
  var r = this, e = at(r), t = r.constructor;
  return hi(r, e <= t.toExpNeg || e >= t.toExpPos);
};
function aS(r, e) {
  var t, n, i, s, a, o, c, l, u = r.constructor, d = u.precision;
  if (!r.s || !e.s)
    return e.s || (e = new u(r)), qe ? Ue(e, d) : e;
  if (c = r.d, l = e.d, a = r.e, i = e.e, c = c.slice(), s = a - i, s) {
    for (s < 0 ? (n = c, s = -s, o = l.length) : (n = l, i = a, o = c.length), a = Math.ceil(d / Ve), o = a > o ? a + 1 : o + 1, s > o && (s = o, n.length = 1), n.reverse(); s--; ) n.push(0);
    n.reverse();
  }
  for (o = c.length, s = l.length, o - s < 0 && (s = o, n = l, l = c, c = n), t = 0; s; )
    t = (c[--s] = c[s] + l[s] + t) / mt | 0, c[s] %= mt;
  for (t && (c.unshift(t), ++i), o = c.length; c[--o] == 0; ) c.pop();
  return e.d = c, e.e = i, qe ? Ue(e, d) : e;
}
function Ur(r, e, t) {
  if (r !== ~~r || r < e || r > t)
    throw Error(li + r);
}
function kr(r) {
  var e, t, n, i = r.length - 1, s = "", a = r[0];
  if (i > 0) {
    for (s += a, e = 1; e < i; e++)
      n = r[e] + "", t = Ve - n.length, t && (s += Pn(t)), s += n;
    a = r[e], n = a + "", t = Ve - n.length, t && (s += Pn(t));
  } else if (a === 0)
    return "0";
  for (; a % 10 === 0; ) a /= 10;
  return s + a;
}
var rn = /* @__PURE__ */ function() {
  function r(n, i) {
    var s, a = 0, o = n.length;
    for (n = n.slice(); o--; )
      s = n[o] * i + a, n[o] = s % mt | 0, a = s / mt | 0;
    return a && n.unshift(a), n;
  }
  function e(n, i, s, a) {
    var o, c;
    if (s != a)
      c = s > a ? 1 : -1;
    else
      for (o = c = 0; o < s; o++)
        if (n[o] != i[o]) {
          c = n[o] > i[o] ? 1 : -1;
          break;
        }
    return c;
  }
  function t(n, i, s) {
    for (var a = 0; s--; )
      n[s] -= a, a = n[s] < i[s] ? 1 : 0, n[s] = a * mt + n[s] - i[s];
    for (; !n[0] && n.length > 1; ) n.shift();
  }
  return function(n, i, s, a) {
    var o, c, l, u, d, f, h, g, m, p, v, y, b, x, S, A, T, I, L = n.constructor, _ = n.s == i.s ? 1 : -1, R = n.d, D = i.d;
    if (!n.s) return new L(n);
    if (!i.s) throw Error(pr + "Division by zero");
    for (c = n.e - i.e, T = D.length, S = R.length, h = new L(_), g = h.d = [], l = 0; D[l] == (R[l] || 0); ) ++l;
    if (D[l] > (R[l] || 0) && --c, s == null ? y = s = L.precision : a ? y = s + (at(n) - at(i)) + 1 : y = s, y < 0) return new L(0);
    if (y = y / Ve + 2 | 0, l = 0, T == 1)
      for (u = 0, D = D[0], y++; (l < S || u) && y--; l++)
        b = u * mt + (R[l] || 0), g[l] = b / D | 0, u = b % D | 0;
    else {
      for (u = mt / (D[0] + 1) | 0, u > 1 && (D = r(D, u), R = r(R, u), T = D.length, S = R.length), x = T, m = R.slice(0, T), p = m.length; p < T; ) m[p++] = 0;
      I = D.slice(), I.unshift(0), A = D[0], D[1] >= mt / 2 && ++A;
      do
        u = 0, o = e(D, m, T, p), o < 0 ? (v = m[0], T != p && (v = v * mt + (m[1] || 0)), u = v / A | 0, u > 1 ? (u >= mt && (u = mt - 1), d = r(D, u), f = d.length, p = m.length, o = e(d, m, f, p), o == 1 && (u--, t(d, T < f ? I : D, f))) : (u == 0 && (o = u = 1), d = D.slice()), f = d.length, f < p && d.unshift(0), t(m, d, p), o == -1 && (p = m.length, o = e(D, m, T, p), o < 1 && (u++, t(m, T < p ? I : D, p))), p = m.length) : o === 0 && (u++, m = [0]), g[l++] = u, o && m[0] ? m[p++] = R[x] || 0 : (m = [R[x]], p = 1);
      while ((x++ < S || m[0] !== void 0) && y--);
    }
    return g[0] || g.shift(), h.e = c, Ue(h, a ? s + at(h) + 1 : s);
  };
}();
function oS(r, e) {
  var t, n, i, s, a, o, c = 0, l = 0, u = r.constructor, d = u.precision;
  if (at(r) > 16) throw Error($h + at(r));
  if (!r.s) return new u(Zt);
  for (qe = !1, o = d, a = new u(0.03125); r.abs().gte(0.1); )
    r = r.times(a), l += 5;
  for (n = Math.log(zn(2, l)) / Math.LN10 * 2 + 5 | 0, o += n, t = i = s = new u(Zt), u.precision = o; ; ) {
    if (i = Ue(i.times(r), o), t = t.times(++c), a = s.plus(rn(i, t, o)), kr(a.d).slice(0, o) === kr(s.d).slice(0, o)) {
      for (; l--; ) s = Ue(s.times(s), o);
      return u.precision = d, e == null ? (qe = !0, Ue(s, d)) : s;
    }
    s = a;
  }
}
function at(r) {
  for (var e = r.e * Ve, t = r.d[0]; t >= 10; t /= 10) e++;
  return e;
}
function _u(r, e, t) {
  if (e > r.LN10.sd())
    throw qe = !0, t && (r.precision = t), Error(pr + "LN10 precision limit exceeded");
  return Ue(new r(r.LN10), e);
}
function Pn(r) {
  for (var e = ""; r--; ) e += "0";
  return e;
}
function Ys(r, e) {
  var t, n, i, s, a, o, c, l, u, d = 1, f = 10, h = r, g = h.d, m = h.constructor, p = m.precision;
  if (h.s < 1) throw Error(pr + (h.s ? "NaN" : "-Infinity"));
  if (h.eq(Zt)) return new m(0);
  if (e == null ? (qe = !1, l = p) : l = e, h.eq(10))
    return e == null && (qe = !0), _u(m, l);
  if (l += f, m.precision = l, t = kr(g), n = t.charAt(0), s = at(h), Math.abs(s) < 15e14) {
    for (; n < 7 && n != 1 || n == 1 && t.charAt(1) > 3; )
      h = h.times(r), t = kr(h.d), n = t.charAt(0), d++;
    s = at(h), n > 1 ? (h = new m("0." + t), s++) : h = new m(n + "." + t.slice(1));
  } else
    return c = _u(m, l + 2, p).times(s + ""), h = Ys(new m(n + "." + t.slice(1)), l - f).plus(c), m.precision = p, e == null ? (qe = !0, Ue(h, p)) : h;
  for (o = a = h = rn(h.minus(Zt), h.plus(Zt), l), u = Ue(h.times(h), l), i = 3; ; ) {
    if (a = Ue(a.times(u), l), c = o.plus(rn(a, new m(i), l)), kr(c.d).slice(0, l) === kr(o.d).slice(0, l))
      return o = o.times(2), s !== 0 && (o = o.plus(_u(m, l + 2, p).times(s + ""))), o = rn(o, new m(d), l), m.precision = p, e == null ? (qe = !0, Ue(o, p)) : o;
    o = c, i += 2;
  }
}
function a0(r, e) {
  var t, n, i;
  for ((t = e.indexOf(".")) > -1 && (e = e.replace(".", "")), (n = e.search(/e/i)) > 0 ? (t < 0 && (t = n), t += +e.slice(n + 1), e = e.substring(0, n)) : t < 0 && (t = e.length), n = 0; e.charCodeAt(n) === 48; ) ++n;
  for (i = e.length; e.charCodeAt(i - 1) === 48; ) --i;
  if (e = e.slice(n, i), e) {
    if (i -= n, t = t - n - 1, r.e = os(t / Ve), r.d = [], n = (t + 1) % Ve, t < 0 && (n += Ve), n < i) {
      for (n && r.d.push(+e.slice(0, n)), i -= Ve; n < i; ) r.d.push(+e.slice(n, n += Ve));
      e = e.slice(n), n = Ve - e.length;
    } else
      n -= i;
    for (; n--; ) e += "0";
    if (r.d.push(+e), qe && (r.e > zo || r.e < -zo)) throw Error($h + t);
  } else
    r.s = 0, r.e = 0, r.d = [0];
  return r;
}
function Ue(r, e, t) {
  var n, i, s, a, o, c, l, u, d = r.d;
  for (a = 1, s = d[0]; s >= 10; s /= 10) a++;
  if (n = e - a, n < 0)
    n += Ve, i = e, l = d[u = 0];
  else {
    if (u = Math.ceil((n + 1) / Ve), s = d.length, u >= s) return r;
    for (l = s = d[u], a = 1; s >= 10; s /= 10) a++;
    n %= Ve, i = n - Ve + a;
  }
  if (t !== void 0 && (s = zn(10, a - i - 1), o = l / s % 10 | 0, c = e < 0 || d[u + 1] !== void 0 || l % s, c = t < 4 ? (o || c) && (t == 0 || t == (r.s < 0 ? 3 : 2)) : o > 5 || o == 5 && (t == 4 || c || t == 6 && // Check whether the digit to the left of the rounding digit is odd.
  (n > 0 ? i > 0 ? l / zn(10, a - i) : 0 : d[u - 1]) % 10 & 1 || t == (r.s < 0 ? 8 : 7))), e < 1 || !d[0])
    return c ? (s = at(r), d.length = 1, e = e - s - 1, d[0] = zn(10, (Ve - e % Ve) % Ve), r.e = os(-e / Ve) || 0) : (d.length = 1, d[0] = r.e = r.s = 0), r;
  if (n == 0 ? (d.length = u, s = 1, u--) : (d.length = u + 1, s = zn(10, Ve - n), d[u] = i > 0 ? (l / zn(10, a - i) % zn(10, i) | 0) * s : 0), c)
    for (; ; )
      if (u == 0) {
        (d[0] += s) == mt && (d[0] = 1, ++r.e);
        break;
      } else {
        if (d[u] += s, d[u] != mt) break;
        d[u--] = 0, s = 1;
      }
  for (n = d.length; d[--n] === 0; ) d.pop();
  if (qe && (r.e > zo || r.e < -zo))
    throw Error($h + at(r));
  return r;
}
function lS(r, e) {
  var t, n, i, s, a, o, c, l, u, d, f = r.constructor, h = f.precision;
  if (!r.s || !e.s)
    return e.s ? e.s = -e.s : e = new f(r), qe ? Ue(e, h) : e;
  if (c = r.d, d = e.d, n = e.e, l = r.e, c = c.slice(), a = l - n, a) {
    for (u = a < 0, u ? (t = c, a = -a, o = d.length) : (t = d, n = l, o = c.length), i = Math.max(Math.ceil(h / Ve), o) + 2, a > i && (a = i, t.length = 1), t.reverse(), i = a; i--; ) t.push(0);
    t.reverse();
  } else {
    for (i = c.length, o = d.length, u = i < o, u && (o = i), i = 0; i < o; i++)
      if (c[i] != d[i]) {
        u = c[i] < d[i];
        break;
      }
    a = 0;
  }
  for (u && (t = c, c = d, d = t, e.s = -e.s), o = c.length, i = d.length - o; i > 0; --i) c[o++] = 0;
  for (i = d.length; i > a; ) {
    if (c[--i] < d[i]) {
      for (s = i; s && c[--s] === 0; ) c[s] = mt - 1;
      --c[s], c[i] += mt;
    }
    c[i] -= d[i];
  }
  for (; c[--o] === 0; ) c.pop();
  for (; c[0] === 0; c.shift()) --n;
  return c[0] ? (e.d = c, e.e = n, qe ? Ue(e, h) : e) : new f(0);
}
function hi(r, e, t) {
  var n, i = at(r), s = kr(r.d), a = s.length;
  return e ? (t && (n = t - a) > 0 ? s = s.charAt(0) + "." + s.slice(1) + Pn(n) : a > 1 && (s = s.charAt(0) + "." + s.slice(1)), s = s + (i < 0 ? "e" : "e+") + i) : i < 0 ? (s = "0." + Pn(-i - 1) + s, t && (n = t - a) > 0 && (s += Pn(n))) : i >= a ? (s += Pn(i + 1 - a), t && (n = t - i - 1) > 0 && (s = s + "." + Pn(n))) : ((n = i + 1) < a && (s = s.slice(0, n) + "." + s.slice(n)), t && (n = t - a) > 0 && (i + 1 === a && (s += "."), s += Pn(n))), r.s < 0 ? "-" + s : s;
}
function o0(r, e) {
  if (r.length > e)
    return r.length = e, !0;
}
function cS(r) {
  var e, t, n;
  function i(s) {
    var a = this;
    if (!(a instanceof i)) return new i(s);
    if (a.constructor = i, s instanceof i) {
      a.s = s.s, a.e = s.e, a.d = (s = s.d) ? s.slice() : s;
      return;
    }
    if (typeof s == "number") {
      if (s * 0 !== 0)
        throw Error(li + s);
      if (s > 0)
        a.s = 1;
      else if (s < 0)
        s = -s, a.s = -1;
      else {
        a.s = 0, a.e = 0, a.d = [0];
        return;
      }
      if (s === ~~s && s < 1e7) {
        a.e = 0, a.d = [s];
        return;
      }
      return a0(a, s.toString());
    } else if (typeof s != "string")
      throw Error(li + s);
    if (s.charCodeAt(0) === 45 ? (s = s.slice(1), a.s = -1) : a.s = 1, zC.test(s)) a0(a, s);
    else throw Error(li + s);
  }
  if (i.prototype = J, i.ROUND_UP = 0, i.ROUND_DOWN = 1, i.ROUND_CEIL = 2, i.ROUND_FLOOR = 3, i.ROUND_HALF_UP = 4, i.ROUND_HALF_DOWN = 5, i.ROUND_HALF_EVEN = 6, i.ROUND_HALF_CEIL = 7, i.ROUND_HALF_FLOOR = 8, i.clone = cS, i.config = i.set = YC, r === void 0 && (r = {}), r)
    for (n = ["precision", "rounding", "toExpNeg", "toExpPos", "LN10"], e = 0; e < n.length; ) r.hasOwnProperty(t = n[e++]) || (r[t] = this[t]);
  return i.config(r), i;
}
function YC(r) {
  if (!r || typeof r != "object")
    throw Error(pr + "Object expected");
  var e, t, n, i = [
    "precision",
    1,
    as,
    "rounding",
    0,
    8,
    "toExpNeg",
    -1 / 0,
    0,
    "toExpPos",
    0,
    1 / 0
  ];
  for (e = 0; e < i.length; e += 3)
    if ((n = r[t = i[e]]) !== void 0)
      if (os(n) === n && n >= i[e + 1] && n <= i[e + 2]) this[t] = n;
      else throw Error(li + t + ": " + n);
  if ((n = r[t = "LN10"]) !== void 0)
    if (n == Math.LN10) this[t] = new this(n);
    else throw Error(li + t + ": " + n);
  return this;
}
var Bh = cS(qC);
Zt = new Bh(1);
const De = Bh;
var XC = (r) => r, uS = {}, dS = (r) => r === uS, l0 = (r) => function e() {
  return arguments.length === 0 || arguments.length === 1 && dS(arguments.length <= 0 ? void 0 : arguments[0]) ? e : r(...arguments);
}, fS = (r, e) => r === 1 ? e : l0(function() {
  for (var t = arguments.length, n = new Array(t), i = 0; i < t; i++)
    n[i] = arguments[i];
  var s = n.filter((a) => a !== uS).length;
  return s >= r ? e(...n) : fS(r - s, l0(function() {
    for (var a = arguments.length, o = new Array(a), c = 0; c < a; c++)
      o[c] = arguments[c];
    var l = n.map((u) => dS(u) ? o.shift() : u);
    return e(...l, ...o);
  }));
}), Nl = (r) => fS(r.length, r), qd = (r, e) => {
  for (var t = [], n = r; n < e; ++n)
    t[n - r] = n;
  return t;
}, QC = Nl((r, e) => Array.isArray(e) ? e.map(r) : Object.keys(e).map((t) => e[t]).map(r)), ZC = function() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  if (!t.length)
    return XC;
  var i = t.reverse(), s = i[0], a = i.slice(1);
  return function() {
    return a.reduce((o, c) => c(o), s(...arguments));
  };
}, zd = (r) => Array.isArray(r) ? r.reverse() : r.split("").reverse().join(""), hS = (r) => {
  var e = null, t = null;
  return function() {
    for (var n = arguments.length, i = new Array(n), s = 0; s < n; s++)
      i[s] = arguments[s];
    return e && i.every((a, o) => {
      var c;
      return a === ((c = e) === null || c === void 0 ? void 0 : c[o]);
    }) || (e = i, t = r(...i)), t;
  };
};
function gS(r) {
  var e;
  return r === 0 ? e = 1 : e = Math.floor(new De(r).abs().log(10).toNumber()) + 1, e;
}
function mS(r, e, t) {
  for (var n = new De(r), i = 0, s = []; n.lt(e) && i < 1e5; )
    s.push(n.toNumber()), n = n.add(t), i++;
  return s;
}
Nl((r, e, t) => {
  var n = +r, i = +e;
  return n + t * (i - n);
});
Nl((r, e, t) => {
  var n = e - +r;
  return n = n || 1 / 0, (t - r) / n;
});
Nl((r, e, t) => {
  var n = e - +r;
  return n = n || 1 / 0, Math.max(0, Math.min(1, (t - r) / n));
});
var pS = (r) => {
  var [e, t] = r, [n, i] = [e, t];
  return e > t && ([n, i] = [t, e]), [n, i];
}, vS = (r, e, t) => {
  if (r.lte(0))
    return new De(0);
  var n = gS(r.toNumber()), i = new De(10).pow(n), s = r.div(i), a = n !== 1 ? 0.05 : 0.1, o = new De(Math.ceil(s.div(a).toNumber())).add(t).mul(a), c = o.mul(i);
  return e ? new De(c.toNumber()) : new De(Math.ceil(c.toNumber()));
}, JC = (r, e, t) => {
  var n = new De(1), i = new De(r);
  if (!i.isint() && t) {
    var s = Math.abs(r);
    s < 1 ? (n = new De(10).pow(gS(r) - 1), i = new De(Math.floor(i.div(n).toNumber())).mul(n)) : s > 1 && (i = new De(Math.floor(r)));
  } else r === 0 ? i = new De(Math.floor((e - 1) / 2)) : t || (i = new De(Math.floor(r)));
  var a = Math.floor((e - 1) / 2), o = ZC(QC((c) => i.add(new De(c - a).mul(n)).toNumber()), qd);
  return o(0, e);
}, yS = function(e, t, n, i) {
  var s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
  if (!Number.isFinite((t - e) / (n - 1)))
    return {
      step: new De(0),
      tickMin: new De(0),
      tickMax: new De(0)
    };
  var a = vS(new De(t).sub(e).div(n - 1), i, s), o;
  e <= 0 && t >= 0 ? o = new De(0) : (o = new De(e).add(t).div(2), o = o.sub(new De(o).mod(a)));
  var c = Math.ceil(o.sub(e).div(a).toNumber()), l = Math.ceil(new De(t).sub(o).div(a).toNumber()), u = c + l + 1;
  return u > n ? yS(e, t, n, i, s + 1) : (u < n && (l = t > 0 ? l + (n - u) : l, c = t > 0 ? c : c + (n - u)), {
    step: a,
    tickMin: o.sub(new De(c).mul(a)),
    tickMax: o.add(new De(l).mul(a))
  });
};
function ek(r) {
  var [e, t] = r, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 6, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, s = Math.max(n, 2), [a, o] = pS([e, t]);
  if (a === -1 / 0 || o === 1 / 0) {
    var c = o === 1 / 0 ? [a, ...qd(0, n - 1).map(() => 1 / 0)] : [...qd(0, n - 1).map(() => -1 / 0), o];
    return e > t ? zd(c) : c;
  }
  if (a === o)
    return JC(a, n, i);
  var {
    step: l,
    tickMin: u,
    tickMax: d
  } = yS(a, o, s, i, 0), f = mS(u, d.add(new De(0.1).mul(l)), l);
  return e > t ? zd(f) : f;
}
function tk(r, e) {
  var [t, n] = r, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, [s, a] = pS([t, n]);
  if (s === -1 / 0 || a === 1 / 0)
    return [t, n];
  if (s === a)
    return [s];
  var o = Math.max(e, 2), c = vS(new De(a).sub(s).div(o - 1), i, 0), l = [...mS(new De(s), new De(a), c), a];
  return i === !1 && (l = l.map((u) => Math.round(u))), t > n ? zd(l) : l;
}
var rk = hS(ek), nk = hS(tk), bS = (r) => r.rootProps.maxBarSize, ik = (r) => r.rootProps.barGap, xS = (r) => r.rootProps.barCategoryGap, sk = (r) => r.rootProps.barSize, ya = (r) => r.rootProps.stackOffset, jh = (r) => r.options.chartName, Uh = (r) => r.rootProps.syncId, ES = (r) => r.rootProps.syncMethod, Gh = (r) => r.options.eventEmitter, Xr = {
  allowDuplicatedCategory: !0,
  // if I set this to false then Tooltip synchronisation stops working in Radar, wtf
  angleAxisId: 0,
  reversed: !1,
  scale: "auto",
  tick: !0,
  type: "category"
}, Yt = {
  allowDataOverflow: !1,
  allowDuplicatedCategory: !0,
  radiusAxisId: 0,
  scale: "auto",
  tick: !0,
  tickCount: 5,
  type: "number"
}, Fl = (r, e) => {
  if (!(!r || !e))
    return r != null && r.reversed ? [e[1], e[0]] : e;
}, ak = {
  allowDataOverflow: !1,
  allowDecimals: !1,
  allowDuplicatedCategory: !1,
  // defaultPolarAngleAxisProps.allowDuplicatedCategory has it set to true but the actual axis rendering ignores the prop because reasons,
  dataKey: void 0,
  domain: void 0,
  id: Xr.angleAxisId,
  includeHidden: !1,
  name: void 0,
  reversed: Xr.reversed,
  scale: Xr.scale,
  tick: Xr.tick,
  tickCount: void 0,
  ticks: void 0,
  type: Xr.type,
  unit: void 0
}, ok = {
  allowDataOverflow: Yt.allowDataOverflow,
  allowDecimals: !1,
  allowDuplicatedCategory: Yt.allowDuplicatedCategory,
  dataKey: void 0,
  domain: void 0,
  id: Yt.radiusAxisId,
  includeHidden: !1,
  name: void 0,
  reversed: !1,
  scale: Yt.scale,
  tick: Yt.tick,
  tickCount: Yt.tickCount,
  ticks: void 0,
  type: Yt.type,
  unit: void 0
}, lk = {
  allowDataOverflow: !1,
  allowDecimals: !1,
  allowDuplicatedCategory: Xr.allowDuplicatedCategory,
  dataKey: void 0,
  domain: void 0,
  id: Xr.angleAxisId,
  includeHidden: !1,
  name: void 0,
  reversed: !1,
  scale: Xr.scale,
  tick: Xr.tick,
  tickCount: void 0,
  ticks: void 0,
  type: "number",
  unit: void 0
}, ck = {
  allowDataOverflow: Yt.allowDataOverflow,
  allowDecimals: !1,
  allowDuplicatedCategory: Yt.allowDuplicatedCategory,
  dataKey: void 0,
  domain: void 0,
  id: Yt.radiusAxisId,
  includeHidden: !1,
  name: void 0,
  reversed: !1,
  scale: Yt.scale,
  tick: Yt.tick,
  tickCount: Yt.tickCount,
  ticks: void 0,
  type: "category",
  unit: void 0
}, Kh = (r, e) => r.polarAxis.angleAxis[e] != null ? r.polarAxis.angleAxis[e] : r.layout.layoutType === "radial" ? lk : ak, Vh = (r, e) => r.polarAxis.radiusAxis[e] != null ? r.polarAxis.radiusAxis[e] : r.layout.layoutType === "radial" ? ck : ok, $l = (r) => r.polarOptions, Wh = M([gn, mn, ut], oE), SS = M([$l, Wh], (r, e) => {
  if (r != null)
    return Dt(r.innerRadius, e, 0);
}), TS = M([$l, Wh], (r, e) => {
  if (r != null)
    return Dt(r.outerRadius, e, e * 0.8);
}), uk = (r) => {
  if (r == null)
    return [0, 0];
  var {
    startAngle: e,
    endAngle: t
  } = r;
  return [e, t];
}, AS = M([$l], uk);
M([Kh, AS], Fl);
var wS = M([Wh, SS, TS], (r, e, t) => {
  if (!(r == null || e == null || t == null))
    return [e, t];
});
M([Vh, wS], Fl);
var dk = M([Ee, $l, SS, TS, gn, mn], (r, e, t, n, i, s) => {
  if (!(r !== "centric" && r !== "radial" || e == null || t == null || n == null)) {
    var {
      cx: a,
      cy: o,
      startAngle: c,
      endAngle: l
    } = e;
    return {
      cx: Dt(a, i, i / 2),
      cy: Dt(o, s, s / 2),
      innerRadius: t,
      outerRadius: n,
      startAngle: c,
      endAngle: l,
      clockWise: !1
    };
  }
}), Ze = (r, e) => e, ba = (r, e, t) => t;
function c0(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function Yo(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? c0(Object(t), !0).forEach(function(n) {
      fk(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : c0(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function fk(r, e, t) {
  return (e = hk(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function hk(r) {
  var e = gk(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function gk(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
var Yd = [0, "auto"], qt = {
  allowDataOverflow: !1,
  allowDecimals: !0,
  allowDuplicatedCategory: !0,
  angle: 0,
  dataKey: void 0,
  domain: void 0,
  height: 30,
  hide: !0,
  id: 0,
  includeHidden: !1,
  interval: "preserveEnd",
  minTickGap: 5,
  mirror: !1,
  name: void 0,
  orientation: "bottom",
  padding: {
    left: 0,
    right: 0
  },
  reversed: !1,
  scale: "auto",
  tick: !0,
  tickCount: 5,
  tickFormatter: void 0,
  ticks: void 0,
  type: "category",
  unit: void 0
}, yn = (r, e) => {
  var t = r.cartesianAxis.xAxis[e];
  return t ?? qt;
}, zt = {
  allowDataOverflow: !1,
  allowDecimals: !0,
  allowDuplicatedCategory: !0,
  angle: 0,
  dataKey: void 0,
  domain: Yd,
  hide: !0,
  id: 0,
  includeHidden: !1,
  interval: "preserveEnd",
  minTickGap: 5,
  mirror: !1,
  name: void 0,
  orientation: "left",
  padding: {
    top: 0,
    bottom: 0
  },
  reversed: !1,
  scale: "auto",
  tick: !0,
  tickCount: 5,
  tickFormatter: void 0,
  ticks: void 0,
  type: "number",
  unit: void 0,
  width: Pl
}, Un = (r, e) => {
  var t = r.cartesianAxis.yAxis[e];
  return t ?? zt;
}, Rn = {
  domain: [0, "auto"],
  includeHidden: !1,
  reversed: !1,
  allowDataOverflow: !1,
  allowDuplicatedCategory: !1,
  dataKey: void 0,
  id: 0,
  name: "",
  range: [64, 64],
  scale: "auto",
  type: "number",
  unit: ""
}, Hh = (r, e) => {
  var t = r.cartesianAxis.zAxis[e];
  return t ?? Rn;
}, Je = (r, e, t) => {
  switch (e) {
    case "xAxis":
      return yn(r, t);
    case "yAxis":
      return Un(r, t);
    case "zAxis":
      return Hh(r, t);
    case "angleAxis":
      return Kh(r, t);
    case "radiusAxis":
      return Vh(r, t);
    default:
      throw new Error("Unexpected axis type: ".concat(e));
  }
}, mk = (r, e, t) => {
  switch (e) {
    case "xAxis":
      return yn(r, t);
    case "yAxis":
      return Un(r, t);
    default:
      throw new Error("Unexpected axis type: ".concat(e));
  }
}, xa = (r, e, t) => {
  switch (e) {
    case "xAxis":
      return yn(r, t);
    case "yAxis":
      return Un(r, t);
    case "angleAxis":
      return Kh(r, t);
    case "radiusAxis":
      return Vh(r, t);
    default:
      throw new Error("Unexpected axis type: ".concat(e));
  }
}, IS = (r) => r.graphicalItems.countOfBars > 0;
function qh(r, e) {
  return (t) => {
    switch (r) {
      case "xAxis":
        return "xAxisId" in t && t.xAxisId === e;
      case "yAxis":
        return "yAxisId" in t && t.yAxisId === e;
      case "zAxis":
        return "zAxisId" in t && t.zAxisId === e;
      case "angleAxis":
        return "angleAxisId" in t && t.angleAxisId === e;
      case "radiusAxis":
        return "radiusAxisId" in t && t.radiusAxisId === e;
      default:
        return !1;
    }
  };
}
var ls = (r) => r.graphicalItems.cartesianItems, pk = M([Ze, ba], qh), zh = (r, e, t) => r.filter(t).filter((n) => (e == null ? void 0 : e.includeHidden) === !0 ? !0 : !n.hide), Ea = M([ls, Je, pk], zh), PS = (r) => r.filter((e) => e.stackId === void 0), vk = M([Ea], PS), Yh = (r) => r.map((e) => e.data).filter(Boolean).flat(1), yk = M([Ea], Yh), Xh = (r, e) => {
  var {
    chartData: t = [],
    dataStartIndex: n,
    dataEndIndex: i
  } = e;
  return r.length > 0 ? r : t.slice(n, i + 1);
}, Bl = M([yk, va], Xh), Qh = (r, e, t) => (e == null ? void 0 : e.dataKey) != null ? r.map((n) => ({
  value: Pe(n, e.dataKey)
})) : t.length > 0 ? t.map((n) => n.dataKey).flatMap((n) => r.map((i) => ({
  value: Pe(i, n)
}))) : r.map((n) => ({
  value: n
})), jl = M([Bl, Je, Ea], Qh);
function _S(r, e) {
  switch (r) {
    case "xAxis":
      return e.direction === "x";
    case "yAxis":
      return e.direction === "y";
    default:
      return !1;
  }
}
function bi(r) {
  return r.filter((e) => Br(e) || e instanceof Date).map(Number).filter((e) => Ut(e) === !1);
}
function bk(r, e, t) {
  return !t || typeof e != "number" || Ut(e) ? [] : t.length ? bi(t.flatMap((n) => {
    var i = Pe(r, n.dataKey), s, a;
    if (Array.isArray(i) ? [s, a] = i : s = a = i, !(!Tt(s) || !Tt(a)))
      return [e - s, e + a];
  })) : [];
}
var LS = (r, e, t) => {
  var n = {}, i = e.reduce((s, a) => (a.stackId == null || (s[a.stackId] == null && (s[a.stackId] = []), s[a.stackId].push(a)), s), n);
  return Object.fromEntries(Object.entries(i).map((s) => {
    var [a, o] = s, c = o.map((l) => l.dataKey);
    return [a, {
      // @ts-expect-error getStackedData requires that the input is array of objects, Recharts does not test for that
      stackedData: x1(r, c, t),
      graphicalItems: o
    }];
  }));
}, Xs = M([Bl, Ea, ya], LS), OS = (r, e, t) => {
  var {
    dataStartIndex: n,
    dataEndIndex: i
  } = e;
  if (t !== "zAxis") {
    var s = A1(r, n, i);
    if (!(s != null && s[0] === 0 && s[1] === 0))
      return s;
  }
}, xk = M([Xs, yi, Ze], OS), RS = (r, e, t, n) => t.length > 0 ? r.flatMap((i) => t.flatMap((s) => {
  var a, o, c = (a = s.errorBars) === null || a === void 0 ? void 0 : a.filter((u) => _S(n, u)), l = Pe(i, (o = e.dataKey) !== null && o !== void 0 ? o : s.dataKey);
  return {
    value: l,
    errorDomain: bk(i, l, c)
  };
})).filter(Boolean) : (e == null ? void 0 : e.dataKey) != null ? r.map((i) => ({
  value: Pe(i, e.dataKey),
  errorDomain: []
})) : r.map((i) => ({
  value: i,
  errorDomain: []
})), Ek = M(Bl, Je, vk, Ze, RS);
function Sk(r) {
  var {
    value: e
  } = r;
  if (Br(e) || e instanceof Date)
    return e;
}
var Tk = (r) => {
  var e = r.flatMap((n) => [n.value, n.errorDomain]).flat(1), t = bi(e);
  if (t.length !== 0)
    return [Math.min(...t), Math.max(...t)];
}, Ak = (r, e, t) => {
  var n = r.map(Sk).filter((i) => i != null);
  return t && (e.dataKey == null || e.allowDuplicatedCategory && Jb(n)) ? AE(0, r.length) : e.allowDuplicatedCategory ? n : Array.from(new Set(n));
}, Zh = (r) => {
  var e;
  if (r == null || !("domain" in r))
    return Yd;
  if (r.domain != null)
    return r.domain;
  if (r.ticks != null) {
    if (r.type === "number") {
      var t = bi(r.ticks);
      return [Math.min(...t), Math.max(...t)];
    }
    if (r.type === "category")
      return r.ticks.map(String);
  }
  return (e = r == null ? void 0 : r.domain) !== null && e !== void 0 ? e : Yd;
}, Jh = function() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  var i = t.filter(Boolean);
  if (i.length !== 0) {
    var s = i.flat(), a = Math.min(...s), o = Math.max(...s);
    return [a, o];
  }
}, DS = (r) => r.referenceElements.dots, cs = (r, e, t) => r.filter((n) => n.ifOverflow === "extendDomain").filter((n) => e === "xAxis" ? n.xAxisId === t : n.yAxisId === t), wk = M([DS, Ze, ba], cs), CS = (r) => r.referenceElements.areas, Ik = M([CS, Ze, ba], cs), kS = (r) => r.referenceElements.lines, Pk = M([kS, Ze, ba], cs), MS = (r, e) => {
  var t = bi(r.map((n) => e === "xAxis" ? n.x : n.y));
  if (t.length !== 0)
    return [Math.min(...t), Math.max(...t)];
}, _k = M(wk, Ze, MS), NS = (r, e) => {
  var t = bi(r.flatMap((n) => [e === "xAxis" ? n.x1 : n.y1, e === "xAxis" ? n.x2 : n.y2]));
  if (t.length !== 0)
    return [Math.min(...t), Math.max(...t)];
}, Lk = M([Ik, Ze], NS), FS = (r, e) => {
  var t = bi(r.map((n) => e === "xAxis" ? n.x : n.y));
  if (t.length !== 0)
    return [Math.min(...t), Math.max(...t)];
}, Ok = M(Pk, Ze, FS), Rk = M(_k, Ok, Lk, (r, e, t) => Jh(r, t, e)), $S = M([Je], Zh), eg = (r, e, t, n, i) => {
  var s = WC(e, r.allowDataOverflow);
  return s ?? HC(e, Jh(t, i, Tk(n)), r.allowDataOverflow);
}, Dk = M([Je, $S, xk, Ek, Rk], eg), Ck = [0, 1], tg = (r, e, t, n, i, s, a) => {
  if (!(r == null || t == null || t.length === 0)) {
    var {
      dataKey: o,
      type: c
    } = r, l = Vr(e, s);
    return l && o == null ? AE(0, t.length) : c === "category" ? Ak(n, r, l) : i === "expand" ? Ck : a;
  }
}, rg = M([Je, Ee, Bl, jl, ya, Ze, Dk], tg), BS = (r, e, t, n, i) => {
  if (r != null) {
    var {
      scale: s,
      type: a
    } = r;
    if (s === "auto")
      return e === "radial" && i === "radiusAxis" ? "band" : e === "radial" && i === "angleAxis" ? "linear" : a === "category" && n && (n.indexOf("LineChart") >= 0 || n.indexOf("AreaChart") >= 0 || n.indexOf("ComposedChart") >= 0 && !t) ? "point" : a === "category" ? "band" : "linear";
    if (typeof s == "string") {
      var o = "scale".concat(la(s));
      return o in Ds ? o : "point";
    }
  }
}, us = M([Je, Ee, IS, jh, Ze], BS);
function kk(r) {
  if (r != null) {
    if (r in Ds)
      return Ds[r]();
    var e = "scale".concat(la(r));
    if (e in Ds)
      return Ds[e]();
  }
}
function ng(r, e, t, n) {
  if (!(t == null || n == null)) {
    if (typeof r.scale == "function")
      return r.scale.copy().domain(t).range(n);
    var i = kk(e);
    if (i != null) {
      var s = i.domain(t).range(n);
      return m1(s), s;
    }
  }
}
var ig = (r, e, t) => {
  var n = Zh(e);
  if (!(t !== "auto" && t !== "linear")) {
    if (e != null && e.tickCount && Array.isArray(n) && (n[0] === "auto" || n[1] === "auto") && Xi(r))
      return rk(r, e.tickCount, e.allowDecimals);
    if (e != null && e.tickCount && e.type === "number" && Xi(r))
      return nk(r, e.tickCount, e.allowDecimals);
  }
}, sg = M([rg, xa, us], ig), ag = (r, e, t, n) => {
  if (
    /*
     * Angle axis for some reason uses nice ticks when rendering axis tick labels,
     * but doesn't use nice ticks for extending domain like all the other axes do.
     * Not really sure why? Is there a good reason,
     * or is it just because someone added support for nice ticks to the other axes and forgot this one?
     */
    n !== "angleAxis" && (r == null ? void 0 : r.type) === "number" && Xi(e) && Array.isArray(t) && t.length > 0
  ) {
    var i = e[0], s = t[0], a = e[1], o = t[t.length - 1];
    return [Math.min(i, s), Math.max(a, o)];
  }
  return e;
}, Mk = M([Je, rg, sg, Ze], ag), Nk = M(jl, Je, (r, e) => {
  if (!(!e || e.type !== "number")) {
    var t = 1 / 0, n = Array.from(bi(r.map((o) => o.value))).sort((o, c) => o - c);
    if (n.length < 2)
      return 1 / 0;
    var i = n[n.length - 1] - n[0];
    if (i === 0)
      return 1 / 0;
    for (var s = 0; s < n.length - 1; s++) {
      var a = n[s + 1] - n[s];
      t = Math.min(t, a);
    }
    return t / i;
  }
}), jS = M(Nk, Ee, xS, ut, (r, e, t, n) => n, (r, e, t, n, i) => {
  if (!Tt(r))
    return 0;
  var s = e === "vertical" ? n.height : n.width;
  if (i === "gap")
    return r * s / 2;
  if (i === "no-gap") {
    var a = Dt(t, r * s), o = r * s / 2;
    return o - a - (o - a) / s * a;
  }
  return 0;
}), Fk = (r, e) => {
  var t = yn(r, e);
  return t == null || typeof t.padding != "string" ? 0 : jS(r, "xAxis", e, t.padding);
}, $k = (r, e) => {
  var t = Un(r, e);
  return t == null || typeof t.padding != "string" ? 0 : jS(r, "yAxis", e, t.padding);
}, Bk = M(yn, Fk, (r, e) => {
  var t, n;
  if (r == null)
    return {
      left: 0,
      right: 0
    };
  var {
    padding: i
  } = r;
  return typeof i == "string" ? {
    left: e,
    right: e
  } : {
    left: ((t = i.left) !== null && t !== void 0 ? t : 0) + e,
    right: ((n = i.right) !== null && n !== void 0 ? n : 0) + e
  };
}), jk = M(Un, $k, (r, e) => {
  var t, n;
  if (r == null)
    return {
      top: 0,
      bottom: 0
    };
  var {
    padding: i
  } = r;
  return typeof i == "string" ? {
    top: e,
    bottom: e
  } : {
    top: ((t = i.top) !== null && t !== void 0 ? t : 0) + e,
    bottom: ((n = i.bottom) !== null && n !== void 0 ? n : 0) + e
  };
}), Uk = M([ut, Bk, Ll, _l, (r, e, t) => t], (r, e, t, n, i) => {
  var {
    padding: s
  } = n;
  return i ? [s.left, t.width - s.right] : [r.left + e.left, r.left + r.width - e.right];
}), Gk = M([ut, Ee, jk, Ll, _l, (r, e, t) => t], (r, e, t, n, i, s) => {
  var {
    padding: a
  } = i;
  return s ? [n.height - a.bottom, a.top] : e === "horizontal" ? [r.top + r.height - t.bottom, r.top + t.top] : [r.top + t.top, r.top + r.height - t.bottom];
}), Sa = (r, e, t, n) => {
  var i;
  switch (e) {
    case "xAxis":
      return Uk(r, t, n);
    case "yAxis":
      return Gk(r, t, n);
    case "zAxis":
      return (i = Hh(r, t)) === null || i === void 0 ? void 0 : i.range;
    case "angleAxis":
      return AS(r);
    case "radiusAxis":
      return wS(r, t);
    default:
      return;
  }
}, US = M([Je, Sa], Fl), ds = M([Je, us, Mk, US], ng);
M(Ea, Ze, (r, e) => r.flatMap((t) => {
  var n;
  return (n = t.errorBars) !== null && n !== void 0 ? n : [];
}).filter((t) => _S(e, t)));
function GS(r, e) {
  return r.id < e.id ? -1 : r.id > e.id ? 1 : 0;
}
var Ul = (r, e) => e, Gl = (r, e, t) => t, Kk = M(sh, Ul, Gl, (r, e, t) => r.filter((n) => n.orientation === e).filter((n) => n.mirror === t).sort(GS)), Vk = M(ah, Ul, Gl, (r, e, t) => r.filter((n) => n.orientation === e).filter((n) => n.mirror === t).sort(GS)), KS = (r, e) => ({
  width: r.width,
  height: e.height
}), Wk = (r, e) => {
  var t = typeof e.width == "number" ? e.width : Pl;
  return {
    width: t,
    height: r.height
  };
}, VS = M(ut, yn, KS), Hk = (r, e, t) => {
  switch (e) {
    case "top":
      return r.top;
    case "bottom":
      return t - r.bottom;
    default:
      return 0;
  }
}, qk = (r, e, t) => {
  switch (e) {
    case "left":
      return r.left;
    case "right":
      return t - r.right;
    default:
      return 0;
  }
}, zk = M(mn, ut, Kk, Ul, Gl, (r, e, t, n, i) => {
  var s = {}, a;
  return t.forEach((o) => {
    var c = KS(e, o);
    a == null && (a = Hk(e, n, r));
    var l = n === "top" && !i || n === "bottom" && i;
    s[o.id] = a - Number(l) * c.height, a += (l ? -1 : 1) * c.height;
  }), s;
}), Yk = M(gn, ut, Vk, Ul, Gl, (r, e, t, n, i) => {
  var s = {}, a;
  return t.forEach((o) => {
    var c = Wk(e, o);
    a == null && (a = qk(e, n, r));
    var l = n === "left" && !i || n === "right" && i;
    s[o.id] = a - Number(l) * c.width, a += (l ? -1 : 1) * c.width;
  }), s;
}), Xk = (r, e) => {
  var t = ut(r), n = yn(r, e);
  if (n != null) {
    var i = zk(r, n.orientation, n.mirror), s = i[e];
    return s == null ? {
      x: t.left,
      y: 0
    } : {
      x: t.left,
      y: s
    };
  }
}, Qk = (r, e) => {
  var t = ut(r), n = Un(r, e);
  if (n != null) {
    var i = Yk(r, n.orientation, n.mirror), s = i[e];
    return s == null ? {
      x: 0,
      y: t.top
    } : {
      x: s,
      y: t.top
    };
  }
}, WS = M(ut, Un, (r, e) => {
  var t = typeof e.width == "number" ? e.width : Pl;
  return {
    width: t,
    height: r.height
  };
}), u0 = (r, e, t) => {
  switch (e) {
    case "xAxis":
      return VS(r, t).width;
    case "yAxis":
      return WS(r, t).height;
    default:
      return;
  }
}, HS = (r, e, t, n) => {
  if (t != null) {
    var {
      allowDuplicatedCategory: i,
      type: s,
      dataKey: a
    } = t, o = Vr(r, n), c = e.map((l) => l.value);
    if (a && o && s === "category" && i && Jb(c))
      return c;
  }
}, og = M([Ee, jl, Je, Ze], HS), qS = (r, e, t, n) => {
  if (!(t == null || t.dataKey == null)) {
    var {
      type: i,
      scale: s
    } = t, a = Vr(r, n);
    if (a && (i === "number" || s !== "auto"))
      return e.map((o) => o.value);
  }
}, lg = M([Ee, jl, xa, Ze], qS), d0 = M([Ee, mk, us, ds, og, lg, Sa, sg, Ze], (r, e, t, n, i, s, a, o, c) => {
  if (e == null)
    return null;
  var l = Vr(r, c);
  return {
    angle: e.angle,
    interval: e.interval,
    minTickGap: e.minTickGap,
    orientation: e.orientation,
    tick: e.tick,
    tickCount: e.tickCount,
    tickFormatter: e.tickFormatter,
    ticks: e.ticks,
    type: e.type,
    unit: e.unit,
    axisType: c,
    categoricalDomain: s,
    duplicateDomain: i,
    isCategorical: l,
    niceTicks: o,
    range: a,
    realScaleType: t,
    scale: n
  };
}), Zk = (r, e, t, n, i, s, a, o, c) => {
  if (!(e == null || n == null)) {
    var l = Vr(r, c), {
      type: u,
      ticks: d,
      tickCount: f
    } = e, h = t === "scaleBand" && typeof n.bandwidth == "function" ? n.bandwidth() / 2 : 2, g = u === "category" && n.bandwidth ? n.bandwidth() / h : 0;
    g = c === "angleAxis" && s != null && s.length >= 2 ? pt(s[0] - s[1]) * 2 * g : g;
    var m = d || i;
    if (m) {
      var p = m.map((v, y) => {
        var b = a ? a.indexOf(v) : v;
        return {
          index: y,
          // If the scaleContent is not a number, the coordinate will be NaN.
          // That could be the case for example with a PointScale and a string as domain.
          coordinate: n(b) + g,
          value: v,
          offset: g
        };
      });
      return p.filter((v) => !Ut(v.coordinate));
    }
    return l && o ? o.map((v, y) => ({
      coordinate: n(v) + g,
      value: v,
      index: y,
      offset: g
    })) : n.ticks ? n.ticks(f).map((v) => ({
      coordinate: n(v) + g,
      value: v,
      offset: g
    })) : n.domain().map((v, y) => ({
      coordinate: n(v) + g,
      value: a ? a[v] : v,
      index: y,
      offset: g
    }));
  }
}, zS = M([Ee, xa, us, ds, sg, Sa, og, lg, Ze], Zk), Jk = (r, e, t, n, i, s, a) => {
  if (!(e == null || t == null || n == null || n[0] === n[1])) {
    var o = Vr(r, a), {
      tickCount: c
    } = e, l = 0;
    return l = a === "angleAxis" && (n == null ? void 0 : n.length) >= 2 ? pt(n[0] - n[1]) * 2 * l : l, o && s ? s.map((u, d) => ({
      coordinate: t(u) + l,
      value: u,
      index: d,
      offset: l
    })) : t.ticks ? t.ticks(c).map((u) => ({
      coordinate: t(u) + l,
      value: u,
      offset: l
    })) : t.domain().map((u, d) => ({
      coordinate: t(u) + l,
      value: i ? i[u] : u,
      index: d,
      offset: l
    }));
  }
}, vr = M([Ee, xa, ds, Sa, og, lg, Ze], Jk), Gt = M(Je, ds, (r, e) => {
  if (!(r == null || e == null))
    return Yo(Yo({}, r), {}, {
      scale: e
    });
}), eM = M([Je, us, rg, US], ng), tM = M((r, e, t) => Hh(r, t), eM, (r, e) => {
  if (!(r == null || e == null))
    return Yo(Yo({}, r), {}, {
      scale: e
    });
}), rM = M([Ee, sh, ah], (r, e, t) => {
  switch (r) {
    case "horizontal":
      return e.some((n) => n.reversed) ? "right-to-left" : "left-to-right";
    case "vertical":
      return t.some((n) => n.reversed) ? "bottom-to-top" : "top-to-bottom";
    // TODO: make this better. For now, right arrow triggers "forward", left arrow "back"
    // however, the tooltip moves an unintuitive direction because of how the indices are rendered
    case "centric":
    case "radial":
      return "left-to-right";
    default:
      return;
  }
}), YS = (r) => r.options.defaultTooltipEventType, XS = (r) => r.options.validateTooltipEventTypes;
function QS(r, e, t) {
  if (r == null)
    return e;
  var n = r ? "axis" : "item";
  return t == null ? e : t.includes(n) ? n : e;
}
function cg(r, e) {
  var t = YS(r), n = XS(r);
  return QS(e, t, n);
}
function nM(r) {
  return te((e) => cg(e, r));
}
var ZS = (r, e) => {
  var t, n = Number(e);
  if (!(Ut(n) || e == null))
    return n >= 0 ? r == null || (t = r[n]) === null || t === void 0 ? void 0 : t.value : void 0;
}, iM = (r) => r.tooltip.settings, On = {
  active: !1,
  index: null,
  dataKey: void 0,
  coordinate: void 0
}, sM = {
  itemInteraction: {
    click: On,
    hover: On
  },
  axisInteraction: {
    click: On,
    hover: On
  },
  keyboardInteraction: On,
  syncInteraction: {
    active: !1,
    index: null,
    dataKey: void 0,
    label: void 0,
    coordinate: void 0
  },
  tooltipItemPayloads: [],
  settings: {
    shared: void 0,
    trigger: "hover",
    axisId: 0,
    active: !1,
    defaultIndex: void 0
  }
}, JS = xr({
  name: "tooltip",
  initialState: sM,
  reducers: {
    addTooltipEntrySettings(r, e) {
      r.tooltipItemPayloads.push(e.payload);
    },
    removeTooltipEntrySettings(r, e) {
      var t = tn(r).tooltipItemPayloads.indexOf(e.payload);
      t > -1 && r.tooltipItemPayloads.splice(t, 1);
    },
    setTooltipSettingsState(r, e) {
      r.settings = e.payload;
    },
    setActiveMouseOverItemIndex(r, e) {
      r.syncInteraction.active = !1, r.keyboardInteraction.active = !1, r.itemInteraction.hover.active = !0, r.itemInteraction.hover.index = e.payload.activeIndex, r.itemInteraction.hover.dataKey = e.payload.activeDataKey, r.itemInteraction.hover.coordinate = e.payload.activeCoordinate;
    },
    mouseLeaveChart(r) {
      r.itemInteraction.hover.active = !1, r.axisInteraction.hover.active = !1;
    },
    mouseLeaveItem(r) {
      r.itemInteraction.hover.active = !1;
    },
    setActiveClickItemIndex(r, e) {
      r.syncInteraction.active = !1, r.itemInteraction.click.active = !0, r.keyboardInteraction.active = !1, r.itemInteraction.click.index = e.payload.activeIndex, r.itemInteraction.click.dataKey = e.payload.activeDataKey, r.itemInteraction.click.coordinate = e.payload.activeCoordinate;
    },
    setMouseOverAxisIndex(r, e) {
      r.syncInteraction.active = !1, r.axisInteraction.hover.active = !0, r.keyboardInteraction.active = !1, r.axisInteraction.hover.index = e.payload.activeIndex, r.axisInteraction.hover.dataKey = e.payload.activeDataKey, r.axisInteraction.hover.coordinate = e.payload.activeCoordinate;
    },
    setMouseClickAxisIndex(r, e) {
      r.syncInteraction.active = !1, r.keyboardInteraction.active = !1, r.axisInteraction.click.active = !0, r.axisInteraction.click.index = e.payload.activeIndex, r.axisInteraction.click.dataKey = e.payload.activeDataKey, r.axisInteraction.click.coordinate = e.payload.activeCoordinate;
    },
    setSyncInteraction(r, e) {
      r.syncInteraction = e.payload;
    },
    setKeyboardInteraction(r, e) {
      r.keyboardInteraction.active = e.payload.active, r.keyboardInteraction.index = e.payload.activeIndex, r.keyboardInteraction.coordinate = e.payload.activeCoordinate, r.keyboardInteraction.dataKey = e.payload.activeDataKey;
    }
  }
}), {
  addTooltipEntrySettings: aM,
  removeTooltipEntrySettings: oM,
  setTooltipSettingsState: lM,
  setActiveMouseOverItemIndex: eT,
  mouseLeaveItem: cM,
  mouseLeaveChart: tT,
  setActiveClickItemIndex: uM,
  setMouseOverAxisIndex: rT,
  setMouseClickAxisIndex: dM,
  setSyncInteraction: Xd,
  setKeyboardInteraction: Qd
} = JS.actions, fM = JS.reducer;
function f0(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function Ya(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? f0(Object(t), !0).forEach(function(n) {
      hM(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : f0(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function hM(r, e, t) {
  return (e = gM(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function gM(r) {
  var e = mM(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function mM(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function pM(r, e, t) {
  return e === "axis" ? t === "click" ? r.axisInteraction.click : r.axisInteraction.hover : t === "click" ? r.itemInteraction.click : r.itemInteraction.hover;
}
function vM(r) {
  return r.index != null;
}
var nT = (r, e, t, n) => {
  if (e == null)
    return On;
  var i = pM(r, e, t);
  if (i == null)
    return On;
  if (i.active)
    return i;
  if (r.keyboardInteraction.active)
    return r.keyboardInteraction;
  if (r.syncInteraction.active && r.syncInteraction.index != null)
    return r.syncInteraction;
  var s = r.settings.active === !0;
  if (vM(i)) {
    if (s)
      return Ya(Ya({}, i), {}, {
        active: !0
      });
  } else if (n != null)
    return {
      active: !0,
      coordinate: void 0,
      dataKey: void 0,
      index: n
    };
  return Ya(Ya({}, On), {}, {
    coordinate: i.coordinate
  });
}, ug = (r, e) => {
  var t = r == null ? void 0 : r.index;
  if (t == null)
    return null;
  var n = Number(t);
  if (!Tt(n))
    return t;
  var i = 0, s = 1 / 0;
  return e.length > 0 && (s = e.length - 1), String(Math.max(i, Math.min(n, s)));
}, iT = (r, e, t, n, i, s, a, o) => {
  if (!(s == null || o == null)) {
    var c = a[0], l = c == null ? void 0 : o(c.positions, s);
    if (l != null)
      return l;
    var u = i == null ? void 0 : i[Number(s)];
    if (u)
      switch (t) {
        case "horizontal":
          return {
            x: u.coordinate,
            y: (n.top + e) / 2
          };
        default:
          return {
            x: (n.left + r) / 2,
            y: u.coordinate
          };
      }
  }
}, sT = (r, e, t, n) => {
  if (e === "axis")
    return r.tooltipItemPayloads;
  if (r.tooltipItemPayloads.length === 0)
    return [];
  var i;
  return t === "hover" ? i = r.itemInteraction.hover.dataKey : i = r.itemInteraction.click.dataKey, i == null && n != null ? [r.tooltipItemPayloads[0]] : r.tooltipItemPayloads.filter((s) => {
    var a;
    return ((a = s.settings) === null || a === void 0 ? void 0 : a.dataKey) === i;
  });
}, Ta = (r) => r.options.tooltipPayloadSearcher, fs = (r) => r.tooltip;
function h0(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function g0(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? h0(Object(t), !0).forEach(function(n) {
      yM(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : h0(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function yM(r, e, t) {
  return (e = bM(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function bM(r) {
  var e = xM(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function xM(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function EM(r, e, t) {
  return Array.isArray(r) && r && e + t !== 0 ? r.slice(e, t + 1) : r;
}
function SM(r, e) {
  return r ?? e;
}
var aT = (r, e, t, n, i, s, a) => {
  if (!(e == null || s == null)) {
    var {
      chartData: o,
      computedData: c,
      dataStartIndex: l,
      dataEndIndex: u
    } = t, d = [];
    return r.reduce((f, h) => {
      var g, {
        dataDefinedOnItem: m,
        settings: p
      } = h, v = SM(m, o), y = EM(v, l, u), b = (g = p == null ? void 0 : p.dataKey) !== null && g !== void 0 ? g : n == null ? void 0 : n.dataKey, x = p == null ? void 0 : p.nameKey, S;
      if (n != null && n.dataKey && Array.isArray(y) && /*
       * findEntryInArray won't work for Scatter because Scatter provides an array of arrays
       * as tooltip payloads and findEntryInArray is not prepared to handle that.
       * Sad but also ScatterChart only allows 'item' tooltipEventType
       * and also this is only a problem if there are multiple Scatters and each has its own data array
       * so let's fix that some other time.
       */
      !Array.isArray(y[0]) && /*
       * If the tooltipEventType is 'axis', we should search for the dataKey in the sliced data
       * because thanks to allowDuplicatedCategory=false, the order of elements in the array
       * no longer matches the order of elements in the original data
       * and so we need to search by the active dataKey + label rather than by index.
       *
       * The same happens if multiple graphical items are present in the chart
       * and each of them has its own data array. Those arrays get concatenated
       * and again the tooltip index no longer matches the original data.
       *
       * On the other hand the tooltipEventType 'item' should always search by index
       * because we get the index from interacting over the individual elements
       * which is always accurate, irrespective of the allowDuplicatedCategory setting.
       */
      a === "axis" ? S = ex(y, n.dataKey, i) : S = s(y, e, c, x), Array.isArray(S))
        S.forEach((T) => {
          var I = g0(g0({}, p), {}, {
            name: T.name,
            unit: T.unit,
            // color and fill are erased to keep 100% the identical behaviour to recharts 2.x - but there's nothing stopping us from returning them here. It's technically a breaking change.
            color: void 0,
            // color and fill are erased to keep 100% the identical behaviour to recharts 2.x - but there's nothing stopping us from returning them here. It's technically a breaking change.
            fill: void 0
          });
          f.push(zp({
            tooltipEntrySettings: I,
            dataKey: T.dataKey,
            payload: T.payload,
            // @ts-expect-error getValueByDataKey does not validate the output type
            value: Pe(T.payload, T.dataKey),
            name: T.name
          }));
        });
      else {
        var A;
        f.push(zp({
          tooltipEntrySettings: p,
          dataKey: b,
          payload: S,
          // @ts-expect-error getValueByDataKey does not validate the output type
          value: Pe(S, b),
          // @ts-expect-error getValueByDataKey does not validate the output type
          name: (A = Pe(S, x)) !== null && A !== void 0 ? A : p == null ? void 0 : p.name
        }));
      }
      return f;
    }, d);
  }
}, yt = (r) => {
  var e = Ee(r);
  return e === "horizontal" ? "xAxis" : e === "vertical" ? "yAxis" : e === "centric" ? "angleAxis" : "radiusAxis";
}, hs = (r) => r.tooltip.settings.axisId, wt = (r) => {
  var e = yt(r), t = hs(r);
  return xa(r, e, t);
}, dg = M([wt, Ee, IS, jh, yt], BS), TM = M([(r) => r.graphicalItems.cartesianItems, (r) => r.graphicalItems.polarItems], (r, e) => [...r, ...e]), AM = M([yt, hs], qh), Kl = M([TM, wt, AM], zh), wM = M([Kl], Yh), xi = M([wM, yi], Xh), fg = M([xi, wt, Kl], Qh), IM = M([wt], Zh), PM = M([xi, Kl, ya], LS), _M = M([PM, yi, yt], OS), LM = M([Kl], PS), OM = M([xi, wt, LM, yt], RS), RM = M([DS, yt, hs], cs), DM = M([RM, yt], MS), CM = M([CS, yt, hs], cs), kM = M([CM, yt], NS), MM = M([kS, yt, hs], cs), NM = M([MM, yt], FS), FM = M([DM, NM, kM], Jh), $M = M([wt, IM, _M, OM, FM], eg), oT = M([wt, Ee, xi, fg, ya, yt, $M], tg), BM = M([oT, wt, dg], ig), jM = M([wt, oT, BM, yt], ag), lT = (r) => {
  var e = yt(r), t = hs(r), n = !1;
  return Sa(r, e, t, n);
}, cT = M([wt, lT], Fl), uT = M([wt, dg, jM, cT], ng), UM = M([Ee, fg, wt, yt], HS), GM = M([Ee, fg, wt, yt], qS), KM = (r, e, t, n, i, s, a, o) => {
  if (e) {
    var {
      type: c
    } = e, l = Vr(r, o);
    if (n) {
      var u = t === "scaleBand" && n.bandwidth ? n.bandwidth() / 2 : 2, d = c === "category" && n.bandwidth ? n.bandwidth() / u : 0;
      return d = o === "angleAxis" && i != null && (i == null ? void 0 : i.length) >= 2 ? pt(i[0] - i[1]) * 2 * d : d, l && a ? a.map((f, h) => ({
        coordinate: n(f) + d,
        value: f,
        index: h,
        offset: d
      })) : n.domain().map((f, h) => ({
        coordinate: n(f) + d,
        value: s ? s[f] : f,
        index: h,
        offset: d
      }));
    }
  }
}, bn = M([Ee, wt, dg, uT, lT, UM, GM, yt], KM), hg = M([YS, XS, iM], (r, e, t) => QS(t.shared, r, e)), dT = (r) => r.tooltip.settings.trigger, gg = (r) => r.tooltip.settings.defaultIndex, Vl = M([fs, hg, dT, gg], nT), cn = M([Vl, xi], ug), fT = M([bn, cn], ZS), hT = M([Vl], (r) => {
  if (r)
    return r.dataKey;
}), gT = M([fs, hg, dT, gg], sT), VM = M([gn, mn, Ee, ut, bn, gg, gT, Ta], iT), WM = M([Vl, VM], (r, e) => r != null && r.coordinate ? r.coordinate : e), HM = M([Vl], (r) => r.active), qM = M([gT, cn, yi, wt, fT, Ta, hg], aT), zM = M([qM], (r) => {
  if (r != null) {
    var e = r.map((t) => t.payload).filter((t) => t != null);
    return Array.from(new Set(e));
  }
});
function m0(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function p0(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? m0(Object(t), !0).forEach(function(n) {
      YM(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : m0(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function YM(r, e, t) {
  return (e = XM(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function XM(r) {
  var e = QM(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function QM(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
var ZM = () => te(wt), JM = () => {
  var r = ZM(), e = te(bn), t = te(uT);
  return fi(p0(p0({}, r), {}, {
    scale: t
  }), e);
}, mT = () => te(jh), mg = (r, e) => e, pT = (r, e, t) => t, pg = (r, e, t, n) => n, eN = M(bn, (r) => El(r, (e) => e.coordinate)), vg = M([fs, mg, pT, pg], nT), vT = M([vg, xi], ug), tN = (r, e, t) => {
  if (e != null) {
    var n = fs(r);
    return e === "axis" ? t === "hover" ? n.axisInteraction.hover.dataKey : n.axisInteraction.click.dataKey : t === "hover" ? n.itemInteraction.hover.dataKey : n.itemInteraction.click.dataKey;
  }
}, yT = M([fs, mg, pT, pg], sT), Xo = M([gn, mn, Ee, ut, bn, pg, yT, Ta], iT), rN = M([vg, Xo], (r, e) => {
  var t;
  return (t = r.coordinate) !== null && t !== void 0 ? t : e;
}), bT = M(bn, vT, ZS), nN = M([yT, vT, yi, wt, bT, Ta, mg], aT), iN = M([vg], (r) => ({
  isActive: r.active,
  activeIndex: r.index
})), sN = (r, e, t, n, i, s, a, o) => {
  if (!(!r || !e || !n || !i || !s)) {
    var c = w1(r.chartX, r.chartY, e, t, o);
    if (c) {
      var l = P1(c, e), u = h1(l, a, s, n, i), d = I1(e, s, u, c);
      return {
        activeIndex: String(u),
        activeCoordinate: d
      };
    }
  }
};
function Zd() {
  return Zd = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t) ({}).hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, Zd.apply(null, arguments);
}
function v0(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function Xa(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? v0(Object(t), !0).forEach(function(n) {
      aN(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : v0(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function aN(r, e, t) {
  return (e = oN(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function oN(r) {
  var e = lN(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function lN(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function cN(r) {
  var {
    coordinate: e,
    payload: t,
    index: n,
    offset: i,
    tooltipAxisBandSize: s,
    layout: a,
    cursor: o,
    tooltipEventType: c,
    chartName: l
  } = r, u = e, d = t, f = n;
  if (!o || !u || l !== "ScatterChart" && c !== "axis")
    return null;
  var h, g;
  if (l === "ScatterChart")
    h = u, g = AO;
  else if (l === "BarChart")
    h = wO(a, u, i, s), g = xE;
  else if (a === "radial") {
    var {
      cx: m,
      cy: p,
      radius: v,
      startAngle: y,
      endAngle: b
    } = EE(u);
    h = {
      cx: m,
      cy: p,
      startAngle: y,
      endAngle: b,
      innerRadius: v,
      outerRadius: v
    }, g = TE;
  } else
    h = {
      points: dR(a, u, i)
    }, g = ai;
  var x = typeof o == "object" && "className" in o ? o.className : void 0, S = Xa(Xa(Xa(Xa({
    stroke: "#ccc",
    pointerEvents: "none"
  }, i), h), de(o, !1)), {}, {
    payload: d,
    payloadIndex: f,
    className: ve("recharts-tooltip-cursor", x)
  });
  return /* @__PURE__ */ _r(o) ? /* @__PURE__ */ fn(o, S) : /* @__PURE__ */ Vb(g, S);
}
function uN(r) {
  var e = JM(), t = fE(), n = fa(), i = mT();
  return /* @__PURE__ */ w.createElement(cN, Zd({}, r, {
    coordinate: r.coordinate,
    index: r.index,
    payload: r.payload,
    offset: t,
    layout: n,
    tooltipAxisBandSize: e,
    chartName: i
  }));
}
var xT = /* @__PURE__ */ dn(null), dN = () => un(xT), Lu = { exports: {} }, y0;
function fN() {
  return y0 || (y0 = 1, function(r) {
    var e = Object.prototype.hasOwnProperty, t = "~";
    function n() {
    }
    Object.create && (n.prototype = /* @__PURE__ */ Object.create(null), new n().__proto__ || (t = !1));
    function i(c, l, u) {
      this.fn = c, this.context = l, this.once = u || !1;
    }
    function s(c, l, u, d, f) {
      if (typeof u != "function")
        throw new TypeError("The listener must be a function");
      var h = new i(u, d || c, f), g = t ? t + l : l;
      return c._events[g] ? c._events[g].fn ? c._events[g] = [c._events[g], h] : c._events[g].push(h) : (c._events[g] = h, c._eventsCount++), c;
    }
    function a(c, l) {
      --c._eventsCount === 0 ? c._events = new n() : delete c._events[l];
    }
    function o() {
      this._events = new n(), this._eventsCount = 0;
    }
    o.prototype.eventNames = function() {
      var l = [], u, d;
      if (this._eventsCount === 0) return l;
      for (d in u = this._events)
        e.call(u, d) && l.push(t ? d.slice(1) : d);
      return Object.getOwnPropertySymbols ? l.concat(Object.getOwnPropertySymbols(u)) : l;
    }, o.prototype.listeners = function(l) {
      var u = t ? t + l : l, d = this._events[u];
      if (!d) return [];
      if (d.fn) return [d.fn];
      for (var f = 0, h = d.length, g = new Array(h); f < h; f++)
        g[f] = d[f].fn;
      return g;
    }, o.prototype.listenerCount = function(l) {
      var u = t ? t + l : l, d = this._events[u];
      return d ? d.fn ? 1 : d.length : 0;
    }, o.prototype.emit = function(l, u, d, f, h, g) {
      var m = t ? t + l : l;
      if (!this._events[m]) return !1;
      var p = this._events[m], v = arguments.length, y, b;
      if (p.fn) {
        switch (p.once && this.removeListener(l, p.fn, void 0, !0), v) {
          case 1:
            return p.fn.call(p.context), !0;
          case 2:
            return p.fn.call(p.context, u), !0;
          case 3:
            return p.fn.call(p.context, u, d), !0;
          case 4:
            return p.fn.call(p.context, u, d, f), !0;
          case 5:
            return p.fn.call(p.context, u, d, f, h), !0;
          case 6:
            return p.fn.call(p.context, u, d, f, h, g), !0;
        }
        for (b = 1, y = new Array(v - 1); b < v; b++)
          y[b - 1] = arguments[b];
        p.fn.apply(p.context, y);
      } else {
        var x = p.length, S;
        for (b = 0; b < x; b++)
          switch (p[b].once && this.removeListener(l, p[b].fn, void 0, !0), v) {
            case 1:
              p[b].fn.call(p[b].context);
              break;
            case 2:
              p[b].fn.call(p[b].context, u);
              break;
            case 3:
              p[b].fn.call(p[b].context, u, d);
              break;
            case 4:
              p[b].fn.call(p[b].context, u, d, f);
              break;
            default:
              if (!y) for (S = 1, y = new Array(v - 1); S < v; S++)
                y[S - 1] = arguments[S];
              p[b].fn.apply(p[b].context, y);
          }
      }
      return !0;
    }, o.prototype.on = function(l, u, d) {
      return s(this, l, u, d, !1);
    }, o.prototype.once = function(l, u, d) {
      return s(this, l, u, d, !0);
    }, o.prototype.removeListener = function(l, u, d, f) {
      var h = t ? t + l : l;
      if (!this._events[h]) return this;
      if (!u)
        return a(this, h), this;
      var g = this._events[h];
      if (g.fn)
        g.fn === u && (!f || g.once) && (!d || g.context === d) && a(this, h);
      else {
        for (var m = 0, p = [], v = g.length; m < v; m++)
          (g[m].fn !== u || f && !g[m].once || d && g[m].context !== d) && p.push(g[m]);
        p.length ? this._events[h] = p.length === 1 ? p[0] : p : a(this, h);
      }
      return this;
    }, o.prototype.removeAllListeners = function(l) {
      var u;
      return l ? (u = t ? t + l : l, this._events[u] && a(this, u)) : (this._events = new n(), this._eventsCount = 0), this;
    }, o.prototype.off = o.prototype.removeListener, o.prototype.addListener = o.prototype.on, o.prefixed = t, o.EventEmitter = o, r.exports = o;
  }(Lu)), Lu.exports;
}
var hN = fN();
const gN = /* @__PURE__ */ hn(hN);
var Qs = new gN(), Jd = "recharts.syncEvent.tooltip", b0 = "recharts.syncEvent.brush";
function Aa(r, e) {
  if (e) {
    var t = Number.parseInt(e, 10);
    if (!Ut(t))
      return r == null ? void 0 : r[t];
  }
}
var mN = {
  chartName: "",
  tooltipPayloadSearcher: void 0,
  eventEmitter: void 0,
  defaultTooltipEventType: "axis"
}, ET = xr({
  name: "options",
  initialState: mN,
  reducers: {
    createEventEmitter: (r) => {
      r.eventEmitter == null && (r.eventEmitter = Symbol("rechartsEventEmitter"));
    }
  }
}), pN = ET.reducer, {
  createEventEmitter: vN
} = ET.actions;
function yN(r) {
  return r.tooltip.syncInteraction;
}
var bN = {
  chartData: void 0,
  computedData: void 0,
  dataStartIndex: 0,
  dataEndIndex: 0
}, ST = xr({
  name: "chartData",
  initialState: bN,
  reducers: {
    setChartData(r, e) {
      if (r.chartData = e.payload, e.payload == null) {
        r.dataStartIndex = 0, r.dataEndIndex = 0;
        return;
      }
      e.payload.length > 0 && r.dataEndIndex !== e.payload.length - 1 && (r.dataEndIndex = e.payload.length - 1);
    },
    setComputedData(r, e) {
      r.computedData = e.payload;
    },
    setDataStartEndIndexes(r, e) {
      var {
        startIndex: t,
        endIndex: n
      } = e.payload;
      t != null && (r.dataStartIndex = t), n != null && (r.dataEndIndex = n);
    }
  }
}), {
  setChartData: x0,
  setDataStartEndIndexes: xN,
  setComputedData: y4
} = ST.actions, EN = ST.reducer, TT = () => {
};
function SN() {
  var r = te(Uh), e = te(Gh), t = He(), n = te(ES), i = te(bn), s = fa(), a = ch(), o = te((c) => c.rootProps.className);
  we(() => {
    if (r == null)
      return TT;
    var c = (l, u, d) => {
      if (e !== d && r === l) {
        if (n === "index") {
          t(u);
          return;
        }
        if (i != null) {
          var f;
          if (typeof n == "function") {
            var h = {
              activeTooltipIndex: u.payload.index == null ? void 0 : Number(u.payload.index),
              isTooltipActive: u.payload.active,
              activeIndex: u.payload.index == null ? void 0 : Number(u.payload.index),
              activeLabel: u.payload.label,
              activeDataKey: u.payload.dataKey,
              activeCoordinate: u.payload.coordinate
            }, g = n(i, h);
            f = i[g];
          } else n === "value" && (f = i.find((A) => String(A.value) === u.payload.label));
          var {
            coordinate: m
          } = u.payload;
          if (f == null || u.payload.active === !1 || m == null || a == null) {
            t(Xd({
              active: !1,
              coordinate: void 0,
              dataKey: void 0,
              index: null,
              label: void 0
            }));
            return;
          }
          var {
            x: p,
            y: v
          } = m, y = Math.min(p, a.x + a.width), b = Math.min(v, a.y + a.height), x = {
            x: s === "horizontal" ? f.coordinate : y,
            y: s === "horizontal" ? b : f.coordinate
          }, S = Xd({
            active: u.payload.active,
            coordinate: x,
            dataKey: u.payload.dataKey,
            index: String(f.index),
            label: u.payload.label
          });
          t(S);
        }
      }
    };
    return Qs.on(Jd, c), () => {
      Qs.off(Jd, c);
    };
  }, [o, t, e, r, n, i, s, a]);
}
function TN() {
  var r = te(Uh), e = te(Gh), t = He();
  we(() => {
    if (r == null)
      return TT;
    var n = (i, s, a) => {
      e !== a && r === i && t(xN(s));
    };
    return Qs.on(b0, n), () => {
      Qs.off(b0, n);
    };
  }, [t, e, r]);
}
function AN() {
  var r = He();
  we(() => {
    r(vN());
  }, [r]), SN(), TN();
}
function wN(r, e, t, n, i, s) {
  var a = te((f) => tN(f, r, e)), o = te(Gh), c = te(Uh), l = te(ES), u = te(yN), d = u == null ? void 0 : u.active;
  we(() => {
    if (!d && c != null && o != null) {
      var f = Xd({
        active: s,
        coordinate: t,
        dataKey: a,
        index: i,
        label: typeof n == "number" ? String(n) : n
      });
      Qs.emit(Jd, c, f, o);
    }
  }, [d, t, a, i, n, o, c, l, s]);
}
function E0(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function S0(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? E0(Object(t), !0).forEach(function(n) {
      IN(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : E0(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function IN(r, e, t) {
  return (e = PN(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function PN(r) {
  var e = _N(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function _N(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function LN(r) {
  return r.dataKey;
}
function ON(r, e) {
  return /* @__PURE__ */ w.isValidElement(r) ? /* @__PURE__ */ w.cloneElement(r, e) : typeof r == "function" ? /* @__PURE__ */ w.createElement(r, e) : /* @__PURE__ */ w.createElement(rO, e);
}
var T0 = [], RN = {
  allowEscapeViewBox: {
    x: !1,
    y: !1
  },
  animationDuration: 400,
  animationEasing: "ease",
  axisId: 0,
  contentStyle: {},
  cursor: !0,
  filterNull: !0,
  isAnimationActive: !pn.isSsr,
  itemSorter: "name",
  itemStyle: {},
  labelStyle: {},
  offset: 10,
  reverseDirection: {
    x: !1,
    y: !1
  },
  separator: " : ",
  trigger: "hover",
  useTranslate3d: !1,
  wrapperStyle: {}
};
function _s(r) {
  var e = Vt(r, RN), {
    active: t,
    allowEscapeViewBox: n,
    animationDuration: i,
    animationEasing: s,
    content: a,
    filterNull: o,
    isAnimationActive: c,
    offset: l,
    payloadUniqBy: u,
    position: d,
    reverseDirection: f,
    useTranslate3d: h,
    wrapperStyle: g,
    cursor: m,
    shared: p,
    trigger: v,
    defaultIndex: y,
    portal: b,
    axisId: x
  } = e, S = He(), A = typeof y == "number" ? String(y) : y;
  we(() => {
    S(lM({
      shared: p,
      trigger: v,
      axisId: x,
      active: t,
      defaultIndex: A
    }));
  }, [S, p, v, x, t, A]);
  var T = ch(), I = pE(), L = nM(p), {
    activeIndex: _,
    isActive: R
  } = te((le) => iN(le, L, v, A)), D = te((le) => nN(le, L, v, A)), F = te((le) => bT(le, L, v, A)), B = te((le) => rN(le, L, v, A)), j = D, U = dN(), K = t ?? R, [G, Y] = Dx([j, K]), Q = L === "axis" ? F : void 0;
  wN(L, v, B, Q, _, K);
  var H = b ?? U;
  if (H == null)
    return null;
  var N = j ?? T0;
  K || (N = T0), o && N.length && (N = Ix(j.filter((le) => le.value != null && (le.hide !== !0 || e.includeHidden)), u, LN));
  var re = N.length > 0, oe = /* @__PURE__ */ w.createElement(cO, {
    allowEscapeViewBox: n,
    animationDuration: i,
    animationEasing: s,
    isAnimationActive: c,
    active: K,
    coordinate: B,
    hasPayload: re,
    offset: l,
    position: d,
    reverseDirection: f,
    useTranslate3d: h,
    viewBox: T,
    wrapperStyle: g,
    lastBoundingBox: G,
    innerRef: Y,
    hasPortalFromProps: !!b
  }, ON(a, S0(S0({}, e), {}, {
    // @ts-expect-error renderContent method expects the payload to be mutable, TODO make it immutable
    payload: N,
    label: Q,
    active: K,
    coordinate: B,
    accessibilityLayer: I
  })));
  return /* @__PURE__ */ w.createElement(w.Fragment, null, /* @__PURE__ */ Nf(oe, H), K && /* @__PURE__ */ w.createElement(uN, {
    cursor: m,
    tooltipEventType: L,
    coordinate: B,
    payload: j,
    index: _
  }));
}
var Ou = {}, Ru = {}, A0;
function DN() {
  return A0 || (A0 = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    function e(t, n = 0, i = {}) {
      typeof i != "object" && (i = {});
      let s = null, a = null, o = null, c = 0, l = null, u;
      const { leading: d = !1, trailing: f = !0, maxWait: h } = i, g = "maxWait" in i, m = g ? Math.max(Number(h) || 0, n) : 0, p = (T) => (s !== null && (u = t.apply(a, s)), s = a = null, c = T, u), v = (T) => (c = T, l = setTimeout(S, n), d && s !== null ? p(T) : u), y = (T) => (l = null, f && s !== null ? p(T) : u), b = (T) => {
        if (o === null)
          return !0;
        const I = T - o, L = I >= n || I < 0, _ = g && T - c >= m;
        return L || _;
      }, x = (T) => {
        const I = o === null ? 0 : T - o, L = n - I, _ = m - (T - c);
        return g ? Math.min(L, _) : L;
      }, S = () => {
        const T = Date.now();
        if (b(T))
          return y(T);
        l = setTimeout(S, x(T));
      }, A = function(...T) {
        const I = Date.now(), L = b(I);
        if (s = T, a = this, o = I, L) {
          if (l === null)
            return v(I);
          if (g)
            return clearTimeout(l), l = setTimeout(S, n), p(I);
        }
        return l === null && (l = setTimeout(S, n)), u;
      };
      return A.cancel = () => {
        l !== null && clearTimeout(l), c = 0, o = s = a = l = null;
      }, A.flush = () => l === null ? u : y(Date.now()), A;
    }
    r.debounce = e;
  }(Ru)), Ru;
}
var w0;
function CN() {
  return w0 || (w0 = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    const e = /* @__PURE__ */ DN();
    function t(n, i = 0, s = {}) {
      const { leading: a = !0, trailing: o = !0 } = s;
      return e.debounce(n, i, {
        leading: a,
        maxWait: i,
        trailing: o
      });
    }
    r.throttle = t;
  }(Ou)), Ou;
}
var Du, I0;
function kN() {
  return I0 || (I0 = 1, Du = CN().throttle), Du;
}
var MN = /* @__PURE__ */ kN();
const NN = /* @__PURE__ */ hn(MN);
var FN = process.env.NODE_ENV !== "production", Ms = function(e, t) {
  for (var n = arguments.length, i = new Array(n > 2 ? n - 2 : 0), s = 2; s < n; s++)
    i[s - 2] = arguments[s];
  if (FN && typeof console < "u" && console.warn && (t === void 0 && console.warn("LogUtils requires an error message argument"), !e))
    if (t === void 0)
      console.warn("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
    else {
      var a = 0;
      console.warn(t.replace(/%s/g, () => i[a++]));
    }
};
function P0(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function Cu(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? P0(Object(t), !0).forEach(function(n) {
      $N(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : P0(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function $N(r, e, t) {
  return (e = BN(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function BN(r) {
  var e = jN(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function jN(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
var UN = /* @__PURE__ */ Kt((r, e) => {
  var {
    aspect: t,
    initialDimension: n = {
      width: -1,
      height: -1
    },
    width: i = "100%",
    height: s = "100%",
    /*
     * default min-width to 0 if not specified - 'auto' causes issues with flexbox
     * https://github.com/recharts/recharts/issues/172
     */
    minWidth: a = 0,
    minHeight: o,
    maxHeight: c,
    children: l,
    debounce: u = 0,
    id: d,
    className: f,
    onResize: h,
    style: g = {}
  } = r, m = Ke(null), p = Ke();
  p.current = h, xI(e, () => m.current);
  var [v, y] = _e({
    containerWidth: n.width,
    containerHeight: n.height
  }), b = Se((S, A) => {
    y((T) => {
      var I = Math.round(S), L = Math.round(A);
      return T.containerWidth === I && T.containerHeight === L ? T : {
        containerWidth: I,
        containerHeight: L
      };
    });
  }, []);
  we(() => {
    var S = (L) => {
      var _, {
        width: R,
        height: D
      } = L[0].contentRect;
      b(R, D), (_ = p.current) === null || _ === void 0 || _.call(p, R, D);
    };
    u > 0 && (S = NN(S, u, {
      trailing: !0,
      leading: !1
    }));
    var A = new ResizeObserver(S), {
      width: T,
      height: I
    } = m.current.getBoundingClientRect();
    return b(T, I), A.observe(m.current), () => {
      A.disconnect();
    };
  }, [b, u]);
  var x = Jt(() => {
    var {
      containerWidth: S,
      containerHeight: A
    } = v;
    if (S < 0 || A < 0)
      return null;
    Ms(Qn(i) || Qn(s), `The width(%s) and height(%s) are both fixed numbers,
       maybe you don't need to use a ResponsiveContainer.`, i, s), Ms(!t || t > 0, "The aspect(%s) must be greater than zero.", t);
    var T = Qn(i) ? S : i, I = Qn(s) ? A : s;
    return t && t > 0 && (T ? I = T / t : I && (T = I * t), c && I > c && (I = c)), Ms(T > 0 || I > 0, `The width(%s) and height(%s) of chart should be greater than 0,
       please check the style of container, or the props width(%s) and height(%s),
       or add a minWidth(%s) or minHeight(%s) or use aspect(%s) to control the
       height and width.`, T, I, i, s, a, o, t), w.Children.map(l, (L) => /* @__PURE__ */ fn(L, {
      width: T,
      height: I,
      // calculate the actual size and override it.
      style: Cu({
        width: T,
        height: I
      }, L.props.style)
    }));
  }, [t, l, s, c, o, a, v, i]);
  return /* @__PURE__ */ w.createElement("div", {
    id: d ? "".concat(d) : void 0,
    className: ve("recharts-responsive-container", f),
    style: Cu(Cu({}, g), {}, {
      width: i,
      height: s,
      minWidth: a,
      minHeight: o,
      maxHeight: c
    }),
    ref: m
  }, /* @__PURE__ */ w.createElement("div", {
    style: {
      width: 0,
      height: 0,
      overflow: "visible"
    }
  }, x));
}), wa = (r) => null;
wa.displayName = "Cell";
function _0(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function ef(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? _0(Object(t), !0).forEach(function(n) {
      GN(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : _0(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function GN(r, e, t) {
  return (e = KN(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function KN(r) {
  var e = VN(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function VN(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
var Ii = {
  widthCache: {},
  cacheCount: 0
}, WN = 2e3, HN = {
  position: "absolute",
  top: "-20000px",
  left: 0,
  padding: 0,
  margin: 0,
  border: "none",
  whiteSpace: "pre"
}, L0 = "recharts_measurement_span";
function qN(r) {
  var e = ef({}, r);
  return Object.keys(e).forEach((t) => {
    e[t] || delete e[t];
  }), e;
}
var Ns = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (e == null || pn.isSsr)
    return {
      width: 0,
      height: 0
    };
  var n = qN(t), i = JSON.stringify({
    text: e,
    copyStyle: n
  });
  if (Ii.widthCache[i])
    return Ii.widthCache[i];
  try {
    var s = document.getElementById(L0);
    s || (s = document.createElement("span"), s.setAttribute("id", L0), s.setAttribute("aria-hidden", "true"), document.body.appendChild(s));
    var a = ef(ef({}, HN), n);
    Object.assign(s.style, a), s.textContent = "".concat(e);
    var o = s.getBoundingClientRect(), c = {
      width: o.width,
      height: o.height
    };
    return Ii.widthCache[i] = c, ++Ii.cacheCount > WN && (Ii.cacheCount = 0, Ii.widthCache = {}), c;
  } catch {
    return {
      width: 0,
      height: 0
    };
  }
}, O0 = /(-?\d+(?:\.\d+)?[a-zA-Z%]*)([*/])(-?\d+(?:\.\d+)?[a-zA-Z%]*)/, R0 = /(-?\d+(?:\.\d+)?[a-zA-Z%]*)([+-])(-?\d+(?:\.\d+)?[a-zA-Z%]*)/, zN = /^px|cm|vh|vw|em|rem|%|mm|in|pt|pc|ex|ch|vmin|vmax|Q$/, YN = /(-?\d+(?:\.\d+)?)([a-zA-Z%]+)?/, AT = {
  cm: 96 / 2.54,
  mm: 96 / 25.4,
  pt: 96 / 72,
  pc: 96 / 6,
  in: 96,
  Q: 96 / (2.54 * 40),
  px: 1
}, XN = Object.keys(AT), Di = "NaN";
function QN(r, e) {
  return r * AT[e];
}
class Nt {
  static parse(e) {
    var t, [, n, i] = (t = YN.exec(e)) !== null && t !== void 0 ? t : [];
    return new Nt(parseFloat(n), i ?? "");
  }
  constructor(e, t) {
    this.num = e, this.unit = t, this.num = e, this.unit = t, Ut(e) && (this.unit = ""), t !== "" && !zN.test(t) && (this.num = NaN, this.unit = ""), XN.includes(t) && (this.num = QN(e, t), this.unit = "px");
  }
  add(e) {
    return this.unit !== e.unit ? new Nt(NaN, "") : new Nt(this.num + e.num, this.unit);
  }
  subtract(e) {
    return this.unit !== e.unit ? new Nt(NaN, "") : new Nt(this.num - e.num, this.unit);
  }
  multiply(e) {
    return this.unit !== "" && e.unit !== "" && this.unit !== e.unit ? new Nt(NaN, "") : new Nt(this.num * e.num, this.unit || e.unit);
  }
  divide(e) {
    return this.unit !== "" && e.unit !== "" && this.unit !== e.unit ? new Nt(NaN, "") : new Nt(this.num / e.num, this.unit || e.unit);
  }
  toString() {
    return "".concat(this.num).concat(this.unit);
  }
  isNaN() {
    return Ut(this.num);
  }
}
function wT(r) {
  if (r.includes(Di))
    return Di;
  for (var e = r; e.includes("*") || e.includes("/"); ) {
    var t, [, n, i, s] = (t = O0.exec(e)) !== null && t !== void 0 ? t : [], a = Nt.parse(n ?? ""), o = Nt.parse(s ?? ""), c = i === "*" ? a.multiply(o) : a.divide(o);
    if (c.isNaN())
      return Di;
    e = e.replace(O0, c.toString());
  }
  for (; e.includes("+") || /.-\d+(?:\.\d+)?/.test(e); ) {
    var l, [, u, d, f] = (l = R0.exec(e)) !== null && l !== void 0 ? l : [], h = Nt.parse(u ?? ""), g = Nt.parse(f ?? ""), m = d === "+" ? h.add(g) : h.subtract(g);
    if (m.isNaN())
      return Di;
    e = e.replace(R0, m.toString());
  }
  return e;
}
var D0 = /\(([^()]*)\)/;
function ZN(r) {
  for (var e = r, t; (t = D0.exec(e)) != null; ) {
    var [, n] = t;
    e = e.replace(D0, wT(n));
  }
  return e;
}
function JN(r) {
  var e = r.replace(/\s+/g, "");
  return e = ZN(e), e = wT(e), e;
}
function eF(r) {
  try {
    return JN(r);
  } catch {
    return Di;
  }
}
function ku(r) {
  var e = eF(r.slice(5, -1));
  return e === Di ? "" : e;
}
var tF = ["x", "y", "lineHeight", "capHeight", "scaleToFit", "textAnchor", "verticalAnchor", "fill"], rF = ["dx", "dy", "angle", "className", "breakAll"];
function tf() {
  return tf = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t) ({}).hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, tf.apply(null, arguments);
}
function C0(r, e) {
  if (r == null) return {};
  var t, n, i = nF(r, e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(r);
    for (n = 0; n < s.length; n++) t = s[n], e.indexOf(t) === -1 && {}.propertyIsEnumerable.call(r, t) && (i[t] = r[t]);
  }
  return i;
}
function nF(r, e) {
  if (r == null) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.indexOf(n) !== -1) continue;
    t[n] = r[n];
  }
  return t;
}
var IT = /[ \f\n\r\t\v\u2028\u2029]+/, PT = (r) => {
  var {
    children: e,
    breakAll: t,
    style: n
  } = r;
  try {
    var i = [];
    ye(e) || (t ? i = e.toString().split("") : i = e.toString().split(IT));
    var s = i.map((o) => ({
      word: o,
      width: Ns(o, n).width
    })), a = t ? 0 : Ns(" ", n).width;
    return {
      wordsWithComputedWidth: s,
      spaceWidth: a
    };
  } catch {
    return null;
  }
}, iF = (r, e, t, n, i) => {
  var {
    maxLines: s,
    children: a,
    style: o,
    breakAll: c
  } = r, l = z(s), u = a, d = function() {
    var R = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return R.reduce((D, F) => {
      var {
        word: B,
        width: j
      } = F, U = D[D.length - 1];
      if (U && (n == null || i || U.width + j + t < Number(n)))
        U.words.push(B), U.width += j + t;
      else {
        var K = {
          words: [B],
          width: j
        };
        D.push(K);
      }
      return D;
    }, []);
  }, f = d(e), h = (_) => _.reduce((R, D) => R.width > D.width ? R : D);
  if (!l || i)
    return f;
  var g = f.length > s || h(f).width > Number(n);
  if (!g)
    return f;
  for (var m = "…", p = (_) => {
    var R = u.slice(0, _), D = PT({
      breakAll: c,
      style: o,
      children: R + m
    }).wordsWithComputedWidth, F = d(D), B = F.length > s || h(F).width > Number(n);
    return [B, F];
  }, v = 0, y = u.length - 1, b = 0, x; v <= y && b <= u.length - 1; ) {
    var S = Math.floor((v + y) / 2), A = S - 1, [T, I] = p(A), [L] = p(S);
    if (!T && !L && (v = S + 1), T && L && (y = S - 1), !T && L) {
      x = I;
      break;
    }
    b++;
  }
  return x || f;
}, k0 = (r) => {
  var e = ye(r) ? [] : r.toString().split(IT);
  return [{
    words: e
  }];
}, sF = (r) => {
  var {
    width: e,
    scaleToFit: t,
    children: n,
    style: i,
    breakAll: s,
    maxLines: a
  } = r;
  if ((e || t) && !pn.isSsr) {
    var o, c, l = PT({
      breakAll: s,
      children: n,
      style: i
    });
    if (l) {
      var {
        wordsWithComputedWidth: u,
        spaceWidth: d
      } = l;
      o = u, c = d;
    } else
      return k0(n);
    return iF({
      breakAll: s,
      children: n,
      maxLines: a,
      style: i
    }, o, c, e, t);
  }
  return k0(n);
}, M0 = "#808080", Wl = /* @__PURE__ */ Kt((r, e) => {
  var {
    x: t = 0,
    y: n = 0,
    lineHeight: i = "1em",
    // Magic number from d3
    capHeight: s = "0.71em",
    scaleToFit: a = !1,
    textAnchor: o = "start",
    // Maintain compat with existing charts / default SVG behavior
    verticalAnchor: c = "end",
    fill: l = M0
  } = r, u = C0(r, tF), d = Jt(() => sF({
    breakAll: u.breakAll,
    children: u.children,
    maxLines: u.maxLines,
    scaleToFit: a,
    style: u.style,
    width: u.width
  }), [u.breakAll, u.children, u.maxLines, a, u.style, u.width]), {
    dx: f,
    dy: h,
    angle: g,
    className: m,
    breakAll: p
  } = u, v = C0(u, rF);
  if (!Br(t) || !Br(n))
    return null;
  var y = t + (z(f) ? f : 0), b = n + (z(h) ? h : 0), x;
  switch (c) {
    case "start":
      x = ku("calc(".concat(s, ")"));
      break;
    case "middle":
      x = ku("calc(".concat((d.length - 1) / 2, " * -").concat(i, " + (").concat(s, " / 2))"));
      break;
    default:
      x = ku("calc(".concat(d.length - 1, " * -").concat(i, ")"));
      break;
  }
  var S = [];
  if (a) {
    var A = d[0].width, {
      width: T
    } = u;
    S.push("scale(".concat(z(T) ? T / A : 1, ")"));
  }
  return g && S.push("rotate(".concat(g, ", ").concat(y, ", ").concat(b, ")")), S.length && (v.transform = S.join(" ")), /* @__PURE__ */ w.createElement("text", tf({}, de(v, !0), {
    ref: e,
    x: y,
    y: b,
    className: ve("recharts-text", m),
    textAnchor: o,
    fill: l.includes("url") ? M0 : l
  }), d.map((I, L) => {
    var _ = I.words.join(p ? "" : " ");
    return (
      // duplicate words will cause duplicate keys
      // eslint-disable-next-line react/no-array-index-key
      /* @__PURE__ */ w.createElement("tspan", {
        x: y,
        dy: L === 0 ? x : i,
        key: "".concat(_, "-").concat(L)
      }, _)
    );
  }));
});
Wl.displayName = "Text";
var aF = ["offset"], oF = ["labelRef"];
function N0(r, e) {
  if (r == null) return {};
  var t, n, i = lF(r, e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(r);
    for (n = 0; n < s.length; n++) t = s[n], e.indexOf(t) === -1 && {}.propertyIsEnumerable.call(r, t) && (i[t] = r[t]);
  }
  return i;
}
function lF(r, e) {
  if (r == null) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.indexOf(n) !== -1) continue;
    t[n] = r[n];
  }
  return t;
}
function F0(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function nt(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? F0(Object(t), !0).forEach(function(n) {
      cF(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : F0(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function cF(r, e, t) {
  return (e = uF(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function uF(r) {
  var e = dF(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function dF(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function Qr() {
  return Qr = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t) ({}).hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, Qr.apply(null, arguments);
}
var fF = (r) => {
  var {
    value: e,
    formatter: t
  } = r, n = ye(r.children) ? e : r.children;
  return typeof t == "function" ? t(n) : n;
}, yg = (r) => r != null && typeof r == "function", hF = (r, e) => {
  var t = pt(e - r), n = Math.min(Math.abs(e - r), 360);
  return t * n;
}, gF = (r, e, t) => {
  var {
    position: n,
    viewBox: i,
    offset: s,
    className: a
  } = r, {
    cx: o,
    cy: c,
    innerRadius: l,
    outerRadius: u,
    startAngle: d,
    endAngle: f,
    clockWise: h
  } = i, g = (l + u) / 2, m = hF(d, f), p = m >= 0 ? 1 : -1, v, y;
  n === "insideStart" ? (v = d + p * s, y = h) : n === "insideEnd" ? (v = f - p * s, y = !h) : n === "end" && (v = f + p * s, y = h), y = m <= 0 ? y : !y;
  var b = st(o, c, g, v), x = st(o, c, g, v + (y ? 1 : -1) * 359), S = "M".concat(b.x, ",").concat(b.y, `
    A`).concat(g, ",").concat(g, ",0,1,").concat(y ? 0 : 1, `,
    `).concat(x.x, ",").concat(x.y), A = ye(r.id) ? nn("recharts-radial-line-") : r.id;
  return /* @__PURE__ */ w.createElement("text", Qr({}, t, {
    dominantBaseline: "central",
    className: ve("recharts-radial-bar-label", a)
  }), /* @__PURE__ */ w.createElement("defs", null, /* @__PURE__ */ w.createElement("path", {
    id: A,
    d: S
  })), /* @__PURE__ */ w.createElement("textPath", {
    xlinkHref: "#".concat(A)
  }, e));
}, mF = (r) => {
  var {
    viewBox: e,
    offset: t,
    position: n
  } = r, {
    cx: i,
    cy: s,
    innerRadius: a,
    outerRadius: o,
    startAngle: c,
    endAngle: l
  } = e, u = (c + l) / 2;
  if (n === "outside") {
    var {
      x: d,
      y: f
    } = st(i, s, o + t, u);
    return {
      x: d,
      y: f,
      textAnchor: d >= i ? "start" : "end",
      verticalAnchor: "middle"
    };
  }
  if (n === "center")
    return {
      x: i,
      y: s,
      textAnchor: "middle",
      verticalAnchor: "middle"
    };
  if (n === "centerTop")
    return {
      x: i,
      y: s,
      textAnchor: "middle",
      verticalAnchor: "start"
    };
  if (n === "centerBottom")
    return {
      x: i,
      y: s,
      textAnchor: "middle",
      verticalAnchor: "end"
    };
  var h = (a + o) / 2, {
    x: g,
    y: m
  } = st(i, s, h, u);
  return {
    x: g,
    y: m,
    textAnchor: "middle",
    verticalAnchor: "middle"
  };
}, pF = (r, e) => {
  var {
    parentViewBox: t,
    offset: n,
    position: i
  } = r, {
    x: s,
    y: a,
    width: o,
    height: c
  } = e, l = c >= 0 ? 1 : -1, u = l * n, d = l > 0 ? "end" : "start", f = l > 0 ? "start" : "end", h = o >= 0 ? 1 : -1, g = h * n, m = h > 0 ? "end" : "start", p = h > 0 ? "start" : "end";
  if (i === "top") {
    var v = {
      x: s + o / 2,
      y: a - l * n,
      textAnchor: "middle",
      verticalAnchor: d
    };
    return nt(nt({}, v), t ? {
      height: Math.max(a - t.y, 0),
      width: o
    } : {});
  }
  if (i === "bottom") {
    var y = {
      x: s + o / 2,
      y: a + c + u,
      textAnchor: "middle",
      verticalAnchor: f
    };
    return nt(nt({}, y), t ? {
      height: Math.max(t.y + t.height - (a + c), 0),
      width: o
    } : {});
  }
  if (i === "left") {
    var b = {
      x: s - g,
      y: a + c / 2,
      textAnchor: m,
      verticalAnchor: "middle"
    };
    return nt(nt({}, b), t ? {
      width: Math.max(b.x - t.x, 0),
      height: c
    } : {});
  }
  if (i === "right") {
    var x = {
      x: s + o + g,
      y: a + c / 2,
      textAnchor: p,
      verticalAnchor: "middle"
    };
    return nt(nt({}, x), t ? {
      width: Math.max(t.x + t.width - x.x, 0),
      height: c
    } : {});
  }
  var S = t ? {
    width: o,
    height: c
  } : {};
  return i === "insideLeft" ? nt({
    x: s + g,
    y: a + c / 2,
    textAnchor: p,
    verticalAnchor: "middle"
  }, S) : i === "insideRight" ? nt({
    x: s + o - g,
    y: a + c / 2,
    textAnchor: m,
    verticalAnchor: "middle"
  }, S) : i === "insideTop" ? nt({
    x: s + o / 2,
    y: a + u,
    textAnchor: "middle",
    verticalAnchor: f
  }, S) : i === "insideBottom" ? nt({
    x: s + o / 2,
    y: a + c - u,
    textAnchor: "middle",
    verticalAnchor: d
  }, S) : i === "insideTopLeft" ? nt({
    x: s + g,
    y: a + u,
    textAnchor: p,
    verticalAnchor: f
  }, S) : i === "insideTopRight" ? nt({
    x: s + o - g,
    y: a + u,
    textAnchor: m,
    verticalAnchor: f
  }, S) : i === "insideBottomLeft" ? nt({
    x: s + g,
    y: a + c - u,
    textAnchor: p,
    verticalAnchor: d
  }, S) : i === "insideBottomRight" ? nt({
    x: s + o - g,
    y: a + c - u,
    textAnchor: m,
    verticalAnchor: d
  }, S) : i && typeof i == "object" && (z(i.x) || Qn(i.x)) && (z(i.y) || Qn(i.y)) ? nt({
    x: s + Dt(i.x, o),
    y: a + Dt(i.y, c),
    textAnchor: "end",
    verticalAnchor: "end"
  }, S) : nt({
    x: s + o / 2,
    y: a + c / 2,
    textAnchor: "middle",
    verticalAnchor: "middle"
  }, S);
}, vF = (r) => "cx" in r && z(r.cx);
function Xt(r) {
  var {
    offset: e = 5
  } = r, t = N0(r, aF), n = nt({
    offset: e
  }, t), {
    viewBox: i,
    position: s,
    value: a,
    children: o,
    content: c,
    className: l = "",
    textBreakAll: u,
    labelRef: d
  } = n, f = ch(), h = i || f;
  if (!h || ye(a) && ye(o) && !/* @__PURE__ */ _r(c) && typeof c != "function")
    return null;
  if (/* @__PURE__ */ _r(c)) {
    var {
      labelRef: g
    } = n, m = N0(n, oF);
    return /* @__PURE__ */ fn(c, m);
  }
  var p;
  if (typeof c == "function") {
    if (p = /* @__PURE__ */ Vb(c, n), /* @__PURE__ */ _r(p))
      return p;
  } else
    p = fF(n);
  var v = vF(h), y = de(n, !0);
  if (v && (s === "insideStart" || s === "insideEnd" || s === "end"))
    return gF(n, p, y);
  var b = v ? mF(n) : pF(n, h);
  return /* @__PURE__ */ w.createElement(Wl, Qr({
    ref: d,
    className: ve("recharts-label", l)
  }, y, b, {
    breakAll: u
  }), p);
}
Xt.displayName = "Label";
var _T = (r) => {
  var {
    cx: e,
    cy: t,
    angle: n,
    startAngle: i,
    endAngle: s,
    r: a,
    radius: o,
    innerRadius: c,
    outerRadius: l,
    x: u,
    y: d,
    top: f,
    left: h,
    width: g,
    height: m,
    clockWise: p,
    labelViewBox: v
  } = r;
  if (v)
    return v;
  if (z(g) && z(m)) {
    if (z(u) && z(d))
      return {
        x: u,
        y: d,
        width: g,
        height: m
      };
    if (z(f) && z(h))
      return {
        x: f,
        y: h,
        width: g,
        height: m
      };
  }
  if (z(u) && z(d))
    return {
      x: u,
      y: d,
      width: 0,
      height: 0
    };
  if (z(e) && z(t))
    return {
      cx: e,
      cy: t,
      startAngle: i || n || 0,
      endAngle: s || n || 0,
      innerRadius: c || 0,
      outerRadius: l || o || a || 0,
      clockWise: p
    };
  if (r.viewBox)
    return r.viewBox;
}, yF = (r, e, t) => {
  if (!r)
    return null;
  var n = {
    viewBox: e,
    labelRef: t
  };
  return r === !0 ? /* @__PURE__ */ w.createElement(Xt, Qr({
    key: "label-implicit"
  }, n)) : Br(r) ? /* @__PURE__ */ w.createElement(Xt, Qr({
    key: "label-implicit",
    value: r
  }, n)) : /* @__PURE__ */ _r(r) ? r.type === Xt ? /* @__PURE__ */ fn(r, nt({
    key: "label-implicit"
  }, n)) : /* @__PURE__ */ w.createElement(Xt, Qr({
    key: "label-implicit",
    content: r
  }, n)) : yg(r) ? /* @__PURE__ */ w.createElement(Xt, Qr({
    key: "label-implicit",
    content: r
  }, n)) : r && typeof r == "object" ? /* @__PURE__ */ w.createElement(Xt, Qr({}, r, {
    key: "label-implicit"
  }, n)) : null;
}, bF = function(e, t) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
  if (!e || !e.children && n && !e.label)
    return null;
  var {
    children: i,
    labelRef: s
  } = e, a = _T(e), o = is(i, Xt).map((l, u) => /* @__PURE__ */ fn(l, {
    viewBox: t || a,
    // eslint-disable-next-line react/no-array-index-key
    key: "label-".concat(u)
  }));
  if (!n)
    return o;
  var c = yF(e.label, t || a, s);
  return [c, ...o];
};
Xt.parseViewBox = _T;
Xt.renderCallByParent = bF;
var Mu = {}, Nu = {}, $0;
function xF() {
  return $0 || ($0 = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    function e(t) {
      return t[t.length - 1];
    }
    r.last = e;
  }(Nu)), Nu;
}
var Fu = {}, B0;
function EF() {
  return B0 || (B0 = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    function e(t) {
      return Array.isArray(t) ? t : Array.from(t);
    }
    r.toArray = e;
  }(Fu)), Fu;
}
var j0;
function SF() {
  return j0 || (j0 = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    const e = /* @__PURE__ */ xF(), t = /* @__PURE__ */ EF(), n = /* @__PURE__ */ qf();
    function i(s) {
      if (n.isArrayLike(s))
        return e.last(t.toArray(s));
    }
    r.last = i;
  }(Mu)), Mu;
}
var $u, U0;
function TF() {
  return U0 || (U0 = 1, $u = SF().last), $u;
}
var AF = /* @__PURE__ */ TF();
const wF = /* @__PURE__ */ hn(AF);
var IF = ["valueAccessor"], PF = ["data", "dataKey", "clockWise", "id", "textBreakAll"];
function Qo() {
  return Qo = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t) ({}).hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, Qo.apply(null, arguments);
}
function G0(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function K0(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? G0(Object(t), !0).forEach(function(n) {
      _F(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : G0(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function _F(r, e, t) {
  return (e = LF(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function LF(r) {
  var e = OF(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function OF(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function V0(r, e) {
  if (r == null) return {};
  var t, n, i = RF(r, e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(r);
    for (n = 0; n < s.length; n++) t = s[n], e.indexOf(t) === -1 && {}.propertyIsEnumerable.call(r, t) && (i[t] = r[t]);
  }
  return i;
}
function RF(r, e) {
  if (r == null) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.indexOf(n) !== -1) continue;
    t[n] = r[n];
  }
  return t;
}
var DF = (r) => Array.isArray(r.value) ? wF(r.value) : r.value;
function $r(r) {
  var {
    valueAccessor: e = DF
  } = r, t = V0(r, IF), {
    data: n,
    dataKey: i,
    clockWise: s,
    id: a,
    textBreakAll: o
  } = t, c = V0(t, PF);
  return !n || !n.length ? null : /* @__PURE__ */ w.createElement(Fe, {
    className: "recharts-label-list"
  }, n.map((l, u) => {
    var d = ye(i) ? e(l, u) : Pe(l && l.payload, i), f = ye(a) ? {} : {
      id: "".concat(a, "-").concat(u)
    };
    return /* @__PURE__ */ w.createElement(Xt, Qo({}, de(l, !0), c, f, {
      parentViewBox: l.parentViewBox,
      value: d,
      textBreakAll: o,
      viewBox: Xt.parseViewBox(ye(s) ? l : K0(K0({}, l), {}, {
        clockWise: s
      })),
      key: "label-".concat(u),
      index: u
    }));
  }));
}
$r.displayName = "LabelList";
function CF(r, e) {
  return r ? r === !0 ? /* @__PURE__ */ w.createElement($r, {
    key: "labelList-implicit",
    data: e
  }) : /* @__PURE__ */ w.isValidElement(r) || yg(r) ? /* @__PURE__ */ w.createElement($r, {
    key: "labelList-implicit",
    data: e,
    content: r
  }) : typeof r == "object" ? /* @__PURE__ */ w.createElement($r, Qo({
    data: e
  }, r, {
    key: "labelList-implicit"
  })) : null : null;
}
function kF(r, e) {
  var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
  if (!r || !r.children && t && !r.label)
    return null;
  var {
    children: n
  } = r, i = is(n, $r).map((a, o) => /* @__PURE__ */ fn(a, {
    data: e,
    // eslint-disable-next-line react/no-array-index-key
    key: "labelList-".concat(o)
  }));
  if (!t)
    return i;
  var s = CF(r.label, e);
  return [s, ...i];
}
$r.renderCallByParent = kF;
function rf() {
  return rf = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t) ({}).hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, rf.apply(null, arguments);
}
var bg = (r) => {
  var {
    cx: e,
    cy: t,
    r: n,
    className: i
  } = r, s = ve("recharts-dot", i);
  return e === +e && t === +t && n === +n ? /* @__PURE__ */ w.createElement("circle", rf({}, de(r, !1), jf(r), {
    className: s,
    cx: e,
    cy: t,
    r: n
  })) : null;
}, LT = (r) => r.graphicalItems.polarItems, MF = M([Ze, ba], qh), xg = M([LT, Je, MF], zh), NF = M([xg], Yh), Eg = M([NF, Fh], Xh), FF = M([Eg, Je, xg], Qh), $F = M([Eg, Je, xg], (r, e, t) => t.length > 0 ? r.flatMap((n) => t.flatMap((i) => {
  var s, a = Pe(n, (s = e.dataKey) !== null && s !== void 0 ? s : i.dataKey);
  return {
    value: a,
    errorDomain: []
    // polar charts do not have error bars
  };
})).filter(Boolean) : (e == null ? void 0 : e.dataKey) != null ? r.map((n) => ({
  value: Pe(n, e.dataKey),
  errorDomain: []
})) : r.map((n) => ({
  value: n,
  errorDomain: []
}))), W0 = () => {
}, BF = M([Je, $S, W0, $F, W0], eg), OT = M([Je, Ee, Eg, FF, ya, Ze, BF], tg), jF = M([OT, Je, us], ig);
M([Je, OT, jF, Ze], ag);
var UF = {
  radiusAxis: {},
  angleAxis: {}
}, RT = xr({
  name: "polarAxis",
  initialState: UF,
  reducers: {
    addRadiusAxis(r, e) {
      r.radiusAxis[e.payload.id] = e.payload;
    },
    removeRadiusAxis(r, e) {
      delete r.radiusAxis[e.payload.id];
    },
    addAngleAxis(r, e) {
      r.angleAxis[e.payload.id] = e.payload;
    },
    removeAngleAxis(r, e) {
      delete r.angleAxis[e.payload.id];
    }
  }
}), {
  addRadiusAxis: b4,
  removeRadiusAxis: x4,
  addAngleAxis: E4,
  removeAngleAxis: S4
} = RT.actions, GF = RT.reducer;
function H0(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function q0(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? H0(Object(t), !0).forEach(function(n) {
      KF(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : H0(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function KF(r, e, t) {
  return (e = VF(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function VF(r) {
  var e = WF(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function WF(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
var Sg = (r, e) => e, HF = [], Tg = (r, e, t) => (t == null ? void 0 : t.length) === 0 ? HF : t, DT = M([Fh, Sg, Tg], (r, e, t) => {
  var {
    chartData: n
  } = r, i;
  if ((e == null ? void 0 : e.data) != null && e.data.length > 0 ? i = e.data : i = n, (!i || !i.length) && t != null && (i = t.map((s) => q0(q0({}, e.presentationProps), s.props))), i != null)
    return i;
}), qF = M([DT, Sg, Tg], (r, e, t) => {
  if (r != null)
    return r.map((n, i) => {
      var s, a = Pe(n, e.nameKey, e.name), o;
      return t != null && (s = t[i]) !== null && s !== void 0 && (s = s.props) !== null && s !== void 0 && s.fill ? o = t[i].props.fill : typeof n == "object" && n != null && "fill" in n ? o = n.fill : o = e.fill, {
        value: Wr(a, e.dataKey),
        color: o,
        payload: n,
        type: e.legendType
      };
    });
}), zF = M([LT, Sg], (r, e) => {
  if (r.some((t) => t.type === "pie" && e.dataKey === t.dataKey && e.data === t.data))
    return e;
}), YF = M([DT, zF, Tg, ut], (r, e, t, n) => {
  if (!(e == null || r == null))
    return j$({
      offset: n,
      pieSettings: e,
      displayedData: r,
      cells: t
    });
}), XF = {
  countOfBars: 0,
  cartesianItems: [],
  polarItems: []
}, CT = xr({
  name: "graphicalItems",
  initialState: XF,
  reducers: {
    addBar(r) {
      r.countOfBars += 1;
    },
    removeBar(r) {
      r.countOfBars -= 1;
    },
    addCartesianGraphicalItem(r, e) {
      r.cartesianItems.push(e.payload);
    },
    replaceCartesianGraphicalItem(r, e) {
      var {
        prev: t,
        next: n
      } = e.payload, i = tn(r).cartesianItems.indexOf(t);
      i > -1 && (r.cartesianItems[i] = n);
    },
    removeCartesianGraphicalItem(r, e) {
      var t = tn(r).cartesianItems.indexOf(e.payload);
      t > -1 && r.cartesianItems.splice(t, 1);
    },
    addPolarGraphicalItem(r, e) {
      r.polarItems.push(e.payload);
    },
    removePolarGraphicalItem(r, e) {
      var t = tn(r).polarItems.indexOf(e.payload);
      t > -1 && r.polarItems.splice(t, 1);
    }
  }
}), {
  addBar: QF,
  removeBar: ZF,
  addCartesianGraphicalItem: JF,
  replaceCartesianGraphicalItem: e$,
  removeCartesianGraphicalItem: t$,
  addPolarGraphicalItem: r$,
  removePolarGraphicalItem: n$
} = CT.actions, i$ = CT.reducer;
function z0(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function Y0(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? z0(Object(t), !0).forEach(function(n) {
      s$(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : z0(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function s$(r, e, t) {
  return (e = a$(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function a$(r) {
  var e = o$(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function o$(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function l$(r) {
  var e = He(), t = Ke(null);
  return we(() => {
    var n = Y0(Y0({}, r), {}, {
      stackId: ih(r.stackId)
    });
    t.current === null ? e(JF(n)) : t.current !== n && e(e$({
      prev: t.current,
      next: n
    })), t.current = n;
  }, [e, r]), we(() => () => {
    t.current && (e(t$(t.current)), t.current = null);
  }, [e]), null;
}
function c$(r) {
  var e = He();
  return we(() => (e(r$(r)), () => {
    e(n$(r));
  }), [e, r]), null;
}
var Bu = {}, X0;
function u$() {
  return X0 || (X0 = 1, function(r) {
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
    function e(t) {
      var i;
      if (typeof t != "object" || t == null)
        return !1;
      if (Object.getPrototypeOf(t) === null)
        return !0;
      if (Object.prototype.toString.call(t) !== "[object Object]") {
        const s = t[Symbol.toStringTag];
        return s == null || !((i = Object.getOwnPropertyDescriptor(t, Symbol.toStringTag)) != null && i.writable) ? !1 : t.toString() === `[object ${s}]`;
      }
      let n = t;
      for (; Object.getPrototypeOf(n) !== null; )
        n = Object.getPrototypeOf(n);
      return Object.getPrototypeOf(t) === n;
    }
    r.isPlainObject = e;
  }(Bu)), Bu;
}
var ju, Q0;
function d$() {
  return Q0 || (Q0 = 1, ju = u$().isPlainObject), ju;
}
var f$ = /* @__PURE__ */ d$();
const h$ = /* @__PURE__ */ hn(f$);
function Zo() {
  return Zo = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t) ({}).hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, Zo.apply(null, arguments);
}
var Z0 = (r, e, t, n, i) => {
  var s = t - n, a;
  return a = "M ".concat(r, ",").concat(e), a += "L ".concat(r + t, ",").concat(e), a += "L ".concat(r + t - s / 2, ",").concat(e + i), a += "L ".concat(r + t - s / 2 - n, ",").concat(e + i), a += "L ".concat(r, ",").concat(e, " Z"), a;
}, g$ = {
  x: 0,
  y: 0,
  upperWidth: 0,
  lowerWidth: 0,
  height: 0,
  isUpdateAnimationActive: !1,
  animationBegin: 0,
  animationDuration: 1500,
  animationEasing: "ease"
}, m$ = (r) => {
  var e = Vt(r, g$), t = Ke(), [n, i] = _e(-1);
  we(() => {
    if (t.current && t.current.getTotalLength)
      try {
        var p = t.current.getTotalLength();
        p && i(p);
      } catch {
      }
  }, []);
  var {
    x: s,
    y: a,
    upperWidth: o,
    lowerWidth: c,
    height: l,
    className: u
  } = e, {
    animationEasing: d,
    animationDuration: f,
    animationBegin: h,
    isUpdateAnimationActive: g
  } = e;
  if (s !== +s || a !== +a || o !== +o || c !== +c || l !== +l || o === 0 && c === 0 || l === 0)
    return null;
  var m = ve("recharts-trapezoid", u);
  return g ? /* @__PURE__ */ w.createElement(jr, {
    canBegin: n > 0,
    from: {
      upperWidth: 0,
      lowerWidth: 0,
      height: l,
      x: s,
      y: a
    },
    to: {
      upperWidth: o,
      lowerWidth: c,
      height: l,
      x: s,
      y: a
    },
    duration: f,
    animationEasing: d,
    isActive: g
  }, (p) => {
    var {
      upperWidth: v,
      lowerWidth: y,
      height: b,
      x,
      y: S
    } = p;
    return /* @__PURE__ */ w.createElement(jr, {
      canBegin: n > 0,
      from: "0px ".concat(n === -1 ? 1 : n, "px"),
      to: "".concat(n, "px 0px"),
      attributeName: "strokeDasharray",
      begin: h,
      duration: f,
      easing: d
    }, /* @__PURE__ */ w.createElement("path", Zo({}, de(e, !0), {
      className: m,
      d: Z0(x, S, v, y, b),
      ref: t
    })));
  }) : /* @__PURE__ */ w.createElement("g", null, /* @__PURE__ */ w.createElement("path", Zo({}, de(e, !0), {
    className: m,
    d: Z0(s, a, o, c, l)
  })));
}, p$ = ["option", "shapeType", "propTransformer", "activeClassName", "isActive"];
function v$(r, e) {
  if (r == null) return {};
  var t, n, i = y$(r, e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(r);
    for (n = 0; n < s.length; n++) t = s[n], e.indexOf(t) === -1 && {}.propertyIsEnumerable.call(r, t) && (i[t] = r[t]);
  }
  return i;
}
function y$(r, e) {
  if (r == null) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.indexOf(n) !== -1) continue;
    t[n] = r[n];
  }
  return t;
}
function J0(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function Jo(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? J0(Object(t), !0).forEach(function(n) {
      b$(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : J0(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function b$(r, e, t) {
  return (e = x$(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function x$(r) {
  var e = E$(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function E$(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function S$(r, e) {
  return Jo(Jo({}, e), r);
}
function T$(r, e) {
  return r === "symbols";
}
function ey(r) {
  var {
    shapeType: e,
    elementProps: t
  } = r;
  switch (e) {
    case "rectangle":
      return /* @__PURE__ */ w.createElement(xE, t);
    case "trapezoid":
      return /* @__PURE__ */ w.createElement(m$, t);
    case "sector":
      return /* @__PURE__ */ w.createElement(TE, t);
    case "symbols":
      if (T$(e))
        return /* @__PURE__ */ w.createElement(xl, t);
      break;
    default:
      return null;
  }
}
function A$(r) {
  return /* @__PURE__ */ _r(r) ? r.props : r;
}
function el(r) {
  var {
    option: e,
    shapeType: t,
    propTransformer: n = S$,
    activeClassName: i = "recharts-active-shape",
    isActive: s
  } = r, a = v$(r, p$), o;
  if (/* @__PURE__ */ _r(e))
    o = /* @__PURE__ */ fn(e, Jo(Jo({}, a), A$(e)));
  else if (typeof e == "function")
    o = e(a);
  else if (h$(e) && typeof e != "boolean") {
    var c = n(e, a);
    o = /* @__PURE__ */ w.createElement(ey, {
      shapeType: t,
      elementProps: c
    });
  } else {
    var l = a;
    o = /* @__PURE__ */ w.createElement(ey, {
      shapeType: t,
      elementProps: l
    });
  }
  return s ? /* @__PURE__ */ w.createElement(Fe, {
    className: i
  }, o) : o;
}
var Hl = (r, e) => {
  var t = He();
  return (n, i) => (s) => {
    r == null || r(n, i, s), t(eT({
      activeIndex: String(i),
      activeDataKey: e,
      activeCoordinate: n.tooltipPosition
    }));
  };
}, ql = (r) => {
  var e = He();
  return (t, n) => (i) => {
    r == null || r(t, n, i), e(cM());
  };
}, zl = (r, e) => {
  var t = He();
  return (n, i) => (s) => {
    r == null || r(n, i, s), t(uM({
      activeIndex: String(i),
      activeDataKey: e,
      activeCoordinate: n.tooltipPosition
    }));
  };
};
function Ia(r) {
  var {
    fn: e,
    args: t
  } = r, n = He(), i = At();
  return we(() => {
    if (!i) {
      var s = e(t);
      return n(aM(s)), () => {
        n(oM(s));
      };
    }
  }, [e, t, n, i]), null;
}
var kT = () => {
};
function Yl(r) {
  var {
    legendPayload: e
  } = r, t = He(), n = At();
  return we(() => n ? kT : (t(gE(e)), () => {
    t(mE(e));
  }), [t, n, e]), null;
}
function w$(r) {
  var {
    legendPayload: e
  } = r, t = He(), n = te(Ee);
  return we(() => n !== "centric" && n !== "radial" ? kT : (t(gE(e)), () => {
    t(mE(e));
  }), [t, n, e]), null;
}
function Pa(r) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "animation-", t = Ke(nn(e)), n = Ke(r);
  return n.current !== r && (t.current = nn(e), n.current = r), t.current;
}
var I$ = ["onMouseEnter", "onClick", "onMouseLeave"];
function P$(r, e) {
  if (r == null) return {};
  var t, n, i = _$(r, e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(r);
    for (n = 0; n < s.length; n++) t = s[n], e.indexOf(t) === -1 && {}.propertyIsEnumerable.call(r, t) && (i[t] = r[t]);
  }
  return i;
}
function _$(r, e) {
  if (r == null) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.indexOf(n) !== -1) continue;
    t[n] = r[n];
  }
  return t;
}
function ty(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function Ye(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ty(Object(t), !0).forEach(function(n) {
      Xl(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : ty(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function Xl(r, e, t) {
  return (e = L$(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function L$(r) {
  var e = O$(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function O$(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function gi() {
  return gi = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t) ({}).hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, gi.apply(null, arguments);
}
function R$(r) {
  var e = Jt(() => de(r, !1), [r]), t = Jt(() => is(r.children, wa), [r.children]), n = Jt(() => ({
    name: r.name,
    nameKey: r.nameKey,
    tooltipType: r.tooltipType,
    data: r.data,
    dataKey: r.dataKey,
    cx: r.cx,
    cy: r.cy,
    startAngle: r.startAngle,
    endAngle: r.endAngle,
    minAngle: r.minAngle,
    paddingAngle: r.paddingAngle,
    innerRadius: r.innerRadius,
    outerRadius: r.outerRadius,
    cornerRadius: r.cornerRadius,
    legendType: r.legendType,
    fill: r.fill,
    presentationProps: e
  }), [r.cornerRadius, r.cx, r.cy, r.data, r.dataKey, r.endAngle, r.innerRadius, r.minAngle, r.name, r.nameKey, r.outerRadius, r.paddingAngle, r.startAngle, r.tooltipType, r.legendType, r.fill, e]), i = te((s) => qF(s, n, t));
  return /* @__PURE__ */ w.createElement(w$, {
    legendPayload: i
  });
}
function D$(r) {
  var {
    dataKey: e,
    nameKey: t,
    sectors: n,
    stroke: i,
    strokeWidth: s,
    fill: a,
    name: o,
    hide: c,
    tooltipType: l
  } = r;
  return {
    dataDefinedOnItem: n == null ? void 0 : n.map((u) => u.tooltipPayload),
    positions: n == null ? void 0 : n.map((u) => u.tooltipPosition),
    settings: {
      stroke: i,
      strokeWidth: s,
      fill: a,
      dataKey: e,
      nameKey: t,
      name: Wr(o, e),
      hide: c,
      type: l,
      color: a,
      unit: ""
      // why doesn't Pie support unit?
    }
  };
}
var C$ = (r, e) => r > e ? "start" : r < e ? "end" : "middle", k$ = (r, e, t) => typeof e == "function" ? e(r) : Dt(e, t, t * 0.8), M$ = (r, e, t) => {
  var {
    top: n,
    left: i,
    width: s,
    height: a
  } = e, o = oE(s, a), c = i + Dt(r.cx, s, s / 2), l = n + Dt(r.cy, a, a / 2), u = Dt(r.innerRadius, o, 0), d = k$(t, r.outerRadius, o), f = r.maxRadius || Math.sqrt(s * s + a * a) / 2;
  return {
    cx: c,
    cy: l,
    innerRadius: u,
    outerRadius: d,
    maxRadius: f
  };
}, N$ = (r, e) => {
  var t = pt(e - r), n = Math.min(Math.abs(e - r), 360);
  return t * n;
}, F$ = (r, e) => {
  if (/* @__PURE__ */ w.isValidElement(r))
    return /* @__PURE__ */ w.cloneElement(r, e);
  if (typeof r == "function")
    return r(e);
  var t = ve("recharts-pie-label-line", typeof r != "boolean" ? r.className : "");
  return /* @__PURE__ */ w.createElement(ai, gi({}, e, {
    type: "linear",
    className: t
  }));
}, $$ = (r, e, t) => {
  if (/* @__PURE__ */ w.isValidElement(r))
    return /* @__PURE__ */ w.cloneElement(r, e);
  var n = t;
  if (typeof r == "function" && (n = r(e), /* @__PURE__ */ w.isValidElement(n)))
    return n;
  var i = ve("recharts-pie-label-text", typeof r != "boolean" && typeof r != "function" ? r.className : "");
  return /* @__PURE__ */ w.createElement(Wl, gi({}, e, {
    alignmentBaseline: "middle",
    className: i
  }), n);
};
function B$(r) {
  var {
    sectors: e,
    props: t,
    showLabels: n
  } = r, {
    label: i,
    labelLine: s,
    dataKey: a
  } = t;
  if (!n || !i || !e)
    return null;
  var o = de(t, !1), c = de(i, !1), l = de(s, !1), u = typeof i == "object" && "offsetRadius" in i && i.offsetRadius || 20, d = e.map((f, h) => {
    var g = (f.startAngle + f.endAngle) / 2, m = st(f.cx, f.cy, f.outerRadius + u, g), p = Ye(Ye(Ye(Ye({}, o), f), {}, {
      stroke: "none"
    }, c), {}, {
      index: h,
      textAnchor: C$(m.x, f.cx)
    }, m), v = Ye(Ye(Ye(Ye({}, o), f), {}, {
      fill: "none",
      stroke: f.fill
    }, l), {}, {
      index: h,
      points: [st(f.cx, f.cy, f.outerRadius, g), m],
      key: "line"
    });
    return (
      // eslint-disable-next-line react/no-array-index-key
      /* @__PURE__ */ w.createElement(Fe, {
        key: "label-".concat(f.startAngle, "-").concat(f.endAngle, "-").concat(f.midAngle, "-").concat(h)
      }, s && F$(s, v), $$(i, p, Pe(f, a)))
    );
  });
  return /* @__PURE__ */ w.createElement(Fe, {
    className: "recharts-pie-labels"
  }, d);
}
function MT(r) {
  var {
    sectors: e,
    activeShape: t,
    inactiveShape: n,
    allOtherPieProps: i,
    showLabels: s
  } = r, a = te(cn), {
    onMouseEnter: o,
    onClick: c,
    onMouseLeave: l
  } = i, u = P$(i, I$), d = Hl(o, i.dataKey), f = ql(l), h = zl(c, i.dataKey);
  return e == null ? null : /* @__PURE__ */ w.createElement(w.Fragment, null, e.map((g, m) => {
    if ((g == null ? void 0 : g.startAngle) === 0 && (g == null ? void 0 : g.endAngle) === 0 && e.length !== 1) return null;
    var p = t && String(m) === a, v = a ? n : null, y = p ? t : v, b = Ye(Ye({}, g), {}, {
      stroke: g.stroke,
      tabIndex: -1,
      [oh]: m,
      [lh]: i.dataKey
    });
    return /* @__PURE__ */ w.createElement(Fe, gi({
      tabIndex: -1,
      className: "recharts-pie-sector"
    }, ns(u, g, m), {
      // @ts-expect-error the types need a bit of attention
      onMouseEnter: d(g, m),
      onMouseLeave: f(g, m),
      onClick: h(g, m),
      key: "sector-".concat(g == null ? void 0 : g.startAngle, "-").concat(g == null ? void 0 : g.endAngle, "-").concat(g.midAngle, "-").concat(m)
    }), /* @__PURE__ */ w.createElement(el, gi({
      option: y,
      isActive: p,
      shapeType: "sector"
    }, b)));
  }), /* @__PURE__ */ w.createElement(B$, {
    sectors: e,
    props: i,
    showLabels: s
  }));
}
function j$(r) {
  var e, {
    pieSettings: t,
    displayedData: n,
    cells: i,
    offset: s
  } = r, {
    cornerRadius: a,
    startAngle: o,
    endAngle: c,
    dataKey: l,
    nameKey: u,
    tooltipType: d
  } = t, f = Math.abs(t.minAngle), h = N$(o, c), g = Math.abs(h), m = n.length <= 1 ? 0 : (e = t.paddingAngle) !== null && e !== void 0 ? e : 0, p = n.filter((A) => Pe(A, l, 0) !== 0).length, v = (g >= 360 ? p : p - 1) * m, y = g - p * f - v, b = n.reduce((A, T) => {
    var I = Pe(T, l, 0);
    return A + (z(I) ? I : 0);
  }, 0), x;
  if (b > 0) {
    var S;
    x = n.map((A, T) => {
      var I = Pe(A, l, 0), L = Pe(A, u, T), _ = M$(t, s, A), R = (z(I) ? I : 0) / b, D, F = Ye(Ye({}, A), i && i[T] && i[T].props);
      T ? D = S.endAngle + pt(h) * m * (I !== 0 ? 1 : 0) : D = o;
      var B = D + pt(h) * ((I !== 0 ? f : 0) + R * y), j = (D + B) / 2, U = (_.innerRadius + _.outerRadius) / 2, K = [{
        // @ts-expect-error getValueByDataKey does not validate the output type
        name: L,
        // @ts-expect-error getValueByDataKey does not validate the output type
        value: I,
        payload: F,
        dataKey: l,
        type: d
      }], G = st(_.cx, _.cy, U, j);
      return S = Ye(Ye(Ye(Ye({}, t.presentationProps), {}, {
        percent: R,
        cornerRadius: a,
        name: L,
        tooltipPayload: K,
        midAngle: j,
        middleRadius: U,
        tooltipPosition: G
      }, F), _), {}, {
        value: Pe(A, l),
        startAngle: D,
        endAngle: B,
        payload: F,
        paddingAngle: pt(h) * m
      }), S;
    });
  }
  return x;
}
function U$(r) {
  var {
    props: e,
    previousSectorsRef: t
  } = r, {
    sectors: n,
    isAnimationActive: i,
    animationBegin: s,
    animationDuration: a,
    animationEasing: o,
    activeShape: c,
    inactiveShape: l,
    onAnimationStart: u,
    onAnimationEnd: d
  } = e, f = Pa(e, "recharts-pie-"), h = t.current, [g, m] = _e(!0), p = Se(() => {
    typeof d == "function" && d(), m(!1);
  }, [d]), v = Se(() => {
    typeof u == "function" && u(), m(!0);
  }, [u]);
  return /* @__PURE__ */ w.createElement(jr, {
    begin: s,
    duration: a,
    isActive: i,
    easing: o,
    from: {
      t: 0
    },
    to: {
      t: 1
    },
    onAnimationStart: v,
    onAnimationEnd: p,
    key: f
  }, (y) => {
    var {
      t: b
    } = y, x = [], S = n && n[0], A = S.startAngle;
    return n.forEach((T, I) => {
      var L = h && h[I], _ = I > 0 ? Mn(T, "paddingAngle", 0) : 0;
      if (L) {
        var R = Et(L.endAngle - L.startAngle, T.endAngle - T.startAngle), D = Ye(Ye({}, T), {}, {
          startAngle: A + _,
          endAngle: A + R(b) + _
        });
        x.push(D), A = D.endAngle;
      } else {
        var {
          endAngle: F,
          startAngle: B
        } = T, j = Et(0, F - B), U = j(b), K = Ye(Ye({}, T), {}, {
          startAngle: A + _,
          endAngle: A + U + _
        });
        x.push(K), A = K.endAngle;
      }
    }), t.current = x, /* @__PURE__ */ w.createElement(Fe, null, /* @__PURE__ */ w.createElement(MT, {
      sectors: x,
      activeShape: c,
      inactiveShape: l,
      allOtherPieProps: e,
      showLabels: !g
    }));
  });
}
function G$(r) {
  var {
    sectors: e,
    isAnimationActive: t,
    activeShape: n,
    inactiveShape: i
  } = r, s = Ke(null), a = s.current;
  return t && e && e.length && (!a || a !== e) ? /* @__PURE__ */ w.createElement(U$, {
    props: r,
    previousSectorsRef: s
  }) : /* @__PURE__ */ w.createElement(MT, {
    sectors: e,
    activeShape: n,
    inactiveShape: i,
    allOtherPieProps: r,
    showLabels: !0
  });
}
function K$(r) {
  var {
    hide: e,
    className: t,
    rootTabIndex: n
  } = r, i = ve("recharts-pie", t);
  return e ? null : /* @__PURE__ */ w.createElement(Fe, {
    tabIndex: n,
    className: i
  }, /* @__PURE__ */ w.createElement(G$, r));
}
var NT = {
  animationBegin: 400,
  animationDuration: 1500,
  animationEasing: "ease",
  cx: "50%",
  cy: "50%",
  dataKey: "value",
  endAngle: 360,
  fill: "#808080",
  hide: !1,
  innerRadius: 0,
  isAnimationActive: !pn.isSsr,
  labelLine: !0,
  legendType: "rect",
  minAngle: 0,
  nameKey: "name",
  outerRadius: "80%",
  paddingAngle: 0,
  rootTabIndex: 0,
  startAngle: 0,
  stroke: "#fff"
};
function V$(r) {
  var e = Vt(r, NT), t = Jt(() => is(r.children, wa), [r.children]), n = de(e, !1), i = Jt(() => ({
    name: e.name,
    nameKey: e.nameKey,
    tooltipType: e.tooltipType,
    data: e.data,
    dataKey: e.dataKey,
    cx: e.cx,
    cy: e.cy,
    startAngle: e.startAngle,
    endAngle: e.endAngle,
    minAngle: e.minAngle,
    paddingAngle: e.paddingAngle,
    innerRadius: e.innerRadius,
    outerRadius: e.outerRadius,
    cornerRadius: e.cornerRadius,
    legendType: e.legendType,
    fill: e.fill,
    presentationProps: n
  }), [e.cornerRadius, e.cx, e.cy, e.data, e.dataKey, e.endAngle, e.innerRadius, e.minAngle, e.name, e.nameKey, e.outerRadius, e.paddingAngle, e.startAngle, e.tooltipType, e.legendType, e.fill, n]), s = te((a) => YF(a, i, t));
  return /* @__PURE__ */ w.createElement(w.Fragment, null, /* @__PURE__ */ w.createElement(Ia, {
    fn: D$,
    args: Ye(Ye({}, e), {}, {
      sectors: s
    })
  }), /* @__PURE__ */ w.createElement(K$, gi({}, e, {
    sectors: s
  })));
}
class Ag extends Kr {
  constructor() {
    super(...arguments), Xl(this, "id", nn("recharts-pie-"));
  }
  render() {
    return /* @__PURE__ */ w.createElement(w.Fragment, null, /* @__PURE__ */ w.createElement(c$, {
      data: this.props.data,
      dataKey: this.props.dataKey,
      hide: this.props.hide,
      angleAxisId: 0,
      radiusAxisId: 0,
      stackId: void 0,
      barSize: void 0,
      type: "pie"
    }), /* @__PURE__ */ w.createElement(R$, this.props), /* @__PURE__ */ w.createElement(V$, this.props), this.props.children);
  }
}
Xl(Ag, "displayName", "Pie");
Xl(Ag, "defaultProps", NT);
var W$ = M([ut], (r) => {
  if (r)
    return {
      top: r.top,
      bottom: r.bottom,
      left: r.left,
      right: r.right
    };
}), H$ = M([W$, gn, mn], (r, e, t) => {
  if (!(!r || e == null || t == null))
    return {
      x: r.left,
      y: r.top,
      width: Math.max(0, e - r.left - r.right),
      height: Math.max(0, t - r.top - r.bottom)
    };
}), q$ = (r) => {
  var e = At();
  return te((t) => Gt(t, "xAxis", r, e));
}, z$ = (r) => {
  var e = At();
  return te((t) => Gt(t, "yAxis", r, e));
}, Ql = () => te(H$), Y$ = () => te(zM);
function ry(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function ny(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ry(Object(t), !0).forEach(function(n) {
      X$(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : ry(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function X$(r, e, t) {
  return (e = Q$(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function Q$(r) {
  var e = Z$(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function Z$(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
var J$ = (r) => {
  var {
    point: e,
    childIndex: t,
    mainColor: n,
    activeDot: i,
    dataKey: s
  } = r;
  if (i === !1 || e.x == null || e.y == null)
    return null;
  var a = ny(ny({
    index: t,
    dataKey: s,
    cx: e.x,
    cy: e.y,
    r: 4,
    fill: n ?? "none",
    strokeWidth: 2,
    stroke: "#fff",
    payload: e.payload,
    value: e.value
  }, de(i, !1)), jf(i)), o;
  return /* @__PURE__ */ _r(i) ? o = /* @__PURE__ */ fn(i, a) : typeof i == "function" ? o = i(a) : o = /* @__PURE__ */ w.createElement(bg, a), /* @__PURE__ */ w.createElement(Fe, {
    className: "recharts-active-dot"
  }, o);
};
function nf(r) {
  var {
    points: e,
    mainColor: t,
    activeDot: n,
    itemDataKey: i
  } = r, s = te(cn), a = Y$();
  if (e == null || a == null)
    return null;
  var o = e.find((c) => a.includes(c.payload));
  return ye(o) ? null : J$({
    point: o,
    childIndex: Number(s),
    mainColor: t,
    dataKey: i,
    activeDot: n
  });
}
var eB = () => {
  var r = He();
  return we(() => (r(QF()), () => {
    r(ZF());
  })), null;
}, tB = ["children"];
function rB(r, e) {
  if (r == null) return {};
  var t, n, i = nB(r, e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(r);
    for (n = 0; n < s.length; n++) t = s[n], e.indexOf(t) === -1 && {}.propertyIsEnumerable.call(r, t) && (i[t] = r[t]);
  }
  return i;
}
function nB(r, e) {
  if (r == null) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.indexOf(n) !== -1) continue;
    t[n] = r[n];
  }
  return t;
}
var iy = () => {
}, FT = /* @__PURE__ */ dn({
  addErrorBar: iy,
  removeErrorBar: iy
}), iB = {
  data: [],
  xAxisId: "xAxis-0",
  yAxisId: "yAxis-0",
  dataPointFormatter: () => ({
    x: 0,
    y: 0,
    value: 0
  }),
  errorBarOffset: 0
}, $T = /* @__PURE__ */ dn(iB);
function wg(r) {
  var {
    children: e
  } = r, t = rB(r, tB);
  return /* @__PURE__ */ w.createElement($T.Provider, {
    value: t
  }, e);
}
var sB = () => un($T), Zl = (r) => {
  var {
    children: e,
    xAxisId: t,
    yAxisId: n,
    zAxisId: i,
    dataKey: s,
    data: a,
    stackId: o,
    hide: c,
    type: l,
    barSize: u
  } = r, [d, f] = w.useState([]), h = Se((p) => {
    f((v) => [...v, p]);
  }, [f]), g = Se((p) => {
    f((v) => v.filter((y) => y !== p));
  }, [f]), m = At();
  return /* @__PURE__ */ w.createElement(FT.Provider, {
    value: {
      addErrorBar: h,
      removeErrorBar: g
    }
  }, /* @__PURE__ */ w.createElement(l$, {
    type: l,
    data: a,
    xAxisId: t,
    yAxisId: n,
    zAxisId: i,
    dataKey: s,
    errorBars: d,
    stackId: o,
    hide: c,
    barSize: u,
    isPanorama: m
  }), e);
};
function aB(r) {
  var {
    addErrorBar: e,
    removeErrorBar: t
  } = un(FT);
  return we(() => (e(r), () => {
    t(r);
  }), [e, t, r]), null;
}
var oB = ["direction", "width", "dataKey", "isAnimationActive", "animationBegin", "animationDuration", "animationEasing"];
function BT(r, e, t) {
  return (e = lB(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function lB(r) {
  var e = cB(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function cB(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function Zs() {
  return Zs = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t) ({}).hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, Zs.apply(null, arguments);
}
function uB(r, e) {
  if (r == null) return {};
  var t, n, i = dB(r, e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(r);
    for (n = 0; n < s.length; n++) t = s[n], e.indexOf(t) === -1 && {}.propertyIsEnumerable.call(r, t) && (i[t] = r[t]);
  }
  return i;
}
function dB(r, e) {
  if (r == null) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.indexOf(n) !== -1) continue;
    t[n] = r[n];
  }
  return t;
}
function fB(r) {
  var {
    direction: e,
    width: t,
    dataKey: n,
    isAnimationActive: i,
    animationBegin: s,
    animationDuration: a,
    animationEasing: o
  } = r, c = uB(r, oB), l = de(c, !1), {
    data: u,
    dataPointFormatter: d,
    xAxisId: f,
    yAxisId: h,
    errorBarOffset: g
  } = sB(), m = q$(f), p = z$(h);
  if ((m == null ? void 0 : m.scale) == null || (p == null ? void 0 : p.scale) == null || u == null || e === "x" && m.type !== "number")
    return null;
  var v = u.map((y) => {
    var {
      x: b,
      y: x,
      value: S,
      errorVal: A
    } = d(y, n, e);
    if (!A)
      return null;
    var T = [], I, L;
    if (Array.isArray(A) ? [I, L] = A : I = L = A, e === "x") {
      var {
        scale: _
      } = m, R = x + g, D = R + t, F = R - t, B = _(S - I), j = _(S + L);
      T.push({
        x1: j,
        y1: D,
        x2: j,
        y2: F
      }), T.push({
        x1: B,
        y1: R,
        x2: j,
        y2: R
      }), T.push({
        x1: B,
        y1: D,
        x2: B,
        y2: F
      });
    } else if (e === "y") {
      var {
        scale: U
      } = p, K = b + g, G = K - t, Y = K + t, Q = U(S - I), H = U(S + L);
      T.push({
        x1: G,
        y1: H,
        x2: Y,
        y2: H
      }), T.push({
        x1: K,
        y1: Q,
        x2: K,
        y2: H
      }), T.push({
        x1: G,
        y1: Q,
        x2: Y,
        y2: Q
      });
    }
    var N = "".concat(b + g, "px ").concat(x + g, "px");
    return /* @__PURE__ */ w.createElement(Fe, Zs({
      className: "recharts-errorBar",
      key: "bar-".concat(T.map((re) => "".concat(re.x1, "-").concat(re.x2, "-").concat(re.y1, "-").concat(re.y2)))
    }, l), T.map((re) => {
      var oe = i ? {
        transformOrigin: "".concat(re.x1 - 5, "px")
      } : void 0;
      return /* @__PURE__ */ w.createElement(jr, {
        from: {
          transform: "scaleY(0)",
          transformOrigin: N
        },
        to: {
          transform: "scaleY(1)",
          transformOrigin: N
        },
        begin: s,
        easing: o,
        isActive: i,
        duration: a,
        key: "line-".concat(re.x1, "-").concat(re.x2, "-").concat(re.y1, "-").concat(re.y2),
        style: {
          transformOrigin: N
        }
      }, /* @__PURE__ */ w.createElement("line", Zs({}, re, {
        style: oe
      })));
    }));
  });
  return /* @__PURE__ */ w.createElement(Fe, {
    className: "recharts-errorBars"
  }, v);
}
var jT = /* @__PURE__ */ dn(void 0);
function hB(r) {
  var e = un(jT);
  return r ?? e ?? "x";
}
function UT(r) {
  var {
    direction: e,
    children: t
  } = r;
  return /* @__PURE__ */ w.createElement(jT.Provider, {
    value: e
  }, t);
}
var GT = {
  stroke: "black",
  strokeWidth: 1.5,
  width: 5,
  offset: 0,
  isAnimationActive: !0,
  animationBegin: 0,
  animationDuration: 400,
  animationEasing: "ease-in-out"
};
function gB(r) {
  var e = hB(r.direction), {
    width: t,
    isAnimationActive: n,
    animationBegin: i,
    animationDuration: s,
    animationEasing: a
  } = Vt(r, GT);
  return /* @__PURE__ */ w.createElement(w.Fragment, null, /* @__PURE__ */ w.createElement(aB, {
    dataKey: r.dataKey,
    direction: e
  }), /* @__PURE__ */ w.createElement(fB, Zs({}, r, {
    direction: e,
    width: t,
    isAnimationActive: n,
    animationBegin: i,
    animationDuration: s,
    animationEasing: a
  })));
}
class KT extends $n {
  render() {
    return /* @__PURE__ */ w.createElement(gB, this.props);
  }
}
BT(KT, "defaultProps", GT);
BT(KT, "displayName", "ErrorBar");
var mB = process.env.NODE_ENV === "production", Uu = "Invariant failed";
function sy(r, e) {
  if (mB)
    throw new Error(Uu);
  var t = typeof e == "function" ? e() : e, n = t ? "".concat(Uu, ": ").concat(t) : Uu;
  throw new Error(n);
}
var pB = ["x", "y"];
function sf() {
  return sf = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t) ({}).hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, sf.apply(null, arguments);
}
function ay(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function Ls(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ay(Object(t), !0).forEach(function(n) {
      vB(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : ay(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function vB(r, e, t) {
  return (e = yB(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function yB(r) {
  var e = bB(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function bB(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function xB(r, e) {
  if (r == null) return {};
  var t, n, i = EB(r, e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(r);
    for (n = 0; n < s.length; n++) t = s[n], e.indexOf(t) === -1 && {}.propertyIsEnumerable.call(r, t) && (i[t] = r[t]);
  }
  return i;
}
function EB(r, e) {
  if (r == null) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.indexOf(n) !== -1) continue;
    t[n] = r[n];
  }
  return t;
}
function SB(r, e) {
  var {
    x: t,
    y: n
  } = r, i = xB(r, pB), s = "".concat(t), a = parseInt(s, 10), o = "".concat(n), c = parseInt(o, 10), l = "".concat(e.height || i.height), u = parseInt(l, 10), d = "".concat(e.width || i.width), f = parseInt(d, 10);
  return Ls(Ls(Ls(Ls(Ls({}, e), i), a ? {
    x: a
  } : {}), c ? {
    y: c
  } : {}), {}, {
    height: u,
    width: f,
    name: e.name,
    radius: e.radius
  });
}
function VT(r) {
  return /* @__PURE__ */ w.createElement(el, sf({
    shapeType: "rectangle",
    propTransformer: SB,
    activeClassName: "recharts-active-bar"
  }, r));
}
var TB = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  return (n, i) => {
    if (z(e)) return e;
    var s = z(n) || ye(n);
    return s ? e(n, i) : (s || (process.env.NODE_ENV !== "production" ? sy(!1, "minPointSize callback function received a value with type of ".concat(typeof n, ". Currently only numbers or null/undefined are supported.")) : sy()), t);
  };
};
function _a(r, e) {
  var t, n, i = te((l) => yn(l, r)), s = te((l) => Un(l, e)), a = (t = i == null ? void 0 : i.allowDataOverflow) !== null && t !== void 0 ? t : qt.allowDataOverflow, o = (n = s == null ? void 0 : s.allowDataOverflow) !== null && n !== void 0 ? n : zt.allowDataOverflow, c = a || o;
  return {
    needClip: c,
    needClipX: a,
    needClipY: o
  };
}
function Jl(r) {
  var {
    xAxisId: e,
    yAxisId: t,
    clipPathId: n
  } = r, i = Ql(), {
    needClipX: s,
    needClipY: a,
    needClip: o
  } = _a(e, t);
  if (!o)
    return null;
  var {
    x: c,
    y: l,
    width: u,
    height: d
  } = i;
  return /* @__PURE__ */ w.createElement("clipPath", {
    id: "clipPath-".concat(n)
  }, /* @__PURE__ */ w.createElement("rect", {
    x: s ? c : c - u / 2,
    y: a ? l : l - d / 2,
    width: s ? u : u * 2,
    height: a ? d : d * 2
  }));
}
var AB = ["onMouseEnter", "onMouseLeave", "onClick"], wB = ["value", "background", "tooltipPosition"], IB = ["onMouseEnter", "onClick", "onMouseLeave"];
function Js() {
  return Js = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t) ({}).hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, Js.apply(null, arguments);
}
function oy(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function _t(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? oy(Object(t), !0).forEach(function(n) {
      ec(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : oy(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function ec(r, e, t) {
  return (e = PB(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function PB(r) {
  var e = _B(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function _B(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function af(r, e) {
  if (r == null) return {};
  var t, n, i = LB(r, e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(r);
    for (n = 0; n < s.length; n++) t = s[n], e.indexOf(t) === -1 && {}.propertyIsEnumerable.call(r, t) && (i[t] = r[t]);
  }
  return i;
}
function LB(r, e) {
  if (r == null) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.indexOf(n) !== -1) continue;
    t[n] = r[n];
  }
  return t;
}
var OB = (r) => {
  var {
    dataKey: e,
    name: t,
    fill: n,
    legendType: i,
    hide: s
  } = r;
  return [{
    inactive: s,
    dataKey: e,
    type: i,
    color: n,
    value: Wr(t, e),
    payload: r
  }];
};
function RB(r) {
  var {
    dataKey: e,
    stroke: t,
    strokeWidth: n,
    fill: i,
    name: s,
    hide: a,
    unit: o
  } = r;
  return {
    dataDefinedOnItem: void 0,
    positions: void 0,
    settings: {
      stroke: t,
      strokeWidth: n,
      fill: i,
      dataKey: e,
      nameKey: void 0,
      name: Wr(s, e),
      hide: a,
      type: r.tooltipType,
      color: r.fill,
      unit: o
    }
  };
}
function DB(r) {
  var e = te(cn), {
    data: t,
    dataKey: n,
    background: i,
    allOtherBarProps: s
  } = r, {
    onMouseEnter: a,
    onMouseLeave: o,
    onClick: c
  } = s, l = af(s, AB), u = Hl(a, n), d = ql(o), f = zl(c, n);
  if (!i || t == null)
    return null;
  var h = de(i, !1);
  return /* @__PURE__ */ w.createElement(w.Fragment, null, t.map((g, m) => {
    var {
      value: p,
      background: v,
      tooltipPosition: y
    } = g, b = af(g, wB);
    if (!v)
      return null;
    var x = u(g, m), S = d(g, m), A = f(g, m), T = _t(_t(_t(_t(_t({
      option: i,
      isActive: String(m) === e
    }, b), {}, {
      // @ts-expect-error BarRectangle props do not accept `fill` property.
      fill: "#eee"
    }, v), h), ns(l, g, m)), {}, {
      onMouseEnter: x,
      onMouseLeave: S,
      onClick: A,
      dataKey: n,
      index: m,
      className: "recharts-bar-background-rectangle"
    });
    return /* @__PURE__ */ w.createElement(VT, Js({
      key: "background-bar-".concat(m)
    }, T));
  }));
}
function WT(r) {
  var {
    data: e,
    props: t,
    showLabels: n
  } = r, i = de(t, !1), {
    shape: s,
    dataKey: a,
    activeBar: o
  } = t, c = te(cn), l = te(hT), {
    onMouseEnter: u,
    onClick: d,
    onMouseLeave: f
  } = t, h = af(t, IB), g = Hl(u, a), m = ql(f), p = zl(d, a);
  return e ? /* @__PURE__ */ w.createElement(w.Fragment, null, e.map((v, y) => {
    var b = o && String(y) === c && (l == null || a === l), x = b ? o : s, S = _t(_t(_t({}, i), v), {}, {
      isActive: b,
      option: x,
      index: y,
      dataKey: a
    });
    return /* @__PURE__ */ w.createElement(Fe, Js({
      className: "recharts-bar-rectangle"
    }, ns(h, v, y), {
      // @ts-expect-error BarRectangleItem type definition says it's missing properties, but I can see them present in debugger!
      onMouseEnter: g(v, y),
      onMouseLeave: m(v, y),
      onClick: p(v, y),
      key: "rectangle-".concat(v == null ? void 0 : v.x, "-").concat(v == null ? void 0 : v.y, "-").concat(v == null ? void 0 : v.value, "-").concat(y)
    }), /* @__PURE__ */ w.createElement(VT, S));
  }), n && $r.renderCallByParent(t, e)) : null;
}
function CB(r) {
  var {
    props: e,
    previousRectanglesRef: t
  } = r, {
    data: n,
    layout: i,
    isAnimationActive: s,
    animationBegin: a,
    animationDuration: o,
    animationEasing: c,
    onAnimationEnd: l,
    onAnimationStart: u
  } = e, d = t.current, f = Pa(e, "recharts-bar-"), [h, g] = _e(!1), m = Se(() => {
    typeof l == "function" && l(), g(!1);
  }, [l]), p = Se(() => {
    typeof u == "function" && u(), g(!0);
  }, [u]);
  return /* @__PURE__ */ w.createElement(jr, {
    begin: a,
    duration: o,
    isActive: s,
    easing: c,
    from: {
      t: 0
    },
    to: {
      t: 1
    },
    onAnimationEnd: m,
    onAnimationStart: p,
    key: f
  }, (v) => {
    var {
      t: y
    } = v, b = y === 1 ? n : n.map((x, S) => {
      var A = d && d[S];
      if (A) {
        var T = Et(A.x, x.x), I = Et(A.y, x.y), L = Et(A.width, x.width), _ = Et(A.height, x.height);
        return _t(_t({}, x), {}, {
          x: T(y),
          y: I(y),
          width: L(y),
          height: _(y)
        });
      }
      if (i === "horizontal") {
        var R = Et(0, x.height), D = R(y);
        return _t(_t({}, x), {}, {
          y: x.y + x.height - D,
          height: D
        });
      }
      var F = Et(0, x.width), B = F(y);
      return _t(_t({}, x), {}, {
        width: B
      });
    });
    return y > 0 && (t.current = b), /* @__PURE__ */ w.createElement(Fe, null, /* @__PURE__ */ w.createElement(WT, {
      props: e,
      data: b,
      showLabels: !h
    }));
  });
}
function kB(r) {
  var {
    data: e,
    isAnimationActive: t
  } = r, n = Ke(null);
  return t && e && e.length && (n.current == null || n.current !== e) ? /* @__PURE__ */ w.createElement(CB, {
    previousRectanglesRef: n,
    props: r
  }) : /* @__PURE__ */ w.createElement(WT, {
    props: r,
    data: e,
    showLabels: !0
  });
}
var HT = 0, MB = (r, e) => {
  var t = Array.isArray(r.value) ? r.value[1] : r.value;
  return {
    x: r.x,
    y: r.y,
    value: t,
    // @ts-expect-error getValueByDataKey does not validate the output type
    errorVal: Pe(r, e)
  };
};
class NB extends Kr {
  constructor() {
    super(...arguments), ec(this, "id", nn("recharts-bar-"));
  }
  render() {
    var {
      hide: e,
      data: t,
      dataKey: n,
      className: i,
      xAxisId: s,
      yAxisId: a,
      needClip: o,
      background: c,
      id: l,
      layout: u
    } = this.props;
    if (e)
      return null;
    var d = ve("recharts-bar", i), f = ye(l) ? this.id : l;
    return /* @__PURE__ */ w.createElement(Fe, {
      className: d
    }, o && /* @__PURE__ */ w.createElement("defs", null, /* @__PURE__ */ w.createElement(Jl, {
      clipPathId: f,
      xAxisId: s,
      yAxisId: a
    })), /* @__PURE__ */ w.createElement(Fe, {
      className: "recharts-bar-rectangles",
      clipPath: o ? "url(#clipPath-".concat(f, ")") : null
    }, /* @__PURE__ */ w.createElement(DB, {
      data: t,
      dataKey: n,
      background: c,
      allOtherBarProps: this.props
    }), /* @__PURE__ */ w.createElement(kB, this.props)), /* @__PURE__ */ w.createElement(UT, {
      direction: u === "horizontal" ? "y" : "x"
    }, this.props.children));
  }
}
var qT = {
  activeBar: !1,
  animationBegin: 0,
  animationDuration: 400,
  animationEasing: "ease",
  hide: !1,
  isAnimationActive: !pn.isSsr,
  legendType: "rect",
  minPointSize: HT,
  xAxisId: 0,
  yAxisId: 0
};
function FB(r) {
  var {
    xAxisId: e,
    yAxisId: t,
    hide: n,
    legendType: i,
    minPointSize: s,
    activeBar: a,
    animationBegin: o,
    animationDuration: c,
    animationEasing: l,
    isAnimationActive: u
  } = Vt(r, qT), {
    needClip: d
  } = _a(e, t), f = fa(), h = At(), g = Jt(() => ({
    barSize: r.barSize,
    data: void 0,
    dataKey: r.dataKey,
    maxBarSize: r.maxBarSize,
    minPointSize: s,
    stackId: ih(r.stackId)
  }), [r.barSize, r.dataKey, r.maxBarSize, s, r.stackId]), m = is(r.children, wa), p = te((b) => dj(b, e, t, h, g, m));
  if (f !== "vertical" && f !== "horizontal")
    return null;
  var v, y = p == null ? void 0 : p[0];
  return y == null || y.height == null || y.width == null ? v = 0 : v = f === "vertical" ? y.height / 2 : y.width / 2, /* @__PURE__ */ w.createElement(wg, {
    xAxisId: e,
    yAxisId: t,
    data: p,
    dataPointFormatter: MB,
    errorBarOffset: v
  }, /* @__PURE__ */ w.createElement(NB, Js({}, r, {
    layout: f,
    needClip: d,
    data: p,
    xAxisId: e,
    yAxisId: t,
    hide: n,
    legendType: i,
    minPointSize: s,
    activeBar: a,
    animationBegin: o,
    animationDuration: c,
    animationEasing: l,
    isAnimationActive: u
  })));
}
function $B(r) {
  var {
    layout: e,
    barSettings: {
      dataKey: t,
      minPointSize: n
    },
    pos: i,
    bandSize: s,
    xAxis: a,
    yAxis: o,
    xAxisTicks: c,
    yAxisTicks: l,
    stackedData: u,
    displayedData: d,
    offset: f,
    cells: h
  } = r, g = e === "horizontal" ? o : a, m = u ? g.scale.domain() : null, p = E1({
    numericAxis: g
  });
  return d.map((v, y) => {
    var b, x, S, A, T, I;
    u ? b = p1(u[y], m) : (b = Pe(v, t), Array.isArray(b) || (b = [p, b]));
    var L = TB(n, HT)(b[1], y);
    if (e === "horizontal") {
      var _, [R, D] = [o.scale(b[0]), o.scale(b[1])];
      x = Wp({
        axis: a,
        ticks: c,
        bandSize: s,
        offset: i.offset,
        entry: v,
        index: y
      }), S = (_ = D ?? R) !== null && _ !== void 0 ? _ : void 0, A = i.size;
      var F = R - D;
      if (T = Ut(F) ? 0 : F, I = {
        x,
        y: f.top,
        width: A,
        height: f.height
      }, Math.abs(L) > 0 && Math.abs(T) < Math.abs(L)) {
        var B = pt(T || L) * (Math.abs(L) - Math.abs(T));
        S -= B, T += B;
      }
    } else {
      var [j, U] = [a.scale(b[0]), a.scale(b[1])];
      if (x = j, S = Wp({
        axis: o,
        ticks: l,
        bandSize: s,
        offset: i.offset,
        entry: v,
        index: y
      }), A = U - j, T = i.size, I = {
        x: f.left,
        y: S,
        width: f.width,
        height: T
      }, Math.abs(L) > 0 && Math.abs(A) < Math.abs(L)) {
        var K = pt(A || L) * (Math.abs(L) - Math.abs(A));
        A += K;
      }
    }
    var G = _t(_t({}, v), {}, {
      x,
      y: S,
      width: A,
      height: T,
      value: u ? b : b[1],
      payload: v,
      background: I,
      tooltipPosition: {
        x: x + A / 2,
        y: S + T / 2
      }
    }, h && h[y] && h[y].props);
    return G;
  });
}
class Ig extends Kr {
  render() {
    return /* @__PURE__ */ w.createElement(Zl, {
      type: "bar",
      data: null,
      xAxisId: this.props.xAxisId,
      yAxisId: this.props.yAxisId,
      zAxisId: 0,
      dataKey: this.props.dataKey,
      stackId: this.props.stackId,
      hide: this.props.hide,
      barSize: this.props.barSize
    }, /* @__PURE__ */ w.createElement(eB, null), /* @__PURE__ */ w.createElement(Yl, {
      legendPayload: OB(this.props)
    }), /* @__PURE__ */ w.createElement(Ia, {
      fn: RB,
      args: this.props
    }), /* @__PURE__ */ w.createElement(FB, this.props));
  }
}
ec(Ig, "displayName", "Bar");
ec(Ig, "defaultProps", qT);
function ly(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function Qa(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ly(Object(t), !0).forEach(function(n) {
      BB(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : ly(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function BB(r, e, t) {
  return (e = jB(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function jB(r) {
  var e = UB(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function UB(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
var GB = (r, e) => e, KB = (r, e, t) => t, VB = (r, e, t, n) => n, Pg = (r, e, t, n, i) => i, WB = (r, e, t, n, i) => i.maxBarSize, HB = (r, e, t, n, i, s) => s, cy = (r, e, t) => {
  var n = t ?? r;
  if (!ye(n))
    return Dt(n, e, 0);
}, qB = M([Ee, ls, GB, KB, VB], (r, e, t, n, i) => e.filter((s) => r === "horizontal" ? s.xAxisId === t : s.yAxisId === n).filter((s) => s.isPanorama === i).filter((s) => s.hide === !1).filter((s) => s.type === "bar")), zB = (r, e, t, n) => {
  var i = Ee(r);
  return i === "horizontal" ? Xs(r, "yAxis", t, n) : Xs(r, "xAxis", e, n);
}, YB = (r, e, t) => {
  var n = Ee(r);
  return n === "horizontal" ? u0(r, "xAxis", e) : u0(r, "yAxis", t);
};
function XB(r) {
  return r.stackId != null && r.dataKey != null;
}
var QB = (r, e, t) => {
  var n = {}, i = r.filter(XB), s = r.filter((l) => l.stackId == null), a = i.reduce((l, u) => (l[u.stackId] || (l[u.stackId] = []), l[u.stackId].push(u), l), n), o = Object.entries(a).map((l) => {
    var [u, d] = l, f = d.map((g) => g.dataKey), h = cy(e, t, d[0].barSize);
    return {
      stackId: u,
      dataKeys: f,
      barSize: h
    };
  }), c = s.map((l) => {
    var u = [l.dataKey].filter((f) => f != null), d = cy(e, t, l.barSize);
    return {
      stackId: void 0,
      dataKeys: u,
      barSize: d
    };
  });
  return [...o, ...c];
}, ZB = M([qB, sk, YB], QB), JB = (r, e, t, n, i) => {
  var s, a, o = Ee(r), c = bS(r), {
    maxBarSize: l
  } = i, u = ye(l) ? c : l, d, f;
  return o === "horizontal" ? (d = Gt(r, "xAxis", e, n), f = vr(r, "xAxis", e, n)) : (d = Gt(r, "yAxis", t, n), f = vr(r, "yAxis", t, n)), (s = (a = fi(d, f, !0)) !== null && a !== void 0 ? a : u) !== null && s !== void 0 ? s : 0;
}, zT = (r, e, t, n) => {
  var i = Ee(r), s, a;
  return i === "horizontal" ? (s = Gt(r, "xAxis", e, n), a = vr(r, "xAxis", e, n)) : (s = Gt(r, "yAxis", t, n), a = vr(r, "yAxis", t, n)), fi(s, a);
};
function ej(r, e, t, n, i) {
  var s = n.length;
  if (!(s < 1)) {
    var a = Dt(r, t, 0, !0), o, c = [];
    if (Tt(n[0].barSize)) {
      var l = !1, u = t / s, d = n.reduce((v, y) => v + (y.barSize || 0), 0);
      d += (s - 1) * a, d >= t && (d -= (s - 1) * a, a = 0), d >= t && u > 0 && (l = !0, u *= 0.9, d = s * u);
      var f = (t - d) / 2 >> 0, h = {
        offset: f - a,
        size: 0
      };
      o = n.reduce((v, y) => {
        var b, x = {
          stackId: y.stackId,
          dataKeys: y.dataKeys,
          position: {
            offset: h.offset + h.size + a,
            size: l ? u : (b = y.barSize) !== null && b !== void 0 ? b : 0
          }
        }, S = [...v, x];
        return h = S[S.length - 1].position, S;
      }, c);
    } else {
      var g = Dt(e, t, 0, !0);
      t - 2 * g - (s - 1) * a <= 0 && (a = 0);
      var m = (t - 2 * g - (s - 1) * a) / s;
      m > 1 && (m >>= 0);
      var p = Tt(i) ? Math.min(m, i) : m;
      o = n.reduce((v, y, b) => [...v, {
        stackId: y.stackId,
        dataKeys: y.dataKeys,
        position: {
          offset: g + (m + a) * b + (m - p) / 2,
          size: p
        }
      }], c);
    }
    return o;
  }
}
var tj = (r, e, t, n, i, s, a) => {
  var o = ye(a) ? e : a, c = ej(t, n, i !== s ? i : s, r, o);
  return i !== s && c != null && (c = c.map((l) => Qa(Qa({}, l), {}, {
    position: Qa(Qa({}, l.position), {}, {
      offset: l.position.offset - i / 2
    })
  }))), c;
}, rj = M([ZB, bS, ik, xS, JB, zT, WB], tj), nj = (r, e, t, n) => Gt(r, "xAxis", e, n), ij = (r, e, t, n) => Gt(r, "yAxis", t, n), sj = (r, e, t, n) => vr(r, "xAxis", e, n), aj = (r, e, t, n) => vr(r, "yAxis", t, n), oj = M([rj, Pg], (r, e) => {
  if (r != null) {
    var t = r.find((n) => n.stackId === e.stackId && n.dataKeys.includes(e.dataKey));
    if (t != null)
      return t.position;
  }
}), lj = (r, e) => {
  if (!(!r || (e == null ? void 0 : e.dataKey) == null)) {
    var {
      stackId: t
    } = e;
    if (t != null) {
      var n = r[t];
      if (n) {
        var {
          stackedData: i
        } = n;
        if (i) {
          var s = i.find((a) => a.key === e.dataKey);
          return s;
        }
      }
    }
  }
}, cj = M([ls, Pg], (r, e) => {
  if (r.some((t) => t.type === "bar" && e.dataKey === t.dataKey && e.stackId === t.stackId && // barSettingsFromProps.data === cgis.data && // bar doesn't support data and one is undefined and another is null and this condition breaks
  e.stackId === t.stackId))
    return e;
}), uj = M([zB, Pg], lj), dj = M([ut, nj, ij, sj, aj, oj, Ee, va, zT, uj, cj, HB], (r, e, t, n, i, s, a, o, c, l, u, d) => {
  var {
    chartData: f,
    dataStartIndex: h,
    dataEndIndex: g
  } = o;
  if (!(u == null || s == null || a !== "horizontal" && a !== "vertical" || e == null || t == null || n == null || i == null || c == null)) {
    var {
      data: m
    } = u, p;
    if (m != null && m.length > 0 ? p = m : p = f == null ? void 0 : f.slice(h, g + 1), p != null)
      return $B({
        layout: a,
        barSettings: u,
        pos: s,
        bandSize: c,
        xAxis: e,
        yAxis: t,
        xAxisTicks: n,
        yAxisTicks: i,
        stackedData: l,
        displayedData: p,
        offset: r,
        cells: d
      });
  }
}), YT = (r) => {
  var {
    chartData: e
  } = r, t = He(), n = At();
  return we(() => n ? () => {
  } : (t(x0(e)), () => {
    t(x0(void 0));
  }), [e, t, n]), null;
}, uy = {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  padding: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }
}, XT = xr({
  name: "brush",
  initialState: uy,
  reducers: {
    setBrushSettings(r, e) {
      return e.payload == null ? uy : e.payload;
    }
  }
}), {
  setBrushSettings: T4
} = XT.actions, fj = XT.reducer;
function hj(r, e, t) {
  return (e = gj(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function gj(r) {
  var e = mj(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function mj(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
class _g {
  static create(e) {
    return new _g(e);
  }
  constructor(e) {
    this.scale = e;
  }
  get domain() {
    return this.scale.domain;
  }
  get range() {
    return this.scale.range;
  }
  get rangeMin() {
    return this.range()[0];
  }
  get rangeMax() {
    return this.range()[1];
  }
  get bandwidth() {
    return this.scale.bandwidth;
  }
  apply(e) {
    var {
      bandAware: t,
      position: n
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (e !== void 0) {
      if (n)
        switch (n) {
          case "start":
            return this.scale(e);
          case "middle": {
            var i = this.bandwidth ? this.bandwidth() / 2 : 0;
            return this.scale(e) + i;
          }
          case "end": {
            var s = this.bandwidth ? this.bandwidth() : 0;
            return this.scale(e) + s;
          }
          default:
            return this.scale(e);
        }
      if (t) {
        var a = this.bandwidth ? this.bandwidth() / 2 : 0;
        return this.scale(e) + a;
      }
      return this.scale(e);
    }
  }
  isInRange(e) {
    var t = this.range(), n = t[0], i = t[t.length - 1];
    return n <= i ? e >= n && e <= i : e >= i && e <= n;
  }
}
hj(_g, "EPS", 1e-4);
function pj(r) {
  return (r % 180 + 180) % 180;
}
var vj = function(e) {
  var {
    width: t,
    height: n
  } = e, i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, s = pj(i), a = s * Math.PI / 180, o = Math.atan(n / t), c = a > o && a < Math.PI - o ? n / Math.sin(a) : t / Math.cos(a);
  return Math.abs(c);
}, yj = {
  dots: [],
  areas: [],
  lines: []
}, QT = xr({
  name: "referenceElements",
  initialState: yj,
  reducers: {
    addDot: (r, e) => {
      r.dots.push(e.payload);
    },
    removeDot: (r, e) => {
      var t = tn(r).dots.findIndex((n) => n === e.payload);
      t !== -1 && r.dots.splice(t, 1);
    },
    addArea: (r, e) => {
      r.areas.push(e.payload);
    },
    removeArea: (r, e) => {
      var t = tn(r).areas.findIndex((n) => n === e.payload);
      t !== -1 && r.areas.splice(t, 1);
    },
    addLine: (r, e) => {
      r.lines.push(e.payload);
    },
    removeLine: (r, e) => {
      var t = tn(r).lines.findIndex((n) => n === e.payload);
      t !== -1 && r.lines.splice(t, 1);
    }
  }
}), {
  addDot: A4,
  removeDot: w4,
  addArea: I4,
  removeArea: P4,
  addLine: _4,
  removeLine: L4
} = QT.actions, bj = QT.reducer, xj = /* @__PURE__ */ dn(void 0), Ej = (r) => {
  var {
    children: e
  } = r, [t] = _e("".concat(nn("recharts"), "-clip")), n = Ql();
  if (n == null)
    return null;
  var {
    x: i,
    y: s,
    width: a,
    height: o
  } = n;
  return /* @__PURE__ */ w.createElement(xj.Provider, {
    value: t
  }, /* @__PURE__ */ w.createElement("defs", null, /* @__PURE__ */ w.createElement("clipPath", {
    id: t
  }, /* @__PURE__ */ w.createElement("rect", {
    x: i,
    y: s,
    height: o,
    width: a
  }))), e);
};
function Gu(r, e) {
  for (var t in r)
    if ({}.hasOwnProperty.call(r, t) && (!{}.hasOwnProperty.call(e, t) || r[t] !== e[t]))
      return !1;
  for (var n in e)
    if ({}.hasOwnProperty.call(e, n) && !{}.hasOwnProperty.call(r, n))
      return !1;
  return !0;
}
function ZT(r, e, t) {
  if (e < 1)
    return [];
  if (e === 1 && t === void 0)
    return r;
  for (var n = [], i = 0; i < r.length; i += e)
    n.push(r[i]);
  return n;
}
function Sj(r, e, t) {
  var n = {
    width: r.width + e.width,
    height: r.height + e.height
  };
  return vj(n, t);
}
function Tj(r, e, t) {
  var n = t === "width", {
    x: i,
    y: s,
    width: a,
    height: o
  } = r;
  return e === 1 ? {
    start: n ? i : s,
    end: n ? i + a : s + o
  } : {
    start: n ? i + a : s + o,
    end: n ? i : s
  };
}
function tl(r, e, t, n, i) {
  if (r * e < r * n || r * e > r * i)
    return !1;
  var s = t();
  return r * (e - r * s / 2 - n) >= 0 && r * (e + r * s / 2 - i) <= 0;
}
function Aj(r, e) {
  return ZT(r, e + 1);
}
function wj(r, e, t, n, i) {
  for (var s = (n || []).slice(), {
    start: a,
    end: o
  } = e, c = 0, l = 1, u = a, d = function() {
    var g = n == null ? void 0 : n[c];
    if (g === void 0)
      return {
        v: ZT(n, l)
      };
    var m = c, p, v = () => (p === void 0 && (p = t(g, m)), p), y = g.coordinate, b = c === 0 || tl(r, y, v, u, o);
    b || (c = 0, u = a, l += 1), b && (u = y + r * (v() / 2 + i), c += l);
  }, f; l <= s.length; )
    if (f = d(), f) return f.v;
  return [];
}
function dy(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function It(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? dy(Object(t), !0).forEach(function(n) {
      Ij(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : dy(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function Ij(r, e, t) {
  return (e = Pj(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function Pj(r) {
  var e = _j(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function _j(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function Lj(r, e, t, n, i) {
  for (var s = (n || []).slice(), a = s.length, {
    start: o
  } = e, {
    end: c
  } = e, l = function(f) {
    var h = s[f], g, m = () => (g === void 0 && (g = t(h, f)), g);
    if (f === a - 1) {
      var p = r * (h.coordinate + r * m() / 2 - c);
      s[f] = h = It(It({}, h), {}, {
        tickCoord: p > 0 ? h.coordinate - p * r : h.coordinate
      });
    } else
      s[f] = h = It(It({}, h), {}, {
        tickCoord: h.coordinate
      });
    var v = tl(r, h.tickCoord, m, o, c);
    v && (c = h.tickCoord - r * (m() / 2 + i), s[f] = It(It({}, h), {}, {
      isShow: !0
    }));
  }, u = a - 1; u >= 0; u--)
    l(u);
  return s;
}
function Oj(r, e, t, n, i, s) {
  var a = (n || []).slice(), o = a.length, {
    start: c,
    end: l
  } = e;
  if (s) {
    var u = n[o - 1], d = t(u, o - 1), f = r * (u.coordinate + r * d / 2 - l);
    a[o - 1] = u = It(It({}, u), {}, {
      tickCoord: f > 0 ? u.coordinate - f * r : u.coordinate
    });
    var h = tl(r, u.tickCoord, () => d, c, l);
    h && (l = u.tickCoord - r * (d / 2 + i), a[o - 1] = It(It({}, u), {}, {
      isShow: !0
    }));
  }
  for (var g = s ? o - 1 : o, m = function(y) {
    var b = a[y], x, S = () => (x === void 0 && (x = t(b, y)), x);
    if (y === 0) {
      var A = r * (b.coordinate - r * S() / 2 - c);
      a[y] = b = It(It({}, b), {}, {
        tickCoord: A < 0 ? b.coordinate - A * r : b.coordinate
      });
    } else
      a[y] = b = It(It({}, b), {}, {
        tickCoord: b.coordinate
      });
    var T = tl(r, b.tickCoord, S, c, l);
    T && (c = b.tickCoord + r * (S() / 2 + i), a[y] = It(It({}, b), {}, {
      isShow: !0
    }));
  }, p = 0; p < g; p++)
    m(p);
  return a;
}
function Lg(r, e, t) {
  var {
    tick: n,
    ticks: i,
    viewBox: s,
    minTickGap: a,
    orientation: o,
    interval: c,
    tickFormatter: l,
    unit: u,
    angle: d
  } = r;
  if (!i || !i.length || !n)
    return [];
  if (z(c) || pn.isSsr) {
    var f;
    return (f = Aj(i, z(c) ? c : 0)) !== null && f !== void 0 ? f : [];
  }
  var h = [], g = o === "top" || o === "bottom" ? "width" : "height", m = u && g === "width" ? Ns(u, {
    fontSize: e,
    letterSpacing: t
  }) : {
    width: 0,
    height: 0
  }, p = (b, x) => {
    var S = typeof l == "function" ? l(b.value, x) : b.value;
    return g === "width" ? Sj(Ns(S, {
      fontSize: e,
      letterSpacing: t
    }), m, d) : Ns(S, {
      fontSize: e,
      letterSpacing: t
    })[g];
  }, v = i.length >= 2 ? pt(i[1].coordinate - i[0].coordinate) : 1, y = Tj(s, v, g);
  return c === "equidistantPreserveStart" ? wj(v, y, p, i, a) : (c === "preserveStart" || c === "preserveStartEnd" ? h = Oj(v, y, p, i, a, c === "preserveStartEnd") : h = Lj(v, y, p, i, a), h.filter((b) => b.isShow));
}
var Rj = ["viewBox"], Dj = ["viewBox"];
function Ci() {
  return Ci = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t) ({}).hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, Ci.apply(null, arguments);
}
function fy(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function lt(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? fy(Object(t), !0).forEach(function(n) {
      Og(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : fy(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function hy(r, e) {
  if (r == null) return {};
  var t, n, i = Cj(r, e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(r);
    for (n = 0; n < s.length; n++) t = s[n], e.indexOf(t) === -1 && {}.propertyIsEnumerable.call(r, t) && (i[t] = r[t]);
  }
  return i;
}
function Cj(r, e) {
  if (r == null) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.indexOf(n) !== -1) continue;
    t[n] = r[n];
  }
  return t;
}
function Og(r, e, t) {
  return (e = kj(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function kj(r) {
  var e = Mj(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function Mj(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
class Gn extends $n {
  constructor(e) {
    super(e), this.tickRefs = /* @__PURE__ */ w.createRef(), this.tickRefs.current = [], this.state = {
      fontSize: "",
      letterSpacing: ""
    };
  }
  shouldComponentUpdate(e, t) {
    var {
      viewBox: n
    } = e, i = hy(e, Rj), s = this.props, {
      viewBox: a
    } = s, o = hy(s, Dj);
    return !Gu(n, a) || !Gu(i, o) || !Gu(t, this.state);
  }
  /**
   * Calculate the coordinates of endpoints in ticks
   * @param  data The data of a simple tick
   * @return (x1, y1): The coordinate of endpoint close to tick text
   *  (x2, y2): The coordinate of endpoint close to axis
   */
  getTickLineCoord(e) {
    var {
      x: t,
      y: n,
      width: i,
      height: s,
      orientation: a,
      tickSize: o,
      mirror: c,
      tickMargin: l
    } = this.props, u, d, f, h, g, m, p = c ? -1 : 1, v = e.tickSize || o, y = z(e.tickCoord) ? e.tickCoord : e.coordinate;
    switch (a) {
      case "top":
        u = d = e.coordinate, h = n + +!c * s, f = h - p * v, m = f - p * l, g = y;
        break;
      case "left":
        f = h = e.coordinate, d = t + +!c * i, u = d - p * v, g = u - p * l, m = y;
        break;
      case "right":
        f = h = e.coordinate, d = t + +c * i, u = d + p * v, g = u + p * l, m = y;
        break;
      default:
        u = d = e.coordinate, h = n + +c * s, f = h + p * v, m = f + p * l, g = y;
        break;
    }
    return {
      line: {
        x1: u,
        y1: f,
        x2: d,
        y2: h
      },
      tick: {
        x: g,
        y: m
      }
    };
  }
  getTickTextAnchor() {
    var {
      orientation: e,
      mirror: t
    } = this.props, n;
    switch (e) {
      case "left":
        n = t ? "start" : "end";
        break;
      case "right":
        n = t ? "end" : "start";
        break;
      default:
        n = "middle";
        break;
    }
    return n;
  }
  getTickVerticalAnchor() {
    var {
      orientation: e,
      mirror: t
    } = this.props;
    switch (e) {
      case "left":
      case "right":
        return "middle";
      case "top":
        return t ? "start" : "end";
      default:
        return t ? "end" : "start";
    }
  }
  renderAxisLine() {
    var {
      x: e,
      y: t,
      width: n,
      height: i,
      orientation: s,
      mirror: a,
      axisLine: o
    } = this.props, c = lt(lt(lt({}, de(this.props, !1)), de(o, !1)), {}, {
      fill: "none"
    });
    if (s === "top" || s === "bottom") {
      var l = +(s === "top" && !a || s === "bottom" && a);
      c = lt(lt({}, c), {}, {
        x1: e,
        y1: t + l * i,
        x2: e + n,
        y2: t + l * i
      });
    } else {
      var u = +(s === "left" && !a || s === "right" && a);
      c = lt(lt({}, c), {}, {
        x1: e + u * n,
        y1: t,
        x2: e + u * n,
        y2: t + i
      });
    }
    return /* @__PURE__ */ w.createElement("line", Ci({}, c, {
      className: ve("recharts-cartesian-axis-line", Mn(o, "className"))
    }));
  }
  static renderTickItem(e, t, n) {
    var i, s = ve(t.className, "recharts-cartesian-axis-tick-value");
    if (/* @__PURE__ */ w.isValidElement(e))
      i = /* @__PURE__ */ w.cloneElement(e, lt(lt({}, t), {}, {
        className: s
      }));
    else if (typeof e == "function")
      i = e(lt(lt({}, t), {}, {
        className: s
      }));
    else {
      var a = "recharts-cartesian-axis-tick-value";
      typeof e != "boolean" && (a = ve(a, e.className)), i = /* @__PURE__ */ w.createElement(Wl, Ci({}, t, {
        className: a
      }), n);
    }
    return i;
  }
  /**
   * render the ticks
   * @param {string} fontSize Fontsize to consider for tick spacing
   * @param {string} letterSpacing Letter spacing to consider for tick spacing
   * @param {Array} ticks The ticks to actually render (overrides what was passed in props)
   * @return {ReactElement | null} renderedTicks
   */
  renderTicks(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], {
      tickLine: i,
      stroke: s,
      tick: a,
      tickFormatter: o,
      unit: c
    } = this.props, l = Lg(lt(lt({}, this.props), {}, {
      ticks: n
    }), e, t), u = this.getTickTextAnchor(), d = this.getTickVerticalAnchor(), f = de(this.props, !1), h = de(a, !1), g = lt(lt({}, f), {}, {
      fill: "none"
    }, de(i, !1)), m = l.map((p, v) => {
      var {
        line: y,
        tick: b
      } = this.getTickLineCoord(p), x = lt(lt(lt(lt({
        textAnchor: u,
        verticalAnchor: d
      }, f), {}, {
        stroke: "none",
        fill: s
      }, h), b), {}, {
        index: v,
        payload: p,
        visibleTicksCount: l.length,
        tickFormatter: o
      });
      return /* @__PURE__ */ w.createElement(Fe, Ci({
        className: "recharts-cartesian-axis-tick",
        key: "tick-".concat(p.value, "-").concat(p.coordinate, "-").concat(p.tickCoord)
      }, ns(this.props, p, v)), i && /* @__PURE__ */ w.createElement("line", Ci({}, g, y, {
        className: ve("recharts-cartesian-axis-tick-line", Mn(i, "className"))
      })), a && Gn.renderTickItem(a, x, "".concat(typeof o == "function" ? o(p.value, v) : p.value).concat(c || "")));
    });
    return m.length > 0 ? /* @__PURE__ */ w.createElement("g", {
      className: "recharts-cartesian-axis-ticks"
    }, m) : null;
  }
  render() {
    var {
      axisLine: e,
      width: t,
      height: n,
      className: i,
      hide: s
    } = this.props;
    if (s)
      return null;
    var {
      ticks: a
    } = this.props;
    return t != null && t <= 0 || n != null && n <= 0 ? null : /* @__PURE__ */ w.createElement(Fe, {
      className: ve("recharts-cartesian-axis", i),
      ref: (o) => {
        if (o) {
          var c = o.getElementsByClassName("recharts-cartesian-axis-tick-value");
          this.tickRefs.current = Array.from(c);
          var l = c[0];
          if (l) {
            var u = window.getComputedStyle(l).fontSize, d = window.getComputedStyle(l).letterSpacing;
            (u !== this.state.fontSize || d !== this.state.letterSpacing) && this.setState({
              fontSize: window.getComputedStyle(l).fontSize,
              letterSpacing: window.getComputedStyle(l).letterSpacing
            });
          }
        }
      }
    }, e && this.renderAxisLine(), this.renderTicks(this.state.fontSize, this.state.letterSpacing, a), Xt.renderCallByParent(this.props));
  }
}
Og(Gn, "displayName", "CartesianAxis");
Og(Gn, "defaultProps", {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  viewBox: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  // The orientation of axis
  orientation: "bottom",
  // The ticks
  ticks: [],
  stroke: "#666",
  tickLine: !0,
  axisLine: !0,
  tick: !0,
  mirror: !1,
  minTickGap: 5,
  // The width or height of tick
  tickSize: 6,
  tickMargin: 2,
  interval: "preserveEnd"
});
var Nj = ["x1", "y1", "x2", "y2", "key"], Fj = ["offset"], $j = ["xAxisId", "yAxisId"], Bj = ["xAxisId", "yAxisId"];
function gy(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function Lt(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? gy(Object(t), !0).forEach(function(n) {
      jj(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : gy(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function jj(r, e, t) {
  return (e = Uj(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function Uj(r) {
  var e = Gj(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function Gj(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function ti() {
  return ti = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t) ({}).hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, ti.apply(null, arguments);
}
function rl(r, e) {
  if (r == null) return {};
  var t, n, i = Kj(r, e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(r);
    for (n = 0; n < s.length; n++) t = s[n], e.indexOf(t) === -1 && {}.propertyIsEnumerable.call(r, t) && (i[t] = r[t]);
  }
  return i;
}
function Kj(r, e) {
  if (r == null) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.indexOf(n) !== -1) continue;
    t[n] = r[n];
  }
  return t;
}
var Vj = (r) => {
  var {
    fill: e
  } = r;
  if (!e || e === "none")
    return null;
  var {
    fillOpacity: t,
    x: n,
    y: i,
    width: s,
    height: a,
    ry: o
  } = r;
  return /* @__PURE__ */ w.createElement("rect", {
    x: n,
    y: i,
    ry: o,
    width: s,
    height: a,
    stroke: "none",
    fill: e,
    fillOpacity: t,
    className: "recharts-cartesian-grid-bg"
  });
};
function JT(r, e) {
  var t;
  if (/* @__PURE__ */ w.isValidElement(r))
    t = /* @__PURE__ */ w.cloneElement(r, e);
  else if (typeof r == "function")
    t = r(e);
  else {
    var {
      x1: n,
      y1: i,
      x2: s,
      y2: a,
      key: o
    } = e, c = rl(e, Nj), l = de(c, !1), {
      offset: u
    } = l, d = rl(l, Fj);
    t = /* @__PURE__ */ w.createElement("line", ti({}, d, {
      x1: n,
      y1: i,
      x2: s,
      y2: a,
      fill: "none",
      key: o
    }));
  }
  return t;
}
function Wj(r) {
  var {
    x: e,
    width: t,
    horizontal: n = !0,
    horizontalPoints: i
  } = r;
  if (!n || !i || !i.length)
    return null;
  var {
    xAxisId: s,
    yAxisId: a
  } = r, o = rl(r, $j), c = i.map((l, u) => {
    var d = Lt(Lt({}, o), {}, {
      x1: e,
      y1: l,
      x2: e + t,
      y2: l,
      key: "line-".concat(u),
      index: u
    });
    return JT(n, d);
  });
  return /* @__PURE__ */ w.createElement("g", {
    className: "recharts-cartesian-grid-horizontal"
  }, c);
}
function Hj(r) {
  var {
    y: e,
    height: t,
    vertical: n = !0,
    verticalPoints: i
  } = r;
  if (!n || !i || !i.length)
    return null;
  var {
    xAxisId: s,
    yAxisId: a
  } = r, o = rl(r, Bj), c = i.map((l, u) => {
    var d = Lt(Lt({}, o), {}, {
      x1: l,
      y1: e,
      x2: l,
      y2: e + t,
      key: "line-".concat(u),
      index: u
    });
    return JT(n, d);
  });
  return /* @__PURE__ */ w.createElement("g", {
    className: "recharts-cartesian-grid-vertical"
  }, c);
}
function qj(r) {
  var {
    horizontalFill: e,
    fillOpacity: t,
    x: n,
    y: i,
    width: s,
    height: a,
    horizontalPoints: o,
    horizontal: c = !0
  } = r;
  if (!c || !e || !e.length)
    return null;
  var l = o.map((d) => Math.round(d + i - i)).sort((d, f) => d - f);
  i !== l[0] && l.unshift(0);
  var u = l.map((d, f) => {
    var h = !l[f + 1], g = h ? i + a - d : l[f + 1] - d;
    if (g <= 0)
      return null;
    var m = f % e.length;
    return /* @__PURE__ */ w.createElement("rect", {
      key: "react-".concat(f),
      y: d,
      x: n,
      height: g,
      width: s,
      stroke: "none",
      fill: e[m],
      fillOpacity: t,
      className: "recharts-cartesian-grid-bg"
    });
  });
  return /* @__PURE__ */ w.createElement("g", {
    className: "recharts-cartesian-gridstripes-horizontal"
  }, u);
}
function zj(r) {
  var {
    vertical: e = !0,
    verticalFill: t,
    fillOpacity: n,
    x: i,
    y: s,
    width: a,
    height: o,
    verticalPoints: c
  } = r;
  if (!e || !t || !t.length)
    return null;
  var l = c.map((d) => Math.round(d + i - i)).sort((d, f) => d - f);
  i !== l[0] && l.unshift(0);
  var u = l.map((d, f) => {
    var h = !l[f + 1], g = h ? i + a - d : l[f + 1] - d;
    if (g <= 0)
      return null;
    var m = f % t.length;
    return /* @__PURE__ */ w.createElement("rect", {
      key: "react-".concat(f),
      x: d,
      y: s,
      width: g,
      height: o,
      stroke: "none",
      fill: t[m],
      fillOpacity: n,
      className: "recharts-cartesian-grid-bg"
    });
  });
  return /* @__PURE__ */ w.createElement("g", {
    className: "recharts-cartesian-gridstripes-vertical"
  }, u);
}
var Yj = (r, e) => {
  var {
    xAxis: t,
    width: n,
    height: i,
    offset: s
  } = r;
  return lE(Lg(Lt(Lt(Lt({}, Gn.defaultProps), t), {}, {
    ticks: cE(t),
    viewBox: {
      x: 0,
      y: 0,
      width: n,
      height: i
    }
  })), s.left, s.left + s.width, e);
}, Xj = (r, e) => {
  var {
    yAxis: t,
    width: n,
    height: i,
    offset: s
  } = r;
  return lE(Lg(Lt(Lt(Lt({}, Gn.defaultProps), t), {}, {
    ticks: cE(t),
    viewBox: {
      x: 0,
      y: 0,
      width: n,
      height: i
    }
  })), s.top, s.top + s.height, e);
}, Qj = {
  horizontal: !0,
  vertical: !0,
  // The ordinates of horizontal grid lines
  horizontalPoints: [],
  // The abscissas of vertical grid lines
  verticalPoints: [],
  stroke: "#ccc",
  fill: "none",
  // The fill of colors of grid lines
  verticalFill: [],
  horizontalFill: [],
  xAxisId: 0,
  yAxisId: 0
};
function Cs(r) {
  var e = uh(), t = dh(), n = fE(), i = Lt(Lt({}, Vt(r, Qj)), {}, {
    x: z(r.x) ? r.x : n.left,
    y: z(r.y) ? r.y : n.top,
    width: z(r.width) ? r.width : n.width,
    height: z(r.height) ? r.height : n.height
  }), {
    xAxisId: s,
    yAxisId: a,
    x: o,
    y: c,
    width: l,
    height: u,
    syncWithTicks: d,
    horizontalValues: f,
    verticalValues: h
  } = i, g = At(), m = te((L) => d0(L, "xAxis", s, g)), p = te((L) => d0(L, "yAxis", a, g));
  if (!z(l) || l <= 0 || !z(u) || u <= 0 || !z(o) || o !== +o || !z(c) || c !== +c)
    return null;
  var v = i.verticalCoordinatesGenerator || Yj, y = i.horizontalCoordinatesGenerator || Xj, {
    horizontalPoints: b,
    verticalPoints: x
  } = i;
  if ((!b || !b.length) && typeof y == "function") {
    var S = f && f.length, A = y({
      yAxis: p ? Lt(Lt({}, p), {}, {
        ticks: S ? f : p.ticks
      }) : void 0,
      width: e,
      height: t,
      offset: n
    }, S ? !0 : d);
    Ms(Array.isArray(A), "horizontalCoordinatesGenerator should return Array but instead it returned [".concat(typeof A, "]")), Array.isArray(A) && (b = A);
  }
  if ((!x || !x.length) && typeof v == "function") {
    var T = h && h.length, I = v({
      xAxis: m ? Lt(Lt({}, m), {}, {
        ticks: T ? h : m.ticks
      }) : void 0,
      width: e,
      height: t,
      offset: n
    }, T ? !0 : d);
    Ms(Array.isArray(I), "verticalCoordinatesGenerator should return Array but instead it returned [".concat(typeof I, "]")), Array.isArray(I) && (x = I);
  }
  return /* @__PURE__ */ w.createElement("g", {
    className: "recharts-cartesian-grid"
  }, /* @__PURE__ */ w.createElement(Vj, {
    fill: i.fill,
    fillOpacity: i.fillOpacity,
    x: i.x,
    y: i.y,
    width: i.width,
    height: i.height,
    ry: i.ry
  }), /* @__PURE__ */ w.createElement(qj, ti({}, i, {
    horizontalPoints: b
  })), /* @__PURE__ */ w.createElement(zj, ti({}, i, {
    verticalPoints: x
  })), /* @__PURE__ */ w.createElement(Wj, ti({}, i, {
    offset: n,
    horizontalPoints: b,
    xAxis: m,
    yAxis: p
  })), /* @__PURE__ */ w.createElement(Hj, ti({}, i, {
    offset: n,
    verticalPoints: x,
    xAxis: m,
    yAxis: p
  })));
}
Cs.displayName = "CartesianGrid";
var eA = (r, e, t, n) => Gt(r, "xAxis", e, n), tA = (r, e, t, n) => vr(r, "xAxis", e, n), rA = (r, e, t, n) => Gt(r, "yAxis", t, n), nA = (r, e, t, n) => vr(r, "yAxis", t, n), Zj = M([Ee, eA, rA, tA, nA], (r, e, t, n, i) => Vr(r, "xAxis") ? fi(e, n, !1) : fi(t, i, !1)), Jj = (r, e, t, n, i) => i, e2 = M([ls, Jj], (r, e) => {
  if (r.some((t) => t.type === "line" && e.dataKey === t.dataKey && e.data === t.data))
    return e;
}), t2 = M([Ee, eA, rA, tA, nA, e2, Zj, va], (r, e, t, n, i, s, a, o) => {
  var {
    chartData: c,
    dataStartIndex: l,
    dataEndIndex: u
  } = o;
  if (!(s == null || e == null || t == null || n == null || i == null || n.length === 0 || i.length === 0 || a == null)) {
    var {
      dataKey: d,
      data: f
    } = s, h;
    if (f != null && f.length > 0 ? h = f : h = c == null ? void 0 : c.slice(l, u + 1), h != null)
      return x2({
        layout: r,
        xAxis: e,
        yAxis: t,
        xAxisTicks: n,
        yAxisTicks: i,
        dataKey: d,
        bandSize: a,
        displayedData: h
      });
  }
}), r2 = ["type", "layout", "connectNulls", "needClip"], n2 = ["activeDot", "animateNewValues", "animationBegin", "animationDuration", "animationEasing", "connectNulls", "dot", "hide", "isAnimationActive", "label", "legendType", "xAxisId", "yAxisId"];
function iA(r, e) {
  if (r == null) return {};
  var t, n, i = i2(r, e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(r);
    for (n = 0; n < s.length; n++) t = s[n], e.indexOf(t) === -1 && {}.propertyIsEnumerable.call(r, t) && (i[t] = r[t]);
  }
  return i;
}
function i2(r, e) {
  if (r == null) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.indexOf(n) !== -1) continue;
    t[n] = r[n];
  }
  return t;
}
function my(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function wr(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? my(Object(t), !0).forEach(function(n) {
      tc(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : my(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function tc(r, e, t) {
  return (e = s2(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function s2(r) {
  var e = a2(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function a2(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function Qi() {
  return Qi = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t) ({}).hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, Qi.apply(null, arguments);
}
var o2 = (r) => {
  var {
    dataKey: e,
    name: t,
    stroke: n,
    legendType: i,
    hide: s
  } = r;
  return [{
    inactive: s,
    dataKey: e,
    type: i,
    color: n,
    value: Wr(t, e),
    payload: r
  }];
};
function l2(r) {
  var {
    dataKey: e,
    data: t,
    stroke: n,
    strokeWidth: i,
    fill: s,
    name: a,
    hide: o,
    unit: c
  } = r;
  return {
    dataDefinedOnItem: t,
    positions: void 0,
    settings: {
      stroke: n,
      strokeWidth: i,
      fill: s,
      dataKey: e,
      nameKey: void 0,
      name: Wr(a, e),
      hide: o,
      type: r.tooltipType,
      color: r.stroke,
      unit: c
    }
  };
}
var sA = (r, e) => "".concat(e, "px ").concat(r - e, "px");
function c2(r, e) {
  for (var t = r.length % 2 !== 0 ? [...r, 0] : r, n = [], i = 0; i < e; ++i)
    n = [...n, ...t];
  return n;
}
var u2 = (r, e, t) => {
  var n = t.reduce((d, f) => d + f);
  if (!n)
    return sA(e, r);
  for (var i = Math.floor(r / n), s = r % n, a = e - r, o = [], c = 0, l = 0; c < t.length; l += t[c], ++c)
    if (l + t[c] > s) {
      o = [...t.slice(0, c), s - l];
      break;
    }
  var u = o.length % 2 === 0 ? [0, a] : [a];
  return [...c2(t, i), ...o, ...u].map((d) => "".concat(d, "px")).join(", ");
};
function d2(r, e) {
  var t;
  if (/* @__PURE__ */ w.isValidElement(r))
    t = /* @__PURE__ */ w.cloneElement(r, e);
  else if (typeof r == "function")
    t = r(e);
  else {
    var n = ve("recharts-line-dot", typeof r != "boolean" ? r.className : "");
    t = /* @__PURE__ */ w.createElement(bg, Qi({}, e, {
      className: n
    }));
  }
  return t;
}
function f2(r, e) {
  return r == null ? !1 : e ? !0 : r.length === 1;
}
function h2(r) {
  var {
    clipPathId: e,
    points: t,
    props: n
  } = r, {
    dot: i,
    dataKey: s,
    needClip: a
  } = n;
  if (!f2(t, i))
    return null;
  var o = pl(i), c = de(n, !1), l = de(i, !0), u = t.map((f, h) => {
    var g = wr(wr(wr({
      key: "dot-".concat(h),
      r: 3
    }, c), l), {}, {
      index: h,
      cx: f.x,
      cy: f.y,
      dataKey: s,
      value: f.value,
      payload: f.payload,
      points: t
    });
    return d2(i, g);
  }), d = {
    clipPath: a ? "url(#clipPath-".concat(o ? "" : "dots-").concat(e, ")") : null
  };
  return /* @__PURE__ */ w.createElement(Fe, Qi({
    className: "recharts-line-dots",
    key: "dots"
  }, d), u);
}
function of(r) {
  var {
    clipPathId: e,
    pathRef: t,
    points: n,
    strokeDasharray: i,
    props: s,
    showLabels: a
  } = r, {
    type: o,
    layout: c,
    connectNulls: l,
    needClip: u
  } = s, d = iA(s, r2), f = wr(wr({}, de(d, !0)), {}, {
    fill: "none",
    className: "recharts-line-curve",
    clipPath: u ? "url(#clipPath-".concat(e, ")") : null,
    points: n,
    type: o,
    layout: c,
    connectNulls: l,
    strokeDasharray: i ?? s.strokeDasharray
  });
  return /* @__PURE__ */ w.createElement(w.Fragment, null, (n == null ? void 0 : n.length) > 1 && /* @__PURE__ */ w.createElement(ai, Qi({}, f, {
    pathRef: t
  })), /* @__PURE__ */ w.createElement(h2, {
    points: n,
    clipPathId: e,
    props: s
  }), a && $r.renderCallByParent(s, n));
}
function g2(r) {
  try {
    return r && r.getTotalLength && r.getTotalLength() || 0;
  } catch {
    return 0;
  }
}
function m2(r) {
  var {
    clipPathId: e,
    props: t,
    pathRef: n,
    previousPointsRef: i,
    longestAnimatedLengthRef: s
  } = r, {
    points: a,
    strokeDasharray: o,
    isAnimationActive: c,
    animationBegin: l,
    animationDuration: u,
    animationEasing: d,
    animateNewValues: f,
    width: h,
    height: g,
    onAnimationEnd: m,
    onAnimationStart: p
  } = t, v = i.current, y = Pa(t, "recharts-line-"), [b, x] = _e(!1), S = Se(() => {
    typeof m == "function" && m(), x(!1);
  }, [m]), A = Se(() => {
    typeof p == "function" && p(), x(!0);
  }, [p]), T = g2(n.current), I = s.current;
  return /* @__PURE__ */ w.createElement(jr, {
    begin: l,
    duration: u,
    isActive: c,
    easing: d,
    from: {
      t: 0
    },
    to: {
      t: 1
    },
    onAnimationEnd: S,
    onAnimationStart: A,
    key: y
  }, (L) => {
    var {
      t: _
    } = L, R = Et(I, T + I), D = Math.min(R(_), T), F;
    if (o) {
      var B = "".concat(o).split(/[,\s]+/gim).map((K) => parseFloat(K));
      F = u2(D, T, B);
    } else
      F = sA(T, D);
    if (v) {
      var j = v.length / a.length, U = _ === 1 ? a : a.map((K, G) => {
        var Y = Math.floor(G * j);
        if (v[Y]) {
          var Q = v[Y], H = Et(Q.x, K.x), N = Et(Q.y, K.y);
          return wr(wr({}, K), {}, {
            x: H(_),
            y: N(_)
          });
        }
        if (f) {
          var re = Et(h * 2, K.x), oe = Et(g / 2, K.y);
          return wr(wr({}, K), {}, {
            x: re(_),
            y: oe(_)
          });
        }
        return wr(wr({}, K), {}, {
          x: K.x,
          y: K.y
        });
      });
      return i.current = U, /* @__PURE__ */ w.createElement(of, {
        props: t,
        points: U,
        clipPathId: e,
        pathRef: n,
        showLabels: !b,
        strokeDasharray: F
      });
    }
    return _ > 0 && T > 0 && (i.current = a, s.current = D), /* @__PURE__ */ w.createElement(of, {
      props: t,
      points: a,
      clipPathId: e,
      pathRef: n,
      showLabels: !b,
      strokeDasharray: F
    });
  });
}
function p2(r) {
  var {
    clipPathId: e,
    props: t
  } = r, {
    points: n,
    isAnimationActive: i
  } = t, s = Ke(null), a = Ke(0), o = Ke(null), c = s.current;
  return i && n && n.length && c !== n ? /* @__PURE__ */ w.createElement(m2, {
    props: t,
    clipPathId: e,
    previousPointsRef: s,
    longestAnimatedLengthRef: a,
    pathRef: o
  }) : /* @__PURE__ */ w.createElement(of, {
    props: t,
    points: n,
    clipPathId: e,
    pathRef: o,
    showLabels: !0
  });
}
var v2 = (r, e) => ({
  x: r.x,
  y: r.y,
  value: r.value,
  // @ts-expect-error getValueByDataKey does not validate the output type
  errorVal: Pe(r.payload, e)
});
class y2 extends $n {
  constructor() {
    super(...arguments), tc(this, "id", nn("recharts-line-"));
  }
  render() {
    var e, {
      hide: t,
      dot: n,
      points: i,
      className: s,
      xAxisId: a,
      yAxisId: o,
      top: c,
      left: l,
      width: u,
      height: d,
      id: f,
      needClip: h,
      layout: g
    } = this.props;
    if (t)
      return null;
    var m = ve("recharts-line", s), p = ye(f) ? this.id : f, {
      r: v = 3,
      strokeWidth: y = 2
    } = (e = de(n, !1)) !== null && e !== void 0 ? e : {
      r: 3,
      strokeWidth: 2
    }, b = pl(n), x = v * 2 + y;
    return /* @__PURE__ */ w.createElement(w.Fragment, null, /* @__PURE__ */ w.createElement(Fe, {
      className: m
    }, h && /* @__PURE__ */ w.createElement("defs", null, /* @__PURE__ */ w.createElement(Jl, {
      clipPathId: p,
      xAxisId: a,
      yAxisId: o
    }), !b && /* @__PURE__ */ w.createElement("clipPath", {
      id: "clipPath-dots-".concat(p)
    }, /* @__PURE__ */ w.createElement("rect", {
      x: l - x / 2,
      y: c - x / 2,
      width: u + x,
      height: d + x
    }))), /* @__PURE__ */ w.createElement(p2, {
      props: this.props,
      clipPathId: p
    }), /* @__PURE__ */ w.createElement(UT, {
      direction: g === "horizontal" ? "y" : "x"
    }, /* @__PURE__ */ w.createElement(wg, {
      xAxisId: a,
      yAxisId: o,
      data: i,
      dataPointFormatter: v2,
      errorBarOffset: 0
    }, this.props.children))), /* @__PURE__ */ w.createElement(nf, {
      activeDot: this.props.activeDot,
      points: i,
      mainColor: this.props.stroke,
      itemDataKey: this.props.dataKey
    }));
  }
}
var aA = {
  activeDot: !0,
  animateNewValues: !0,
  animationBegin: 0,
  animationDuration: 1500,
  animationEasing: "ease",
  connectNulls: !1,
  dot: !0,
  fill: "#fff",
  hide: !1,
  isAnimationActive: !pn.isSsr,
  label: !1,
  legendType: "line",
  stroke: "#3182bd",
  strokeWidth: 1,
  xAxisId: 0,
  yAxisId: 0
};
function b2(r) {
  var e = Vt(r, aA), {
    activeDot: t,
    animateNewValues: n,
    animationBegin: i,
    animationDuration: s,
    animationEasing: a,
    connectNulls: o,
    dot: c,
    hide: l,
    isAnimationActive: u,
    label: d,
    legendType: f,
    xAxisId: h,
    yAxisId: g
  } = e, m = iA(e, n2), {
    needClip: p
  } = _a(h, g), {
    height: v,
    width: y,
    x: b,
    y: x
  } = Ql(), S = fa(), A = At(), T = Jt(() => ({
    dataKey: r.dataKey,
    data: r.data
  }), [r.dataKey, r.data]), I = te((L) => t2(L, h, g, A, T));
  return S !== "horizontal" && S !== "vertical" ? null : /* @__PURE__ */ w.createElement(y2, Qi({}, m, {
    connectNulls: o,
    dot: c,
    activeDot: t,
    animateNewValues: n,
    animationBegin: i,
    animationDuration: s,
    animationEasing: a,
    isAnimationActive: u,
    hide: l,
    label: d,
    legendType: f,
    xAxisId: h,
    yAxisId: g,
    points: I,
    layout: S,
    height: v,
    width: y,
    left: b,
    top: x,
    needClip: p
  }));
}
function x2(r) {
  var {
    layout: e,
    xAxis: t,
    yAxis: n,
    xAxisTicks: i,
    yAxisTicks: s,
    dataKey: a,
    bandSize: o,
    displayedData: c
  } = r;
  return c.map((l, u) => {
    var d = Pe(l, a);
    return e === "horizontal" ? {
      x: Vi({
        axis: t,
        ticks: i,
        bandSize: o,
        entry: l,
        index: u
      }),
      y: ye(d) ? null : n.scale(d),
      value: d,
      payload: l
    } : {
      x: ye(d) ? null : t.scale(d),
      y: Vi({
        axis: n,
        ticks: s,
        bandSize: o,
        entry: l,
        index: u
      }),
      value: d,
      payload: l
    };
  });
}
class Rg extends Kr {
  render() {
    return /* @__PURE__ */ w.createElement(Zl, {
      type: "line",
      data: this.props.data,
      xAxisId: this.props.xAxisId,
      yAxisId: this.props.yAxisId,
      zAxisId: 0,
      dataKey: this.props.dataKey,
      stackId: void 0,
      hide: this.props.hide,
      barSize: void 0
    }, /* @__PURE__ */ w.createElement(Yl, {
      legendPayload: o2(this.props)
    }), /* @__PURE__ */ w.createElement(Ia, {
      fn: l2,
      args: this.props
    }), /* @__PURE__ */ w.createElement(b2, this.props));
  }
}
tc(Rg, "displayName", "Line");
tc(Rg, "defaultProps", aA);
var oA = (r, e, t, n) => Gt(r, "xAxis", e, n), lA = (r, e, t, n) => vr(r, "xAxis", e, n), cA = (r, e, t, n) => Gt(r, "yAxis", t, n), uA = (r, e, t, n) => vr(r, "yAxis", t, n), E2 = M([Ee, oA, cA, lA, uA], (r, e, t, n, i) => Vr(r, "xAxis") ? fi(e, n, !1) : fi(t, i, !1)), S2 = (r, e, t, n, i) => {
  var s, a = Ee(r), o = Vr(a, "xAxis"), c;
  if (o ? c = Xs(r, "yAxis", t, n) : c = Xs(r, "xAxis", e, n), c != null) {
    var {
      dataKey: l,
      stackId: u
    } = i;
    if (u != null) {
      var d = (s = c[u]) === null || s === void 0 ? void 0 : s.stackedData;
      return d == null ? void 0 : d.find((f) => f.key === l);
    }
  }
}, T2 = (r, e, t, n, i) => i, A2 = M([ls, T2], (r, e) => {
  if (r.some((t) => t.type === "area" && e.dataKey === t.dataKey && ih(e.stackId) === t.stackId && e.data === t.data))
    return e;
}), w2 = M([Ee, oA, cA, lA, uA, S2, va, E2, A2], (r, e, t, n, i, s, a, o, c) => {
  var {
    chartData: l,
    dataStartIndex: u,
    dataEndIndex: d
  } = a;
  if (!(c == null || r !== "horizontal" && r !== "vertical" || e == null || t == null || n == null || i == null || n.length === 0 || i.length === 0 || o == null)) {
    var {
      data: f
    } = c, h;
    if (f && f.length > 0 ? h = f : h = l == null ? void 0 : l.slice(u, d + 1), h != null) {
      var g = void 0;
      return V2({
        layout: r,
        xAxis: e,
        yAxis: t,
        xAxisTicks: n,
        yAxisTicks: i,
        dataStartIndex: u,
        areaSettings: c,
        stackedData: s,
        displayedData: h,
        chartBaseValue: g,
        bandSize: o
      });
    }
  }
}), I2 = ["layout", "type", "stroke", "connectNulls", "isRange"], P2 = ["activeDot", "animationBegin", "animationDuration", "animationEasing", "connectNulls", "dot", "fill", "fillOpacity", "hide", "isAnimationActive", "legendType", "stroke", "xAxisId", "yAxisId"];
function dA(r, e) {
  if (r == null) return {};
  var t, n, i = _2(r, e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(r);
    for (n = 0; n < s.length; n++) t = s[n], e.indexOf(t) === -1 && {}.propertyIsEnumerable.call(r, t) && (i[t] = r[t]);
  }
  return i;
}
function _2(r, e) {
  if (r == null) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.indexOf(n) !== -1) continue;
    t[n] = r[n];
  }
  return t;
}
function py(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function ri(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? py(Object(t), !0).forEach(function(n) {
      rc(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : py(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function rc(r, e, t) {
  return (e = L2(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function L2(r) {
  var e = O2(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function O2(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function kn() {
  return kn = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t) ({}).hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, kn.apply(null, arguments);
}
function nl(r, e) {
  return r && r !== "none" ? r : e;
}
var R2 = (r) => {
  var {
    dataKey: e,
    name: t,
    stroke: n,
    fill: i,
    legendType: s,
    hide: a
  } = r;
  return [{
    inactive: a,
    dataKey: e,
    type: s,
    color: nl(n, i),
    value: Wr(t, e),
    payload: r
  }];
};
function D2(r) {
  var {
    dataKey: e,
    data: t,
    stroke: n,
    strokeWidth: i,
    fill: s,
    name: a,
    hide: o,
    unit: c
  } = r;
  return {
    dataDefinedOnItem: t,
    positions: void 0,
    settings: {
      stroke: n,
      strokeWidth: i,
      fill: s,
      dataKey: e,
      nameKey: void 0,
      name: Wr(a, e),
      hide: o,
      type: r.tooltipType,
      color: nl(n, s),
      unit: c
    }
  };
}
var C2 = (r, e) => {
  var t;
  if (/* @__PURE__ */ w.isValidElement(r))
    t = /* @__PURE__ */ w.cloneElement(r, e);
  else if (typeof r == "function")
    t = r(e);
  else {
    var n = ve("recharts-area-dot", typeof r != "boolean" ? r.className : "");
    t = /* @__PURE__ */ w.createElement(bg, kn({}, e, {
      className: n
    }));
  }
  return t;
};
function k2(r, e) {
  return r == null ? !1 : e ? !0 : r.length === 1;
}
function M2(r) {
  var {
    clipPathId: e,
    points: t,
    props: n
  } = r, {
    needClip: i,
    dot: s,
    dataKey: a
  } = n;
  if (!k2(t, s))
    return null;
  var o = pl(s), c = de(n, !1), l = de(s, !0), u = t.map((f, h) => {
    var g = ri(ri(ri({
      key: "dot-".concat(h),
      r: 3
    }, c), l), {}, {
      index: h,
      cx: f.x,
      cy: f.y,
      dataKey: a,
      value: f.value,
      payload: f.payload,
      points: t
    });
    return C2(s, g);
  }), d = {
    clipPath: i ? "url(#clipPath-".concat(o ? "" : "dots-").concat(e, ")") : void 0
  };
  return /* @__PURE__ */ w.createElement(Fe, kn({
    className: "recharts-area-dots"
  }, d), u);
}
function lf(r) {
  var {
    points: e,
    baseLine: t,
    needClip: n,
    clipPathId: i,
    props: s,
    showLabels: a
  } = r, {
    layout: o,
    type: c,
    stroke: l,
    connectNulls: u,
    isRange: d
  } = s, f = dA(s, I2);
  return /* @__PURE__ */ w.createElement(w.Fragment, null, (e == null ? void 0 : e.length) > 1 && /* @__PURE__ */ w.createElement(Fe, {
    clipPath: n ? "url(#clipPath-".concat(i, ")") : void 0
  }, /* @__PURE__ */ w.createElement(ai, kn({}, de(f, !0), {
    points: e,
    connectNulls: u,
    type: c,
    baseLine: t,
    layout: o,
    stroke: "none",
    className: "recharts-area-area"
  })), l !== "none" && /* @__PURE__ */ w.createElement(ai, kn({}, de(s, !1), {
    className: "recharts-area-curve",
    layout: o,
    type: c,
    connectNulls: u,
    fill: "none",
    points: e
  })), l !== "none" && d && /* @__PURE__ */ w.createElement(ai, kn({}, de(s, !1), {
    className: "recharts-area-curve",
    layout: o,
    type: c,
    connectNulls: u,
    fill: "none",
    points: t
  }))), /* @__PURE__ */ w.createElement(M2, {
    points: e,
    props: s,
    clipPathId: i
  }), a && $r.renderCallByParent(s, e));
}
function N2(r) {
  var {
    alpha: e,
    baseLine: t,
    points: n,
    strokeWidth: i
  } = r, s = n[0].y, a = n[n.length - 1].y;
  if (!Tt(s) || !Tt(a))
    return null;
  var o = e * Math.abs(s - a), c = Math.max(...n.map((l) => l.x || 0));
  return z(t) ? c = Math.max(t, c) : t && Array.isArray(t) && t.length && (c = Math.max(...t.map((l) => l.x || 0), c)), z(c) ? /* @__PURE__ */ w.createElement("rect", {
    x: 0,
    y: s < a ? s : s - o,
    width: c + (i ? parseInt("".concat(i), 10) : 1),
    height: Math.floor(o)
  }) : null;
}
function F2(r) {
  var {
    alpha: e,
    baseLine: t,
    points: n,
    strokeWidth: i
  } = r, s = n[0].x, a = n[n.length - 1].x;
  if (!Tt(s) || !Tt(a))
    return null;
  var o = e * Math.abs(s - a), c = Math.max(...n.map((l) => l.y || 0));
  return z(t) ? c = Math.max(t, c) : t && Array.isArray(t) && t.length && (c = Math.max(...t.map((l) => l.y || 0), c)), z(c) ? /* @__PURE__ */ w.createElement("rect", {
    x: s < a ? s : s - o,
    y: 0,
    width: o,
    height: Math.floor(c + (i ? parseInt("".concat(i), 10) : 1))
  }) : null;
}
function $2(r) {
  var {
    alpha: e,
    layout: t,
    points: n,
    baseLine: i,
    strokeWidth: s
  } = r;
  return t === "vertical" ? /* @__PURE__ */ w.createElement(N2, {
    alpha: e,
    points: n,
    baseLine: i,
    strokeWidth: s
  }) : /* @__PURE__ */ w.createElement(F2, {
    alpha: e,
    points: n,
    baseLine: i,
    strokeWidth: s
  });
}
function B2(r) {
  var {
    needClip: e,
    clipPathId: t,
    props: n,
    previousPointsRef: i,
    previousBaselineRef: s
  } = r, {
    points: a,
    baseLine: o,
    isAnimationActive: c,
    animationBegin: l,
    animationDuration: u,
    animationEasing: d,
    onAnimationStart: f,
    onAnimationEnd: h
  } = n, g = Pa(n, "recharts-area-"), [m, p] = _e(!0), v = Se(() => {
    typeof h == "function" && h(), p(!1);
  }, [h]), y = Se(() => {
    typeof f == "function" && f(), p(!0);
  }, [f]), b = i.current, x = s.current;
  return /* @__PURE__ */ w.createElement(jr, {
    begin: l,
    duration: u,
    isActive: c,
    easing: d,
    from: {
      t: 0
    },
    to: {
      t: 1
    },
    onAnimationEnd: v,
    onAnimationStart: y,
    key: g
  }, (S) => {
    var {
      t: A
    } = S;
    if (b) {
      var T = b.length / a.length, I = (
        /*
         * Here it is important that at the very end of the animation, on the last frame,
         * we render the original points without any interpolation.
         * This is needed because the code above is checking for reference equality to decide if the animation should run
         * and if we create a new array instance (even if the numbers were the same)
         * then we would break animations.
         */
        A === 1 ? a : a.map((_, R) => {
          var D = Math.floor(R * T);
          if (b[D]) {
            var F = b[D];
            return ri(ri({}, _), {}, {
              x: Ai(F.x, _.x, A),
              y: Ai(F.y, _.y, A)
            });
          }
          return _;
        })
      ), L;
      return z(o) ? L = Ai(x, o, A) : ye(o) || Ut(o) ? L = Ai(x, 0, A) : L = o.map((_, R) => {
        var D = Math.floor(R * T);
        if (Array.isArray(x) && x[D]) {
          var F = x[D];
          return ri(ri({}, _), {}, {
            x: Ai(F.x, _.x, A),
            y: Ai(F.y, _.y, A)
          });
        }
        return _;
      }), A > 0 && (i.current = I, s.current = L), /* @__PURE__ */ w.createElement(lf, {
        points: I,
        baseLine: L,
        needClip: e,
        clipPathId: t,
        props: n,
        showLabels: !m
      });
    }
    return A > 0 && (i.current = a, s.current = o), /* @__PURE__ */ w.createElement(Fe, null, /* @__PURE__ */ w.createElement("defs", null, /* @__PURE__ */ w.createElement("clipPath", {
      id: "animationClipPath-".concat(t)
    }, /* @__PURE__ */ w.createElement($2, {
      alpha: A,
      points: a,
      baseLine: o,
      layout: n.layout,
      strokeWidth: n.strokeWidth
    }))), /* @__PURE__ */ w.createElement(Fe, {
      clipPath: "url(#animationClipPath-".concat(t, ")")
    }, /* @__PURE__ */ w.createElement(lf, {
      points: a,
      baseLine: o,
      needClip: e,
      clipPathId: t,
      props: n,
      showLabels: !0
    })));
  });
}
function j2(r) {
  var {
    needClip: e,
    clipPathId: t,
    props: n
  } = r, {
    points: i,
    baseLine: s,
    isAnimationActive: a
  } = n, o = Ke(null), c = Ke(), l = o.current, u = c.current;
  return a && /*
   * Here it's important that we unmount of AreaWithAnimation in case points are undefined
   * - this will make sure to interrupt the animation if it's running.
   * We still get to keep the last shape of the animation in the refs above.
   */
  i && i.length && (l !== i || u !== s) ? /* @__PURE__ */ w.createElement(B2, {
    needClip: e,
    clipPathId: t,
    props: n,
    previousPointsRef: o,
    previousBaselineRef: c
  }) : /* @__PURE__ */ w.createElement(lf, {
    points: i,
    baseLine: s,
    needClip: e,
    clipPathId: t,
    props: n,
    showLabels: !0
  });
}
class U2 extends Kr {
  constructor() {
    super(...arguments), rc(this, "id", nn("recharts-area-"));
  }
  render() {
    var e, {
      hide: t,
      dot: n,
      points: i,
      className: s,
      top: a,
      left: o,
      needClip: c,
      xAxisId: l,
      yAxisId: u,
      width: d,
      height: f,
      id: h,
      baseLine: g
    } = this.props;
    if (t)
      return null;
    var m = ve("recharts-area", s), p = ye(h) ? this.id : h, {
      r: v = 3,
      strokeWidth: y = 2
    } = (e = de(n, !1)) !== null && e !== void 0 ? e : {
      r: 3,
      strokeWidth: 2
    }, b = pl(n), x = v * 2 + y;
    return /* @__PURE__ */ w.createElement(w.Fragment, null, /* @__PURE__ */ w.createElement(Fe, {
      className: m
    }, c && /* @__PURE__ */ w.createElement("defs", null, /* @__PURE__ */ w.createElement(Jl, {
      clipPathId: p,
      xAxisId: l,
      yAxisId: u
    }), !b && /* @__PURE__ */ w.createElement("clipPath", {
      id: "clipPath-dots-".concat(p)
    }, /* @__PURE__ */ w.createElement("rect", {
      x: o - x / 2,
      y: a - x / 2,
      width: d + x,
      height: f + x
    }))), /* @__PURE__ */ w.createElement(j2, {
      needClip: c,
      clipPathId: p,
      props: this.props
    })), /* @__PURE__ */ w.createElement(nf, {
      points: i,
      mainColor: nl(this.props.stroke, this.props.fill),
      itemDataKey: this.props.dataKey,
      activeDot: this.props.activeDot
    }), this.props.isRange && Array.isArray(g) && /* @__PURE__ */ w.createElement(nf, {
      points: g,
      mainColor: nl(this.props.stroke, this.props.fill),
      itemDataKey: this.props.dataKey,
      activeDot: this.props.activeDot
    }));
  }
}
var fA = {
  activeDot: !0,
  animationBegin: 0,
  animationDuration: 1500,
  animationEasing: "ease",
  connectNulls: !1,
  dot: !1,
  fill: "#3182bd",
  fillOpacity: 0.6,
  hide: !1,
  isAnimationActive: !pn.isSsr,
  legendType: "line",
  stroke: "#3182bd",
  xAxisId: 0,
  yAxisId: 0
};
function G2(r) {
  var e, t = Vt(r, fA), {
    activeDot: n,
    animationBegin: i,
    animationDuration: s,
    animationEasing: a,
    connectNulls: o,
    dot: c,
    fill: l,
    fillOpacity: u,
    hide: d,
    isAnimationActive: f,
    legendType: h,
    stroke: g,
    xAxisId: m,
    yAxisId: p
  } = t, v = dA(t, P2), y = fa(), b = mT(), {
    needClip: x
  } = _a(m, p), S = At(), A = Jt(() => ({
    baseValue: r.baseValue,
    stackId: r.stackId,
    connectNulls: o,
    data: r.data,
    dataKey: r.dataKey
  }), [r.baseValue, r.stackId, o, r.data, r.dataKey]), {
    points: T,
    isRange: I,
    baseLine: L
  } = (e = te((B) => w2(B, m, p, S, A))) !== null && e !== void 0 ? e : {}, {
    height: _,
    width: R,
    x: D,
    y: F
  } = Ql();
  return y !== "horizontal" && y !== "vertical" || b !== "AreaChart" && b !== "ComposedChart" ? null : /* @__PURE__ */ w.createElement(U2, kn({}, v, {
    activeDot: n,
    animationBegin: i,
    animationDuration: s,
    animationEasing: a,
    baseLine: L,
    connectNulls: o,
    dot: c,
    fill: l,
    fillOpacity: u,
    height: _,
    hide: d,
    layout: y,
    isAnimationActive: f,
    isRange: I,
    legendType: h,
    needClip: x,
    points: T,
    stroke: g,
    width: R,
    left: D,
    top: F,
    xAxisId: m,
    yAxisId: p
  }));
}
var K2 = (r, e, t, n, i) => {
  var s = t ?? e;
  if (z(s))
    return s;
  var a = r === "horizontal" ? i : n, o = a.scale.domain();
  if (a.type === "number") {
    var c = Math.max(o[0], o[1]), l = Math.min(o[0], o[1]);
    return s === "dataMin" ? l : s === "dataMax" || c < 0 ? c : Math.max(Math.min(o[0], o[1]), 0);
  }
  return s === "dataMin" ? o[0] : s === "dataMax" ? o[1] : o[0];
};
function V2(r) {
  var {
    areaSettings: {
      connectNulls: e,
      baseValue: t,
      dataKey: n
    },
    stackedData: i,
    layout: s,
    chartBaseValue: a,
    xAxis: o,
    yAxis: c,
    displayedData: l,
    dataStartIndex: u,
    xAxisTicks: d,
    yAxisTicks: f,
    bandSize: h
  } = r, g = i && i.length, m = K2(s, a, t, o, c), p = s === "horizontal", v = !1, y = l.map((x, S) => {
    var A;
    g ? A = i[u + S] : (A = Pe(x, n), Array.isArray(A) ? v = !0 : A = [m, A]);
    var T = A[1] == null || g && !e && Pe(x, n) == null;
    return p ? {
      // @ts-expect-error getCateCoordinateOfLine expects chart data to be an object, we allow unknown
      x: Vi({
        axis: o,
        ticks: d,
        bandSize: h,
        entry: x,
        index: S
      }),
      y: T ? null : c.scale(A[1]),
      value: A,
      payload: x
    } : {
      x: T ? null : o.scale(A[1]),
      // @ts-expect-error getCateCoordinateOfLine expects chart data to be an object, we allow unknown
      y: Vi({
        axis: c,
        ticks: f,
        bandSize: h,
        entry: x,
        index: S
      }),
      value: A,
      payload: x
    };
  }), b;
  return g || v ? b = y.map((x) => {
    var S = Array.isArray(x.value) ? x.value[0] : null;
    return p ? {
      x: x.x,
      y: S != null && x.y != null ? c.scale(S) : null
    } : {
      x: S != null ? o.scale(S) : null,
      y: x.y
    };
  }) : b = p ? c.scale(m) : o.scale(m), {
    points: y,
    baseLine: b,
    isRange: v
  };
}
class Dg extends Kr {
  render() {
    return /* @__PURE__ */ w.createElement(Zl, {
      type: "area",
      data: this.props.data,
      dataKey: this.props.dataKey,
      xAxisId: this.props.xAxisId,
      yAxisId: this.props.yAxisId,
      zAxisId: 0,
      stackId: this.props.stackId,
      hide: this.props.hide,
      barSize: void 0
    }, /* @__PURE__ */ w.createElement(Yl, {
      legendPayload: R2(this.props)
    }), /* @__PURE__ */ w.createElement(Ia, {
      fn: D2,
      args: this.props
    }), /* @__PURE__ */ w.createElement(G2, this.props));
  }
}
rc(Dg, "displayName", "Area");
rc(Dg, "defaultProps", fA);
function vy(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function yy(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? vy(Object(t), !0).forEach(function(n) {
      W2(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : vy(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function W2(r, e, t) {
  return (e = H2(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function H2(r) {
  var e = q2(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function q2(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
var z2 = {
  xAxis: {},
  yAxis: {},
  zAxis: {}
}, hA = xr({
  name: "cartesianAxis",
  initialState: z2,
  reducers: {
    addXAxis(r, e) {
      r.xAxis[e.payload.id] = e.payload;
    },
    removeXAxis(r, e) {
      delete r.xAxis[e.payload.id];
    },
    addYAxis(r, e) {
      r.yAxis[e.payload.id] = e.payload;
    },
    removeYAxis(r, e) {
      delete r.yAxis[e.payload.id];
    },
    addZAxis(r, e) {
      r.zAxis[e.payload.id] = e.payload;
    },
    removeZAxis(r, e) {
      delete r.zAxis[e.payload.id];
    },
    updateYAxisWidth(r, e) {
      var {
        id: t,
        width: n
      } = e.payload;
      r.yAxis[t] && (r.yAxis[t] = yy(yy({}, r.yAxis[t]), {}, {
        width: n
      }));
    }
  }
}), {
  addXAxis: Y2,
  removeXAxis: X2,
  addYAxis: Q2,
  removeYAxis: Z2,
  addZAxis: J2,
  removeZAxis: eU,
  updateYAxisWidth: tU
} = hA.actions, rU = hA.reducer;
function gA(r, e, t) {
  return (e = nU(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function nU(r) {
  var e = iU(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function iU(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function sU(r) {
  var e = He();
  return we(() => (e(J2(r)), () => {
    e(eU(r));
  }), [r, e]), null;
}
class Cg extends $n {
  render() {
    return /* @__PURE__ */ w.createElement(sU, {
      domain: this.props.domain,
      id: this.props.zAxisId,
      dataKey: this.props.dataKey,
      name: this.props.name,
      unit: this.props.unit,
      range: this.props.range,
      scale: this.props.scale,
      type: this.props.type,
      allowDuplicatedCategory: Rn.allowDuplicatedCategory,
      allowDataOverflow: Rn.allowDataOverflow,
      reversed: Rn.reversed,
      includeHidden: Rn.includeHidden
    });
  }
}
gA(Cg, "displayName", "ZAxis");
gA(Cg, "defaultProps", {
  zAxisId: 0,
  range: Rn.range,
  scale: Rn.scale,
  type: Rn.type
});
var aU = ["option", "isActive"];
function Fs() {
  return Fs = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t) ({}).hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, Fs.apply(null, arguments);
}
function oU(r, e) {
  if (r == null) return {};
  var t, n, i = lU(r, e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(r);
    for (n = 0; n < s.length; n++) t = s[n], e.indexOf(t) === -1 && {}.propertyIsEnumerable.call(r, t) && (i[t] = r[t]);
  }
  return i;
}
function lU(r, e) {
  if (r == null) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.indexOf(n) !== -1) continue;
    t[n] = r[n];
  }
  return t;
}
function cU(r) {
  var {
    option: e,
    isActive: t
  } = r, n = oU(r, aU);
  return typeof e == "string" ? /* @__PURE__ */ w.createElement(el, Fs({
    option: /* @__PURE__ */ w.createElement(xl, Fs({
      type: e
    }, n)),
    isActive: t,
    shapeType: "symbols"
  }, n)) : /* @__PURE__ */ w.createElement(el, Fs({
    option: e,
    isActive: t,
    shapeType: "symbols"
  }, n));
}
var uU = (r, e, t, n, i, s, a) => Gt(r, "xAxis", e, a), dU = (r, e, t, n, i, s, a) => vr(r, "xAxis", e, a), fU = (r, e, t, n, i, s, a) => Gt(r, "yAxis", t, a), hU = (r, e, t, n, i, s, a) => vr(r, "yAxis", t, a), gU = (r, e, t, n) => tM(r, "zAxis", n, !1), mU = (r, e, t, n, i) => i, pU = (r, e, t, n, i, s) => s, vU = (r, e, t, n, i, s, a) => va(r, e, t, a), yU = M([ls, mU], (r, e) => {
  if (r.some((t) => t.type === "scatter" && e.dataKey === t.dataKey && e.data === t.data))
    return e;
}), bU = M([vU, uU, dU, fU, hU, gU, yU, pU], (r, e, t, n, i, s, a, o) => {
  var {
    chartData: c,
    dataStartIndex: l,
    dataEndIndex: u
  } = r;
  if (a != null) {
    var d;
    if ((a == null ? void 0 : a.data) != null && a.data.length > 0 ? d = a.data : d = c == null ? void 0 : c.slice(l, u + 1), !(d == null || e == null || n == null || t == null || i == null || (t == null ? void 0 : t.length) === 0 || (i == null ? void 0 : i.length) === 0))
      return OU({
        displayedData: d,
        xAxis: e,
        yAxis: n,
        zAxis: s,
        scatterSettings: a,
        xAxisTicks: t,
        yAxisTicks: i,
        cells: o
      });
  }
}), xU = ["onMouseEnter", "onClick", "onMouseLeave"], EU = ["animationBegin", "animationDuration", "animationEasing", "hide", "isAnimationActive", "legendType", "lineJointType", "lineType", "shape", "xAxisId", "yAxisId", "zAxisId"];
function mA(r, e) {
  if (r == null) return {};
  var t, n, i = SU(r, e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(r);
    for (n = 0; n < s.length; n++) t = s[n], e.indexOf(t) === -1 && {}.propertyIsEnumerable.call(r, t) && (i[t] = r[t]);
  }
  return i;
}
function SU(r, e) {
  if (r == null) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.indexOf(n) !== -1) continue;
    t[n] = r[n];
  }
  return t;
}
function Zi() {
  return Zi = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t) ({}).hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, Zi.apply(null, arguments);
}
function by(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function jt(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? by(Object(t), !0).forEach(function(n) {
      kg(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : by(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function kg(r, e, t) {
  return (e = TU(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function TU(r) {
  var e = AU(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function AU(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
var wU = (r) => {
  var {
    dataKey: e,
    name: t,
    fill: n,
    legendType: i,
    hide: s
  } = r;
  return [{
    inactive: s,
    dataKey: e,
    type: i,
    color: n,
    value: Wr(t, e),
    payload: r
  }];
};
function IU(r) {
  var {
    points: e,
    props: t
  } = r, {
    line: n,
    lineType: i,
    lineJointType: s
  } = t;
  if (!n)
    return null;
  var a = de(t, !1), o = de(n, !1), c, l;
  if (i === "joint")
    c = e.map((p) => ({
      x: p.cx,
      y: p.cy
    }));
  else if (i === "fitting") {
    var {
      xmin: u,
      xmax: d,
      a: f,
      b: h
    } = VI(e), g = (p) => f * p + h;
    c = [{
      x: u,
      y: g(u)
    }, {
      x: d,
      y: g(d)
    }];
  }
  var m = jt(jt(jt({}, a), {}, {
    fill: "none",
    stroke: a && a.fill
  }, o), {}, {
    points: c
  });
  return /* @__PURE__ */ w.isValidElement(n) ? l = /* @__PURE__ */ w.cloneElement(n, m) : typeof n == "function" ? l = n(m) : l = /* @__PURE__ */ w.createElement(ai, Zi({}, m, {
    type: s
  })), /* @__PURE__ */ w.createElement(Fe, {
    className: "recharts-scatter-line",
    key: "recharts-scatter-line"
  }, l);
}
function pA(r) {
  var {
    points: e,
    showLabels: t,
    allOtherScatterProps: n
  } = r, {
    shape: i,
    activeShape: s,
    dataKey: a
  } = n, o = de(n, !1), c = te(cn), {
    onMouseEnter: l,
    onClick: u,
    onMouseLeave: d
  } = n, f = mA(n, xU), h = Hl(l, n.dataKey), g = ql(d), m = zl(u, n.dataKey);
  return e == null ? null : /* @__PURE__ */ w.createElement(w.Fragment, null, /* @__PURE__ */ w.createElement(IU, {
    points: e,
    props: n
  }), e.map((p, v) => {
    var y = s && c === String(v), b = y ? s : i, x = jt(jt(jt({
      key: "symbol-".concat(v)
    }, o), p), {}, {
      [oh]: v,
      [lh]: String(a)
    });
    return /* @__PURE__ */ w.createElement(Fe, Zi({
      className: "recharts-scatter-symbol"
    }, ns(f, p, v), {
      // @ts-expect-error the types need a bit of attention
      onMouseEnter: h(p, v),
      onMouseLeave: g(p, v),
      onClick: m(p, v),
      key: "symbol-".concat(p == null ? void 0 : p.cx, "-").concat(p == null ? void 0 : p.cy, "-").concat(p == null ? void 0 : p.size, "-").concat(v)
    }), /* @__PURE__ */ w.createElement(cU, Zi({
      option: b,
      isActive: y
    }, x)));
  }), t && $r.renderCallByParent(n, e));
}
function PU(r) {
  var {
    previousPointsRef: e,
    props: t
  } = r, {
    points: n,
    isAnimationActive: i,
    animationBegin: s,
    animationDuration: a,
    animationEasing: o
  } = t, c = e.current, l = Pa(t, "recharts-scatter-"), [u, d] = _e(!1), f = Se(() => {
    d(!1);
  }, []), h = Se(() => {
    d(!0);
  }, []);
  return /* @__PURE__ */ w.createElement(jr, {
    begin: s,
    duration: a,
    isActive: i,
    easing: o,
    from: {
      t: 0
    },
    to: {
      t: 1
    },
    onAnimationEnd: f,
    onAnimationStart: h,
    key: l
  }, (g) => {
    var {
      t: m
    } = g, p = m === 1 ? n : n.map((v, y) => {
      var b = c && c[y];
      if (b) {
        var x = Et(b.cx, v.cx), S = Et(b.cy, v.cy), A = Et(b.size, v.size);
        return jt(jt({}, v), {}, {
          cx: x(m),
          cy: S(m),
          size: A(m)
        });
      }
      var T = Et(0, v.size);
      return jt(jt({}, v), {}, {
        size: T(m)
      });
    });
    return m > 0 && (e.current = p), /* @__PURE__ */ w.createElement(Fe, null, /* @__PURE__ */ w.createElement(pA, {
      points: p,
      allOtherScatterProps: t,
      showLabels: !u
    }));
  });
}
function _U(r) {
  var {
    points: e,
    isAnimationActive: t
  } = r, n = Ke(null), i = n.current;
  return t && e && e.length && (!i || i !== e) ? /* @__PURE__ */ w.createElement(PU, {
    props: r,
    previousPointsRef: n
  }) : /* @__PURE__ */ w.createElement(pA, {
    points: e,
    allOtherScatterProps: r,
    showLabels: !0
  });
}
function LU(r) {
  var {
    dataKey: e,
    points: t,
    stroke: n,
    strokeWidth: i,
    fill: s,
    name: a,
    hide: o,
    tooltipType: c
  } = r;
  return {
    dataDefinedOnItem: t == null ? void 0 : t.map((l) => l.tooltipPayload),
    positions: t == null ? void 0 : t.map((l) => l.tooltipPosition),
    settings: {
      stroke: n,
      strokeWidth: i,
      fill: s,
      nameKey: void 0,
      dataKey: e,
      name: Wr(a, e),
      hide: o,
      type: c,
      color: s,
      unit: ""
      // why doesn't Scatter support unit?
    }
  };
}
function OU(r) {
  var {
    displayedData: e,
    xAxis: t,
    yAxis: n,
    zAxis: i,
    scatterSettings: s,
    xAxisTicks: a,
    yAxisTicks: o,
    cells: c
  } = r, l = ye(t.dataKey) ? s.dataKey : t.dataKey, u = ye(n.dataKey) ? s.dataKey : n.dataKey, d = i && i.dataKey, f = i ? i.range : Cg.defaultProps.range, h = f && f[0], g = t.scale.bandwidth ? t.scale.bandwidth() : 0, m = n.scale.bandwidth ? n.scale.bandwidth() : 0;
  return e.map((p, v) => {
    var y = Pe(p, l), b = Pe(p, u), x = !ye(d) && Pe(p, d) || "-", S = [{
      // @ts-expect-error name prop should not have dataKey in it
      name: ye(t.dataKey) ? s.name : t.name || t.dataKey,
      unit: t.unit || "",
      // @ts-expect-error getValueByDataKey does not validate the output type
      value: y,
      payload: p,
      dataKey: l,
      type: s.tooltipType
    }, {
      // @ts-expect-error name prop should not have dataKey in it
      name: ye(n.dataKey) ? s.name : n.name || n.dataKey,
      unit: n.unit || "",
      // @ts-expect-error getValueByDataKey does not validate the output type
      value: b,
      payload: p,
      dataKey: u,
      type: s.tooltipType
    }];
    x !== "-" && S.push({
      // @ts-expect-error name prop should not have dataKey in it
      name: i.name || i.dataKey,
      unit: i.unit || "",
      // @ts-expect-error getValueByDataKey does not validate the output type
      value: x,
      payload: p,
      dataKey: d,
      type: s.tooltipType
    });
    var A = Vi({
      axis: t,
      ticks: a,
      bandSize: g,
      entry: p,
      index: v,
      dataKey: l
    }), T = Vi({
      axis: n,
      ticks: o,
      bandSize: m,
      entry: p,
      index: v,
      dataKey: u
    }), I = x !== "-" ? i.scale(x) : h, L = Math.sqrt(Math.max(I, 0) / Math.PI);
    return jt(jt({}, p), {}, {
      cx: A,
      cy: T,
      x: A - L,
      y: T - L,
      width: 2 * L,
      height: 2 * L,
      size: I,
      node: {
        x: y,
        y: b,
        z: x
      },
      tooltipPayload: S,
      tooltipPosition: {
        x: A,
        y: T
      },
      payload: p
    }, c && c[v] && c[v].props);
  });
}
var RU = (r, e, t) => ({
  x: r.cx,
  y: r.cy,
  value: t === "x" ? +r.node.x : +r.node.y,
  // @ts-expect-error getValueByDataKey does not validate the output type
  errorVal: Pe(r, e)
});
function DU(r) {
  var e = Ke(nn("recharts-scatter-")), {
    hide: t,
    points: n,
    className: i,
    needClip: s,
    xAxisId: a,
    yAxisId: o,
    id: c,
    children: l
  } = r;
  if (t)
    return null;
  var u = ve("recharts-scatter", i), d = ye(c) ? e.current : c;
  return /* @__PURE__ */ w.createElement(Fe, {
    className: u,
    clipPath: s ? "url(#clipPath-".concat(d, ")") : null
  }, s && /* @__PURE__ */ w.createElement("defs", null, /* @__PURE__ */ w.createElement(Jl, {
    clipPathId: d,
    xAxisId: a,
    yAxisId: o
  })), /* @__PURE__ */ w.createElement(wg, {
    xAxisId: a,
    yAxisId: o,
    data: n,
    dataPointFormatter: RU,
    errorBarOffset: 0
  }, l), /* @__PURE__ */ w.createElement(Fe, {
    key: "recharts-scatter-symbols"
  }, /* @__PURE__ */ w.createElement(_U, r)));
}
var vA = {
  xAxisId: 0,
  yAxisId: 0,
  zAxisId: 0,
  legendType: "circle",
  lineType: "joint",
  lineJointType: "linear",
  data: [],
  shape: "circle",
  hide: !1,
  isAnimationActive: !pn.isSsr,
  animationBegin: 0,
  animationDuration: 400,
  animationEasing: "linear"
};
function CU(r) {
  var e = Vt(r, vA), {
    animationBegin: t,
    animationDuration: n,
    animationEasing: i,
    hide: s,
    isAnimationActive: a,
    legendType: o,
    lineJointType: c,
    lineType: l,
    shape: u,
    xAxisId: d,
    yAxisId: f,
    zAxisId: h
  } = e, g = mA(e, EU), {
    needClip: m
  } = _a(d, f), p = Jt(() => is(r.children, wa), [r.children]), v = Jt(() => ({
    name: r.name,
    tooltipType: r.tooltipType,
    data: r.data,
    dataKey: r.dataKey
  }), [r.data, r.dataKey, r.name, r.tooltipType]), y = At(), b = te((x) => bU(x, d, f, h, v, p, y));
  return m == null ? null : /* @__PURE__ */ w.createElement(w.Fragment, null, /* @__PURE__ */ w.createElement(Ia, {
    fn: LU,
    args: jt(jt({}, r), {}, {
      points: b
    })
  }), /* @__PURE__ */ w.createElement(DU, Zi({}, g, {
    xAxisId: d,
    yAxisId: f,
    zAxisId: h,
    lineType: l,
    lineJointType: c,
    legendType: o,
    shape: u,
    hide: s,
    isAnimationActive: a,
    animationBegin: t,
    animationDuration: n,
    animationEasing: i,
    points: b,
    needClip: m
  })));
}
class Mg extends $n {
  render() {
    return /* @__PURE__ */ w.createElement(Zl, {
      type: "scatter",
      data: this.props.data,
      xAxisId: this.props.xAxisId,
      yAxisId: this.props.yAxisId,
      zAxisId: this.props.zAxisId,
      dataKey: this.props.dataKey,
      stackId: void 0,
      hide: this.props.hide,
      barSize: void 0
    }, /* @__PURE__ */ w.createElement(Yl, {
      legendPayload: wU(this.props)
    }), /* @__PURE__ */ w.createElement(CU, this.props));
  }
}
kg(Mg, "displayName", "Scatter");
kg(Mg, "defaultProps", vA);
var kU = ["children"], MU = ["dangerouslySetInnerHTML", "ticks"];
function yA(r, e, t) {
  return (e = NU(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function NU(r) {
  var e = FU(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function FU(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function cf() {
  return cf = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t) ({}).hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, cf.apply(null, arguments);
}
function bA(r, e) {
  if (r == null) return {};
  var t, n, i = $U(r, e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(r);
    for (n = 0; n < s.length; n++) t = s[n], e.indexOf(t) === -1 && {}.propertyIsEnumerable.call(r, t) && (i[t] = r[t]);
  }
  return i;
}
function $U(r, e) {
  if (r == null) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.indexOf(n) !== -1) continue;
    t[n] = r[n];
  }
  return t;
}
function BU(r) {
  var e = He(), t = Jt(() => {
    var {
      children: s
    } = r, a = bA(r, kU);
    return a;
  }, [r]), n = te((s) => yn(s, t.id)), i = t === n;
  return we(() => (e(Y2(t)), () => {
    e(X2(t));
  }), [t, e]), i ? r.children : null;
}
var jU = (r) => {
  var {
    xAxisId: e,
    className: t
  } = r, n = te(dE), i = At(), s = "xAxis", a = te((h) => ds(h, s, e, i)), o = te((h) => zS(h, s, e, i)), c = te((h) => VS(h, e)), l = te((h) => Xk(h, e));
  if (c == null || l == null)
    return null;
  var {
    dangerouslySetInnerHTML: u,
    ticks: d
  } = r, f = bA(r, MU);
  return /* @__PURE__ */ w.createElement(Gn, cf({}, f, {
    scale: a,
    x: l.x,
    y: l.y,
    width: c.width,
    height: c.height,
    className: ve("recharts-".concat(s, " ").concat(s), t),
    viewBox: n,
    ticks: o
  }));
}, UU = (r) => {
  var e, t, n, i, s;
  return /* @__PURE__ */ w.createElement(BU, {
    interval: (e = r.interval) !== null && e !== void 0 ? e : "preserveEnd",
    id: r.xAxisId,
    scale: r.scale,
    type: r.type,
    padding: r.padding,
    allowDataOverflow: r.allowDataOverflow,
    domain: r.domain,
    dataKey: r.dataKey,
    allowDuplicatedCategory: r.allowDuplicatedCategory,
    allowDecimals: r.allowDecimals,
    tickCount: r.tickCount,
    includeHidden: (t = r.includeHidden) !== null && t !== void 0 ? t : !1,
    reversed: r.reversed,
    ticks: r.ticks,
    height: r.height,
    orientation: r.orientation,
    mirror: r.mirror,
    hide: r.hide,
    unit: r.unit,
    name: r.name,
    angle: (n = r.angle) !== null && n !== void 0 ? n : 0,
    minTickGap: (i = r.minTickGap) !== null && i !== void 0 ? i : 5,
    tick: (s = r.tick) !== null && s !== void 0 ? s : !0,
    tickFormatter: r.tickFormatter
  }, /* @__PURE__ */ w.createElement(jU, r));
};
class ki extends $n {
  render() {
    return /* @__PURE__ */ w.createElement(UU, this.props);
  }
}
yA(ki, "displayName", "XAxis");
yA(ki, "defaultProps", {
  allowDataOverflow: qt.allowDataOverflow,
  allowDecimals: qt.allowDecimals,
  allowDuplicatedCategory: qt.allowDuplicatedCategory,
  height: qt.height,
  hide: !1,
  mirror: qt.mirror,
  orientation: qt.orientation,
  padding: qt.padding,
  reversed: qt.reversed,
  scale: qt.scale,
  tickCount: qt.tickCount,
  type: qt.type,
  xAxisId: 0
});
var GU = (r) => {
  var {
    ticks: e,
    label: t,
    labelGapWithTick: n = 5,
    // Default gap between label and tick
    tickSize: i = 0,
    tickMargin: s = 0
  } = r, a = 0;
  if (e) {
    e.forEach((u) => {
      if (u) {
        var d = u.getBoundingClientRect();
        d.width > a && (a = d.width);
      }
    });
    var o = t ? t.getBoundingClientRect().width : 0, c = i + s, l = a + c + o + (t ? n : 0);
    return Math.round(l);
  }
  return 0;
}, KU = ["dangerouslySetInnerHTML", "ticks"];
function xA(r, e, t) {
  return (e = VU(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function VU(r) {
  var e = WU(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function WU(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function uf() {
  return uf = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t) ({}).hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, uf.apply(null, arguments);
}
function HU(r, e) {
  if (r == null) return {};
  var t, n, i = qU(r, e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(r);
    for (n = 0; n < s.length; n++) t = s[n], e.indexOf(t) === -1 && {}.propertyIsEnumerable.call(r, t) && (i[t] = r[t]);
  }
  return i;
}
function qU(r, e) {
  if (r == null) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.indexOf(n) !== -1) continue;
    t[n] = r[n];
  }
  return t;
}
function zU(r) {
  var e = He();
  return we(() => (e(Q2(r)), () => {
    e(Z2(r));
  }), [r, e]), null;
}
var YU = (r) => {
  var e, {
    yAxisId: t,
    className: n,
    width: i,
    label: s
  } = r, a = Ke(null), o = Ke(null), c = te(dE), l = At(), u = He(), d = "yAxis", f = te((b) => ds(b, d, t, l)), h = te((b) => WS(b, t)), g = te((b) => Qk(b, t)), m = te((b) => zS(b, d, t, l));
  if (EI(() => {
    var b;
    if (!(i !== "auto" || !h || yg(s) || /* @__PURE__ */ _r(s))) {
      var x = a.current, S = x == null || (b = x.tickRefs) === null || b === void 0 ? void 0 : b.current, {
        tickSize: A,
        tickMargin: T
      } = x.props, I = GU({
        ticks: S,
        label: o.current,
        labelGapWithTick: 5,
        tickSize: A,
        tickMargin: T
      });
      Math.round(h.width) !== Math.round(I) && u(tU({
        id: t,
        width: I
      }));
    }
  }, [
    a,
    a == null || (e = a.current) === null || e === void 0 || (e = e.tickRefs) === null || e === void 0 ? void 0 : e.current,
    // required to do re-calculation when using brush
    h == null ? void 0 : h.width,
    h,
    u,
    s,
    t,
    i
  ]), h == null || g == null)
    return null;
  var {
    dangerouslySetInnerHTML: p,
    ticks: v
  } = r, y = HU(r, KU);
  return /* @__PURE__ */ w.createElement(Gn, uf({}, y, {
    ref: a,
    labelRef: o,
    scale: f,
    x: g.x,
    y: g.y,
    width: h.width,
    height: h.height,
    className: ve("recharts-".concat(d, " ").concat(d), n),
    viewBox: c,
    ticks: m
  }));
}, XU = (r) => {
  var e, t, n, i, s;
  return /* @__PURE__ */ w.createElement(w.Fragment, null, /* @__PURE__ */ w.createElement(zU, {
    interval: (e = r.interval) !== null && e !== void 0 ? e : "preserveEnd",
    id: r.yAxisId,
    scale: r.scale,
    type: r.type,
    domain: r.domain,
    allowDataOverflow: r.allowDataOverflow,
    dataKey: r.dataKey,
    allowDuplicatedCategory: r.allowDuplicatedCategory,
    allowDecimals: r.allowDecimals,
    tickCount: r.tickCount,
    padding: r.padding,
    includeHidden: (t = r.includeHidden) !== null && t !== void 0 ? t : !1,
    reversed: r.reversed,
    ticks: r.ticks,
    width: r.width,
    orientation: r.orientation,
    mirror: r.mirror,
    hide: r.hide,
    unit: r.unit,
    name: r.name,
    angle: (n = r.angle) !== null && n !== void 0 ? n : 0,
    minTickGap: (i = r.minTickGap) !== null && i !== void 0 ? i : 5,
    tick: (s = r.tick) !== null && s !== void 0 ? s : !0,
    tickFormatter: r.tickFormatter
  }), /* @__PURE__ */ w.createElement(YU, r));
}, QU = {
  allowDataOverflow: zt.allowDataOverflow,
  allowDecimals: zt.allowDecimals,
  allowDuplicatedCategory: zt.allowDuplicatedCategory,
  hide: !1,
  mirror: zt.mirror,
  orientation: zt.orientation,
  padding: zt.padding,
  reversed: zt.reversed,
  scale: zt.scale,
  tickCount: zt.tickCount,
  type: zt.type,
  width: zt.width,
  yAxisId: 0
};
class Mi extends $n {
  render() {
    return /* @__PURE__ */ w.createElement(XU, this.props);
  }
}
xA(Mi, "displayName", "YAxis");
xA(Mi, "defaultProps", QU);
var Za = { exports: {} }, Ku = {};
/**
 * @license React
 * use-sync-external-store-with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var xy;
function ZU() {
  if (xy) return Ku;
  xy = 1;
  var r = Ct;
  function e(c, l) {
    return c === l && (c !== 0 || 1 / c === 1 / l) || c !== c && l !== l;
  }
  var t = typeof Object.is == "function" ? Object.is : e, n = r.useSyncExternalStore, i = r.useRef, s = r.useEffect, a = r.useMemo, o = r.useDebugValue;
  return Ku.useSyncExternalStoreWithSelector = function(c, l, u, d, f) {
    var h = i(null);
    if (h.current === null) {
      var g = { hasValue: !1, value: null };
      h.current = g;
    } else g = h.current;
    h = a(
      function() {
        function p(S) {
          if (!v) {
            if (v = !0, y = S, S = d(S), f !== void 0 && g.hasValue) {
              var A = g.value;
              if (f(A, S))
                return b = A;
            }
            return b = S;
          }
          if (A = b, t(y, S)) return A;
          var T = d(S);
          return f !== void 0 && f(A, T) ? (y = S, A) : (y = S, b = T);
        }
        var v = !1, y, b, x = u === void 0 ? null : u;
        return [
          function() {
            return p(l());
          },
          x === null ? void 0 : function() {
            return p(x());
          }
        ];
      },
      [l, u, d, f]
    );
    var m = n(c, h[0], h[1]);
    return s(
      function() {
        g.hasValue = !0, g.value = m;
      },
      [m]
    ), o(m), m;
  }, Ku;
}
var Vu = {};
/**
 * @license React
 * use-sync-external-store-with-selector.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Ey;
function JU() {
  return Ey || (Ey = 1, process.env.NODE_ENV !== "production" && function() {
    function r(c, l) {
      return c === l && (c !== 0 || 1 / c === 1 / l) || c !== c && l !== l;
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var e = Ct, t = typeof Object.is == "function" ? Object.is : r, n = e.useSyncExternalStore, i = e.useRef, s = e.useEffect, a = e.useMemo, o = e.useDebugValue;
    Vu.useSyncExternalStoreWithSelector = function(c, l, u, d, f) {
      var h = i(null);
      if (h.current === null) {
        var g = { hasValue: !1, value: null };
        h.current = g;
      } else g = h.current;
      h = a(
        function() {
          function p(S) {
            if (!v) {
              if (v = !0, y = S, S = d(S), f !== void 0 && g.hasValue) {
                var A = g.value;
                if (f(A, S))
                  return b = A;
              }
              return b = S;
            }
            if (A = b, t(y, S))
              return A;
            var T = d(S);
            return f !== void 0 && f(A, T) ? (y = S, A) : (y = S, b = T);
          }
          var v = !1, y, b, x = u === void 0 ? null : u;
          return [
            function() {
              return p(l());
            },
            x === null ? void 0 : function() {
              return p(x());
            }
          ];
        },
        [l, u, d, f]
      );
      var m = n(c, h[0], h[1]);
      return s(
        function() {
          g.hasValue = !0, g.value = m;
        },
        [m]
      ), o(m), m;
    }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }()), Vu;
}
var Sy;
function eG() {
  return Sy || (Sy = 1, process.env.NODE_ENV === "production" ? Za.exports = ZU() : Za.exports = JU()), Za.exports;
}
eG();
function tG(r) {
  r();
}
function rG() {
  let r = null, e = null;
  return {
    clear() {
      r = null, e = null;
    },
    notify() {
      tG(() => {
        let t = r;
        for (; t; )
          t.callback(), t = t.next;
      });
    },
    get() {
      const t = [];
      let n = r;
      for (; n; )
        t.push(n), n = n.next;
      return t;
    },
    subscribe(t) {
      let n = !0;
      const i = e = {
        callback: t,
        next: null,
        prev: e
      };
      return i.prev ? i.prev.next = i : r = i, function() {
        !n || r === null || (n = !1, i.next ? i.next.prev = i.prev : e = i.prev, i.prev ? i.prev.next = i.next : r = i.next);
      };
    }
  };
}
var Ty = {
  notify() {
  },
  get: () => []
};
function nG(r, e) {
  let t, n = Ty, i = 0, s = !1;
  function a(m) {
    u();
    const p = n.subscribe(m);
    let v = !1;
    return () => {
      v || (v = !0, p(), d());
    };
  }
  function o() {
    n.notify();
  }
  function c() {
    g.onStateChange && g.onStateChange();
  }
  function l() {
    return s;
  }
  function u() {
    i++, t || (t = r.subscribe(c), n = rG());
  }
  function d() {
    i--, t && i === 0 && (t(), t = void 0, n.clear(), n = Ty);
  }
  function f() {
    s || (s = !0, u());
  }
  function h() {
    s && (s = !1, d());
  }
  const g = {
    addNestedSub: a,
    notifyNestedSubs: o,
    handleChangeWrapper: c,
    isSubscribed: l,
    trySubscribe: f,
    tryUnsubscribe: h,
    getListeners: () => n
  };
  return g;
}
var iG = () => typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", sG = /* @__PURE__ */ iG(), aG = () => typeof navigator < "u" && navigator.product === "ReactNative", oG = /* @__PURE__ */ aG(), lG = () => sG || oG ? w.useLayoutEffect : w.useEffect, cG = /* @__PURE__ */ lG(), Wu = /* @__PURE__ */ Symbol.for("react-redux-context"), Hu = typeof globalThis < "u" ? globalThis : (
  /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */
  {}
);
function uG() {
  if (!w.createContext) return {};
  const r = Hu[Wu] ?? (Hu[Wu] = /* @__PURE__ */ new Map());
  let e = r.get(w.createContext);
  return e || (e = w.createContext(
    null
  ), process.env.NODE_ENV !== "production" && (e.displayName = "ReactRedux"), r.set(w.createContext, e)), e;
}
var dG = /* @__PURE__ */ uG();
function fG(r) {
  const { children: e, context: t, serverState: n, store: i } = r, s = w.useMemo(() => {
    const c = nG(i), l = {
      store: i,
      subscription: c,
      getServerState: n ? () => n : void 0
    };
    if (process.env.NODE_ENV === "production")
      return l;
    {
      const { identityFunctionCheck: u = "once", stabilityCheck: d = "once" } = r;
      return /* @__PURE__ */ Object.assign(l, {
        stabilityCheck: d,
        identityFunctionCheck: u
      });
    }
  }, [i, n]), a = w.useMemo(() => i.getState(), [i]);
  cG(() => {
    const { subscription: c } = s;
    return c.onStateChange = c.notifyNestedSubs, c.trySubscribe(), a !== i.getState() && c.notifyNestedSubs(), () => {
      c.tryUnsubscribe(), c.onStateChange = void 0;
    };
  }, [s, a]);
  const o = t || dG;
  return /* @__PURE__ */ w.createElement(o.Provider, { value: s }, e);
}
var hG = fG, gG = (r, e) => e, Ng = M([gG, Ee, dk, yt, cT, bn, eN, ut], sN), Fg = (r) => {
  var e = r.currentTarget.getBoundingClientRect(), t = e.width / r.currentTarget.offsetWidth, n = e.height / r.currentTarget.offsetHeight;
  return {
    /*
     * Here it's important to use:
     * - event.clientX and event.clientY to get the mouse position relative to the viewport, including scroll.
     * - pageX and pageY are not used because they are relative to the whole document, and ignore scroll.
     * - rect.left and rect.top are used to get the position of the chart relative to the viewport.
     * - offsetX and offsetY are not used because they are relative to the offset parent
     *  which may or may not be the same as the clientX and clientY, depending on the position of the chart in the DOM
     *  and surrounding element styles. CSS position: relative, absolute, fixed, will change the offset parent.
     * - scaleX and scaleY are necessary for when the chart element is scaled using CSS `transform: scale(N)`.
     */
    chartX: Math.round((r.clientX - e.left) / t),
    chartY: Math.round((r.clientY - e.top) / n)
  };
}, EA = mr("mouseClick"), SA = da();
SA.startListening({
  actionCreator: EA,
  effect: (r, e) => {
    var t = r.payload, n = Ng(e.getState(), Fg(t));
    (n == null ? void 0 : n.activeIndex) != null && e.dispatch(dM({
      activeIndex: n.activeIndex,
      activeDataKey: void 0,
      activeCoordinate: n.activeCoordinate
    }));
  }
});
var df = mr("mouseMove"), TA = da();
TA.startListening({
  actionCreator: df,
  effect: (r, e) => {
    var t = r.payload, n = e.getState(), i = cg(n, n.tooltip.settings.shared), s = Ng(n, Fg(t));
    i === "axis" && ((s == null ? void 0 : s.activeIndex) != null ? e.dispatch(rT({
      activeIndex: s.activeIndex,
      activeDataKey: void 0,
      activeCoordinate: s.activeCoordinate
    })) : e.dispatch(tT()));
  }
});
function mG(r, e) {
  return e instanceof HTMLElement ? "HTMLElement <".concat(e.tagName, ' class="').concat(e.className, '">') : e === window ? "global.window" : e;
}
var Ay = {
  accessibilityLayer: !0,
  barCategoryGap: "10%",
  barGap: 4,
  barSize: void 0,
  className: void 0,
  maxBarSize: void 0,
  stackOffset: "none",
  syncId: void 0,
  syncMethod: "index"
}, AA = xr({
  name: "rootProps",
  initialState: Ay,
  reducers: {
    updateOptions: (r, e) => {
      var t;
      r.accessibilityLayer = e.payload.accessibilityLayer, r.barCategoryGap = e.payload.barCategoryGap, r.barGap = (t = e.payload.barGap) !== null && t !== void 0 ? t : Ay.barGap, r.barSize = e.payload.barSize, r.maxBarSize = e.payload.maxBarSize, r.stackOffset = e.payload.stackOffset, r.syncId = e.payload.syncId, r.syncMethod = e.payload.syncMethod, r.className = e.payload.className;
    }
  }
}), pG = AA.reducer, {
  updateOptions: vG
} = AA.actions, wA = xr({
  name: "polarOptions",
  initialState: null,
  reducers: {
    updatePolarOptions: (r, e) => e.payload
  }
}), {
  updatePolarOptions: yG
} = wA.actions, bG = wA.reducer, IA = mr("keyDown"), PA = mr("focus"), $g = da();
$g.startListening({
  actionCreator: IA,
  effect: (r, e) => {
    var t = e.getState(), n = t.rootProps.accessibilityLayer !== !1;
    if (n) {
      var {
        keyboardInteraction: i
      } = t.tooltip, s = r.payload;
      if (!(s !== "ArrowRight" && s !== "ArrowLeft" && s !== "Enter")) {
        var a = Number(ug(i, xi(t))), o = bn(t);
        if (s === "Enter") {
          var c = Xo(t, "axis", "hover", String(i.index));
          e.dispatch(Qd({
            active: !i.active,
            activeIndex: i.index,
            activeDataKey: i.dataKey,
            activeCoordinate: c
          }));
          return;
        }
        var l = rM(t), u = l === "left-to-right" ? 1 : -1, d = s === "ArrowRight" ? 1 : -1, f = a + d * u;
        if (!(o == null || f >= o.length || f < 0)) {
          var h = Xo(t, "axis", "hover", String(f));
          e.dispatch(Qd({
            active: !0,
            activeIndex: f.toString(),
            activeDataKey: void 0,
            activeCoordinate: h
          }));
        }
      }
    }
  }
});
$g.startListening({
  actionCreator: PA,
  effect: (r, e) => {
    var t = e.getState(), n = t.rootProps.accessibilityLayer !== !1;
    if (n) {
      var {
        keyboardInteraction: i
      } = t.tooltip;
      if (!i.active && i.index == null) {
        var s = "0", a = Xo(t, "axis", "hover", String(s));
        e.dispatch(Qd({
          activeDataKey: void 0,
          active: !0,
          activeIndex: s,
          activeCoordinate: a
        }));
      }
    }
  }
});
var ur = mr("externalEvent"), _A = da();
_A.startListening({
  actionCreator: ur,
  effect: (r, e) => {
    if (r.payload.handler != null) {
      var t = e.getState(), n = {
        activeCoordinate: WM(t),
        activeDataKey: hT(t),
        activeIndex: cn(t),
        activeLabel: fT(t),
        activeTooltipIndex: cn(t),
        isTooltipActive: HM(t)
      };
      r.payload.handler(n, r.payload.reactEvent);
    }
  }
});
var xG = M([fs], (r) => r.tooltipItemPayloads), EG = M([xG, Ta, (r, e, t) => e, (r, e, t) => t], (r, e, t, n) => {
  var i = r.find((o) => o.settings.dataKey === n);
  if (i != null) {
    var {
      positions: s
    } = i;
    if (s != null) {
      var a = e(s, t);
      return a;
    }
  }
}), LA = mr("touchMove"), OA = da();
OA.startListening({
  actionCreator: LA,
  effect: (r, e) => {
    var t = r.payload, n = e.getState(), i = cg(n, n.tooltip.settings.shared);
    if (i === "axis") {
      var s = Ng(n, Fg({
        clientX: t.touches[0].clientX,
        clientY: t.touches[0].clientY,
        currentTarget: t.currentTarget
      }));
      (s == null ? void 0 : s.activeIndex) != null && e.dispatch(rT({
        activeIndex: s.activeIndex,
        activeDataKey: void 0,
        activeCoordinate: s.activeCoordinate
      }));
    } else if (i === "item") {
      var a, o = t.touches[0], c = document.elementFromPoint(o.clientX, o.clientY);
      if (!c || !c.getAttribute)
        return;
      var l = c.getAttribute(oh), u = (a = c.getAttribute(lh)) !== null && a !== void 0 ? a : void 0, d = EG(e.getState(), l, u);
      e.dispatch(eT({
        activeDataKey: u,
        activeIndex: l,
        activeCoordinate: d
      }));
    }
  }
});
var SG = kx({
  brush: fj,
  cartesianAxis: rU,
  chartData: EN,
  graphicalItems: i$,
  layout: e1,
  legend: j1,
  options: pN,
  polarAxis: GF,
  polarOptions: bG,
  referenceElements: bj,
  rootProps: pG,
  tooltip: fM
}), TG = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "Chart";
  return wL({
    reducer: SG,
    // redux-toolkit v1 types are unhappy with the preloadedState type. Remove the `as any` when bumping to v2
    preloadedState: e,
    // @ts-expect-error redux-toolkit v1 types are unhappy with the middleware array. Remove this comment when bumping to v2
    middleware: (n) => n({
      serializableCheck: !1
    }).concat([SA.middleware, TA.middleware, $g.middleware, _A.middleware, OA.middleware]),
    devTools: {
      serialize: {
        replacer: mG
      },
      name: "recharts-".concat(t)
    }
  });
};
function RA(r) {
  var {
    preloadedState: e,
    children: t,
    reduxStoreName: n
  } = r, i = At(), s = Ke(null);
  if (i)
    return t;
  s.current == null && (s.current = TG(e, n));
  var a = Zf;
  return /* @__PURE__ */ w.createElement(hG, {
    context: a,
    store: s.current
  }, t);
}
function DA(r) {
  var {
    layout: e,
    width: t,
    height: n,
    margin: i
  } = r, s = He(), a = At();
  return we(() => {
    a || (s(QL(e)), s(ZL({
      width: t,
      height: n
    })), s(XL(i)));
  }, [s, a, e, t, n, i]), null;
}
function CA(r) {
  var e = He();
  return we(() => {
    e(vG(r));
  }, [e, r]), null;
}
var AG = ["children"];
function wG(r, e) {
  if (r == null) return {};
  var t, n, i = IG(r, e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(r);
    for (n = 0; n < s.length; n++) t = s[n], e.indexOf(t) === -1 && {}.propertyIsEnumerable.call(r, t) && (i[t] = r[t]);
  }
  return i;
}
function IG(r, e) {
  if (r == null) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.indexOf(n) !== -1) continue;
    t[n] = r[n];
  }
  return t;
}
function il() {
  return il = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t) ({}).hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, il.apply(null, arguments);
}
var PG = {
  width: "100%",
  height: "100%"
}, _G = /* @__PURE__ */ Kt((r, e) => {
  var t = uh(), n = dh(), i = pE();
  if (!Hi(t) || !Hi(n))
    return null;
  var {
    children: s,
    otherAttributes: a,
    title: o,
    desc: c
  } = r, l, u;
  return typeof a.tabIndex == "number" ? l = a.tabIndex : l = i ? 0 : void 0, typeof a.role == "string" ? u = a.role : u = i ? "application" : void 0, /* @__PURE__ */ w.createElement(Uf, il({}, a, {
    title: o,
    desc: c,
    role: u,
    tabIndex: l,
    width: t,
    height: n,
    style: PG,
    ref: e
  }), s);
}), LG = (r) => {
  var {
    children: e
  } = r, t = te(Ll);
  if (!t)
    return null;
  var {
    width: n,
    height: i,
    y: s,
    x: a
  } = t;
  return /* @__PURE__ */ w.createElement(Uf, {
    width: n,
    height: i,
    x: a,
    y: s
  }, e);
}, wy = /* @__PURE__ */ Kt((r, e) => {
  var {
    children: t
  } = r, n = wG(r, AG), i = At();
  return i ? /* @__PURE__ */ w.createElement(LG, null, t) : /* @__PURE__ */ w.createElement(_G, il({
    ref: e
  }, n), t);
});
function OG() {
  var r = He(), [e, t] = _e(null), n = te(_1);
  return we(() => {
    if (e != null) {
      var i = e.getBoundingClientRect(), s = i.width / e.offsetWidth;
      Tt(s) && s !== n && r(JL(s));
    }
  }, [e, r, n]), t;
}
function Iy(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function RG(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Iy(Object(t), !0).forEach(function(n) {
      DG(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : Iy(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function DG(r, e, t) {
  return (e = CG(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function CG(r) {
  var e = kG(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function kG(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
var MG = /* @__PURE__ */ Kt((r, e) => {
  var {
    children: t,
    className: n,
    height: i,
    onClick: s,
    onContextMenu: a,
    onDoubleClick: o,
    onMouseDown: c,
    onMouseEnter: l,
    onMouseLeave: u,
    onMouseMove: d,
    onMouseUp: f,
    onTouchEnd: h,
    onTouchMove: g,
    onTouchStart: m,
    style: p,
    width: v
  } = r, y = He(), [b, x] = _e(null), [S, A] = _e(null);
  AN();
  var T = OG(), I = Se((N) => {
    T(N), typeof e == "function" && e(N), x(N), A(N);
  }, [T, e, x, A]), L = Se((N) => {
    y(EA(N)), y(ur({
      handler: s,
      reactEvent: N
    }));
  }, [y, s]), _ = Se((N) => {
    y(df(N)), y(ur({
      handler: l,
      reactEvent: N
    }));
  }, [y, l]), R = Se((N) => {
    y(tT()), y(ur({
      handler: u,
      reactEvent: N
    }));
  }, [y, u]), D = Se((N) => {
    y(df(N)), y(ur({
      handler: d,
      reactEvent: N
    }));
  }, [y, d]), F = Se(() => {
    y(PA());
  }, [y]), B = Se((N) => {
    y(IA(N.key));
  }, [y]), j = Se((N) => {
    y(ur({
      handler: a,
      reactEvent: N
    }));
  }, [y, a]), U = Se((N) => {
    y(ur({
      handler: o,
      reactEvent: N
    }));
  }, [y, o]), K = Se((N) => {
    y(ur({
      handler: c,
      reactEvent: N
    }));
  }, [y, c]), G = Se((N) => {
    y(ur({
      handler: f,
      reactEvent: N
    }));
  }, [y, f]), Y = Se((N) => {
    y(ur({
      handler: m,
      reactEvent: N
    }));
  }, [y, m]), Q = Se((N) => {
    y(LA(N)), y(ur({
      handler: g,
      reactEvent: N
    }));
  }, [y, g]), H = Se((N) => {
    y(ur({
      handler: h,
      reactEvent: N
    }));
  }, [y, h]);
  return /* @__PURE__ */ w.createElement(xT.Provider, {
    value: b
  }, /* @__PURE__ */ w.createElement(rx.Provider, {
    value: S
  }, /* @__PURE__ */ w.createElement("div", {
    className: ve("recharts-wrapper", n),
    style: RG({
      position: "relative",
      cursor: "default",
      width: v,
      height: i
    }, p),
    onClick: L,
    onContextMenu: j,
    onDoubleClick: U,
    onFocus: F,
    onKeyDown: B,
    onMouseDown: K,
    onMouseEnter: _,
    onMouseLeave: R,
    onMouseMove: D,
    onMouseUp: G,
    onTouchEnd: H,
    onTouchMove: Q,
    onTouchStart: Y,
    ref: I
  }, t)));
}), NG = ["children", "className", "width", "height", "style", "compact", "title", "desc"];
function FG(r, e) {
  if (r == null) return {};
  var t, n, i = $G(r, e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(r);
    for (n = 0; n < s.length; n++) t = s[n], e.indexOf(t) === -1 && {}.propertyIsEnumerable.call(r, t) && (i[t] = r[t]);
  }
  return i;
}
function $G(r, e) {
  if (r == null) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.indexOf(n) !== -1) continue;
    t[n] = r[n];
  }
  return t;
}
var kA = /* @__PURE__ */ Kt((r, e) => {
  var {
    children: t,
    className: n,
    width: i,
    height: s,
    style: a,
    compact: o,
    title: c,
    desc: l
  } = r, u = FG(r, NG), d = de(u, !1);
  return o ? /* @__PURE__ */ w.createElement(wy, {
    otherAttributes: d,
    title: c,
    desc: l
  }, t) : /* @__PURE__ */ w.createElement(MG, {
    className: n,
    style: a,
    width: i,
    height: s,
    onClick: r.onClick,
    onMouseLeave: r.onMouseLeave,
    onMouseEnter: r.onMouseEnter,
    onMouseMove: r.onMouseMove,
    onMouseDown: r.onMouseDown,
    onMouseUp: r.onMouseUp,
    onContextMenu: r.onContextMenu,
    onDoubleClick: r.onDoubleClick,
    onTouchStart: r.onTouchStart,
    onTouchMove: r.onTouchMove,
    onTouchEnd: r.onTouchEnd
  }, /* @__PURE__ */ w.createElement(wy, {
    otherAttributes: d,
    title: c,
    desc: l,
    ref: e
  }, /* @__PURE__ */ w.createElement(Ej, null, t)));
}), BG = ["width", "height"];
function ff() {
  return ff = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t) ({}).hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, ff.apply(null, arguments);
}
function jG(r, e) {
  if (r == null) return {};
  var t, n, i = UG(r, e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(r);
    for (n = 0; n < s.length; n++) t = s[n], e.indexOf(t) === -1 && {}.propertyIsEnumerable.call(r, t) && (i[t] = r[t]);
  }
  return i;
}
function UG(r, e) {
  if (r == null) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.indexOf(n) !== -1) continue;
    t[n] = r[n];
  }
  return t;
}
var GG = {
  top: 5,
  right: 5,
  bottom: 5,
  left: 5
}, KG = {
  accessibilityLayer: !0,
  layout: "horizontal",
  stackOffset: "none",
  barCategoryGap: "10%",
  barGap: 4,
  margin: GG,
  reverseStackOrder: !1,
  syncMethod: "index"
}, nc = /* @__PURE__ */ Kt(function(e, t) {
  var n, i = Vt(e.categoricalChartProps, KG), {
    width: s,
    height: a
  } = i, o = jG(i, BG);
  if (!Hi(s) || !Hi(a))
    return null;
  var {
    chartName: c,
    defaultTooltipEventType: l,
    validateTooltipEventTypes: u,
    tooltipPayloadSearcher: d,
    categoricalChartProps: f
  } = e, h = {
    chartName: c,
    defaultTooltipEventType: l,
    validateTooltipEventTypes: u,
    tooltipPayloadSearcher: d,
    eventEmitter: void 0
  };
  return /* @__PURE__ */ w.createElement(RA, {
    preloadedState: {
      options: h
    },
    reduxStoreName: (n = f.id) !== null && n !== void 0 ? n : c
  }, /* @__PURE__ */ w.createElement(YT, {
    chartData: f.data
  }), /* @__PURE__ */ w.createElement(DA, {
    width: s,
    height: a,
    layout: i.layout,
    margin: i.margin
  }), /* @__PURE__ */ w.createElement(CA, {
    accessibilityLayer: i.accessibilityLayer,
    barCategoryGap: i.barCategoryGap,
    maxBarSize: i.maxBarSize,
    stackOffset: i.stackOffset,
    barGap: i.barGap,
    barSize: i.barSize,
    syncId: i.syncId,
    syncMethod: i.syncMethod,
    className: i.className
  }), /* @__PURE__ */ w.createElement(kA, ff({}, o, {
    width: s,
    height: a,
    ref: t
  })));
}), VG = ["axis"], WG = /* @__PURE__ */ Kt((r, e) => /* @__PURE__ */ w.createElement(nc, {
  chartName: "LineChart",
  defaultTooltipEventType: "axis",
  validateTooltipEventTypes: VG,
  tooltipPayloadSearcher: Aa,
  categoricalChartProps: r,
  ref: e
})), HG = ["axis", "item"], qG = /* @__PURE__ */ Kt((r, e) => /* @__PURE__ */ w.createElement(nc, {
  chartName: "BarChart",
  defaultTooltipEventType: "axis",
  validateTooltipEventTypes: HG,
  tooltipPayloadSearcher: Aa,
  categoricalChartProps: r,
  ref: e
}));
function zG(r) {
  var e = He();
  return we(() => {
    e(yG(r));
  }, [e, r]), null;
}
var YG = ["width", "height", "layout"];
function hf() {
  return hf = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t) ({}).hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, hf.apply(null, arguments);
}
function XG(r, e) {
  if (r == null) return {};
  var t, n, i = QG(r, e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(r);
    for (n = 0; n < s.length; n++) t = s[n], e.indexOf(t) === -1 && {}.propertyIsEnumerable.call(r, t) && (i[t] = r[t]);
  }
  return i;
}
function QG(r, e) {
  if (r == null) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.indexOf(n) !== -1) continue;
    t[n] = r[n];
  }
  return t;
}
var ZG = {
  top: 5,
  right: 5,
  bottom: 5,
  left: 5
}, JG = {
  accessibilityLayer: !0,
  stackOffset: "none",
  barCategoryGap: "10%",
  barGap: 4,
  margin: ZG,
  reverseStackOrder: !1,
  syncMethod: "index",
  layout: "radial"
}, eK = /* @__PURE__ */ Kt(function(e, t) {
  var n, i = Vt(e.categoricalChartProps, JG), {
    width: s,
    height: a,
    layout: o
  } = i, c = XG(i, YG);
  if (!Hi(s) || !Hi(a))
    return null;
  var {
    chartName: l,
    defaultTooltipEventType: u,
    validateTooltipEventTypes: d,
    tooltipPayloadSearcher: f
  } = e, h = {
    chartName: l,
    defaultTooltipEventType: u,
    validateTooltipEventTypes: d,
    tooltipPayloadSearcher: f,
    eventEmitter: void 0
  };
  return /* @__PURE__ */ w.createElement(RA, {
    preloadedState: {
      options: h
    },
    reduxStoreName: (n = i.id) !== null && n !== void 0 ? n : l
  }, /* @__PURE__ */ w.createElement(YT, {
    chartData: i.data
  }), /* @__PURE__ */ w.createElement(DA, {
    width: s,
    height: a,
    layout: o,
    margin: i.margin
  }), /* @__PURE__ */ w.createElement(CA, {
    accessibilityLayer: i.accessibilityLayer,
    barCategoryGap: i.barCategoryGap,
    maxBarSize: i.maxBarSize,
    stackOffset: i.stackOffset,
    barGap: i.barGap,
    barSize: i.barSize,
    syncId: i.syncId,
    syncMethod: i.syncMethod,
    className: i.className
  }), /* @__PURE__ */ w.createElement(zG, {
    cx: i.cx,
    cy: i.cy,
    startAngle: i.startAngle,
    endAngle: i.endAngle,
    innerRadius: i.innerRadius,
    outerRadius: i.outerRadius
  }), /* @__PURE__ */ w.createElement(kA, hf({
    width: s,
    height: a
  }, c, {
    ref: t
  })));
}), tK = ["item"], rK = {
  layout: "centric",
  startAngle: 0,
  endAngle: 360,
  cx: "50%",
  cy: "50%",
  innerRadius: 0,
  outerRadius: "80%"
}, nK = /* @__PURE__ */ Kt((r, e) => {
  var t = Vt(r, rK);
  return /* @__PURE__ */ w.createElement(eK, {
    chartName: "PieChart",
    defaultTooltipEventType: "item",
    validateTooltipEventTypes: tK,
    tooltipPayloadSearcher: Aa,
    categoricalChartProps: t,
    ref: e
  });
}), iK = ["item"], sK = /* @__PURE__ */ Kt((r, e) => /* @__PURE__ */ w.createElement(nc, {
  chartName: "ScatterChart",
  defaultTooltipEventType: "item",
  validateTooltipEventTypes: iK,
  tooltipPayloadSearcher: Aa,
  categoricalChartProps: r,
  ref: e
})), aK = ["axis"], oK = /* @__PURE__ */ Kt((r, e) => /* @__PURE__ */ w.createElement(nc, {
  chartName: "AreaChart",
  defaultTooltipEventType: "axis",
  validateTooltipEventTypes: aK,
  tooltipPayloadSearcher: Aa,
  categoricalChartProps: r,
  ref: e
}));
const O4 = ({ data: r, type: e, updateInterval: t }) => {
  const [n, i] = _e(r);
  qb(() => {
    i(
      n.map((a) => ({
        ...a,
        value: a.value + Math.floor(Math.random() * 100)
      }))
    );
  }, t || null);
  const s = () => {
    switch (e) {
      case "line":
        return /* @__PURE__ */ P.jsxs(WG, { data: n, children: [
          /* @__PURE__ */ P.jsx(Cs, { strokeDasharray: "3 3" }),
          /* @__PURE__ */ P.jsx(ki, { dataKey: "name" }),
          /* @__PURE__ */ P.jsx(Mi, {}),
          /* @__PURE__ */ P.jsx(_s, {}),
          /* @__PURE__ */ P.jsx(Ks, {}),
          /* @__PURE__ */ P.jsx(Rg, { type: "monotone", dataKey: "value", stroke: "#8884d8" })
        ] });
      case "bar":
        return /* @__PURE__ */ P.jsxs(qG, { data: n, children: [
          /* @__PURE__ */ P.jsx(Cs, { strokeDasharray: "3 3" }),
          /* @__PURE__ */ P.jsx(ki, { dataKey: "name" }),
          /* @__PURE__ */ P.jsx(Mi, {}),
          /* @__PURE__ */ P.jsx(_s, {}),
          /* @__PURE__ */ P.jsx(Ks, {}),
          /* @__PURE__ */ P.jsx(Ig, { dataKey: "value", fill: "#8884d8" })
        ] });
      case "pie":
        return /* @__PURE__ */ P.jsxs(nK, { children: [
          /* @__PURE__ */ P.jsx(
            Ag,
            {
              data: n,
              dataKey: "value",
              nameKey: "name",
              fill: "#8884d8",
              isAnimationActive: !1
            }
          ),
          /* @__PURE__ */ P.jsx(_s, {})
        ] });
      case "scatter":
        return /* @__PURE__ */ P.jsxs(sK, { children: [
          /* @__PURE__ */ P.jsx(Cs, {}),
          /* @__PURE__ */ P.jsx(ki, { type: "category", dataKey: "name", name: "name" }),
          /* @__PURE__ */ P.jsx(Mi, { type: "number", dataKey: "value", name: "value" }),
          /* @__PURE__ */ P.jsx(_s, { cursor: { strokeDasharray: "3 3" } }),
          /* @__PURE__ */ P.jsx(Mg, { name: "A school", data: n, fill: "#8884d8" })
        ] });
      case "area":
        return /* @__PURE__ */ P.jsxs(oK, { data: n, children: [
          /* @__PURE__ */ P.jsx(Cs, { strokeDasharray: "3 3" }),
          /* @__PURE__ */ P.jsx(ki, { dataKey: "name" }),
          /* @__PURE__ */ P.jsx(Mi, {}),
          /* @__PURE__ */ P.jsx(_s, {}),
          /* @__PURE__ */ P.jsx(Dg, { type: "monotone", dataKey: "value", stroke: "#8884d8", fill: "#8884d8" })
        ] });
      default:
        throw new Error(`Invalid chart type: ${e}`);
    }
  };
  return /* @__PURE__ */ P.jsx(UN, { width: "100%", height: 300, children: s() });
}, X = Number.isFinite || function(r) {
  return typeof r == "number" && isFinite(r);
}, lK = Number.isSafeInteger || function(r) {
  return typeof r == "number" && Math.abs(r) <= cK;
}, cK = Number.MAX_SAFE_INTEGER || 9007199254740991;
let ne = /* @__PURE__ */ function(r) {
  return r.NETWORK_ERROR = "networkError", r.MEDIA_ERROR = "mediaError", r.KEY_SYSTEM_ERROR = "keySystemError", r.MUX_ERROR = "muxError", r.OTHER_ERROR = "otherError", r;
}({}), k = /* @__PURE__ */ function(r) {
  return r.KEY_SYSTEM_NO_KEYS = "keySystemNoKeys", r.KEY_SYSTEM_NO_ACCESS = "keySystemNoAccess", r.KEY_SYSTEM_NO_SESSION = "keySystemNoSession", r.KEY_SYSTEM_NO_CONFIGURED_LICENSE = "keySystemNoConfiguredLicense", r.KEY_SYSTEM_LICENSE_REQUEST_FAILED = "keySystemLicenseRequestFailed", r.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED = "keySystemServerCertificateRequestFailed", r.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED = "keySystemServerCertificateUpdateFailed", r.KEY_SYSTEM_SESSION_UPDATE_FAILED = "keySystemSessionUpdateFailed", r.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED = "keySystemStatusOutputRestricted", r.KEY_SYSTEM_STATUS_INTERNAL_ERROR = "keySystemStatusInternalError", r.KEY_SYSTEM_DESTROY_MEDIA_KEYS_ERROR = "keySystemDestroyMediaKeysError", r.KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR = "keySystemDestroyCloseSessionError", r.KEY_SYSTEM_DESTROY_REMOVE_SESSION_ERROR = "keySystemDestroyRemoveSessionError", r.MANIFEST_LOAD_ERROR = "manifestLoadError", r.MANIFEST_LOAD_TIMEOUT = "manifestLoadTimeOut", r.MANIFEST_PARSING_ERROR = "manifestParsingError", r.MANIFEST_INCOMPATIBLE_CODECS_ERROR = "manifestIncompatibleCodecsError", r.LEVEL_EMPTY_ERROR = "levelEmptyError", r.LEVEL_LOAD_ERROR = "levelLoadError", r.LEVEL_LOAD_TIMEOUT = "levelLoadTimeOut", r.LEVEL_PARSING_ERROR = "levelParsingError", r.LEVEL_SWITCH_ERROR = "levelSwitchError", r.AUDIO_TRACK_LOAD_ERROR = "audioTrackLoadError", r.AUDIO_TRACK_LOAD_TIMEOUT = "audioTrackLoadTimeOut", r.SUBTITLE_LOAD_ERROR = "subtitleTrackLoadError", r.SUBTITLE_TRACK_LOAD_TIMEOUT = "subtitleTrackLoadTimeOut", r.FRAG_LOAD_ERROR = "fragLoadError", r.FRAG_LOAD_TIMEOUT = "fragLoadTimeOut", r.FRAG_DECRYPT_ERROR = "fragDecryptError", r.FRAG_PARSING_ERROR = "fragParsingError", r.FRAG_GAP = "fragGap", r.REMUX_ALLOC_ERROR = "remuxAllocError", r.KEY_LOAD_ERROR = "keyLoadError", r.KEY_LOAD_TIMEOUT = "keyLoadTimeOut", r.BUFFER_ADD_CODEC_ERROR = "bufferAddCodecError", r.BUFFER_INCOMPATIBLE_CODECS_ERROR = "bufferIncompatibleCodecsError", r.BUFFER_APPEND_ERROR = "bufferAppendError", r.BUFFER_APPENDING_ERROR = "bufferAppendingError", r.BUFFER_STALLED_ERROR = "bufferStalledError", r.BUFFER_FULL_ERROR = "bufferFullError", r.BUFFER_SEEK_OVER_HOLE = "bufferSeekOverHole", r.BUFFER_NUDGE_ON_STALL = "bufferNudgeOnStall", r.ASSET_LIST_LOAD_ERROR = "assetListLoadError", r.ASSET_LIST_LOAD_TIMEOUT = "assetListLoadTimeout", r.ASSET_LIST_PARSING_ERROR = "assetListParsingError", r.INTERSTITIAL_ASSET_ITEM_ERROR = "interstitialAssetItemError", r.INTERNAL_EXCEPTION = "internalException", r.INTERNAL_ABORTED = "aborted", r.ATTACH_MEDIA_ERROR = "attachMediaError", r.UNKNOWN = "unknown", r;
}({}), E = /* @__PURE__ */ function(r) {
  return r.MEDIA_ATTACHING = "hlsMediaAttaching", r.MEDIA_ATTACHED = "hlsMediaAttached", r.MEDIA_DETACHING = "hlsMediaDetaching", r.MEDIA_DETACHED = "hlsMediaDetached", r.MEDIA_ENDED = "hlsMediaEnded", r.STALL_RESOLVED = "hlsStallResolved", r.BUFFER_RESET = "hlsBufferReset", r.BUFFER_CODECS = "hlsBufferCodecs", r.BUFFER_CREATED = "hlsBufferCreated", r.BUFFER_APPENDING = "hlsBufferAppending", r.BUFFER_APPENDED = "hlsBufferAppended", r.BUFFER_EOS = "hlsBufferEos", r.BUFFERED_TO_END = "hlsBufferedToEnd", r.BUFFER_FLUSHING = "hlsBufferFlushing", r.BUFFER_FLUSHED = "hlsBufferFlushed", r.MANIFEST_LOADING = "hlsManifestLoading", r.MANIFEST_LOADED = "hlsManifestLoaded", r.MANIFEST_PARSED = "hlsManifestParsed", r.LEVEL_SWITCHING = "hlsLevelSwitching", r.LEVEL_SWITCHED = "hlsLevelSwitched", r.LEVEL_LOADING = "hlsLevelLoading", r.LEVEL_LOADED = "hlsLevelLoaded", r.LEVEL_UPDATED = "hlsLevelUpdated", r.LEVEL_PTS_UPDATED = "hlsLevelPtsUpdated", r.LEVELS_UPDATED = "hlsLevelsUpdated", r.AUDIO_TRACKS_UPDATED = "hlsAudioTracksUpdated", r.AUDIO_TRACK_SWITCHING = "hlsAudioTrackSwitching", r.AUDIO_TRACK_SWITCHED = "hlsAudioTrackSwitched", r.AUDIO_TRACK_LOADING = "hlsAudioTrackLoading", r.AUDIO_TRACK_LOADED = "hlsAudioTrackLoaded", r.AUDIO_TRACK_UPDATED = "hlsAudioTrackUpdated", r.SUBTITLE_TRACKS_UPDATED = "hlsSubtitleTracksUpdated", r.SUBTITLE_TRACKS_CLEARED = "hlsSubtitleTracksCleared", r.SUBTITLE_TRACK_SWITCH = "hlsSubtitleTrackSwitch", r.SUBTITLE_TRACK_LOADING = "hlsSubtitleTrackLoading", r.SUBTITLE_TRACK_LOADED = "hlsSubtitleTrackLoaded", r.SUBTITLE_TRACK_UPDATED = "hlsSubtitleTrackUpdated", r.SUBTITLE_FRAG_PROCESSED = "hlsSubtitleFragProcessed", r.CUES_PARSED = "hlsCuesParsed", r.NON_NATIVE_TEXT_TRACKS_FOUND = "hlsNonNativeTextTracksFound", r.INIT_PTS_FOUND = "hlsInitPtsFound", r.FRAG_LOADING = "hlsFragLoading", r.FRAG_LOAD_EMERGENCY_ABORTED = "hlsFragLoadEmergencyAborted", r.FRAG_LOADED = "hlsFragLoaded", r.FRAG_DECRYPTED = "hlsFragDecrypted", r.FRAG_PARSING_INIT_SEGMENT = "hlsFragParsingInitSegment", r.FRAG_PARSING_USERDATA = "hlsFragParsingUserdata", r.FRAG_PARSING_METADATA = "hlsFragParsingMetadata", r.FRAG_PARSED = "hlsFragParsed", r.FRAG_BUFFERED = "hlsFragBuffered", r.FRAG_CHANGED = "hlsFragChanged", r.FPS_DROP = "hlsFpsDrop", r.FPS_DROP_LEVEL_CAPPING = "hlsFpsDropLevelCapping", r.MAX_AUTO_LEVEL_UPDATED = "hlsMaxAutoLevelUpdated", r.ERROR = "hlsError", r.DESTROYING = "hlsDestroying", r.KEY_LOADING = "hlsKeyLoading", r.KEY_LOADED = "hlsKeyLoaded", r.LIVE_BACK_BUFFER_REACHED = "hlsLiveBackBufferReached", r.BACK_BUFFER_REACHED = "hlsBackBufferReached", r.STEERING_MANIFEST_LOADED = "hlsSteeringManifestLoaded", r.ASSET_LIST_LOADING = "hlsAssetListLoading", r.ASSET_LIST_LOADED = "hlsAssetListLoaded", r.INTERSTITIALS_UPDATED = "hlsInterstitialsUpdated", r.INTERSTITIALS_BUFFERED_TO_BOUNDARY = "hlsInterstitialsBufferedToBoundary", r.INTERSTITIAL_ASSET_PLAYER_CREATED = "hlsInterstitialAssetPlayerCreated", r.INTERSTITIAL_STARTED = "hlsInterstitialStarted", r.INTERSTITIAL_ASSET_STARTED = "hlsInterstitialAssetStarted", r.INTERSTITIAL_ASSET_ENDED = "hlsInterstitialAssetEnded", r.INTERSTITIAL_ASSET_ERROR = "hlsInterstitialAssetError", r.INTERSTITIAL_ENDED = "hlsInterstitialEnded", r.INTERSTITIALS_PRIMARY_RESUMED = "hlsInterstitialsPrimaryResumed", r.PLAYOUT_LIMIT_REACHED = "hlsPlayoutLimitReached", r.EVENT_CUE_ENTER = "hlsEventCueEnter", r;
}({});
var me = {
  MANIFEST: "manifest",
  LEVEL: "level",
  AUDIO_TRACK: "audioTrack",
  SUBTITLE_TRACK: "subtitleTrack"
}, ee = {
  MAIN: "main",
  AUDIO: "audio",
  SUBTITLE: "subtitle"
};
class Pi {
  //  About half of the estimated value will be from the last |halfLife| samples by weight.
  constructor(e, t = 0, n = 0) {
    this.halfLife = void 0, this.alpha_ = void 0, this.estimate_ = void 0, this.totalWeight_ = void 0, this.halfLife = e, this.alpha_ = e ? Math.exp(Math.log(0.5) / e) : 0, this.estimate_ = t, this.totalWeight_ = n;
  }
  sample(e, t) {
    const n = Math.pow(this.alpha_, e);
    this.estimate_ = t * (1 - n) + n * this.estimate_, this.totalWeight_ += e;
  }
  getTotalWeight() {
    return this.totalWeight_;
  }
  getEstimate() {
    if (this.alpha_) {
      const e = 1 - Math.pow(this.alpha_, this.totalWeight_);
      if (e)
        return this.estimate_ / e;
    }
    return this.estimate_;
  }
}
class uK {
  constructor(e, t, n, i = 100) {
    this.defaultEstimate_ = void 0, this.minWeight_ = void 0, this.minDelayMs_ = void 0, this.slow_ = void 0, this.fast_ = void 0, this.defaultTTFB_ = void 0, this.ttfb_ = void 0, this.defaultEstimate_ = n, this.minWeight_ = 1e-3, this.minDelayMs_ = 50, this.slow_ = new Pi(e), this.fast_ = new Pi(t), this.defaultTTFB_ = i, this.ttfb_ = new Pi(e);
  }
  update(e, t) {
    const {
      slow_: n,
      fast_: i,
      ttfb_: s
    } = this;
    n.halfLife !== e && (this.slow_ = new Pi(e, n.getEstimate(), n.getTotalWeight())), i.halfLife !== t && (this.fast_ = new Pi(t, i.getEstimate(), i.getTotalWeight())), s.halfLife !== e && (this.ttfb_ = new Pi(e, s.getEstimate(), s.getTotalWeight()));
  }
  sample(e, t) {
    e = Math.max(e, this.minDelayMs_);
    const n = 8 * t, i = e / 1e3, s = n / i;
    this.fast_.sample(i, s), this.slow_.sample(i, s);
  }
  sampleTTFB(e) {
    const t = e / 1e3, n = Math.sqrt(2) * Math.exp(-Math.pow(t, 2) / 2);
    this.ttfb_.sample(n, Math.max(e, 5));
  }
  canEstimate() {
    return this.fast_.getTotalWeight() >= this.minWeight_;
  }
  getEstimate() {
    return this.canEstimate() ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate()) : this.defaultEstimate_;
  }
  getEstimateTTFB() {
    return this.ttfb_.getTotalWeight() >= this.minWeight_ ? this.ttfb_.getEstimate() : this.defaultTTFB_;
  }
  get defaultEstimate() {
    return this.defaultEstimate_;
  }
  destroy() {
  }
}
function dK(r, e, t) {
  return (e = hK(e)) in r ? Object.defineProperty(r, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : r[e] = t, r;
}
function Ce() {
  return Ce = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t) ({}).hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, Ce.apply(null, arguments);
}
function Py(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function Ne(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Py(Object(t), !0).forEach(function(n) {
      dK(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : Py(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function fK(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function hK(r) {
  var e = fK(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
class Or {
  constructor(e, t) {
    this.trace = void 0, this.debug = void 0, this.log = void 0, this.warn = void 0, this.info = void 0, this.error = void 0;
    const n = `[${e}]:`;
    this.trace = _n, this.debug = t.debug.bind(null, n), this.log = t.log.bind(null, n), this.warn = t.warn.bind(null, n), this.info = t.info.bind(null, n), this.error = t.error.bind(null, n);
  }
}
const _n = function() {
}, gK = {
  trace: _n,
  debug: _n,
  log: _n,
  warn: _n,
  info: _n,
  error: _n
};
function gf() {
  return Ce({}, gK);
}
function mK(r, e) {
  const t = self.console[r];
  return t ? t.bind(self.console, `${e ? "[" + e + "] " : ""}[${r}] >`) : _n;
}
function _y(r, e, t) {
  return e[r] ? e[r].bind(e) : mK(r, t);
}
const mf = gf();
function pK(r, e, t) {
  const n = gf();
  if (typeof console == "object" && r === !0 || typeof r == "object") {
    const i = [
      // Remove out from list here to hard-disable a log-level
      // 'trace',
      "debug",
      "log",
      "info",
      "warn",
      "error"
    ];
    i.forEach((s) => {
      n[s] = _y(s, r, t);
    });
    try {
      n.log(`Debug logs enabled for "${e}" in hls.js version 1.6.7`);
    } catch {
      return gf();
    }
    i.forEach((s) => {
      mf[s] = _y(s, r);
    });
  } else
    Ce(mf, n);
  return n;
}
const Ae = mf;
function Nn(r = !0) {
  return typeof self > "u" ? void 0 : (r || !self.MediaSource) && self.ManagedMediaSource || self.MediaSource || self.WebKitMediaSource;
}
function vK(r) {
  return typeof self < "u" && r === self.ManagedMediaSource;
}
function MA(r, e) {
  const t = Object.keys(r), n = Object.keys(e), i = t.length, s = n.length;
  return !i || !s || i === s && !t.some((a) => n.indexOf(a) === -1);
}
function tr(r, e = !1) {
  if (typeof TextDecoder < "u") {
    const l = new TextDecoder("utf-8").decode(r);
    if (e) {
      const u = l.indexOf("\0");
      return u !== -1 ? l.substring(0, u) : l;
    }
    return l.replace(/\0/g, "");
  }
  const t = r.length;
  let n, i, s, a = "", o = 0;
  for (; o < t; ) {
    if (n = r[o++], n === 0 && e)
      return a;
    if (n === 0 || n === 3)
      continue;
    switch (n >> 4) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
        a += String.fromCharCode(n);
        break;
      case 12:
      case 13:
        i = r[o++], a += String.fromCharCode((n & 31) << 6 | i & 63);
        break;
      case 14:
        i = r[o++], s = r[o++], a += String.fromCharCode((n & 15) << 12 | (i & 63) << 6 | (s & 63) << 0);
        break;
    }
  }
  return a;
}
const Xn = {
  hexDump: function(r) {
    let e = "";
    for (let t = 0; t < r.length; t++) {
      let n = r[t].toString(16);
      n.length < 2 && (n = "0" + n), e += n;
    }
    return e;
  }
};
function NA(r) {
  return Uint8Array.from(r.replace(/^0x/, "").replace(/([\da-fA-F]{2}) ?/g, "0x$1 ").replace(/ +$/, "").split(" ")).buffer;
}
function yK(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
var qu = { exports: {} }, Ly;
function bK() {
  return Ly || (Ly = 1, function(r, e) {
    (function(t) {
      var n = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/, i = /^(?=([^\/?#]*))\1([^]*)$/, s = /(?:\/|^)\.(?=\/)/g, a = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g, o = {
        // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
        // E.g
        // With opts.alwaysNormalize = false (default, spec compliant)
        // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
        // With opts.alwaysNormalize = true (not spec compliant)
        // http://a.com/b/cd + /e/f/../g => http://a.com/e/g
        buildAbsoluteURL: function(c, l, u) {
          if (u = u || {}, c = c.trim(), l = l.trim(), !l) {
            if (!u.alwaysNormalize)
              return c;
            var d = o.parseURL(c);
            if (!d)
              throw new Error("Error trying to parse base URL.");
            return d.path = o.normalizePath(
              d.path
            ), o.buildURLFromParts(d);
          }
          var f = o.parseURL(l);
          if (!f)
            throw new Error("Error trying to parse relative URL.");
          if (f.scheme)
            return u.alwaysNormalize ? (f.path = o.normalizePath(f.path), o.buildURLFromParts(f)) : l;
          var h = o.parseURL(c);
          if (!h)
            throw new Error("Error trying to parse base URL.");
          if (!h.netLoc && h.path && h.path[0] !== "/") {
            var g = i.exec(h.path);
            h.netLoc = g[1], h.path = g[2];
          }
          h.netLoc && !h.path && (h.path = "/");
          var m = {
            // 2c) Otherwise, the embedded URL inherits the scheme of
            // the base URL.
            scheme: h.scheme,
            netLoc: f.netLoc,
            path: null,
            params: f.params,
            query: f.query,
            fragment: f.fragment
          };
          if (!f.netLoc && (m.netLoc = h.netLoc, f.path[0] !== "/"))
            if (!f.path)
              m.path = h.path, f.params || (m.params = h.params, f.query || (m.query = h.query));
            else {
              var p = h.path, v = p.substring(0, p.lastIndexOf("/") + 1) + f.path;
              m.path = o.normalizePath(v);
            }
          return m.path === null && (m.path = u.alwaysNormalize ? o.normalizePath(f.path) : f.path), o.buildURLFromParts(m);
        },
        parseURL: function(c) {
          var l = n.exec(c);
          return l ? {
            scheme: l[1] || "",
            netLoc: l[2] || "",
            path: l[3] || "",
            params: l[4] || "",
            query: l[5] || "",
            fragment: l[6] || ""
          } : null;
        },
        normalizePath: function(c) {
          for (c = c.split("").reverse().join("").replace(s, ""); c.length !== (c = c.replace(a, "")).length; )
            ;
          return c.split("").reverse().join("");
        },
        buildURLFromParts: function(c) {
          return c.scheme + c.netLoc + c.path + c.params + c.query + c.fragment;
        }
      };
      r.exports = o;
    })();
  }(qu)), qu.exports;
}
var Bg = bK();
class jg {
  constructor() {
    this.aborted = !1, this.loaded = 0, this.retry = 0, this.total = 0, this.chunkCount = 0, this.bwEstimate = 0, this.loading = {
      start: 0,
      first: 0,
      end: 0
    }, this.parsing = {
      start: 0,
      end: 0
    }, this.buffering = {
      start: 0,
      first: 0,
      end: 0
    };
  }
}
var je = {
  AUDIO: "audio",
  VIDEO: "video",
  AUDIOVIDEO: "audiovideo"
};
class FA {
  constructor(e) {
    this._byteRange = null, this._url = null, this._stats = null, this._streams = null, this.base = void 0, this.relurl = void 0, typeof e == "string" && (e = {
      url: e
    }), this.base = e, EK(this, "stats");
  }
  // setByteRange converts a EXT-X-BYTERANGE attribute into a two element array
  setByteRange(e, t) {
    const n = e.split("@", 2);
    let i;
    n.length === 1 ? i = (t == null ? void 0 : t.byteRangeEndOffset) || 0 : i = parseInt(n[1]), this._byteRange = [i, parseInt(n[0]) + i];
  }
  get baseurl() {
    return this.base.url;
  }
  get byteRange() {
    return this._byteRange === null ? [] : this._byteRange;
  }
  get byteRangeStartOffset() {
    return this.byteRange[0];
  }
  get byteRangeEndOffset() {
    return this.byteRange[1];
  }
  get elementaryStreams() {
    return this._streams === null && (this._streams = {
      [je.AUDIO]: null,
      [je.VIDEO]: null,
      [je.AUDIOVIDEO]: null
    }), this._streams;
  }
  set elementaryStreams(e) {
    this._streams = e;
  }
  get hasStats() {
    return this._stats !== null;
  }
  get hasStreams() {
    return this._streams !== null;
  }
  get stats() {
    return this._stats === null && (this._stats = new jg()), this._stats;
  }
  set stats(e) {
    this._stats = e;
  }
  get url() {
    return !this._url && this.baseurl && this.relurl && (this._url = Bg.buildAbsoluteURL(this.baseurl, this.relurl, {
      alwaysNormalize: !0
    })), this._url || "";
  }
  set url(e) {
    this._url = e;
  }
  clearElementaryStreamInfo() {
    const {
      elementaryStreams: e
    } = this;
    e[je.AUDIO] = null, e[je.VIDEO] = null, e[je.AUDIOVIDEO] = null;
  }
}
function it(r) {
  return r.sn !== "initSegment";
}
class zu extends FA {
  constructor(e, t) {
    super(t), this._decryptdata = null, this._programDateTime = null, this._ref = null, this._bitrate = void 0, this.rawProgramDateTime = null, this.tagList = [], this.duration = 0, this.sn = 0, this.levelkeys = void 0, this.type = void 0, this.loader = null, this.keyLoader = null, this.level = -1, this.cc = 0, this.startPTS = void 0, this.endPTS = void 0, this.startDTS = void 0, this.endDTS = void 0, this.start = 0, this.playlistOffset = 0, this.deltaPTS = void 0, this.maxStartPTS = void 0, this.minEndPTS = void 0, this.data = void 0, this.bitrateTest = !1, this.title = null, this.initSegment = null, this.endList = void 0, this.gap = void 0, this.urlId = 0, this.type = e;
  }
  get byteLength() {
    if (this.hasStats) {
      const e = this.stats.total;
      if (e)
        return e;
    }
    if (this.byteRange) {
      const e = this.byteRange[0], t = this.byteRange[1];
      if (X(e) && X(t))
        return t - e;
    }
    return null;
  }
  get bitrate() {
    return this.byteLength ? this.byteLength * 8 / this.duration : this._bitrate ? this._bitrate : null;
  }
  set bitrate(e) {
    this._bitrate = e;
  }
  get decryptdata() {
    const {
      levelkeys: e
    } = this;
    if (!e && !this._decryptdata)
      return null;
    if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) {
      const t = this.levelkeys.identity;
      if (t)
        this._decryptdata = t.getDecryptData(this.sn);
      else {
        const n = Object.keys(this.levelkeys);
        if (n.length === 1)
          return this._decryptdata = this.levelkeys[n[0]].getDecryptData(this.sn);
      }
    }
    return this._decryptdata;
  }
  get end() {
    return this.start + this.duration;
  }
  get endProgramDateTime() {
    if (this.programDateTime === null)
      return null;
    const e = X(this.duration) ? this.duration : 0;
    return this.programDateTime + e * 1e3;
  }
  get encrypted() {
    var e;
    if ((e = this._decryptdata) != null && e.encrypted)
      return !0;
    if (this.levelkeys) {
      const t = Object.keys(this.levelkeys), n = t.length;
      if (n > 1 || n === 1 && this.levelkeys[t[0]].encrypted)
        return !0;
    }
    return !1;
  }
  get programDateTime() {
    return this._programDateTime === null && this.rawProgramDateTime && (this.programDateTime = Date.parse(this.rawProgramDateTime)), this._programDateTime;
  }
  set programDateTime(e) {
    if (!X(e)) {
      this._programDateTime = this.rawProgramDateTime = null;
      return;
    }
    this._programDateTime = e;
  }
  get ref() {
    return it(this) ? (this._ref || (this._ref = {
      base: this.base,
      start: this.start,
      duration: this.duration,
      sn: this.sn,
      programDateTime: this.programDateTime
    }), this._ref) : null;
  }
  addStart(e) {
    this.setStart(this.start + e);
  }
  setStart(e) {
    this.start = e, this._ref && (this._ref.start = e);
  }
  setDuration(e) {
    this.duration = e, this._ref && (this._ref.duration = e);
  }
  setKeyFormat(e) {
    if (this.levelkeys) {
      const t = this.levelkeys[e];
      t && !this._decryptdata && (this._decryptdata = t.getDecryptData(this.sn));
    }
  }
  abortRequests() {
    var e, t;
    (e = this.loader) == null || e.abort(), (t = this.keyLoader) == null || t.abort();
  }
  setElementaryStreamInfo(e, t, n, i, s, a = !1) {
    const {
      elementaryStreams: o
    } = this, c = o[e];
    if (!c) {
      o[e] = {
        startPTS: t,
        endPTS: n,
        startDTS: i,
        endDTS: s,
        partial: a
      };
      return;
    }
    c.startPTS = Math.min(c.startPTS, t), c.endPTS = Math.max(c.endPTS, n), c.startDTS = Math.min(c.startDTS, i), c.endDTS = Math.max(c.endDTS, s);
  }
}
class xK extends FA {
  constructor(e, t, n, i, s) {
    super(n), this.fragOffset = 0, this.duration = 0, this.gap = !1, this.independent = !1, this.relurl = void 0, this.fragment = void 0, this.index = void 0, this.duration = e.decimalFloatingPoint("DURATION"), this.gap = e.bool("GAP"), this.independent = e.bool("INDEPENDENT"), this.relurl = e.enumeratedString("URI"), this.fragment = t, this.index = i;
    const a = e.enumeratedString("BYTERANGE");
    a && this.setByteRange(a, s), s && (this.fragOffset = s.fragOffset + s.duration);
  }
  get start() {
    return this.fragment.start + this.fragOffset;
  }
  get end() {
    return this.start + this.duration;
  }
  get loaded() {
    const {
      elementaryStreams: e
    } = this;
    return !!(e.audio || e.video || e.audiovideo);
  }
}
function $A(r, e) {
  const t = Object.getPrototypeOf(r);
  if (t) {
    const n = Object.getOwnPropertyDescriptor(t, e);
    return n || $A(t, e);
  }
}
function EK(r, e) {
  const t = $A(r, e);
  t && (t.enumerable = !0, Object.defineProperty(r, e, t));
}
const Oy = Math.pow(2, 32) - 1, SK = [].push, BA = {
  video: 1,
  audio: 2,
  id3: 3,
  text: 4
};
function gt(r) {
  return String.fromCharCode.apply(null, r);
}
function jA(r, e) {
  const t = r[e] << 8 | r[e + 1];
  return t < 0 ? 65536 + t : t;
}
function ae(r, e) {
  const t = UA(r, e);
  return t < 0 ? 4294967296 + t : t;
}
function Ry(r, e) {
  let t = ae(r, e);
  return t *= Math.pow(2, 32), t += ae(r, e + 4), t;
}
function UA(r, e) {
  return r[e] << 24 | r[e + 1] << 16 | r[e + 2] << 8 | r[e + 3];
}
function TK(r) {
  const e = r.byteLength;
  for (let t = 0; t < e; ) {
    const n = ae(r, t);
    if (n > 8 && r[t + 4] === 109 && r[t + 5] === 111 && r[t + 6] === 111 && r[t + 7] === 102)
      return !0;
    t = n > 1 ? t + n : e;
  }
  return !1;
}
function ge(r, e) {
  const t = [];
  if (!e.length)
    return t;
  const n = r.byteLength;
  for (let i = 0; i < n; ) {
    const s = ae(r, i), a = gt(r.subarray(i + 4, i + 8)), o = s > 1 ? i + s : n;
    if (a === e[0])
      if (e.length === 1)
        t.push(r.subarray(i + 8, o));
      else {
        const c = ge(r.subarray(i + 8, o), e.slice(1));
        c.length && SK.apply(t, c);
      }
    i = o;
  }
  return t;
}
function AK(r) {
  const e = [], t = r[0];
  let n = 8;
  const i = ae(r, n);
  n += 4;
  let s = 0, a = 0;
  t === 0 ? (s = ae(r, n), a = ae(r, n + 4), n += 8) : (s = Ry(r, n), a = Ry(r, n + 8), n += 16), n += 2;
  let o = r.length + a;
  const c = jA(r, n);
  n += 2;
  for (let l = 0; l < c; l++) {
    let u = n;
    const d = ae(r, u);
    u += 4;
    const f = d & 2147483647;
    if ((d & 2147483648) >>> 31 === 1)
      return Ae.warn("SIDX has hierarchical references (not supported)"), null;
    const g = ae(r, u);
    u += 4, e.push({
      referenceSize: f,
      subsegmentDuration: g,
      // unscaled
      info: {
        duration: g / i,
        start: o,
        end: o + f - 1
      }
    }), o += f, u += 4, n = u;
  }
  return {
    earliestPresentationTime: s,
    timescale: i,
    version: t,
    referencesCount: c,
    references: e
  };
}
function GA(r) {
  const e = [], t = ge(r, ["moov", "trak"]);
  for (let i = 0; i < t.length; i++) {
    const s = t[i], a = ge(s, ["tkhd"])[0];
    if (a) {
      let o = a[0];
      const c = ae(a, o === 0 ? 12 : 20), l = ge(s, ["mdia", "mdhd"])[0];
      if (l) {
        o = l[0];
        const u = ae(l, o === 0 ? 12 : 20), d = ge(s, ["mdia", "hdlr"])[0];
        if (d) {
          const f = gt(d.subarray(8, 12)), h = {
            soun: je.AUDIO,
            vide: je.VIDEO
          }[f], g = ge(s, ["mdia", "minf", "stbl", "stsd"])[0], m = wK(g);
          h ? (e[c] = {
            timescale: u,
            type: h,
            stsd: m
          }, e[h] = Ne({
            timescale: u,
            id: c
          }, m)) : e[c] = {
            timescale: u,
            type: f,
            stsd: m
          };
        }
      }
    }
  }
  return ge(r, ["moov", "mvex", "trex"]).forEach((i) => {
    const s = ae(i, 4), a = e[s];
    a && (a.default = {
      duration: ae(i, 12),
      flags: ae(i, 20)
    });
  }), e;
}
function wK(r) {
  const e = r.subarray(8), t = e.subarray(86), n = gt(e.subarray(4, 8));
  let i = n, s;
  const a = n === "enca" || n === "encv";
  if (a) {
    const l = ge(e, [n])[0].subarray(n === "enca" ? 28 : 78);
    ge(l, ["sinf"]).forEach((d) => {
      const f = ge(d, ["schm"])[0];
      if (f) {
        const h = gt(f.subarray(4, 8));
        if (h === "cbcs" || h === "cenc") {
          const g = ge(d, ["frma"])[0];
          g && (i = gt(g));
        }
      }
    });
  }
  const o = i;
  switch (i) {
    case "avc1":
    case "avc2":
    case "avc3":
    case "avc4": {
      const c = ge(t, ["avcC"])[0];
      c && c.length > 3 && (i += "." + eo(c[1]) + eo(c[2]) + eo(c[3]), s = Ja(o === "avc1" ? "dva1" : "dvav", t));
      break;
    }
    case "mp4a": {
      const c = ge(e, [n])[0], l = ge(c.subarray(28), ["esds"])[0];
      if (l && l.length > 7) {
        let u = 4;
        if (l[u++] !== 3)
          break;
        u = Yu(l, u), u += 2;
        const d = l[u++];
        if (d & 128 && (u += 2), d & 64 && (u += l[u++]), l[u++] !== 4)
          break;
        u = Yu(l, u);
        const f = l[u++];
        if (f === 64)
          i += "." + eo(f);
        else
          break;
        if (u += 12, l[u++] !== 5)
          break;
        u = Yu(l, u);
        const h = l[u++];
        let g = (h & 248) >> 3;
        g === 31 && (g += 1 + ((h & 7) << 3) + ((l[u] & 224) >> 5)), i += "." + g;
      }
      break;
    }
    case "hvc1":
    case "hev1": {
      const c = ge(t, ["hvcC"])[0];
      if (c && c.length > 12) {
        const l = c[1], u = ["", "A", "B", "C"][l >> 6], d = l & 31, f = ae(c, 2), h = (l & 32) >> 5 ? "H" : "L", g = c[12], m = c.subarray(6, 12);
        i += "." + u + d, i += "." + IK(f).toString(16).toUpperCase(), i += "." + h + g;
        let p = "";
        for (let v = m.length; v--; ) {
          const y = m[v];
          (y || p) && (p = "." + y.toString(16).toUpperCase() + p);
        }
        i += p;
      }
      s = Ja(o == "hev1" ? "dvhe" : "dvh1", t);
      break;
    }
    case "dvh1":
    case "dvhe":
    case "dvav":
    case "dva1":
    case "dav1": {
      i = Ja(i, t) || i;
      break;
    }
    case "vp09": {
      const c = ge(t, ["vpcC"])[0];
      if (c && c.length > 6) {
        const l = c[4], u = c[5], d = c[6] >> 4 & 15;
        i += "." + Dr(l) + "." + Dr(u) + "." + Dr(d);
      }
      break;
    }
    case "av01": {
      const c = ge(t, ["av1C"])[0];
      if (c && c.length > 2) {
        const l = c[1] >>> 5, u = c[1] & 31, d = c[2] >>> 7 ? "H" : "M", f = (c[2] & 64) >> 6, h = (c[2] & 32) >> 5, g = l === 2 && f ? h ? 12 : 10 : f ? 10 : 8, m = (c[2] & 16) >> 4, p = (c[2] & 8) >> 3, v = (c[2] & 4) >> 2, y = c[2] & 3;
        i += "." + l + "." + Dr(u) + d + "." + Dr(g) + "." + m + "." + p + v + y + "." + Dr(1) + "." + Dr(1) + "." + Dr(1) + "." + 0, s = Ja("dav1", t);
      }
      break;
    }
  }
  return {
    codec: i,
    encrypted: a,
    supplemental: s
  };
}
function Ja(r, e) {
  const t = ge(e, ["dvvC"]), n = t.length ? t[0] : ge(e, ["dvcC"])[0];
  if (n) {
    const i = n[2] >> 1 & 127, s = n[2] << 5 & 32 | n[3] >> 3 & 31;
    return r + "." + Dr(i) + "." + Dr(s);
  }
}
function IK(r) {
  let e = 0;
  for (let t = 0; t < 32; t++)
    e |= (r >> t & 1) << 31 - t;
  return e >>> 0;
}
function Yu(r, e) {
  const t = e + 5;
  for (; r[e++] & 128 && e < t; )
    ;
  return e;
}
function eo(r) {
  return ("0" + r.toString(16).toUpperCase()).slice(-2);
}
function Dr(r) {
  return (r < 10 ? "0" : "") + r;
}
function PK(r, e) {
  if (!r || !e)
    return r;
  const t = e.keyId;
  return t && e.isCommonEncryption && ge(r, ["moov", "trak"]).forEach((i) => {
    const a = ge(i, ["mdia", "minf", "stbl", "stsd"])[0].subarray(8);
    let o = ge(a, ["enca"]);
    const c = o.length > 0;
    c || (o = ge(a, ["encv"])), o.forEach((l) => {
      const u = c ? l.subarray(28) : l.subarray(78);
      ge(u, ["sinf"]).forEach((f) => {
        const h = _K(f);
        if (h) {
          const g = h.subarray(8, 24);
          g.some((m) => m !== 0) || (Ae.log(`[eme] Patching keyId in 'enc${c ? "a" : "v"}>sinf>>tenc' box: ${Xn.hexDump(g)} -> ${Xn.hexDump(t)}`), h.set(t, 8));
        }
      });
    });
  }), r;
}
function _K(r) {
  const e = ge(r, ["schm"])[0];
  if (e) {
    const t = gt(e.subarray(4, 8));
    if (t === "cbcs" || t === "cenc")
      return ge(r, ["schi", "tenc"])[0];
  }
  return null;
}
function LK(r, e, t) {
  const n = {}, i = ge(r, ["moof", "traf"]);
  for (let s = 0; s < i.length; s++) {
    const a = i[s], o = ge(a, ["tfhd"])[0], c = ae(o, 4), l = e[c];
    if (!l)
      continue;
    const u = n[c] || (n[c] = {
      start: NaN,
      duration: 0,
      sampleCount: 0,
      timescale: l.timescale,
      type: l.type
    }), d = ge(a, ["tfdt"])[0];
    if (d) {
      const b = d[0];
      let x = ae(d, 4);
      b === 1 && (x === Oy ? t.warn("[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time") : (x *= Oy + 1, x += ae(d, 8))), X(x) && (!X(u.start) || x < u.start) && (u.start = x);
    }
    const f = l.default, h = ae(o, 0) | (f == null ? void 0 : f.flags);
    let g = (f == null ? void 0 : f.duration) || 0;
    h & 8 && (h & 2 ? g = ae(o, 12) : g = ae(o, 8));
    const m = ge(a, ["trun"]);
    let p = u.start || 0, v = 0, y = g;
    for (let b = 0; b < m.length; b++) {
      const x = m[b], S = ae(x, 4), A = u.sampleCount;
      u.sampleCount += S;
      const T = x[3] & 1, I = x[3] & 4, L = x[2] & 1, _ = x[2] & 2, R = x[2] & 4, D = x[2] & 8;
      let F = 8, B = S;
      for (T && (F += 4), I && S && (!(x[F + 1] & 1) && u.keyFrameIndex === void 0 && (u.keyFrameIndex = A), F += 4, L ? (y = ae(x, F), F += 4) : y = g, _ && (F += 4), D && (F += 4), p += y, v += y, B--); B--; )
        L ? (y = ae(x, F), F += 4) : y = g, _ && (F += 4), R && (x[F + 1] & 1 || u.keyFrameIndex === void 0 && (u.keyFrameIndex = u.sampleCount - (B + 1), u.keyFrameStart = p), F += 4), D && (F += 4), p += y, v += y;
      !v && g && (v += g * S);
    }
    u.duration += v;
  }
  if (!Object.keys(n).some((s) => n[s].duration)) {
    let s = 1 / 0, a = 0;
    const o = ge(r, ["sidx"]);
    for (let c = 0; c < o.length; c++) {
      const l = AK(o[c]);
      if (l != null && l.references) {
        s = Math.min(s, l.earliestPresentationTime / l.timescale);
        const u = l.references.reduce((d, f) => d + f.info.duration || 0, 0);
        a = Math.max(a, u + l.earliestPresentationTime / l.timescale);
      }
    }
    a && X(a) && Object.keys(n).forEach((c) => {
      n[c].duration || (n[c].duration = a * n[c].timescale - n[c].start);
    });
  }
  return n;
}
function OK(r) {
  const e = {
    valid: null,
    remainder: null
  }, t = ge(r, ["moof"]);
  if (t.length < 2)
    return e.remainder = r, e;
  const n = t[t.length - 1];
  return e.valid = r.slice(0, n.byteOffset - 8), e.remainder = r.slice(n.byteOffset - 8), e;
}
function yr(r, e) {
  const t = new Uint8Array(r.length + e.length);
  return t.set(r), t.set(e, r.length), t;
}
function Dy(r, e) {
  const t = [], n = e.samples, i = e.timescale, s = e.id;
  let a = !1;
  return ge(n, ["moof"]).map((c) => {
    const l = c.byteOffset - 8;
    ge(c, ["traf"]).map((d) => {
      const f = ge(d, ["tfdt"]).map((h) => {
        const g = h[0];
        let m = ae(h, 4);
        return g === 1 && (m *= Math.pow(2, 32), m += ae(h, 8)), m / i;
      })[0];
      return f !== void 0 && (r = f), ge(d, ["tfhd"]).map((h) => {
        const g = ae(h, 4), m = ae(h, 0) & 16777215, p = (m & 1) !== 0, v = (m & 2) !== 0, y = (m & 8) !== 0;
        let b = 0;
        const x = (m & 16) !== 0;
        let S = 0;
        const A = (m & 32) !== 0;
        let T = 8;
        g === s && (p && (T += 8), v && (T += 4), y && (b = ae(h, T), T += 4), x && (S = ae(h, T), T += 4), A && (T += 4), e.type === "video" && (a = ic(e.codec)), ge(d, ["trun"]).map((I) => {
          const L = I[0], _ = ae(I, 0) & 16777215, R = (_ & 1) !== 0;
          let D = 0;
          const F = (_ & 4) !== 0, B = (_ & 256) !== 0;
          let j = 0;
          const U = (_ & 512) !== 0;
          let K = 0;
          const G = (_ & 1024) !== 0, Y = (_ & 2048) !== 0;
          let Q = 0;
          const H = ae(I, 4);
          let N = 8;
          R && (D = ae(I, N), N += 4), F && (N += 4);
          let re = D + l;
          for (let oe = 0; oe < H; oe++) {
            if (B ? (j = ae(I, N), N += 4) : j = b, U ? (K = ae(I, N), N += 4) : K = S, G && (N += 4), Y && (L === 0 ? Q = ae(I, N) : Q = UA(I, N), N += 4), e.type === je.VIDEO) {
              let le = 0;
              for (; le < K; ) {
                const he = ae(n, re);
                if (re += 4, RK(a, n[re])) {
                  const Re = n.subarray(re, re + he);
                  Ug(Re, a ? 2 : 1, r + Q / i, t);
                }
                re += he, le += he + 4;
              }
            }
            r += j / i;
          }
        }));
      });
    });
  }), t;
}
function ic(r) {
  if (!r)
    return !1;
  const e = r.substring(0, 4);
  return e === "hvc1" || e === "hev1" || // Dolby Vision
  e === "dvh1" || e === "dvhe";
}
function RK(r, e) {
  if (r) {
    const t = e >> 1 & 63;
    return t === 39 || t === 40;
  } else
    return (e & 31) === 6;
}
function Ug(r, e, t, n) {
  const i = KA(r);
  let s = 0;
  s += e;
  let a = 0, o = 0, c = 0;
  for (; s < i.length; ) {
    a = 0;
    do {
      if (s >= i.length)
        break;
      c = i[s++], a += c;
    } while (c === 255);
    o = 0;
    do {
      if (s >= i.length)
        break;
      c = i[s++], o += c;
    } while (c === 255);
    const l = i.length - s;
    let u = s;
    if (o < l)
      s += o;
    else if (o > l) {
      Ae.error(`Malformed SEI payload. ${o} is too small, only ${l} bytes left to parse.`);
      break;
    }
    if (a === 4) {
      if (i[u++] === 181) {
        const f = jA(i, u);
        if (u += 2, f === 49) {
          const h = ae(i, u);
          if (u += 4, h === 1195456820) {
            const g = i[u++];
            if (g === 3) {
              const m = i[u++], p = 31 & m, v = 64 & m, y = v ? 2 + p * 3 : 0, b = new Uint8Array(y);
              if (v) {
                b[0] = m;
                for (let x = 1; x < y; x++)
                  b[x] = i[u++];
              }
              n.push({
                type: g,
                payloadType: a,
                pts: t,
                bytes: b
              });
            }
          }
        }
      }
    } else if (a === 5 && o > 16) {
      const d = [];
      for (let g = 0; g < 16; g++) {
        const m = i[u++].toString(16);
        d.push(m.length == 1 ? "0" + m : m), (g === 3 || g === 5 || g === 7 || g === 9) && d.push("-");
      }
      const f = o - 16, h = new Uint8Array(f);
      for (let g = 0; g < f; g++)
        h[g] = i[u++];
      n.push({
        payloadType: a,
        pts: t,
        uuid: d.join(""),
        userData: tr(h),
        userDataBytes: h
      });
    }
  }
}
function KA(r) {
  const e = r.byteLength, t = [];
  let n = 1;
  for (; n < e - 2; )
    r[n] === 0 && r[n + 1] === 0 && r[n + 2] === 3 ? (t.push(n + 2), n += 2) : n++;
  if (t.length === 0)
    return r;
  const i = e - t.length, s = new Uint8Array(i);
  let a = 0;
  for (n = 0; n < i; a++, n++)
    a === t[0] && (a++, t.shift()), s[n] = r[a];
  return s;
}
function DK(r) {
  const e = r[0];
  let t = "", n = "", i = 0, s = 0, a = 0, o = 0, c = 0, l = 0;
  if (e === 0) {
    for (; gt(r.subarray(l, l + 1)) !== "\0"; )
      t += gt(r.subarray(l, l + 1)), l += 1;
    for (t += gt(r.subarray(l, l + 1)), l += 1; gt(r.subarray(l, l + 1)) !== "\0"; )
      n += gt(r.subarray(l, l + 1)), l += 1;
    n += gt(r.subarray(l, l + 1)), l += 1, i = ae(r, 12), s = ae(r, 16), o = ae(r, 20), c = ae(r, 24), l = 28;
  } else if (e === 1) {
    l += 4, i = ae(r, l), l += 4;
    const d = ae(r, l);
    l += 4;
    const f = ae(r, l);
    for (l += 4, a = 2 ** 32 * d + f, lK(a) || (a = Number.MAX_SAFE_INTEGER, Ae.warn("Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box")), o = ae(r, l), l += 4, c = ae(r, l), l += 4; gt(r.subarray(l, l + 1)) !== "\0"; )
      t += gt(r.subarray(l, l + 1)), l += 1;
    for (t += gt(r.subarray(l, l + 1)), l += 1; gt(r.subarray(l, l + 1)) !== "\0"; )
      n += gt(r.subarray(l, l + 1)), l += 1;
    n += gt(r.subarray(l, l + 1)), l += 1;
  }
  const u = r.subarray(l, r.byteLength);
  return {
    schemeIdUri: t,
    value: n,
    timeScale: i,
    presentationTime: a,
    presentationTimeDelta: s,
    eventDuration: o,
    id: c,
    payload: u
  };
}
function CK(r, ...e) {
  const t = e.length;
  let n = 8, i = t;
  for (; i--; )
    n += e[i].byteLength;
  const s = new Uint8Array(n);
  for (s[0] = n >> 24 & 255, s[1] = n >> 16 & 255, s[2] = n >> 8 & 255, s[3] = n & 255, s.set(r, 4), i = 0, n = 8; i < t; i++)
    s.set(e[i], n), n += e[i].byteLength;
  return s;
}
function kK(r, e, t) {
  if (r.byteLength !== 16)
    throw new RangeError("Invalid system id");
  let n, i;
  n = 0, i = new Uint8Array();
  let s;
  n > 0 ? (s = new Uint8Array(4), e.length > 0 && new DataView(s.buffer).setUint32(0, e.length, !1)) : s = new Uint8Array();
  const a = new Uint8Array(4);
  return t && t.byteLength > 0 && new DataView(a.buffer).setUint32(0, t.byteLength, !1), CK(
    [112, 115, 115, 104],
    new Uint8Array([
      n,
      0,
      0,
      0
      // Flags
    ]),
    r,
    // 16 bytes
    s,
    i,
    a,
    t || new Uint8Array()
  );
}
const VA = () => /\(Windows.+Firefox\//i.test(navigator.userAgent), Ji = {
  audio: {
    a3ds: 1,
    "ac-3": 0.95,
    "ac-4": 1,
    alac: 0.9,
    alaw: 1,
    dra1: 1,
    "dts+": 1,
    "dts-": 1,
    dtsc: 1,
    dtse: 1,
    dtsh: 1,
    "ec-3": 0.9,
    enca: 1,
    fLaC: 0.9,
    // MP4-RA listed codec entry for FLAC
    flac: 0.9,
    // legacy browser codec name for FLAC
    FLAC: 0.9,
    // some manifests may list "FLAC" with Apple's tools
    g719: 1,
    g726: 1,
    m4ae: 1,
    mha1: 1,
    mha2: 1,
    mhm1: 1,
    mhm2: 1,
    mlpa: 1,
    mp4a: 1,
    "raw ": 1,
    Opus: 1,
    opus: 1,
    // browsers expect this to be lowercase despite MP4RA says 'Opus'
    samr: 1,
    sawb: 1,
    sawp: 1,
    sevc: 1,
    sqcp: 1,
    ssmv: 1,
    twos: 1,
    ulaw: 1
  },
  video: {
    avc1: 1,
    avc2: 1,
    avc3: 1,
    avc4: 1,
    avcp: 1,
    av01: 0.8,
    dav1: 0.8,
    drac: 1,
    dva1: 1,
    dvav: 1,
    dvh1: 0.7,
    dvhe: 0.7,
    encv: 1,
    hev1: 0.75,
    hvc1: 0.75,
    mjp2: 1,
    mp4v: 1,
    mvc1: 1,
    mvc2: 1,
    mvc3: 1,
    mvc4: 1,
    resv: 1,
    rv60: 1,
    s263: 1,
    svc1: 1,
    svc2: 1,
    "vc-1": 1,
    vp08: 1,
    vp09: 0.9
  },
  text: {
    stpp: 1,
    wvtt: 1
  }
};
function Gg(r, e) {
  const t = Ji[e];
  return !!t && !!t[r.slice(0, 4)];
}
function pf(r, e, t = !0) {
  return !r.split(",").some((n) => !Kg(n, e, t));
}
function Kg(r, e, t = !0) {
  var n;
  const i = Nn(t);
  return (n = i == null ? void 0 : i.isTypeSupported(ea(r, e))) != null ? n : !1;
}
function ea(r, e) {
  return `${e}/mp4;codecs=${r}`;
}
function Cy(r) {
  if (r) {
    const e = r.substring(0, 4);
    return Ji.video[e];
  }
  return 2;
}
function sl(r) {
  const e = VA();
  return r.split(",").reduce((t, n) => {
    const s = e && ic(n) ? 9 : Ji.video[n];
    return s ? (s * 2 + t) / (t ? 3 : 2) : (Ji.audio[n] + t) / (t ? 2 : 1);
  }, 0);
}
const Xu = {};
function MK(r, e = !0) {
  if (Xu[r])
    return Xu[r];
  const t = {
    // Idealy fLaC and Opus would be first (spec-compliant) but
    // some browsers will report that fLaC is supported then fail.
    // see: https://bugs.chromium.org/p/chromium/issues/detail?id=1422728
    flac: ["flac", "fLaC", "FLAC"],
    opus: ["opus", "Opus"],
    // Replace audio codec info if browser does not support mp4a.40.34,
    // and demuxer can fallback to 'audio/mpeg' or 'audio/mp4;codecs="mp3"'
    "mp4a.40.34": ["mp3"]
  }[r];
  for (let i = 0; i < t.length; i++) {
    var n;
    if (Kg(t[i], "audio", e))
      return Xu[r] = t[i], t[i];
    if (t[i] === "mp3" && (n = Nn(e)) != null && n.isTypeSupported("audio/mpeg"))
      return "";
  }
  return r;
}
const NK = /flac|opus|mp4a\.40\.34/i;
function al(r, e = !0) {
  return r.replace(NK, (t) => MK(t.toLowerCase(), e));
}
function FK(r, e) {
  const t = [];
  if (r) {
    const n = r.split(",");
    for (let i = 0; i < n.length; i++)
      Gg(n[i], "video") || t.push(n[i]);
  }
  return e && t.push(e), t.join(",");
}
function po(r, e) {
  if (r && (r.length > 4 || ["ac-3", "ec-3", "alac", "fLaC", "Opus"].indexOf(r) !== -1) && (ky(r, "audio") || ky(r, "video")))
    return r;
  if (e) {
    const t = e.split(",");
    if (t.length > 1) {
      if (r) {
        for (let n = t.length; n--; )
          if (t[n].substring(0, 4) === r.substring(0, 4))
            return t[n];
      }
      return t[0];
    }
  }
  return e || r;
}
function ky(r, e) {
  return Gg(r, e) && Kg(r, e);
}
function $K(r) {
  const e = r.split(",");
  for (let t = 0; t < e.length; t++) {
    const n = e[t].split(".");
    n.length > 2 && n[0] === "avc1" && (e[t] = `avc1.${parseInt(n[1]).toString(16)}${("000" + parseInt(n[2]).toString(16)).slice(-4)}`);
  }
  return e.join(",");
}
function BK(r) {
  if (r.startsWith("av01.")) {
    const e = r.split("."), t = ["0", "111", "01", "01", "01", "0"];
    for (let n = e.length; n > 4 && n < 10; n++)
      e[n] = t[n - 4];
    return e.join(".");
  }
  return r;
}
function My(r) {
  const e = Nn(r) || {
    isTypeSupported: () => !1
  };
  return {
    mpeg: e.isTypeSupported("audio/mpeg"),
    mp3: e.isTypeSupported('audio/mp4; codecs="mp3"'),
    ac3: e.isTypeSupported('audio/mp4; codecs="ac-3"')
  };
}
function vf(r) {
  return r.replace(/^.+codecs=["']?([^"']+).*$/, "$1");
}
const WA = {
  supported: !0,
  configurations: [],
  decodingInfoResults: [{
    supported: !0,
    powerEfficient: !0,
    smooth: !0
  }]
};
function HA(r, e) {
  return {
    supported: !1,
    configurations: e,
    decodingInfoResults: [{
      supported: !1,
      smooth: !1,
      powerEfficient: !1
    }],
    error: r
  };
}
function jK(r, e, t, n, i, s) {
  const a = r.videoCodec, o = r.audioCodec ? r.audioGroups : null, c = s == null ? void 0 : s.audioCodec, l = s == null ? void 0 : s.channels, u = l ? parseInt(l) : c ? 1 / 0 : 2;
  let d = null;
  if (o != null && o.length)
    try {
      o.length === 1 && o[0] ? d = e.groups[o[0]].channels : d = o.reduce((f, h) => {
        if (h) {
          const g = e.groups[h];
          if (!g)
            throw new Error(`Audio track group ${h} not found`);
          Object.keys(g.channels).forEach((m) => {
            f[m] = (f[m] || 0) + g.channels[m];
          });
        }
        return f;
      }, {
        2: 0
      });
    } catch {
      return !0;
    }
  return a !== void 0 && // Force media capabilities check for HEVC to avoid failure on Windows
  (a.split(",").some((f) => ic(f)) || r.width > 1920 && r.height > 1088 || r.height > 1920 && r.width > 1088 || r.frameRate > Math.max(n, 30) || r.videoRange !== "SDR" && r.videoRange !== t || r.bitrate > Math.max(i, 8e6)) || !!d && X(u) && Object.keys(d).some((f) => parseInt(f) > u);
}
function qA(r, e, t, n = {}) {
  const i = r.videoCodec;
  if (!i && !r.audioCodec || !t)
    return Promise.resolve(WA);
  const s = [], a = UK(r), o = a.length, c = GK(r, e, o > 0), l = c.length;
  for (let u = o || 1 * l || 1; u--; ) {
    const d = {
      type: "media-source"
    };
    if (o && (d.video = a[u % o]), l) {
      d.audio = c[u % l];
      const f = d.audio.bitrate;
      d.video && f && (d.video.bitrate -= f);
    }
    s.push(d);
  }
  if (i) {
    const u = navigator.userAgent;
    if (i.split(",").some((d) => ic(d)) && VA())
      return Promise.resolve(HA(new Error(`Overriding Windows Firefox HEVC MediaCapabilities result based on user-agent string: (${u})`), s));
  }
  return Promise.all(s.map((u) => {
    const d = VK(u);
    return n[d] || (n[d] = t.decodingInfo(u));
  })).then((u) => ({
    supported: !u.some((d) => !d.supported),
    configurations: s,
    decodingInfoResults: u
  })).catch((u) => ({
    supported: !1,
    configurations: s,
    decodingInfoResults: [],
    error: u
  }));
}
function UK(r) {
  var e;
  const t = (e = r.videoCodec) == null ? void 0 : e.split(","), n = zA(r), i = r.width || 640, s = r.height || 480, a = r.frameRate || 30, o = r.videoRange.toLowerCase();
  return t ? t.map((c) => {
    const l = {
      contentType: ea(BK(c), "video"),
      width: i,
      height: s,
      bitrate: n,
      framerate: a
    };
    return o !== "sdr" && (l.transferFunction = o), l;
  }) : [];
}
function GK(r, e, t) {
  var n;
  const i = (n = r.audioCodec) == null ? void 0 : n.split(","), s = zA(r);
  return i && r.audioGroups ? r.audioGroups.reduce((a, o) => {
    var c;
    const l = o ? (c = e.groups[o]) == null ? void 0 : c.tracks : null;
    return l ? l.reduce((u, d) => {
      if (d.groupId === o) {
        const f = parseFloat(d.channels || "");
        i.forEach((h) => {
          const g = {
            contentType: ea(h, "audio"),
            bitrate: t ? KK(h, s) : s
          };
          f && (g.channels = "" + f), u.push(g);
        });
      }
      return u;
    }, a) : a;
  }, []) : [];
}
function KK(r, e) {
  if (e <= 1)
    return 1;
  let t = 128e3;
  return r === "ec-3" ? t = 768e3 : r === "ac-3" && (t = 64e4), Math.min(e / 2, t);
}
function zA(r) {
  return Math.ceil(Math.max(r.bitrate * 0.9, r.averageBitrate) / 1e3) * 1e3 || 1;
}
function VK(r) {
  let e = "";
  const {
    audio: t,
    video: n
  } = r;
  if (n) {
    const i = vf(n.contentType);
    e += `${i}_r${n.height}x${n.width}f${Math.ceil(n.framerate)}${n.transferFunction || "sd"}_${Math.ceil(n.bitrate / 1e5)}`;
  }
  if (t) {
    const i = vf(t.contentType);
    e += `${n ? "_" : ""}${i}_c${t.channels}`;
  }
  return e;
}
const yf = ["NONE", "TYPE-0", "TYPE-1", null];
function WK(r) {
  return yf.indexOf(r) > -1;
}
const ol = ["SDR", "PQ", "HLG"];
function HK(r) {
  return !!r && ol.indexOf(r) > -1;
}
var vo = {
  No: "",
  Yes: "YES",
  v2: "v2"
};
function Ny(r) {
  const {
    canSkipUntil: e,
    canSkipDateRanges: t,
    age: n
  } = r, i = n < e / 2;
  return e && i ? t ? vo.v2 : vo.Yes : vo.No;
}
class Fy {
  constructor(e, t, n) {
    this.msn = void 0, this.part = void 0, this.skip = void 0, this.msn = e, this.part = t, this.skip = n;
  }
  addDirectives(e) {
    const t = new self.URL(e);
    return this.msn !== void 0 && t.searchParams.set("_HLS_msn", this.msn.toString()), this.part !== void 0 && t.searchParams.set("_HLS_part", this.part.toString()), this.skip && t.searchParams.set("_HLS_skip", this.skip), t.href;
  }
}
class ta {
  constructor(e) {
    if (this._attrs = void 0, this.audioCodec = void 0, this.bitrate = void 0, this.codecSet = void 0, this.url = void 0, this.frameRate = void 0, this.height = void 0, this.id = void 0, this.name = void 0, this.supplemental = void 0, this.videoCodec = void 0, this.width = void 0, this.details = void 0, this.fragmentError = 0, this.loadError = 0, this.loaded = void 0, this.realBitrate = 0, this.supportedPromise = void 0, this.supportedResult = void 0, this._avgBitrate = 0, this._audioGroups = void 0, this._subtitleGroups = void 0, this._urlId = 0, this.url = [e.url], this._attrs = [e.attrs], this.bitrate = e.bitrate, e.details && (this.details = e.details), this.id = e.id || 0, this.name = e.name, this.width = e.width || 0, this.height = e.height || 0, this.frameRate = e.attrs.optionalFloat("FRAME-RATE", 0), this._avgBitrate = e.attrs.decimalInteger("AVERAGE-BANDWIDTH"), this.audioCodec = e.audioCodec, this.videoCodec = e.videoCodec, this.codecSet = [e.videoCodec, e.audioCodec].filter((n) => !!n).map((n) => n.substring(0, 4)).join(","), "supplemental" in e) {
      var t;
      this.supplemental = e.supplemental;
      const n = (t = e.supplemental) == null ? void 0 : t.videoCodec;
      n && n !== e.videoCodec && (this.codecSet += `,${n.substring(0, 4)}`);
    }
    this.addGroupId("audio", e.attrs.AUDIO), this.addGroupId("text", e.attrs.SUBTITLES);
  }
  get maxBitrate() {
    return Math.max(this.realBitrate, this.bitrate);
  }
  get averageBitrate() {
    return this._avgBitrate || this.realBitrate || this.bitrate;
  }
  get attrs() {
    return this._attrs[0];
  }
  get codecs() {
    return this.attrs.CODECS || "";
  }
  get pathwayId() {
    return this.attrs["PATHWAY-ID"] || ".";
  }
  get videoRange() {
    return this.attrs["VIDEO-RANGE"] || "SDR";
  }
  get score() {
    return this.attrs.optionalFloat("SCORE", 0);
  }
  get uri() {
    return this.url[0] || "";
  }
  hasAudioGroup(e) {
    return $y(this._audioGroups, e);
  }
  hasSubtitleGroup(e) {
    return $y(this._subtitleGroups, e);
  }
  get audioGroups() {
    return this._audioGroups;
  }
  get subtitleGroups() {
    return this._subtitleGroups;
  }
  addGroupId(e, t) {
    if (t) {
      if (e === "audio") {
        let n = this._audioGroups;
        n || (n = this._audioGroups = []), n.indexOf(t) === -1 && n.push(t);
      } else if (e === "text") {
        let n = this._subtitleGroups;
        n || (n = this._subtitleGroups = []), n.indexOf(t) === -1 && n.push(t);
      }
    }
  }
  // Deprecated methods (retained for backwards compatibility)
  get urlId() {
    return 0;
  }
  set urlId(e) {
  }
  get audioGroupIds() {
    return this.audioGroups ? [this.audioGroupId] : void 0;
  }
  get textGroupIds() {
    return this.subtitleGroups ? [this.textGroupId] : void 0;
  }
  get audioGroupId() {
    var e;
    return (e = this.audioGroups) == null ? void 0 : e[0];
  }
  get textGroupId() {
    var e;
    return (e = this.subtitleGroups) == null ? void 0 : e[0];
  }
  addFallback() {
  }
}
function $y(r, e) {
  return !e || !r ? !1 : r.indexOf(e) !== -1;
}
function qK() {
  if (typeof matchMedia == "function") {
    const r = matchMedia("(dynamic-range: high)"), e = matchMedia("bad query");
    if (r.media !== e.media)
      return r.matches === !0;
  }
  return !1;
}
function zK(r, e) {
  let t = !1, n = [];
  if (r && (t = r !== "SDR", n = [r]), e) {
    n = e.allowedVideoRanges || ol.slice(0);
    const i = n.join("") !== "SDR" && !e.videoCodec;
    t = e.preferHDR !== void 0 ? e.preferHDR : i && qK(), t || (n = ["SDR"]);
  }
  return {
    preferHDR: t,
    allowedVideoRanges: n
  };
}
const YK = (r) => {
  const e = /* @__PURE__ */ new WeakSet();
  return (t, n) => {
    if (r && (n = r(t, n)), typeof n == "object" && n !== null) {
      if (e.has(n))
        return;
      e.add(n);
    }
    return n;
  };
}, We = (r, e) => JSON.stringify(r, YK(e));
function XK(r, e, t, n, i) {
  const s = Object.keys(r), a = n == null ? void 0 : n.channels, o = n == null ? void 0 : n.audioCodec, c = i == null ? void 0 : i.videoCodec, l = a && parseInt(a) === 2;
  let u = !1, d = !1, f = 1 / 0, h = 1 / 0, g = 1 / 0, m = 1 / 0, p = 0, v = [];
  const {
    preferHDR: y,
    allowedVideoRanges: b
  } = zK(e, i);
  for (let I = s.length; I--; ) {
    const L = r[s[I]];
    u || (u = L.channels[2] > 0), f = Math.min(f, L.minHeight), h = Math.min(h, L.minFramerate), g = Math.min(g, L.minBitrate), b.filter((R) => L.videoRanges[R] > 0).length > 0 && (d = !0);
  }
  f = X(f) ? f : 0, h = X(h) ? h : 0;
  const x = Math.max(1080, f), S = Math.max(30, h);
  g = X(g) ? g : t, t = Math.max(g, t), d || (e = void 0);
  const A = s.length > 1;
  return {
    codecSet: s.reduce((I, L) => {
      const _ = r[L];
      if (L === I)
        return I;
      if (v = d ? b.filter((R) => _.videoRanges[R] > 0) : [], A) {
        if (_.minBitrate > t)
          return Rr(L, `min bitrate of ${_.minBitrate} > current estimate of ${t}`), I;
        if (!_.hasDefaultAudio)
          return Rr(L, "no renditions with default or auto-select sound found"), I;
        if (o && L.indexOf(o.substring(0, 4)) % 5 !== 0)
          return Rr(L, `audio codec preference "${o}" not found`), I;
        if (a && !l) {
          if (!_.channels[a])
            return Rr(L, `no renditions with ${a} channel sound found (channels options: ${Object.keys(_.channels)})`), I;
        } else if ((!o || l) && u && _.channels[2] === 0)
          return Rr(L, "no renditions with stereo sound found"), I;
        if (_.minHeight > x)
          return Rr(L, `min resolution of ${_.minHeight} > maximum of ${x}`), I;
        if (_.minFramerate > S)
          return Rr(L, `min framerate of ${_.minFramerate} > maximum of ${S}`), I;
        if (!v.some((R) => _.videoRanges[R] > 0))
          return Rr(L, `no variants with VIDEO-RANGE of ${We(v)} found`), I;
        if (c && L.indexOf(c.substring(0, 4)) % 5 !== 0)
          return Rr(L, `video codec preference "${c}" not found`), I;
        if (_.maxScore < p)
          return Rr(L, `max score of ${_.maxScore} < selected max of ${p}`), I;
      }
      return I && (sl(L) >= sl(I) || _.fragmentError > r[I].fragmentError) ? I : (m = _.minIndex, p = _.maxScore, L);
    }, void 0),
    videoRanges: v,
    preferHDR: y,
    minFramerate: h,
    minBitrate: g,
    minIndex: m
  };
}
function Rr(r, e) {
  Ae.log(`[abr] start candidates with "${r}" ignored because ${e}`);
}
function YA(r) {
  return r.reduce((e, t) => {
    let n = e.groups[t.groupId];
    n || (n = e.groups[t.groupId] = {
      tracks: [],
      channels: {
        2: 0
      },
      hasDefault: !1,
      hasAutoSelect: !1
    }), n.tracks.push(t);
    const i = t.channels || "2";
    return n.channels[i] = (n.channels[i] || 0) + 1, n.hasDefault = n.hasDefault || t.default, n.hasAutoSelect = n.hasAutoSelect || t.autoselect, n.hasDefault && (e.hasDefaultAudio = !0), n.hasAutoSelect && (e.hasAutoSelectAudio = !0), e;
  }, {
    hasDefaultAudio: !1,
    hasAutoSelectAudio: !1,
    groups: {}
  });
}
function QK(r, e, t, n) {
  return r.slice(t, n + 1).reduce((i, s, a) => {
    if (!s.codecSet)
      return i;
    const o = s.audioGroups;
    let c = i[s.codecSet];
    c || (i[s.codecSet] = c = {
      minBitrate: 1 / 0,
      minHeight: 1 / 0,
      minFramerate: 1 / 0,
      minIndex: a,
      maxScore: 0,
      videoRanges: {
        SDR: 0
      },
      channels: {
        2: 0
      },
      hasDefaultAudio: !o,
      fragmentError: 0
    }), c.minBitrate = Math.min(c.minBitrate, s.bitrate);
    const l = Math.min(s.height, s.width);
    return c.minHeight = Math.min(c.minHeight, l), c.minFramerate = Math.min(c.minFramerate, s.frameRate), c.minIndex = Math.min(c.minIndex, a), c.maxScore = Math.max(c.maxScore, s.score), c.fragmentError += s.fragmentError, c.videoRanges[s.videoRange] = (c.videoRanges[s.videoRange] || 0) + 1, o && o.forEach((u) => {
      if (!u)
        return;
      const d = e.groups[u];
      d && (c.hasDefaultAudio = c.hasDefaultAudio || e.hasDefaultAudio ? d.hasDefault : d.hasAutoSelect || !e.hasDefaultAudio && !e.hasAutoSelectAudio, Object.keys(d.channels).forEach((f) => {
        c.channels[f] = (c.channels[f] || 0) + d.channels[f];
      }));
    }), i;
  }, {});
}
function By(r) {
  if (!r)
    return r;
  const {
    lang: e,
    assocLang: t,
    characteristics: n,
    channels: i,
    audioCodec: s
  } = r;
  return {
    lang: e,
    assocLang: t,
    characteristics: n,
    channels: i,
    audioCodec: s
  };
}
function Mr(r, e, t) {
  if ("attrs" in r) {
    const n = e.indexOf(r);
    if (n !== -1)
      return n;
  }
  for (let n = 0; n < e.length; n++) {
    const i = e[n];
    if (ci(r, i, t))
      return n;
  }
  return -1;
}
function ci(r, e, t) {
  const {
    groupId: n,
    name: i,
    lang: s,
    assocLang: a,
    default: o
  } = r, c = r.forced;
  return (n === void 0 || e.groupId === n) && (i === void 0 || e.name === i) && (s === void 0 || ZK(s, e.lang)) && (s === void 0 || e.assocLang === a) && (o === void 0 || e.default === o) && (c === void 0 || e.forced === c) && (!("characteristics" in r) || JK(r.characteristics || "", e.characteristics)) && (t === void 0 || t(r, e));
}
function ZK(r, e = "--") {
  return r.length === e.length ? r === e : r.startsWith(e) || e.startsWith(r);
}
function JK(r, e = "") {
  const t = r.split(","), n = e.split(",");
  return t.length === n.length && !t.some((i) => n.indexOf(i) === -1);
}
function Yn(r, e) {
  const {
    audioCodec: t,
    channels: n
  } = r;
  return (t === void 0 || (e.audioCodec || "").substring(0, 4) === t.substring(0, 4)) && (n === void 0 || n === (e.channels || "2"));
}
function e3(r, e, t, n, i) {
  const s = e[n], o = e.reduce((f, h, g) => {
    const m = h.uri;
    return (f[m] || (f[m] = [])).push(g), f;
  }, {})[s.uri];
  o.length > 1 && (n = Math.max.apply(Math, o));
  const c = s.videoRange, l = s.frameRate, u = s.codecSet.substring(0, 4), d = jy(e, n, (f) => {
    if (f.videoRange !== c || f.frameRate !== l || f.codecSet.substring(0, 4) !== u)
      return !1;
    const h = f.audioGroups, g = t.filter((m) => !h || h.indexOf(m.groupId) !== -1);
    return Mr(r, g, i) > -1;
  });
  return d > -1 ? d : jy(e, n, (f) => {
    const h = f.audioGroups, g = t.filter((m) => !h || h.indexOf(m.groupId) !== -1);
    return Mr(r, g, i) > -1;
  });
}
function jy(r, e, t) {
  for (let n = e; n > -1; n--)
    if (t(r[n]))
      return n;
  for (let n = e + 1; n < r.length; n++)
    if (t(r[n]))
      return n;
  return -1;
}
function ll(r, e) {
  var t;
  return !!r && r !== ((t = e.loadLevelObj) == null ? void 0 : t.uri);
}
class t3 extends Or {
  constructor(e) {
    super("abr", e.logger), this.hls = void 0, this.lastLevelLoadSec = 0, this.lastLoadedFragLevel = -1, this.firstSelection = -1, this._nextAutoLevel = -1, this.nextAutoLevelKey = "", this.audioTracksByGroup = null, this.codecTiers = null, this.timer = -1, this.fragCurrent = null, this.partCurrent = null, this.bitrateTestDelay = 0, this.rebufferNotice = -1, this.supportedCache = {}, this.bwEstimator = void 0, this._abandonRulesCheck = (t) => {
      var n;
      const {
        fragCurrent: i,
        partCurrent: s,
        hls: a
      } = this, {
        autoLevelEnabled: o,
        media: c
      } = a;
      if (!i || !c)
        return;
      const l = performance.now(), u = s ? s.stats : i.stats, d = s ? s.duration : i.duration, f = l - u.loading.start, h = a.minAutoLevel, g = i.level, m = this._nextAutoLevel;
      if (u.aborted || u.loaded && u.loaded === u.total || g <= h) {
        this.clearTimer(), this._nextAutoLevel = -1;
        return;
      }
      if (!o)
        return;
      const p = m > -1 && m !== g, v = !!t || p;
      if (!v && (c.paused || !c.playbackRate || !c.readyState))
        return;
      const y = a.mainForwardBufferInfo;
      if (!v && y === null)
        return;
      const b = this.bwEstimator.getEstimateTTFB(), x = Math.abs(c.playbackRate);
      if (f <= Math.max(b, 1e3 * (d / (x * 2))))
        return;
      const S = y ? y.len / x : 0, A = u.loading.first ? u.loading.first - u.loading.start : -1, T = u.loaded && A > -1, I = this.getBwEstimate(), L = a.levels, _ = L[g], R = Math.max(u.loaded, Math.round(d * (i.bitrate || _.averageBitrate) / 8));
      let D = T ? f - A : f;
      D < 1 && T && (D = Math.min(f, u.loaded * 8 / I));
      const F = T ? u.loaded * 1e3 / D : 0, B = b / 1e3, j = F ? (R - u.loaded) / F : R * 8 / I + B;
      if (j <= S)
        return;
      const U = F ? F * 8 : I, K = ((n = (t == null ? void 0 : t.details) || this.hls.latestLevelDetails) == null ? void 0 : n.live) === !0, G = this.hls.config.abrBandWidthUpFactor;
      let Y = Number.POSITIVE_INFINITY, Q;
      for (Q = g - 1; Q > h; Q--) {
        const oe = L[Q].maxBitrate, le = !L[Q].details || K;
        if (Y = this.getTimeToLoadFrag(B, U, d * oe, le), Y < Math.min(S, d + B))
          break;
      }
      if (Y >= j || Y > d * 10)
        return;
      T ? this.bwEstimator.sample(f - Math.min(b, A), u.loaded) : this.bwEstimator.sampleTTFB(f);
      const H = L[Q].maxBitrate;
      this.getBwEstimate() * G > H && this.resetEstimator(H);
      const N = this.findBestLevel(H, h, Q, 0, S, 1, 1);
      N > -1 && (Q = N), this.warn(`Fragment ${i.sn}${s ? " part " + s.index : ""} of level ${g} is loading too slowly;
      Fragment duration: ${i.duration.toFixed(3)}
      Time to underbuffer: ${S.toFixed(3)} s
      Estimated load time for current fragment: ${j.toFixed(3)} s
      Estimated load time for down switch fragment: ${Y.toFixed(3)} s
      TTFB estimate: ${A | 0} ms
      Current BW estimate: ${X(I) ? I | 0 : "Unknown"} bps
      New BW estimate: ${this.getBwEstimate() | 0} bps
      Switching to level ${Q} @ ${H | 0} bps`), a.nextLoadLevel = a.nextAutoLevel = Q, this.clearTimer();
      const re = () => {
        if (this.clearTimer(), this.fragCurrent === i && this.hls.loadLevel === Q && Q > 0) {
          const oe = this.getStarvationDelay();
          if (this.warn(`Aborting inflight request ${Q > 0 ? "and switching down" : ""}
      Fragment duration: ${i.duration.toFixed(3)} s
      Time to underbuffer: ${oe.toFixed(3)} s`), i.abortRequests(), this.fragCurrent = this.partCurrent = null, Q > h) {
            let le = this.findBestLevel(this.hls.levels[h].bitrate, h, Q, 0, oe, 1, 1);
            le === -1 && (le = h), this.hls.nextLoadLevel = this.hls.nextAutoLevel = le, this.resetEstimator(this.hls.levels[le].bitrate);
          }
        }
      };
      p || j > Y * 2 ? re() : this.timer = self.setInterval(re, Y * 1e3), a.trigger(E.FRAG_LOAD_EMERGENCY_ABORTED, {
        frag: i,
        part: s,
        stats: u
      });
    }, this.hls = e, this.bwEstimator = this.initEstimator(), this.registerListeners();
  }
  resetEstimator(e) {
    e && (this.log(`setting initial bwe to ${e}`), this.hls.config.abrEwmaDefaultEstimate = e), this.firstSelection = -1, this.bwEstimator = this.initEstimator();
  }
  initEstimator() {
    const e = this.hls.config;
    return new uK(e.abrEwmaSlowVoD, e.abrEwmaFastVoD, e.abrEwmaDefaultEstimate);
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e.on(E.MANIFEST_LOADING, this.onManifestLoading, this), e.on(E.FRAG_LOADING, this.onFragLoading, this), e.on(E.FRAG_LOADED, this.onFragLoaded, this), e.on(E.FRAG_BUFFERED, this.onFragBuffered, this), e.on(E.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(E.LEVEL_LOADED, this.onLevelLoaded, this), e.on(E.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(E.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this), e.on(E.ERROR, this.onError, this);
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e && (e.off(E.MANIFEST_LOADING, this.onManifestLoading, this), e.off(E.FRAG_LOADING, this.onFragLoading, this), e.off(E.FRAG_LOADED, this.onFragLoaded, this), e.off(E.FRAG_BUFFERED, this.onFragBuffered, this), e.off(E.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(E.LEVEL_LOADED, this.onLevelLoaded, this), e.off(E.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(E.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this), e.off(E.ERROR, this.onError, this));
  }
  destroy() {
    this.unregisterListeners(), this.clearTimer(), this.hls = this._abandonRulesCheck = this.supportedCache = null, this.fragCurrent = this.partCurrent = null;
  }
  onManifestLoading(e, t) {
    this.lastLoadedFragLevel = -1, this.firstSelection = -1, this.lastLevelLoadSec = 0, this.supportedCache = {}, this.fragCurrent = this.partCurrent = null, this.onLevelsUpdated(), this.clearTimer();
  }
  onLevelsUpdated() {
    this.lastLoadedFragLevel > -1 && this.fragCurrent && (this.lastLoadedFragLevel = this.fragCurrent.level), this._nextAutoLevel = -1, this.onMaxAutoLevelUpdated(), this.codecTiers = null, this.audioTracksByGroup = null;
  }
  onMaxAutoLevelUpdated() {
    this.firstSelection = -1, this.nextAutoLevelKey = "";
  }
  onFragLoading(e, t) {
    const n = t.frag;
    if (!this.ignoreFragment(n)) {
      if (!n.bitrateTest) {
        var i;
        this.fragCurrent = n, this.partCurrent = (i = t.part) != null ? i : null;
      }
      this.clearTimer(), this.timer = self.setInterval(this._abandonRulesCheck, 100);
    }
  }
  onLevelSwitching(e, t) {
    this.clearTimer();
  }
  onError(e, t) {
    if (!t.fatal)
      switch (t.details) {
        case k.BUFFER_ADD_CODEC_ERROR:
        case k.BUFFER_APPEND_ERROR:
          this.lastLoadedFragLevel = -1, this.firstSelection = -1;
          break;
        case k.FRAG_LOAD_TIMEOUT: {
          const n = t.frag, {
            fragCurrent: i,
            partCurrent: s
          } = this;
          if (n && i && n.sn === i.sn && n.level === i.level) {
            const a = performance.now(), o = s ? s.stats : n.stats, c = a - o.loading.start, l = o.loading.first ? o.loading.first - o.loading.start : -1;
            if (o.loaded && l > -1) {
              const d = this.bwEstimator.getEstimateTTFB();
              this.bwEstimator.sample(c - Math.min(d, l), o.loaded);
            } else
              this.bwEstimator.sampleTTFB(c);
          }
          break;
        }
      }
  }
  getTimeToLoadFrag(e, t, n, i) {
    const s = e + n / t, a = i ? e + this.lastLevelLoadSec : 0;
    return s + a;
  }
  onLevelLoaded(e, t) {
    const n = this.hls.config, {
      loading: i
    } = t.stats, s = i.end - i.first;
    X(s) && (this.lastLevelLoadSec = s / 1e3), t.details.live ? this.bwEstimator.update(n.abrEwmaSlowLive, n.abrEwmaFastLive) : this.bwEstimator.update(n.abrEwmaSlowVoD, n.abrEwmaFastVoD), this.timer > -1 && this._abandonRulesCheck(t.levelInfo);
  }
  onFragLoaded(e, {
    frag: t,
    part: n
  }) {
    const i = n ? n.stats : t.stats;
    if (t.type === ee.MAIN && this.bwEstimator.sampleTTFB(i.loading.first - i.loading.start), !this.ignoreFragment(t)) {
      if (this.clearTimer(), t.level === this._nextAutoLevel && (this._nextAutoLevel = -1), this.firstSelection = -1, this.hls.config.abrMaxWithRealBitrate) {
        const s = n ? n.duration : t.duration, a = this.hls.levels[t.level], o = (a.loaded ? a.loaded.bytes : 0) + i.loaded, c = (a.loaded ? a.loaded.duration : 0) + s;
        a.loaded = {
          bytes: o,
          duration: c
        }, a.realBitrate = Math.round(8 * o / c);
      }
      if (t.bitrateTest) {
        const s = {
          stats: i,
          frag: t,
          part: n,
          id: t.type
        };
        this.onFragBuffered(E.FRAG_BUFFERED, s), t.bitrateTest = !1;
      } else
        this.lastLoadedFragLevel = t.level;
    }
  }
  onFragBuffered(e, t) {
    const {
      frag: n,
      part: i
    } = t, s = i != null && i.stats.loaded ? i.stats : n.stats;
    if (s.aborted || this.ignoreFragment(n))
      return;
    const a = s.parsing.end - s.loading.start - Math.min(s.loading.first - s.loading.start, this.bwEstimator.getEstimateTTFB());
    this.bwEstimator.sample(a, s.loaded), s.bwEstimate = this.getBwEstimate(), n.bitrateTest ? this.bitrateTestDelay = a / 1e3 : this.bitrateTestDelay = 0;
  }
  ignoreFragment(e) {
    return e.type !== ee.MAIN || e.sn === "initSegment";
  }
  clearTimer() {
    this.timer > -1 && (self.clearInterval(this.timer), this.timer = -1);
  }
  get firstAutoLevel() {
    const {
      maxAutoLevel: e,
      minAutoLevel: t
    } = this.hls, n = this.getBwEstimate(), i = this.hls.config.maxStarvationDelay, s = this.findBestLevel(n, t, e, 0, i, 1, 1);
    if (s > -1)
      return s;
    const a = this.hls.firstLevel, o = Math.min(Math.max(a, t), e);
    return this.warn(`Could not find best starting auto level. Defaulting to first in playlist ${a} clamped to ${o}`), o;
  }
  get forcedAutoLevel() {
    return this.nextAutoLevelKey ? -1 : this._nextAutoLevel;
  }
  // return next auto level
  get nextAutoLevel() {
    const e = this.forcedAutoLevel, n = this.bwEstimator.canEstimate(), i = this.lastLoadedFragLevel > -1;
    if (e !== -1 && (!n || !i || this.nextAutoLevelKey === this.getAutoLevelKey()))
      return e;
    const s = n && i ? this.getNextABRAutoLevel() : this.firstAutoLevel;
    if (e !== -1) {
      const a = this.hls.levels;
      if (a.length > Math.max(e, s) && a[e].loadError <= a[s].loadError)
        return e;
    }
    return this._nextAutoLevel = s, this.nextAutoLevelKey = this.getAutoLevelKey(), s;
  }
  getAutoLevelKey() {
    return `${this.getBwEstimate()}_${this.getStarvationDelay().toFixed(2)}`;
  }
  getNextABRAutoLevel() {
    const {
      fragCurrent: e,
      partCurrent: t,
      hls: n
    } = this;
    if (n.levels.length <= 1)
      return n.loadLevel;
    const {
      maxAutoLevel: i,
      config: s,
      minAutoLevel: a
    } = n, o = t ? t.duration : e ? e.duration : 0, c = this.getBwEstimate(), l = this.getStarvationDelay();
    let u = s.abrBandWidthFactor, d = s.abrBandWidthUpFactor;
    if (l) {
      const p = this.findBestLevel(c, a, i, l, 0, u, d);
      if (p >= 0)
        return this.rebufferNotice = -1, p;
    }
    let f = o ? Math.min(o, s.maxStarvationDelay) : s.maxStarvationDelay;
    if (!l) {
      const p = this.bitrateTestDelay;
      p && (f = (o ? Math.min(o, s.maxLoadingDelay) : s.maxLoadingDelay) - p, this.info(`bitrate test took ${Math.round(1e3 * p)}ms, set first fragment max fetchDuration to ${Math.round(1e3 * f)} ms`), u = d = 1);
    }
    const h = this.findBestLevel(c, a, i, l, f, u, d);
    if (this.rebufferNotice !== h && (this.rebufferNotice = h, this.info(`${l ? "rebuffering expected" : "buffer is empty"}, optimal quality level ${h}`)), h > -1)
      return h;
    const g = n.levels[a], m = n.loadLevelObj;
    return m && (g == null ? void 0 : g.bitrate) < m.bitrate ? a : n.loadLevel;
  }
  getStarvationDelay() {
    const e = this.hls, t = e.media;
    if (!t)
      return 1 / 0;
    const n = t && t.playbackRate !== 0 ? Math.abs(t.playbackRate) : 1, i = e.mainForwardBufferInfo;
    return (i ? i.len : 0) / n;
  }
  getBwEstimate() {
    return this.bwEstimator.canEstimate() ? this.bwEstimator.getEstimate() : this.hls.config.abrEwmaDefaultEstimate;
  }
  findBestLevel(e, t, n, i, s, a, o) {
    var c;
    const l = i + s, u = this.lastLoadedFragLevel, d = u === -1 ? this.hls.firstLevel : u, {
      fragCurrent: f,
      partCurrent: h
    } = this, {
      levels: g,
      allAudioTracks: m,
      loadLevel: p,
      config: v
    } = this.hls;
    if (g.length === 1)
      return 0;
    const y = g[d], b = !!((c = this.hls.latestLevelDetails) != null && c.live), x = p === -1 || u === -1;
    let S, A = "SDR", T = (y == null ? void 0 : y.frameRate) || 0;
    const {
      audioPreference: I,
      videoPreference: L
    } = v, _ = this.audioTracksByGroup || (this.audioTracksByGroup = YA(m));
    let R = -1;
    if (x) {
      if (this.firstSelection !== -1)
        return this.firstSelection;
      const K = this.codecTiers || (this.codecTiers = QK(g, _, t, n)), G = XK(K, A, e, I, L), {
        codecSet: Y,
        videoRanges: Q,
        minFramerate: H,
        minBitrate: N,
        minIndex: re,
        preferHDR: oe
      } = G;
      R = re, S = Y, A = oe ? Q[Q.length - 1] : Q[0], T = H, e = Math.max(e, N), this.log(`picked start tier ${We(G)}`);
    } else
      S = y == null ? void 0 : y.codecSet, A = y == null ? void 0 : y.videoRange;
    const D = h ? h.duration : f ? f.duration : 0, F = this.bwEstimator.getEstimateTTFB() / 1e3, B = [];
    for (let K = n; K >= t; K--) {
      var j, U;
      const G = g[K], Y = K > d;
      if (!G)
        continue;
      if (v.useMediaCapabilities && !G.supportedResult && !G.supportedPromise) {
        const he = navigator.mediaCapabilities;
        typeof (he == null ? void 0 : he.decodingInfo) == "function" && jK(G, _, A, T, e, I) ? (G.supportedPromise = qA(G, _, he, this.supportedCache), G.supportedPromise.then((Re) => {
          if (!this.hls)
            return;
          G.supportedResult = Re;
          const et = this.hls.levels, q = et.indexOf(G);
          Re.error ? this.warn(`MediaCapabilities decodingInfo error: "${Re.error}" for level ${q} ${We(Re)}`) : Re.supported ? Re.decodingInfoResults.some((ie) => ie.smooth === !1 || ie.powerEfficient === !1) && this.log(`MediaCapabilities decodingInfo for level ${q} not smooth or powerEfficient: ${We(Re)}`) : (this.warn(`Unsupported MediaCapabilities decodingInfo result for level ${q} ${We(Re)}`), q > -1 && et.length > 1 && (this.log(`Removing unsupported level ${q}`), this.hls.removeLevel(q), this.hls.loadLevel === -1 && (this.hls.nextLoadLevel = 0)));
        })) : G.supportedResult = WA;
      }
      if ((S && G.codecSet !== S || A && G.videoRange !== A || Y && T > G.frameRate || !Y && T > 0 && T < G.frameRate || (j = G.supportedResult) != null && (U = j.decodingInfoResults) != null && U.some((he) => he.smooth === !1)) && (!x || K !== R)) {
        B.push(K);
        continue;
      }
      const Q = G.details, H = (h ? Q == null ? void 0 : Q.partTarget : Q == null ? void 0 : Q.averagetargetduration) || D;
      let N;
      Y ? N = o * e : N = a * e;
      const re = D && i >= D * 2 && s === 0 ? G.averageBitrate : G.maxBitrate, oe = this.getTimeToLoadFrag(F, N, re * H, Q === void 0);
      if (
        // if adjusted bw is greater than level bitrate AND
        N >= re && // no level change, or new level has no error history
        (K === u || G.loadError === 0 && G.fragmentError === 0) && // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches
        // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...
        // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that findBestLevel will return -1
        (oe <= F || !X(oe) || b && !this.bitrateTestDelay || oe < l)
      ) {
        const he = this.forcedAutoLevel;
        return K !== p && (he === -1 || he !== p) && (B.length && this.trace(`Skipped level(s) ${B.join(",")} of ${n} max with CODECS and VIDEO-RANGE:"${g[B[0]].codecs}" ${g[B[0]].videoRange}; not compatible with "${S}" ${A}`), this.info(`switch candidate:${d}->${K} adjustedbw(${Math.round(N)})-bitrate=${Math.round(N - re)} ttfb:${F.toFixed(1)} avgDuration:${H.toFixed(1)} maxFetchDuration:${l.toFixed(1)} fetchDuration:${oe.toFixed(1)} firstSelection:${x} codecSet:${G.codecSet} videoRange:${G.videoRange} hls.loadLevel:${p}`)), x && (this.firstSelection = K), K;
      }
    }
    return -1;
  }
  set nextAutoLevel(e) {
    const t = this.deriveNextAutoLevel(e);
    this._nextAutoLevel !== t && (this.nextAutoLevelKey = "", this._nextAutoLevel = t);
  }
  deriveNextAutoLevel(e) {
    const {
      maxAutoLevel: t,
      minAutoLevel: n
    } = this.hls;
    return Math.min(Math.max(e, n), t);
  }
}
const XA = {
  /**
   * Searches for an item in an array which matches a certain condition.
   * This requires the condition to only match one item in the array,
   * and for the array to be ordered.
   *
   * @param list The array to search.
   * @param comparisonFn
   *      Called and provided a candidate item as the first argument.
   *      Should return:
   *          > -1 if the item should be located at a lower index than the provided item.
   *          > 1 if the item should be located at a higher index than the provided item.
   *          > 0 if the item is the item you're looking for.
   *
   * @returns the object if found, otherwise returns null
   */
  search: function(r, e) {
    let t = 0, n = r.length - 1, i = null, s = null;
    for (; t <= n; ) {
      i = (t + n) / 2 | 0, s = r[i];
      const a = e(s);
      if (a > 0)
        t = i + 1;
      else if (a < 0)
        n = i - 1;
      else
        return s;
    }
    return null;
  }
};
function r3(r, e, t) {
  if (e === null || !Array.isArray(r) || !r.length || !X(e))
    return null;
  const n = r[0].programDateTime;
  if (e < (n || 0))
    return null;
  const i = r[r.length - 1].endProgramDateTime;
  if (e >= (i || 0))
    return null;
  for (let s = 0; s < r.length; ++s) {
    const a = r[s];
    if (i3(e, t, a))
      return a;
  }
  return null;
}
function mi(r, e, t = 0, n = 0, i = 5e-3) {
  let s = null;
  if (r) {
    s = e[1 + r.sn - e[0].sn] || null;
    const o = r.endDTS - t;
    o > 0 && o < 15e-7 && (t += 15e-7), s && r.level !== s.level && s.end <= r.end && (s = e[2 + r.sn - e[0].sn] || null);
  } else t === 0 && e[0].start === 0 && (s = e[0]);
  if (s && ((!r || r.level === s.level) && Uy(t, n, s) === 0 || n3(s, r, Math.min(i, n))))
    return s;
  const a = XA.search(e, Uy.bind(null, t, n));
  return a && (a !== r || !s) ? a : s;
}
function n3(r, e, t) {
  if (e && e.start === 0 && e.level < r.level && (e.endPTS || 0) > 0) {
    const n = e.tagList.reduce((i, s) => (s[0] === "INF" && (i += parseFloat(s[1])), i), t);
    return r.start <= n;
  }
  return !1;
}
function Uy(r = 0, e = 0, t) {
  if (t.start <= r && t.start + t.duration > r)
    return 0;
  const n = Math.min(e, t.duration + (t.deltaPTS ? t.deltaPTS : 0));
  return t.start + t.duration - n <= r ? 1 : t.start - n > r && t.start ? -1 : 0;
}
function i3(r, e, t) {
  const n = Math.min(e, t.duration + (t.deltaPTS ? t.deltaPTS : 0)) * 1e3;
  return (t.endProgramDateTime || 0) - n > r;
}
function QA(r, e, t) {
  if (r && r.startCC <= e && r.endCC >= e) {
    let n = r.fragments;
    const {
      fragmentHint: i
    } = r;
    i && (n = n.concat(i));
    let s;
    return XA.search(n, (a) => a.cc < e ? 1 : a.cc > e ? -1 : (s = a, a.end <= t ? 1 : a.start > t ? -1 : 0)), s || null;
  }
  return null;
}
function cl(r) {
  switch (r.details) {
    case k.FRAG_LOAD_TIMEOUT:
    case k.KEY_LOAD_TIMEOUT:
    case k.LEVEL_LOAD_TIMEOUT:
    case k.MANIFEST_LOAD_TIMEOUT:
      return !0;
  }
  return !1;
}
function Gy(r, e) {
  const t = cl(e);
  return r.default[`${t ? "timeout" : "error"}Retry`];
}
function Vg(r, e) {
  const t = r.backoff === "linear" ? 1 : Math.pow(2, e);
  return Math.min(t * r.retryDelayMs, r.maxRetryDelayMs);
}
function Ky(r) {
  return Ne(Ne({}, r), {
    errorRetry: null,
    timeoutRetry: null
  });
}
function ul(r, e, t, n) {
  if (!r)
    return !1;
  const i = n == null ? void 0 : n.code, s = e < r.maxNumRetry && (s3(i) || !!t);
  return r.shouldRetry ? r.shouldRetry(r, e, t, n, s) : s;
}
function s3(r) {
  return r === 0 && navigator.onLine === !1 || !!r && (r < 400 || r > 499);
}
var Pt = {
  DoNothing: 0,
  SendAlternateToPenaltyBox: 2,
  RemoveAlternatePermanently: 3,
  RetryRequest: 5
}, Ar = {
  None: 0,
  MoveAllAlternatesMatchingHost: 1,
  MoveAllAlternatesMatchingHDCP: 2
};
class a3 extends Or {
  constructor(e) {
    super("error-controller", e.logger), this.hls = void 0, this.playlistError = 0, this.penalizedRenditions = {}, this.hls = e, this.registerListeners();
  }
  registerListeners() {
    const e = this.hls;
    e.on(E.ERROR, this.onError, this), e.on(E.MANIFEST_LOADING, this.onManifestLoading, this), e.on(E.LEVEL_UPDATED, this.onLevelUpdated, this);
  }
  unregisterListeners() {
    const e = this.hls;
    e && (e.off(E.ERROR, this.onError, this), e.off(E.ERROR, this.onErrorOut, this), e.off(E.MANIFEST_LOADING, this.onManifestLoading, this), e.off(E.LEVEL_UPDATED, this.onLevelUpdated, this));
  }
  destroy() {
    this.unregisterListeners(), this.hls = null, this.penalizedRenditions = {};
  }
  startLoad(e) {
  }
  stopLoad() {
    this.playlistError = 0;
  }
  getVariantLevelIndex(e) {
    return (e == null ? void 0 : e.type) === ee.MAIN ? e.level : this.hls.loadLevel;
  }
  onManifestLoading() {
    this.playlistError = 0, this.penalizedRenditions = {};
  }
  onLevelUpdated() {
    this.playlistError = 0;
  }
  onError(e, t) {
    var n;
    if (t.fatal)
      return;
    const i = this.hls, s = t.context;
    switch (t.details) {
      case k.FRAG_LOAD_ERROR:
      case k.FRAG_LOAD_TIMEOUT:
      case k.KEY_LOAD_ERROR:
      case k.KEY_LOAD_TIMEOUT:
        t.errorAction = this.getFragRetryOrSwitchAction(t);
        return;
      case k.FRAG_PARSING_ERROR:
        if ((n = t.frag) != null && n.gap) {
          t.errorAction = ra();
          return;
        }
      // falls through
      case k.FRAG_GAP:
      case k.FRAG_DECRYPT_ERROR: {
        t.errorAction = this.getFragRetryOrSwitchAction(t), t.errorAction.action = Pt.SendAlternateToPenaltyBox;
        return;
      }
      case k.LEVEL_EMPTY_ERROR:
      case k.LEVEL_PARSING_ERROR:
        {
          var a, o;
          const l = t.parent === ee.MAIN ? t.level : i.loadLevel;
          t.details === k.LEVEL_EMPTY_ERROR && ((a = t.context) != null && (o = a.levelDetails) != null && o.live) ? t.errorAction = this.getPlaylistRetryOrSwitchAction(t, l) : (t.levelRetry = !1, t.errorAction = this.getLevelSwitchAction(t, l));
        }
        return;
      case k.LEVEL_LOAD_ERROR:
      case k.LEVEL_LOAD_TIMEOUT:
        typeof (s == null ? void 0 : s.level) == "number" && (t.errorAction = this.getPlaylistRetryOrSwitchAction(t, s.level));
        return;
      case k.AUDIO_TRACK_LOAD_ERROR:
      case k.AUDIO_TRACK_LOAD_TIMEOUT:
      case k.SUBTITLE_LOAD_ERROR:
      case k.SUBTITLE_TRACK_LOAD_TIMEOUT:
        if (s) {
          const l = i.loadLevelObj;
          if (l && (s.type === me.AUDIO_TRACK && l.hasAudioGroup(s.groupId) || s.type === me.SUBTITLE_TRACK && l.hasSubtitleGroup(s.groupId))) {
            t.errorAction = this.getPlaylistRetryOrSwitchAction(t, i.loadLevel), t.errorAction.action = Pt.SendAlternateToPenaltyBox, t.errorAction.flags = Ar.MoveAllAlternatesMatchingHost;
            return;
          }
        }
        return;
      case k.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED:
        {
          const l = i.loadLevelObj, u = l == null ? void 0 : l.attrs["HDCP-LEVEL"];
          u ? t.errorAction = {
            action: Pt.SendAlternateToPenaltyBox,
            flags: Ar.MoveAllAlternatesMatchingHDCP,
            hdcpLevel: u
          } : this.keySystemError(t);
        }
        return;
      case k.BUFFER_ADD_CODEC_ERROR:
      case k.REMUX_ALLOC_ERROR:
      case k.BUFFER_APPEND_ERROR:
        if (!t.errorAction) {
          var c;
          t.errorAction = this.getLevelSwitchAction(t, (c = t.level) != null ? c : i.loadLevel);
        }
        return;
      case k.INTERNAL_EXCEPTION:
      case k.BUFFER_APPENDING_ERROR:
      case k.BUFFER_FULL_ERROR:
      case k.LEVEL_SWITCH_ERROR:
      case k.BUFFER_STALLED_ERROR:
      case k.BUFFER_SEEK_OVER_HOLE:
      case k.BUFFER_NUDGE_ON_STALL:
        t.errorAction = ra();
        return;
    }
    t.type === ne.KEY_SYSTEM_ERROR && this.keySystemError(t);
  }
  keySystemError(e) {
    const t = this.getVariantLevelIndex(e.frag);
    e.levelRetry = !1, e.errorAction = this.getLevelSwitchAction(e, t);
  }
  getPlaylistRetryOrSwitchAction(e, t) {
    const n = this.hls, i = Gy(n.config.playlistLoadPolicy, e), s = this.playlistError++;
    if (ul(i, s, cl(e), e.response))
      return {
        action: Pt.RetryRequest,
        flags: Ar.None,
        retryConfig: i,
        retryCount: s
      };
    const o = this.getLevelSwitchAction(e, t);
    return i && (o.retryConfig = i, o.retryCount = s), o;
  }
  getFragRetryOrSwitchAction(e) {
    const t = this.hls, n = this.getVariantLevelIndex(e.frag), i = t.levels[n], {
      fragLoadPolicy: s,
      keyLoadPolicy: a
    } = t.config, o = Gy(e.details.startsWith("key") ? a : s, e), c = t.levels.reduce((u, d) => u + d.fragmentError, 0);
    if (i && (e.details !== k.FRAG_GAP && i.fragmentError++, ul(o, c, cl(e), e.response)))
      return {
        action: Pt.RetryRequest,
        flags: Ar.None,
        retryConfig: o,
        retryCount: c
      };
    const l = this.getLevelSwitchAction(e, n);
    return o && (l.retryConfig = o, l.retryCount = c), l;
  }
  getLevelSwitchAction(e, t) {
    const n = this.hls;
    t == null && (t = n.loadLevel);
    const i = this.hls.levels[t];
    if (i) {
      var s, a;
      const l = e.details;
      i.loadError++, l === k.BUFFER_APPEND_ERROR && i.fragmentError++;
      let u = -1;
      const {
        levels: d,
        loadLevel: f,
        minAutoLevel: h,
        maxAutoLevel: g
      } = n;
      !n.autoLevelEnabled && !n.config.preserveManualLevelOnError && (n.loadLevel = -1);
      const m = (s = e.frag) == null ? void 0 : s.type, v = (m === ee.AUDIO && l === k.FRAG_PARSING_ERROR || e.sourceBufferName === "audio" && (l === k.BUFFER_ADD_CODEC_ERROR || l === k.BUFFER_APPEND_ERROR)) && d.some(({
        audioCodec: A
      }) => i.audioCodec !== A), b = e.sourceBufferName === "video" && (l === k.BUFFER_ADD_CODEC_ERROR || l === k.BUFFER_APPEND_ERROR) && d.some(({
        codecSet: A,
        audioCodec: T
      }) => i.codecSet !== A && i.audioCodec === T), {
        type: x,
        groupId: S
      } = (a = e.context) != null ? a : {};
      for (let A = d.length; A--; ) {
        const T = (A + f) % d.length;
        if (T !== f && T >= h && T <= g && d[T].loadError === 0) {
          var o, c;
          const I = d[T];
          if (l === k.FRAG_GAP && m === ee.MAIN && e.frag) {
            const L = d[T].details;
            if (L) {
              const _ = mi(e.frag, L.fragments, e.frag.start);
              if (_ != null && _.gap)
                continue;
            }
          } else {
            if (x === me.AUDIO_TRACK && I.hasAudioGroup(S) || x === me.SUBTITLE_TRACK && I.hasSubtitleGroup(S))
              continue;
            if (m === ee.AUDIO && (o = i.audioGroups) != null && o.some((L) => I.hasAudioGroup(L)) || m === ee.SUBTITLE && (c = i.subtitleGroups) != null && c.some((L) => I.hasSubtitleGroup(L)) || v && i.audioCodec === I.audioCodec || !v && i.audioCodec !== I.audioCodec || b && i.codecSet === I.codecSet)
              continue;
          }
          u = T;
          break;
        }
      }
      if (u > -1 && n.loadLevel !== u)
        return e.levelRetry = !0, this.playlistError = 0, {
          action: Pt.SendAlternateToPenaltyBox,
          flags: Ar.None,
          nextAutoLevel: u
        };
    }
    return {
      action: Pt.SendAlternateToPenaltyBox,
      flags: Ar.MoveAllAlternatesMatchingHost
    };
  }
  onErrorOut(e, t) {
    var n;
    switch ((n = t.errorAction) == null ? void 0 : n.action) {
      case Pt.DoNothing:
        break;
      case Pt.SendAlternateToPenaltyBox:
        this.sendAlternateToPenaltyBox(t), !t.errorAction.resolved && t.details !== k.FRAG_GAP ? t.fatal = !0 : /MediaSource readyState: ended/.test(t.error.message) && (this.warn(`MediaSource ended after "${t.sourceBufferName}" sourceBuffer append error. Attempting to recover from media error.`), this.hls.recoverMediaError());
        break;
    }
    if (t.fatal) {
      this.hls.stopLoad();
      return;
    }
  }
  sendAlternateToPenaltyBox(e) {
    const t = this.hls, n = e.errorAction;
    if (!n)
      return;
    const {
      flags: i,
      hdcpLevel: s,
      nextAutoLevel: a
    } = n;
    switch (i) {
      case Ar.None:
        this.switchLevel(e, a);
        break;
      case Ar.MoveAllAlternatesMatchingHDCP:
        s && (t.maxHdcpLevel = yf[yf.indexOf(s) - 1], n.resolved = !0), this.warn(`Restricting playback to HDCP-LEVEL of "${t.maxHdcpLevel}" or lower`);
        break;
    }
    n.resolved || this.switchLevel(e, a);
  }
  switchLevel(e, t) {
    if (t !== void 0 && e.errorAction && (this.warn(`switching to level ${t} after ${e.details}`), this.hls.nextAutoLevel = t, e.errorAction.resolved = !0, this.hls.nextLoadLevel = this.hls.nextAutoLevel, e.details === k.BUFFER_ADD_CODEC_ERROR && e.mimeType && e.sourceBufferName !== "audiovideo")) {
      const n = vf(e.mimeType), i = this.hls.levels;
      for (let s = i.length; s--; )
        i[s][`${e.sourceBufferName}Codec`] === n && this.hls.removeLevel(s);
    }
  }
}
function ra(r) {
  const e = {
    action: Pt.DoNothing,
    flags: Ar.None
  };
  return r && (e.resolved = !0), e;
}
var ct = {
  NOT_LOADED: "NOT_LOADED",
  APPENDING: "APPENDING",
  PARTIAL: "PARTIAL",
  OK: "OK"
};
class o3 {
  constructor(e) {
    this.activePartLists = /* @__PURE__ */ Object.create(null), this.endListFragments = /* @__PURE__ */ Object.create(null), this.fragments = /* @__PURE__ */ Object.create(null), this.timeRanges = /* @__PURE__ */ Object.create(null), this.bufferPadding = 0.2, this.hls = void 0, this.hasGaps = !1, this.hls = e, this._registerListeners();
  }
  _registerListeners() {
    const {
      hls: e
    } = this;
    e.on(E.MANIFEST_LOADING, this.onManifestLoading, this), e.on(E.BUFFER_APPENDED, this.onBufferAppended, this), e.on(E.FRAG_BUFFERED, this.onFragBuffered, this), e.on(E.FRAG_LOADED, this.onFragLoaded, this);
  }
  _unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off(E.MANIFEST_LOADING, this.onManifestLoading, this), e.off(E.BUFFER_APPENDED, this.onBufferAppended, this), e.off(E.FRAG_BUFFERED, this.onFragBuffered, this), e.off(E.FRAG_LOADED, this.onFragLoaded, this);
  }
  destroy() {
    this._unregisterListeners(), this.fragments = // @ts-ignore
    this.activePartLists = // @ts-ignore
    this.endListFragments = this.timeRanges = null;
  }
  /**
   * Return a Fragment or Part with an appended range that matches the position and levelType
   * Otherwise, return null
   */
  getAppendedFrag(e, t) {
    const n = this.activePartLists[t];
    if (n)
      for (let i = n.length; i--; ) {
        const s = n[i];
        if (!s)
          break;
        const a = s.end;
        if (s.start <= e && a !== null && e <= a)
          return s;
      }
    return this.getBufferedFrag(e, t);
  }
  /**
   * Return a buffered Fragment that matches the position and levelType.
   * A buffered Fragment is one whose loading, parsing and appending is done (completed or "partial" meaning aborted).
   * If not found any Fragment, return null
   */
  getBufferedFrag(e, t) {
    return this.getFragAtPos(e, t, !0);
  }
  getFragAtPos(e, t, n) {
    const {
      fragments: i
    } = this, s = Object.keys(i);
    for (let a = s.length; a--; ) {
      const o = i[s[a]];
      if ((o == null ? void 0 : o.body.type) === t && (!n || o.buffered)) {
        const c = o.body;
        if (c.start <= e && e <= c.end)
          return c;
      }
    }
    return null;
  }
  /**
   * Partial fragments effected by coded frame eviction will be removed
   * The browser will unload parts of the buffer to free up memory for new buffer data
   * Fragments will need to be reloaded when the buffer is freed up, removing partial fragments will allow them to reload(since there might be parts that are still playable)
   */
  detectEvictedFragments(e, t, n, i, s) {
    this.timeRanges && (this.timeRanges[e] = t);
    const a = (i == null ? void 0 : i.fragment.sn) || -1;
    Object.keys(this.fragments).forEach((o) => {
      const c = this.fragments[o];
      if (!c || a >= c.body.sn)
        return;
      if (!c.buffered && (!c.loaded || s)) {
        c.body.type === n && this.removeFragment(c.body);
        return;
      }
      const l = c.range[e];
      if (l) {
        if (l.time.length === 0) {
          this.removeFragment(c.body);
          return;
        }
        l.time.some((u) => {
          const d = !this.isTimeBuffered(u.startPTS, u.endPTS, t);
          return d && this.removeFragment(c.body), d;
        });
      }
    });
  }
  /**
   * Checks if the fragment passed in is loaded in the buffer properly
   * Partially loaded fragments will be registered as a partial fragment
   */
  detectPartialFragments(e) {
    const t = this.timeRanges;
    if (!t || e.frag.sn === "initSegment")
      return;
    const n = e.frag, i = _i(n), s = this.fragments[i];
    if (!s || s.buffered && n.gap)
      return;
    const a = !n.relurl;
    Object.keys(t).forEach((o) => {
      const c = n.elementaryStreams[o];
      if (!c)
        return;
      const l = t[o], u = a || c.partial === !0;
      s.range[o] = this.getBufferedTimes(n, e.part, u, l);
    }), s.loaded = null, Object.keys(s.range).length ? (s.buffered = !0, (s.body.endList = n.endList || s.body.endList) && (this.endListFragments[s.body.type] = s), to(s) || this.removeParts(n.sn - 1, n.type)) : this.removeFragment(s.body);
  }
  removeParts(e, t) {
    const n = this.activePartLists[t];
    n && (this.activePartLists[t] = Vy(n, (i) => i.fragment.sn >= e));
  }
  fragBuffered(e, t) {
    const n = _i(e);
    let i = this.fragments[n];
    !i && t && (i = this.fragments[n] = {
      body: e,
      appendedPTS: null,
      loaded: null,
      buffered: !1,
      range: /* @__PURE__ */ Object.create(null)
    }, e.gap && (this.hasGaps = !0)), i && (i.loaded = null, i.buffered = !0);
  }
  getBufferedTimes(e, t, n, i) {
    const s = {
      time: [],
      partial: n
    }, a = e.start, o = e.end, c = e.minEndPTS || o, l = e.maxStartPTS || a;
    for (let u = 0; u < i.length; u++) {
      const d = i.start(u) - this.bufferPadding, f = i.end(u) + this.bufferPadding;
      if (l >= d && c <= f) {
        s.time.push({
          startPTS: Math.max(a, i.start(u)),
          endPTS: Math.min(o, i.end(u))
        });
        break;
      } else if (a < f && o > d) {
        const h = Math.max(a, i.start(u)), g = Math.min(o, i.end(u));
        g > h && (s.partial = !0, s.time.push({
          startPTS: h,
          endPTS: g
        }));
      } else if (o <= d)
        break;
    }
    return s;
  }
  /**
   * Gets the partial fragment for a certain time
   */
  getPartialFragment(e) {
    let t = null, n, i, s, a = 0;
    const {
      bufferPadding: o,
      fragments: c
    } = this;
    return Object.keys(c).forEach((l) => {
      const u = c[l];
      u && to(u) && (i = u.body.start - o, s = u.body.end + o, e >= i && e <= s && (n = Math.min(e - i, s - e), a <= n && (t = u.body, a = n)));
    }), t;
  }
  isEndListAppended(e) {
    const t = this.endListFragments[e];
    return t !== void 0 && (t.buffered || to(t));
  }
  getState(e) {
    const t = _i(e), n = this.fragments[t];
    return n ? n.buffered ? to(n) ? ct.PARTIAL : ct.OK : ct.APPENDING : ct.NOT_LOADED;
  }
  isTimeBuffered(e, t, n) {
    let i, s;
    for (let a = 0; a < n.length; a++) {
      if (i = n.start(a) - this.bufferPadding, s = n.end(a) + this.bufferPadding, e >= i && t <= s)
        return !0;
      if (t <= i)
        return !1;
    }
    return !1;
  }
  onManifestLoading() {
    this.removeAllFragments();
  }
  onFragLoaded(e, t) {
    if (t.frag.sn === "initSegment" || t.frag.bitrateTest)
      return;
    const n = t.frag, i = t.part ? null : t, s = _i(n);
    this.fragments[s] = {
      body: n,
      appendedPTS: null,
      loaded: i,
      buffered: !1,
      range: /* @__PURE__ */ Object.create(null)
    };
  }
  onBufferAppended(e, t) {
    const {
      frag: n,
      part: i,
      timeRanges: s,
      type: a
    } = t;
    if (n.sn === "initSegment")
      return;
    const o = n.type;
    if (i) {
      let l = this.activePartLists[o];
      l || (this.activePartLists[o] = l = []), l.push(i);
    }
    this.timeRanges = s;
    const c = s[a];
    this.detectEvictedFragments(a, c, o, i);
  }
  onFragBuffered(e, t) {
    this.detectPartialFragments(t);
  }
  hasFragment(e) {
    const t = _i(e);
    return !!this.fragments[t];
  }
  hasFragments(e) {
    const {
      fragments: t
    } = this, n = Object.keys(t);
    if (!e)
      return n.length > 0;
    for (let i = n.length; i--; ) {
      const s = t[n[i]];
      if ((s == null ? void 0 : s.body.type) === e)
        return !0;
    }
    return !1;
  }
  hasParts(e) {
    var t;
    return !!((t = this.activePartLists[e]) != null && t.length);
  }
  removeFragmentsInRange(e, t, n, i, s) {
    i && !this.hasGaps || Object.keys(this.fragments).forEach((a) => {
      const o = this.fragments[a];
      if (!o)
        return;
      const c = o.body;
      c.type !== n || i && !c.gap || c.start < t && c.end > e && (o.buffered || s) && this.removeFragment(c);
    });
  }
  removeFragment(e) {
    const t = _i(e);
    e.clearElementaryStreamInfo();
    const n = this.activePartLists[e.type];
    if (n) {
      const i = e.sn;
      this.activePartLists[e.type] = Vy(n, (s) => s.fragment.sn !== i);
    }
    delete this.fragments[t], e.endList && delete this.endListFragments[e.type];
  }
  removeAllFragments() {
    var e, t;
    this.fragments = /* @__PURE__ */ Object.create(null), this.endListFragments = /* @__PURE__ */ Object.create(null), this.activePartLists = /* @__PURE__ */ Object.create(null), this.hasGaps = !1;
    const n = (e = this.hls) == null || (t = e.latestLevelDetails) == null ? void 0 : t.partList;
    n && n.forEach((i) => i.clearElementaryStreamInfo());
  }
}
function to(r) {
  var e, t, n;
  return r.buffered && (r.body.gap || ((e = r.range.video) == null ? void 0 : e.partial) || ((t = r.range.audio) == null ? void 0 : t.partial) || ((n = r.range.audiovideo) == null ? void 0 : n.partial));
}
function _i(r) {
  return `${r.type}_${r.level}_${r.sn}`;
}
function Vy(r, e) {
  return r.filter((t) => {
    const n = e(t);
    return n || t.clearElementaryStreamInfo(), n;
  });
}
var Fn = {
  cbc: 0,
  ctr: 1
};
class l3 {
  constructor(e, t, n) {
    this.subtle = void 0, this.aesIV = void 0, this.aesMode = void 0, this.subtle = e, this.aesIV = t, this.aesMode = n;
  }
  decrypt(e, t) {
    switch (this.aesMode) {
      case Fn.cbc:
        return this.subtle.decrypt({
          name: "AES-CBC",
          iv: this.aesIV
        }, t, e);
      case Fn.ctr:
        return this.subtle.decrypt(
          {
            name: "AES-CTR",
            counter: this.aesIV,
            length: 64
          },
          //64 : NIST SP800-38A standard suggests that the counter should occupy half of the counter block
          t,
          e
        );
      default:
        throw new Error(`[AESCrypto] invalid aes mode ${this.aesMode}`);
    }
  }
}
function c3(r) {
  const e = r.byteLength, t = e && new DataView(r.buffer).getUint8(e - 1);
  return t ? r.slice(0, e - t) : r;
}
class u3 {
  constructor() {
    this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.sBox = new Uint32Array(256), this.invSBox = new Uint32Array(256), this.key = new Uint32Array(0), this.ksRows = 0, this.keySize = 0, this.keySchedule = void 0, this.invKeySchedule = void 0, this.initTable();
  }
  // Using view.getUint32() also swaps the byte order.
  uint8ArrayToUint32Array_(e) {
    const t = new DataView(e), n = new Uint32Array(4);
    for (let i = 0; i < 4; i++)
      n[i] = t.getUint32(i * 4);
    return n;
  }
  initTable() {
    const e = this.sBox, t = this.invSBox, n = this.subMix, i = n[0], s = n[1], a = n[2], o = n[3], c = this.invSubMix, l = c[0], u = c[1], d = c[2], f = c[3], h = new Uint32Array(256);
    let g = 0, m = 0, p = 0;
    for (p = 0; p < 256; p++)
      p < 128 ? h[p] = p << 1 : h[p] = p << 1 ^ 283;
    for (p = 0; p < 256; p++) {
      let v = m ^ m << 1 ^ m << 2 ^ m << 3 ^ m << 4;
      v = v >>> 8 ^ v & 255 ^ 99, e[g] = v, t[v] = g;
      const y = h[g], b = h[y], x = h[b];
      let S = h[v] * 257 ^ v * 16843008;
      i[g] = S << 24 | S >>> 8, s[g] = S << 16 | S >>> 16, a[g] = S << 8 | S >>> 24, o[g] = S, S = x * 16843009 ^ b * 65537 ^ y * 257 ^ g * 16843008, l[v] = S << 24 | S >>> 8, u[v] = S << 16 | S >>> 16, d[v] = S << 8 | S >>> 24, f[v] = S, g ? (g = y ^ h[h[h[x ^ y]]], m ^= h[h[m]]) : g = m = 1;
    }
  }
  expandKey(e) {
    const t = this.uint8ArrayToUint32Array_(e);
    let n = !0, i = 0;
    for (; i < t.length && n; )
      n = t[i] === this.key[i], i++;
    if (n)
      return;
    this.key = t;
    const s = this.keySize = t.length;
    if (s !== 4 && s !== 6 && s !== 8)
      throw new Error("Invalid aes key size=" + s);
    const a = this.ksRows = (s + 6 + 1) * 4;
    let o, c;
    const l = this.keySchedule = new Uint32Array(a), u = this.invKeySchedule = new Uint32Array(a), d = this.sBox, f = this.rcon, h = this.invSubMix, g = h[0], m = h[1], p = h[2], v = h[3];
    let y, b;
    for (o = 0; o < a; o++) {
      if (o < s) {
        y = l[o] = t[o];
        continue;
      }
      b = y, o % s === 0 ? (b = b << 8 | b >>> 24, b = d[b >>> 24] << 24 | d[b >>> 16 & 255] << 16 | d[b >>> 8 & 255] << 8 | d[b & 255], b ^= f[o / s | 0] << 24) : s > 6 && o % s === 4 && (b = d[b >>> 24] << 24 | d[b >>> 16 & 255] << 16 | d[b >>> 8 & 255] << 8 | d[b & 255]), l[o] = y = (l[o - s] ^ b) >>> 0;
    }
    for (c = 0; c < a; c++)
      o = a - c, c & 3 ? b = l[o] : b = l[o - 4], c < 4 || o <= 4 ? u[c] = b : u[c] = g[d[b >>> 24]] ^ m[d[b >>> 16 & 255]] ^ p[d[b >>> 8 & 255]] ^ v[d[b & 255]], u[c] = u[c] >>> 0;
  }
  // Adding this as a method greatly improves performance.
  networkToHostOrderSwap(e) {
    return e << 24 | (e & 65280) << 8 | (e & 16711680) >> 8 | e >>> 24;
  }
  decrypt(e, t, n) {
    const i = this.keySize + 6, s = this.invKeySchedule, a = this.invSBox, o = this.invSubMix, c = o[0], l = o[1], u = o[2], d = o[3], f = this.uint8ArrayToUint32Array_(n);
    let h = f[0], g = f[1], m = f[2], p = f[3];
    const v = new Int32Array(e), y = new Int32Array(v.length);
    let b, x, S, A, T, I, L, _, R, D, F, B, j, U;
    const K = this.networkToHostOrderSwap;
    for (; t < v.length; ) {
      for (R = K(v[t]), D = K(v[t + 1]), F = K(v[t + 2]), B = K(v[t + 3]), T = R ^ s[0], I = B ^ s[1], L = F ^ s[2], _ = D ^ s[3], j = 4, U = 1; U < i; U++)
        b = c[T >>> 24] ^ l[I >> 16 & 255] ^ u[L >> 8 & 255] ^ d[_ & 255] ^ s[j], x = c[I >>> 24] ^ l[L >> 16 & 255] ^ u[_ >> 8 & 255] ^ d[T & 255] ^ s[j + 1], S = c[L >>> 24] ^ l[_ >> 16 & 255] ^ u[T >> 8 & 255] ^ d[I & 255] ^ s[j + 2], A = c[_ >>> 24] ^ l[T >> 16 & 255] ^ u[I >> 8 & 255] ^ d[L & 255] ^ s[j + 3], T = b, I = x, L = S, _ = A, j = j + 4;
      b = a[T >>> 24] << 24 ^ a[I >> 16 & 255] << 16 ^ a[L >> 8 & 255] << 8 ^ a[_ & 255] ^ s[j], x = a[I >>> 24] << 24 ^ a[L >> 16 & 255] << 16 ^ a[_ >> 8 & 255] << 8 ^ a[T & 255] ^ s[j + 1], S = a[L >>> 24] << 24 ^ a[_ >> 16 & 255] << 16 ^ a[T >> 8 & 255] << 8 ^ a[I & 255] ^ s[j + 2], A = a[_ >>> 24] << 24 ^ a[T >> 16 & 255] << 16 ^ a[I >> 8 & 255] << 8 ^ a[L & 255] ^ s[j + 3], y[t] = K(b ^ h), y[t + 1] = K(A ^ g), y[t + 2] = K(S ^ m), y[t + 3] = K(x ^ p), h = R, g = D, m = F, p = B, t = t + 4;
    }
    return y.buffer;
  }
}
class d3 {
  constructor(e, t, n) {
    this.subtle = void 0, this.key = void 0, this.aesMode = void 0, this.subtle = e, this.key = t, this.aesMode = n;
  }
  expandKey() {
    const e = f3(this.aesMode);
    return this.subtle.importKey("raw", this.key, {
      name: e
    }, !1, ["encrypt", "decrypt"]);
  }
}
function f3(r) {
  switch (r) {
    case Fn.cbc:
      return "AES-CBC";
    case Fn.ctr:
      return "AES-CTR";
    default:
      throw new Error(`[FastAESKey] invalid aes mode ${r}`);
  }
}
const h3 = 16;
class Wg {
  constructor(e, {
    removePKCS7Padding: t = !0
  } = {}) {
    if (this.logEnabled = !0, this.removePKCS7Padding = void 0, this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null, this.useSoftware = void 0, this.enableSoftwareAES = void 0, this.enableSoftwareAES = e.enableSoftwareAES, this.removePKCS7Padding = t, t)
      try {
        const n = self.crypto;
        n && (this.subtle = n.subtle || n.webkitSubtle);
      } catch {
      }
    this.useSoftware = !this.subtle;
  }
  destroy() {
    this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null;
  }
  isSync() {
    return this.useSoftware;
  }
  flush() {
    const {
      currentResult: e,
      remainderData: t
    } = this;
    if (!e || t)
      return this.reset(), null;
    const n = new Uint8Array(e);
    return this.reset(), this.removePKCS7Padding ? c3(n) : n;
  }
  reset() {
    this.currentResult = null, this.currentIV = null, this.remainderData = null, this.softwareDecrypter && (this.softwareDecrypter = null);
  }
  decrypt(e, t, n, i) {
    return this.useSoftware ? new Promise((s, a) => {
      const o = ArrayBuffer.isView(e) ? e : new Uint8Array(e);
      this.softwareDecrypt(o, t, n, i);
      const c = this.flush();
      c ? s(c.buffer) : a(new Error("[softwareDecrypt] Failed to decrypt data"));
    }) : this.webCryptoDecrypt(new Uint8Array(e), t, n, i);
  }
  // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached
  // data is handled in the flush() call
  softwareDecrypt(e, t, n, i) {
    const {
      currentIV: s,
      currentResult: a,
      remainderData: o
    } = this;
    if (i !== Fn.cbc || t.byteLength !== 16)
      return Ae.warn("SoftwareDecrypt: can only handle AES-128-CBC"), null;
    this.logOnce("JS AES decrypt"), o && (e = yr(o, e), this.remainderData = null);
    const c = this.getValidChunk(e);
    if (!c.length)
      return null;
    s && (n = s);
    let l = this.softwareDecrypter;
    l || (l = this.softwareDecrypter = new u3()), l.expandKey(t);
    const u = a;
    return this.currentResult = l.decrypt(c.buffer, 0, n), this.currentIV = c.slice(-16).buffer, u || null;
  }
  webCryptoDecrypt(e, t, n, i) {
    if (this.key !== t || !this.fastAesKey) {
      if (!this.subtle)
        return Promise.resolve(this.onWebCryptoError(e, t, n, i));
      this.key = t, this.fastAesKey = new d3(this.subtle, t, i);
    }
    return this.fastAesKey.expandKey().then((s) => this.subtle ? (this.logOnce("WebCrypto AES decrypt"), new l3(this.subtle, new Uint8Array(n), i).decrypt(e.buffer, s)) : Promise.reject(new Error("web crypto not initialized"))).catch((s) => (Ae.warn(`[decrypter]: WebCrypto Error, disable WebCrypto API, ${s.name}: ${s.message}`), this.onWebCryptoError(e, t, n, i)));
  }
  onWebCryptoError(e, t, n, i) {
    const s = this.enableSoftwareAES;
    if (s) {
      this.useSoftware = !0, this.logEnabled = !0, this.softwareDecrypt(e, t, n, i);
      const a = this.flush();
      if (a)
        return a.buffer;
    }
    throw new Error("WebCrypto" + (s ? " and softwareDecrypt" : "") + ": failed to decrypt data");
  }
  getValidChunk(e) {
    let t = e;
    const n = e.length - e.length % h3;
    return n !== e.length && (t = e.slice(0, n), this.remainderData = e.slice(n)), t;
  }
  logOnce(e) {
    this.logEnabled && (Ae.log(`[decrypter]: ${e}`), this.logEnabled = !1);
  }
}
const Wy = Math.pow(2, 17);
class g3 {
  constructor(e) {
    this.config = void 0, this.loader = null, this.partLoadTimeout = -1, this.config = e;
  }
  destroy() {
    this.loader && (this.loader.destroy(), this.loader = null);
  }
  abort() {
    this.loader && this.loader.abort();
  }
  load(e, t) {
    const n = e.url;
    if (!n)
      return Promise.reject(new zr({
        type: ne.NETWORK_ERROR,
        details: k.FRAG_LOAD_ERROR,
        fatal: !1,
        frag: e,
        error: new Error(`Fragment does not have a ${n ? "part list" : "url"}`),
        networkDetails: null
      }));
    this.abort();
    const i = this.config, s = i.fLoader, a = i.loader;
    return new Promise((o, c) => {
      if (this.loader && this.loader.destroy(), e.gap)
        if (e.tagList.some((g) => g[0] === "GAP")) {
          c(qy(e));
          return;
        } else
          e.gap = !1;
      const l = this.loader = s ? new s(i) : new a(i), u = Hy(e);
      e.loader = l;
      const d = Ky(i.fragLoadPolicy.default), f = {
        loadPolicy: d,
        timeout: d.maxLoadTimeMs,
        maxRetry: 0,
        retryDelay: 0,
        maxRetryDelay: 0,
        highWaterMark: e.sn === "initSegment" ? 1 / 0 : Wy
      };
      e.stats = l.stats;
      const h = {
        onSuccess: (g, m, p, v) => {
          this.resetLoader(e, l);
          let y = g.data;
          p.resetIV && e.decryptdata && (e.decryptdata.iv = new Uint8Array(y.slice(0, 16)), y = y.slice(16)), o({
            frag: e,
            part: null,
            payload: y,
            networkDetails: v
          });
        },
        onError: (g, m, p, v) => {
          this.resetLoader(e, l), c(new zr({
            type: ne.NETWORK_ERROR,
            details: k.FRAG_LOAD_ERROR,
            fatal: !1,
            frag: e,
            response: Ne({
              url: n,
              data: void 0
            }, g),
            error: new Error(`HTTP Error ${g.code} ${g.text}`),
            networkDetails: p,
            stats: v
          }));
        },
        onAbort: (g, m, p) => {
          this.resetLoader(e, l), c(new zr({
            type: ne.NETWORK_ERROR,
            details: k.INTERNAL_ABORTED,
            fatal: !1,
            frag: e,
            error: new Error("Aborted"),
            networkDetails: p,
            stats: g
          }));
        },
        onTimeout: (g, m, p) => {
          this.resetLoader(e, l), c(new zr({
            type: ne.NETWORK_ERROR,
            details: k.FRAG_LOAD_TIMEOUT,
            fatal: !1,
            frag: e,
            error: new Error(`Timeout after ${f.timeout}ms`),
            networkDetails: p,
            stats: g
          }));
        }
      };
      t && (h.onProgress = (g, m, p, v) => t({
        frag: e,
        part: null,
        payload: p,
        networkDetails: v
      })), l.load(u, f, h);
    });
  }
  loadPart(e, t, n) {
    this.abort();
    const i = this.config, s = i.fLoader, a = i.loader;
    return new Promise((o, c) => {
      if (this.loader && this.loader.destroy(), e.gap || t.gap) {
        c(qy(e, t));
        return;
      }
      const l = this.loader = s ? new s(i) : new a(i), u = Hy(e, t);
      e.loader = l;
      const d = Ky(i.fragLoadPolicy.default), f = {
        loadPolicy: d,
        timeout: d.maxLoadTimeMs,
        maxRetry: 0,
        retryDelay: 0,
        maxRetryDelay: 0,
        highWaterMark: Wy
      };
      t.stats = l.stats, l.load(u, f, {
        onSuccess: (h, g, m, p) => {
          this.resetLoader(e, l), this.updateStatsFromPart(e, t);
          const v = {
            frag: e,
            part: t,
            payload: h.data,
            networkDetails: p
          };
          n(v), o(v);
        },
        onError: (h, g, m, p) => {
          this.resetLoader(e, l), c(new zr({
            type: ne.NETWORK_ERROR,
            details: k.FRAG_LOAD_ERROR,
            fatal: !1,
            frag: e,
            part: t,
            response: Ne({
              url: u.url,
              data: void 0
            }, h),
            error: new Error(`HTTP Error ${h.code} ${h.text}`),
            networkDetails: m,
            stats: p
          }));
        },
        onAbort: (h, g, m) => {
          e.stats.aborted = t.stats.aborted, this.resetLoader(e, l), c(new zr({
            type: ne.NETWORK_ERROR,
            details: k.INTERNAL_ABORTED,
            fatal: !1,
            frag: e,
            part: t,
            error: new Error("Aborted"),
            networkDetails: m,
            stats: h
          }));
        },
        onTimeout: (h, g, m) => {
          this.resetLoader(e, l), c(new zr({
            type: ne.NETWORK_ERROR,
            details: k.FRAG_LOAD_TIMEOUT,
            fatal: !1,
            frag: e,
            part: t,
            error: new Error(`Timeout after ${f.timeout}ms`),
            networkDetails: m,
            stats: h
          }));
        }
      });
    });
  }
  updateStatsFromPart(e, t) {
    const n = e.stats, i = t.stats, s = i.total;
    if (n.loaded += i.loaded, s) {
      const c = Math.round(e.duration / t.duration), l = Math.min(Math.round(n.loaded / s), c), d = (c - l) * Math.round(n.loaded / l);
      n.total = n.loaded + d;
    } else
      n.total = Math.max(n.loaded, n.total);
    const a = n.loading, o = i.loading;
    a.start ? a.first += o.first - o.start : (a.start = o.start, a.first = o.first), a.end = o.end;
  }
  resetLoader(e, t) {
    e.loader = null, this.loader === t && (self.clearTimeout(this.partLoadTimeout), this.loader = null), t.destroy();
  }
}
function Hy(r, e = null) {
  const t = e || r, n = {
    frag: r,
    part: e,
    responseType: "arraybuffer",
    url: t.url,
    headers: {},
    rangeStart: 0,
    rangeEnd: 0
  }, i = t.byteRangeStartOffset, s = t.byteRangeEndOffset;
  if (X(i) && X(s)) {
    var a;
    let o = i, c = s;
    if (r.sn === "initSegment" && m3((a = r.decryptdata) == null ? void 0 : a.method)) {
      const l = s - i;
      l % 16 && (c = s + (16 - l % 16)), i !== 0 && (n.resetIV = !0, o = i - 16);
    }
    n.rangeStart = o, n.rangeEnd = c;
  }
  return n;
}
function qy(r, e) {
  const t = new Error(`GAP ${r.gap ? "tag" : "attribute"} found`), n = {
    type: ne.MEDIA_ERROR,
    details: k.FRAG_GAP,
    fatal: !1,
    frag: r,
    error: t,
    networkDetails: null
  };
  return e && (n.part = e), (e || r).stats.aborted = !0, new zr(n);
}
function m3(r) {
  return r === "AES-128" || r === "AES-256";
}
class zr extends Error {
  constructor(e) {
    super(e.error.message), this.data = void 0, this.data = e;
  }
}
class ZA extends Or {
  constructor(e, t) {
    super(e, t), this._boundTick = void 0, this._tickTimer = null, this._tickInterval = null, this._tickCallCount = 0, this._boundTick = this.tick.bind(this);
  }
  destroy() {
    this.onHandlerDestroying(), this.onHandlerDestroyed();
  }
  onHandlerDestroying() {
    this.clearNextTick(), this.clearInterval();
  }
  onHandlerDestroyed() {
  }
  hasInterval() {
    return !!this._tickInterval;
  }
  hasNextTick() {
    return !!this._tickTimer;
  }
  /**
   * @param millis - Interval time (ms)
   * @eturns True when interval has been scheduled, false when already scheduled (no effect)
   */
  setInterval(e) {
    return this._tickInterval ? !1 : (this._tickCallCount = 0, this._tickInterval = self.setInterval(this._boundTick, e), !0);
  }
  /**
   * @returns True when interval was cleared, false when none was set (no effect)
   */
  clearInterval() {
    return this._tickInterval ? (self.clearInterval(this._tickInterval), this._tickInterval = null, !0) : !1;
  }
  /**
   * @returns True when timeout was cleared, false when none was set (no effect)
   */
  clearNextTick() {
    return this._tickTimer ? (self.clearTimeout(this._tickTimer), this._tickTimer = null, !0) : !1;
  }
  /**
   * Will call the subclass doTick implementation in this main loop tick
   * or in the next one (via setTimeout(,0)) in case it has already been called
   * in this tick (in case this is a re-entrant call).
   */
  tick() {
    this._tickCallCount++, this._tickCallCount === 1 && (this.doTick(), this._tickCallCount > 1 && this.tickImmediate(), this._tickCallCount = 0);
  }
  tickImmediate() {
    this.clearNextTick(), this._tickTimer = self.setTimeout(this._boundTick, 0);
  }
  /**
   * For subclass to implement task logic
   * @abstract
   */
  doTick() {
  }
}
class Hg {
  constructor(e, t, n, i = 0, s = -1, a = !1) {
    this.level = void 0, this.sn = void 0, this.part = void 0, this.id = void 0, this.size = void 0, this.partial = void 0, this.transmuxing = ro(), this.buffering = {
      audio: ro(),
      video: ro(),
      audiovideo: ro()
    }, this.level = e, this.sn = t, this.id = n, this.size = i, this.part = s, this.partial = a;
  }
}
function ro() {
  return {
    start: 0,
    executeStart: 0,
    executeEnd: 0,
    end: 0
  };
}
const zy = {
  length: 0,
  start: () => 0,
  end: () => 0
};
class ue {
  /**
   * Return true if `media`'s buffered include `position`
   */
  static isBuffered(e, t) {
    if (e) {
      const n = ue.getBuffered(e);
      for (let i = n.length; i--; )
        if (t >= n.start(i) && t <= n.end(i))
          return !0;
    }
    return !1;
  }
  static bufferedRanges(e) {
    if (e) {
      const t = ue.getBuffered(e);
      return ue.timeRangesToArray(t);
    }
    return [];
  }
  static timeRangesToArray(e) {
    const t = [];
    for (let n = 0; n < e.length; n++)
      t.push({
        start: e.start(n),
        end: e.end(n)
      });
    return t;
  }
  static bufferInfo(e, t, n) {
    if (e) {
      const i = ue.bufferedRanges(e);
      if (i.length)
        return ue.bufferedInfo(i, t, n);
    }
    return {
      len: 0,
      start: t,
      end: t,
      bufferedIndex: -1
    };
  }
  static bufferedInfo(e, t, n) {
    t = Math.max(0, t), e.length > 1 && e.sort((u, d) => u.start - d.start || d.end - u.end);
    let i = -1, s = [];
    if (n)
      for (let u = 0; u < e.length; u++) {
        t >= e[u].start && t <= e[u].end && (i = u);
        const d = s.length;
        if (d) {
          const f = s[d - 1].end;
          e[u].start - f < n ? e[u].end > f && (s[d - 1].end = e[u].end) : s.push(e[u]);
        } else
          s.push(e[u]);
      }
    else
      s = e;
    let a = 0, o, c = t, l = t;
    for (let u = 0; u < s.length; u++) {
      const d = s[u].start, f = s[u].end;
      if (i === -1 && t >= d && t <= f && (i = u), t + n >= d && t < f)
        c = d, l = f, a = l - t;
      else if (t + n < d) {
        o = d;
        break;
      }
    }
    return {
      len: a,
      start: c || 0,
      end: l || 0,
      nextStart: o,
      buffered: e,
      bufferedIndex: i
    };
  }
  /**
   * Safe method to get buffered property.
   * SourceBuffer.buffered may throw if SourceBuffer is removed from it's MediaSource
   */
  static getBuffered(e) {
    try {
      return e.buffered || zy;
    } catch (t) {
      return Ae.log("failed to get media.buffered", t), zy;
    }
  }
}
const JA = /\{\$([a-zA-Z0-9-_]+)\}/g;
function Yy(r) {
  return JA.test(r);
}
function bf(r, e) {
  if (r.variableList !== null || r.hasVariableRefs) {
    const t = r.variableList;
    return e.replace(JA, (n) => {
      const i = n.substring(2, n.length - 1), s = t == null ? void 0 : t[i];
      return s === void 0 ? (r.playlistParsingError || (r.playlistParsingError = new Error(`Missing preceding EXT-X-DEFINE tag for Variable Reference: "${i}"`)), n) : s;
    });
  }
  return e;
}
function Xy(r, e, t) {
  let n = r.variableList;
  n || (r.variableList = n = {});
  let i, s;
  if ("QUERYPARAM" in e) {
    i = e.QUERYPARAM;
    try {
      const a = new self.URL(t).searchParams;
      if (a.has(i))
        s = a.get(i);
      else
        throw new Error(`"${i}" does not match any query parameter in URI: "${t}"`);
    } catch (a) {
      r.playlistParsingError || (r.playlistParsingError = new Error(`EXT-X-DEFINE QUERYPARAM: ${a.message}`));
    }
  } else
    i = e.NAME, s = e.VALUE;
  i in n ? r.playlistParsingError || (r.playlistParsingError = new Error(`EXT-X-DEFINE duplicate Variable Name declarations: "${i}"`)) : n[i] = s || "";
}
function p3(r, e, t) {
  const n = e.IMPORT;
  if (t && n in t) {
    let i = r.variableList;
    i || (r.variableList = i = {}), i[n] = t[n];
  } else
    r.playlistParsingError || (r.playlistParsingError = new Error(`EXT-X-DEFINE IMPORT attribute not found in Multivariant Playlist: "${n}"`));
}
const v3 = /^(\d+)x(\d+)$/, Qy = /(.+?)=(".*?"|.*?)(?:,|$)/g;
class ze {
  constructor(e, t) {
    typeof e == "string" && (e = ze.parseAttrList(e, t)), Ce(this, e);
  }
  get clientAttrs() {
    return Object.keys(this).filter((e) => e.substring(0, 2) === "X-");
  }
  decimalInteger(e) {
    const t = parseInt(this[e], 10);
    return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t;
  }
  hexadecimalInteger(e) {
    if (this[e]) {
      let t = (this[e] || "0x").slice(2);
      t = (t.length & 1 ? "0" : "") + t;
      const n = new Uint8Array(t.length / 2);
      for (let i = 0; i < t.length / 2; i++)
        n[i] = parseInt(t.slice(i * 2, i * 2 + 2), 16);
      return n;
    }
    return null;
  }
  hexadecimalIntegerAsNumber(e) {
    const t = parseInt(this[e], 16);
    return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t;
  }
  decimalFloatingPoint(e) {
    return parseFloat(this[e]);
  }
  optionalFloat(e, t) {
    const n = this[e];
    return n ? parseFloat(n) : t;
  }
  enumeratedString(e) {
    return this[e];
  }
  enumeratedStringList(e, t) {
    const n = this[e];
    return (n ? n.split(/[ ,]+/) : []).reduce((i, s) => (i[s.toLowerCase()] = !0, i), t);
  }
  bool(e) {
    return this[e] === "YES";
  }
  decimalResolution(e) {
    const t = v3.exec(this[e]);
    if (t !== null)
      return {
        width: parseInt(t[1], 10),
        height: parseInt(t[2], 10)
      };
  }
  static parseAttrList(e, t) {
    let n;
    const i = {}, s = '"';
    for (Qy.lastIndex = 0; (n = Qy.exec(e)) !== null; ) {
      const a = n[1].trim();
      let o = n[2];
      const c = o.indexOf(s) === 0 && o.lastIndexOf(s) === o.length - 1;
      let l = !1;
      if (c)
        o = o.slice(1, -1);
      else
        switch (a) {
          case "IV":
          case "SCTE35-CMD":
          case "SCTE35-IN":
          case "SCTE35-OUT":
            l = !0;
        }
      if (t && (c || l))
        o = bf(t, o);
      else if (!l && !c)
        switch (a) {
          case "CLOSED-CAPTIONS":
            if (o === "NONE")
              break;
          // falls through
          case "ALLOWED-CPC":
          case "CLASS":
          case "ASSOC-LANGUAGE":
          case "AUDIO":
          case "BYTERANGE":
          case "CHANNELS":
          case "CHARACTERISTICS":
          case "CODECS":
          case "DATA-ID":
          case "END-DATE":
          case "GROUP-ID":
          case "ID":
          case "IMPORT":
          case "INSTREAM-ID":
          case "KEYFORMAT":
          case "KEYFORMATVERSIONS":
          case "LANGUAGE":
          case "NAME":
          case "PATHWAY-ID":
          case "QUERYPARAM":
          case "RECENTLY-REMOVED-DATERANGES":
          case "SERVER-URI":
          case "STABLE-RENDITION-ID":
          case "STABLE-VARIANT-ID":
          case "START-DATE":
          case "SUBTITLES":
          case "SUPPLEMENTAL-CODECS":
          case "URI":
          case "VALUE":
          case "VIDEO":
          case "X-ASSET-LIST":
          case "X-ASSET-URI":
            Ae.warn(`${e}: attribute ${a} is missing quotes`);
        }
      i[a] = o;
    }
    return i;
  }
}
const y3 = "com.apple.hls.interstitial";
function b3(r) {
  return r !== "ID" && r !== "CLASS" && r !== "CUE" && r !== "START-DATE" && r !== "DURATION" && r !== "END-DATE" && r !== "END-ON-NEXT";
}
function x3(r) {
  return r === "SCTE35-OUT" || r === "SCTE35-IN" || r === "SCTE35-CMD";
}
class ew {
  constructor(e, t, n = 0) {
    var i;
    if (this.attr = void 0, this.tagAnchor = void 0, this.tagOrder = void 0, this._startDate = void 0, this._endDate = void 0, this._dateAtEnd = void 0, this._cue = void 0, this._badValueForSameId = void 0, this.tagAnchor = (t == null ? void 0 : t.tagAnchor) || null, this.tagOrder = (i = t == null ? void 0 : t.tagOrder) != null ? i : n, t) {
      const s = t.attr;
      for (const a in s)
        if (Object.prototype.hasOwnProperty.call(e, a) && e[a] !== s[a]) {
          Ae.warn(`DATERANGE tag attribute: "${a}" does not match for tags with ID: "${e.ID}"`), this._badValueForSameId = a;
          break;
        }
      e = Ce(new ze({}), s, e);
    }
    if (this.attr = e, t ? (this._startDate = t._startDate, this._cue = t._cue, this._endDate = t._endDate, this._dateAtEnd = t._dateAtEnd) : this._startDate = new Date(e["START-DATE"]), "END-DATE" in this.attr) {
      const s = (t == null ? void 0 : t.endDate) || new Date(this.attr["END-DATE"]);
      X(s.getTime()) && (this._endDate = s);
    }
  }
  get id() {
    return this.attr.ID;
  }
  get class() {
    return this.attr.CLASS;
  }
  get cue() {
    const e = this._cue;
    return e === void 0 ? this._cue = this.attr.enumeratedStringList(this.attr.CUE ? "CUE" : "X-CUE", {
      pre: !1,
      post: !1,
      once: !1
    }) : e;
  }
  get startTime() {
    const {
      tagAnchor: e
    } = this;
    return e === null || e.programDateTime === null ? (Ae.warn(`Expected tagAnchor Fragment with PDT set for DateRange "${this.id}": ${e}`), NaN) : e.start + (this.startDate.getTime() - e.programDateTime) / 1e3;
  }
  get startDate() {
    return this._startDate;
  }
  get endDate() {
    const e = this._endDate || this._dateAtEnd;
    if (e)
      return e;
    const t = this.duration;
    return t !== null ? this._dateAtEnd = new Date(this._startDate.getTime() + t * 1e3) : null;
  }
  get duration() {
    if ("DURATION" in this.attr) {
      const e = this.attr.decimalFloatingPoint("DURATION");
      if (X(e))
        return e;
    } else if (this._endDate)
      return (this._endDate.getTime() - this._startDate.getTime()) / 1e3;
    return null;
  }
  get plannedDuration() {
    return "PLANNED-DURATION" in this.attr ? this.attr.decimalFloatingPoint("PLANNED-DURATION") : null;
  }
  get endOnNext() {
    return this.attr.bool("END-ON-NEXT");
  }
  get isInterstitial() {
    return this.class === y3;
  }
  get isValid() {
    return !!this.id && !this._badValueForSameId && X(this.startDate.getTime()) && (this.duration === null || this.duration >= 0) && (!this.endOnNext || !!this.class) && (!this.attr.CUE || !this.cue.pre && !this.cue.post || this.cue.pre !== this.cue.post) && (!this.isInterstitial || "X-ASSET-URI" in this.attr || "X-ASSET-LIST" in this.attr);
  }
}
const E3 = 10;
class S3 {
  constructor(e) {
    this.PTSKnown = !1, this.alignedSliding = !1, this.averagetargetduration = void 0, this.endCC = 0, this.endSN = 0, this.fragments = void 0, this.fragmentHint = void 0, this.partList = null, this.dateRanges = void 0, this.dateRangeTagCount = 0, this.live = !0, this.requestScheduled = -1, this.ageHeader = 0, this.advancedDateTime = void 0, this.updated = !0, this.advanced = !0, this.misses = 0, this.startCC = 0, this.startSN = 0, this.startTimeOffset = null, this.targetduration = 0, this.totalduration = 0, this.type = null, this.url = void 0, this.m3u8 = "", this.version = null, this.canBlockReload = !1, this.canSkipUntil = 0, this.canSkipDateRanges = !1, this.skippedSegments = 0, this.recentlyRemovedDateranges = void 0, this.partHoldBack = 0, this.holdBack = 0, this.partTarget = 0, this.preloadHint = void 0, this.renditionReports = void 0, this.tuneInGoal = 0, this.deltaUpdateFailed = void 0, this.driftStartTime = 0, this.driftEndTime = 0, this.driftStart = 0, this.driftEnd = 0, this.encryptedFragments = void 0, this.playlistParsingError = null, this.variableList = null, this.hasVariableRefs = !1, this.appliedTimelineOffset = void 0, this.fragments = [], this.encryptedFragments = [], this.dateRanges = {}, this.url = e;
  }
  reloaded(e) {
    if (!e) {
      this.advanced = !0, this.updated = !0;
      return;
    }
    const t = this.lastPartSn - e.lastPartSn, n = this.lastPartIndex - e.lastPartIndex;
    this.updated = this.endSN !== e.endSN || !!n || !!t || !this.live, this.advanced = this.endSN > e.endSN || t > 0 || t === 0 && n > 0, this.updated || this.advanced ? this.misses = Math.floor(e.misses * 0.6) : this.misses = e.misses + 1;
  }
  get hasProgramDateTime() {
    return this.fragments.length ? X(this.fragments[this.fragments.length - 1].programDateTime) : !1;
  }
  get levelTargetDuration() {
    return this.averagetargetduration || this.targetduration || E3;
  }
  get drift() {
    const e = this.driftEndTime - this.driftStartTime;
    return e > 0 ? (this.driftEnd - this.driftStart) * 1e3 / e : 1;
  }
  get edge() {
    return this.partEnd || this.fragmentEnd;
  }
  get partEnd() {
    var e;
    return (e = this.partList) != null && e.length ? this.partList[this.partList.length - 1].end : this.fragmentEnd;
  }
  get fragmentEnd() {
    var e;
    return (e = this.fragments) != null && e.length ? this.fragments[this.fragments.length - 1].end : 0;
  }
  get fragmentStart() {
    var e;
    return (e = this.fragments) != null && e.length ? this.fragments[0].start : 0;
  }
  get age() {
    return this.advancedDateTime ? Math.max(Date.now() - this.advancedDateTime, 0) / 1e3 : 0;
  }
  get lastPartIndex() {
    var e;
    return (e = this.partList) != null && e.length ? this.partList[this.partList.length - 1].index : -1;
  }
  get maxPartIndex() {
    const e = this.partList;
    if (e) {
      const t = this.lastPartIndex;
      if (t !== -1) {
        for (let n = e.length; n--; )
          if (e[n].index > t)
            return e[n].index;
        return t;
      }
    }
    return 0;
  }
  get lastPartSn() {
    var e;
    return (e = this.partList) != null && e.length ? this.partList[this.partList.length - 1].fragment.sn : this.endSN;
  }
  get expired() {
    if (this.live && this.age && this.misses < 3) {
      const e = this.partEnd - this.fragmentStart;
      return this.age > Math.max(e, this.totalduration) + this.levelTargetDuration;
    }
    return !1;
  }
}
function Bi(r) {
  return r === "AES-128" || r === "AES-256" || r === "AES-256-CTR";
}
function qg(r) {
  switch (r) {
    case "AES-128":
    case "AES-256":
      return Fn.cbc;
    case "AES-256-CTR":
      return Fn.ctr;
    default:
      throw new Error(`invalid full segment method ${r}`);
  }
}
function tw(r) {
  return Uint8Array.from(atob(r), (e) => e.charCodeAt(0));
}
function xf(r) {
  return Uint8Array.from(unescape(encodeURIComponent(r)), (e) => e.charCodeAt(0));
}
function T3(r) {
  const e = xf(r).subarray(0, 16), t = new Uint8Array(16);
  return t.set(e, 16 - e.length), t;
}
function A3(r) {
  const e = function(n, i, s) {
    const a = n[i];
    n[i] = n[s], n[s] = a;
  };
  e(r, 0, 3), e(r, 1, 2), e(r, 4, 5), e(r, 6, 7);
}
function w3(r) {
  const e = r.split(":");
  let t = null;
  if (e[0] === "data" && e.length === 2) {
    const n = e[1].split(";"), i = n[n.length - 1].split(",");
    if (i.length === 2) {
      const s = i[0] === "base64", a = i[1];
      s ? (n.splice(-1, 1), t = tw(a)) : t = T3(a);
    }
  }
  return t;
}
const dl = typeof self < "u" ? self : void 0;
var Qe = {
  CLEARKEY: "org.w3.clearkey",
  FAIRPLAY: "com.apple.fps",
  PLAYREADY: "com.microsoft.playready",
  WIDEVINE: "com.widevine.alpha"
}, Ft = {
  CLEARKEY: "org.w3.clearkey",
  FAIRPLAY: "com.apple.streamingkeydelivery",
  PLAYREADY: "com.microsoft.playready",
  WIDEVINE: "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed"
};
function Ef(r) {
  switch (r) {
    case Ft.FAIRPLAY:
      return Qe.FAIRPLAY;
    case Ft.PLAYREADY:
      return Qe.PLAYREADY;
    case Ft.WIDEVINE:
      return Qe.WIDEVINE;
    case Ft.CLEARKEY:
      return Qe.CLEARKEY;
  }
}
function Zy(r) {
  switch (r) {
    case Qe.FAIRPLAY:
      return Ft.FAIRPLAY;
    case Qe.PLAYREADY:
      return Ft.PLAYREADY;
    case Qe.WIDEVINE:
      return Ft.WIDEVINE;
    case Qe.CLEARKEY:
      return Ft.CLEARKEY;
  }
}
function yo(r) {
  const {
    drmSystems: e,
    widevineLicenseUrl: t
  } = r, n = e ? [Qe.FAIRPLAY, Qe.WIDEVINE, Qe.PLAYREADY, Qe.CLEARKEY].filter((i) => !!e[i]) : [];
  return !n[Qe.WIDEVINE] && t && n.push(Qe.WIDEVINE), n;
}
const rw = function(r) {
  return dl != null && (r = dl.navigator) != null && r.requestMediaKeySystemAccess ? self.navigator.requestMediaKeySystemAccess.bind(self.navigator) : null;
}();
function I3(r, e, t, n) {
  let i;
  switch (r) {
    case Qe.FAIRPLAY:
      i = ["cenc", "sinf"];
      break;
    case Qe.WIDEVINE:
    case Qe.PLAYREADY:
      i = ["cenc"];
      break;
    case Qe.CLEARKEY:
      i = ["cenc", "keyids"];
      break;
    default:
      throw new Error(`Unknown key-system: ${r}`);
  }
  return P3(i, e, t, n);
}
function P3(r, e, t, n) {
  return [{
    initDataTypes: r,
    persistentState: n.persistentState || "optional",
    distinctiveIdentifier: n.distinctiveIdentifier || "optional",
    sessionTypes: n.sessionTypes || [n.sessionType || "temporary"],
    audioCapabilities: e.map((s) => ({
      contentType: `audio/mp4; codecs=${s}`,
      robustness: n.audioRobustness || "",
      encryptionScheme: n.audioEncryptionScheme || null
    })),
    videoCapabilities: t.map((s) => ({
      contentType: `video/mp4; codecs=${s}`,
      robustness: n.videoRobustness || "",
      encryptionScheme: n.videoEncryptionScheme || null
    }))
  }];
}
function _3(r) {
  var e;
  return r.sessionType === "persistent-license" || !!((e = r.sessionTypes) != null && e.some((t) => t === "persistent-license"));
}
function L3(r) {
  const e = new Uint16Array(r.buffer, r.byteOffset, r.byteLength / 2), t = String.fromCharCode.apply(null, Array.from(e)), n = t.substring(t.indexOf("<"), t.length), a = new DOMParser().parseFromString(n, "text/xml").getElementsByTagName("KID")[0];
  if (a) {
    const o = a.childNodes[0] ? a.childNodes[0].nodeValue : a.getAttribute("VALUE");
    if (o) {
      const c = tw(o).subarray(0, 16);
      return A3(c), c;
    }
  }
  return null;
}
let no = {};
class sc {
  static clearKeyUriToKeyIdMap() {
    no = {};
  }
  constructor(e, t, n, i = [1], s = null, a) {
    this.uri = void 0, this.method = void 0, this.keyFormat = void 0, this.keyFormatVersions = void 0, this.encrypted = void 0, this.isCommonEncryption = void 0, this.iv = null, this.key = null, this.keyId = null, this.pssh = null, this.method = e, this.uri = t, this.keyFormat = n, this.keyFormatVersions = i, this.iv = s, this.encrypted = e ? e !== "NONE" : !1, this.isCommonEncryption = this.encrypted && !Bi(e), a != null && a.startsWith("0x") && (this.keyId = new Uint8Array(NA(a)));
  }
  matches(e) {
    var t, n;
    return e.uri === this.uri && e.method === this.method && e.encrypted === this.encrypted && e.keyFormat === this.keyFormat && e.keyFormatVersions.join(",") === this.keyFormatVersions.join(",") && ((t = e.iv) == null ? void 0 : t.join(",")) === ((n = this.iv) == null ? void 0 : n.join(","));
  }
  isSupported() {
    if (this.method) {
      if (Bi(this.method) || this.method === "NONE")
        return !0;
      if (this.keyFormat === "identity")
        return this.method === "SAMPLE-AES";
      switch (this.keyFormat) {
        case Ft.FAIRPLAY:
        case Ft.WIDEVINE:
        case Ft.PLAYREADY:
        case Ft.CLEARKEY:
          return ["ISO-23001-7", "SAMPLE-AES", "SAMPLE-AES-CENC", "SAMPLE-AES-CTR"].indexOf(this.method) !== -1;
      }
    }
    return !1;
  }
  getDecryptData(e) {
    if (!this.encrypted || !this.uri)
      return null;
    if (Bi(this.method) && this.uri && !this.iv) {
      typeof e != "number" && (Ae.warn(`missing IV for initialization segment with method="${this.method}" - compliance issue`), e = 0);
      const n = O3(e);
      return new sc(this.method, this.uri, "identity", this.keyFormatVersions, n);
    }
    if (this.pssh && this.keyId)
      return this;
    const t = w3(this.uri);
    if (t)
      switch (this.keyFormat) {
        case Ft.WIDEVINE:
          if (this.pssh = t, !this.keyId && t.length >= 22) {
            const n = t.length - 22;
            this.keyId = t.subarray(n, n + 16);
          }
          break;
        case Ft.PLAYREADY: {
          const n = new Uint8Array([154, 4, 240, 121, 152, 64, 66, 134, 171, 146, 230, 91, 224, 136, 95, 149]);
          this.pssh = kK(n, null, t), this.keyId = L3(t);
          break;
        }
        default: {
          let n = t.subarray(0, 16);
          if (n.length !== 16) {
            const i = new Uint8Array(16);
            i.set(n, 16 - n.length), n = i;
          }
          this.keyId = n;
          break;
        }
      }
    if (!this.keyId || this.keyId.byteLength !== 16) {
      let n = no[this.uri];
      if (!n) {
        const i = Object.keys(no).length % Number.MAX_SAFE_INTEGER;
        n = new Uint8Array(16), new DataView(n.buffer, 12, 4).setUint32(0, i), no[this.uri] = n;
      }
      this.keyId = n;
    }
    return this;
  }
}
function O3(r) {
  const e = new Uint8Array(16);
  for (let t = 12; t < 16; t++)
    e[t] = r >> 8 * (15 - t) & 255;
  return e;
}
const Jy = /#EXT-X-STREAM-INF:([^\r\n]*)(?:[\r\n](?:#[^\r\n]*)?)*([^\r\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\r\n]*)[\r\n]+/g, eb = /#EXT-X-MEDIA:(.*)/g, R3 = /^#EXT(?:INF|-X-TARGETDURATION):/m, Qu = new RegExp([
  /#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source,
  // duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title
  /(?!#) *(\S[^\r\n]*)/.source,
  // segment URI, group 3 => the URI (note newline is not eaten)
  /#.*/.source
  // All other non-segment oriented tags will match with all groups empty
].join("|"), "g"), D3 = new RegExp([/#EXT-X-(PROGRAM-DATE-TIME|BYTERANGE|DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP|INDEPENDENT-SEGMENTS)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\r?\n?/.source].join("|"));
class Nr {
  static findGroup(e, t) {
    for (let n = 0; n < e.length; n++) {
      const i = e[n];
      if (i.id === t)
        return i;
    }
  }
  static resolve(e, t) {
    return Bg.buildAbsoluteURL(t, e, {
      alwaysNormalize: !0
    });
  }
  static isMediaPlaylist(e) {
    return R3.test(e);
  }
  static parseMasterPlaylist(e, t) {
    const n = Yy(e), i = {
      contentSteering: null,
      levels: [],
      playlistParsingError: null,
      sessionData: null,
      sessionKeys: null,
      startTimeOffset: null,
      variableList: null,
      hasVariableRefs: n
    }, s = [];
    Jy.lastIndex = 0;
    let a;
    for (; (a = Jy.exec(e)) != null; )
      if (a[1]) {
        var o;
        const l = new ze(a[1], i), u = bf(i, a[2]), d = {
          attrs: l,
          bitrate: l.decimalInteger("BANDWIDTH") || l.decimalInteger("AVERAGE-BANDWIDTH"),
          name: l.NAME,
          url: Nr.resolve(u, t)
        }, f = l.decimalResolution("RESOLUTION");
        f && (d.width = f.width, d.height = f.height), nb(l.CODECS, d);
        const h = l["SUPPLEMENTAL-CODECS"];
        h && (d.supplemental = {}, nb(h, d.supplemental)), (o = d.unknownCodecs) != null && o.length || s.push(d), i.levels.push(d);
      } else if (a[3]) {
        const l = a[3], u = a[4];
        switch (l) {
          case "SESSION-DATA": {
            const d = new ze(u, i), f = d["DATA-ID"];
            f && (i.sessionData === null && (i.sessionData = {}), i.sessionData[f] = d);
            break;
          }
          case "SESSION-KEY": {
            const d = tb(u, t, i);
            d.encrypted && d.isSupported() ? (i.sessionKeys === null && (i.sessionKeys = []), i.sessionKeys.push(d)) : Ae.warn(`[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: "${u}"`);
            break;
          }
          case "DEFINE": {
            {
              const d = new ze(u, i);
              Xy(i, d, t);
            }
            break;
          }
          case "CONTENT-STEERING": {
            const d = new ze(u, i);
            i.contentSteering = {
              uri: Nr.resolve(d["SERVER-URI"], t),
              pathwayId: d["PATHWAY-ID"] || "."
            };
            break;
          }
          case "START": {
            i.startTimeOffset = rb(u);
            break;
          }
        }
      }
    const c = s.length > 0 && s.length < i.levels.length;
    return i.levels = c ? s : i.levels, i.levels.length === 0 && (i.playlistParsingError = new Error("no levels found in manifest")), i;
  }
  static parseMasterPlaylistMedia(e, t, n) {
    let i;
    const s = {}, a = n.levels, o = {
      AUDIO: a.map((l) => ({
        id: l.attrs.AUDIO,
        audioCodec: l.audioCodec
      })),
      SUBTITLES: a.map((l) => ({
        id: l.attrs.SUBTITLES,
        textCodec: l.textCodec
      })),
      "CLOSED-CAPTIONS": []
    };
    let c = 0;
    for (eb.lastIndex = 0; (i = eb.exec(e)) !== null; ) {
      const l = new ze(i[1], n), u = l.TYPE;
      if (u) {
        const d = o[u], f = s[u] || [];
        s[u] = f;
        const h = l.LANGUAGE, g = l["ASSOC-LANGUAGE"], m = l.CHANNELS, p = l.CHARACTERISTICS, v = l["INSTREAM-ID"], y = {
          attrs: l,
          bitrate: 0,
          id: c++,
          groupId: l["GROUP-ID"] || "",
          name: l.NAME || h || "",
          type: u,
          default: l.bool("DEFAULT"),
          autoselect: l.bool("AUTOSELECT"),
          forced: l.bool("FORCED"),
          lang: h,
          url: l.URI ? Nr.resolve(l.URI, t) : ""
        };
        if (g && (y.assocLang = g), m && (y.channels = m), p && (y.characteristics = p), v && (y.instreamId = v), d != null && d.length) {
          const b = Nr.findGroup(d, y.groupId) || d[0];
          ib(y, b, "audioCodec"), ib(y, b, "textCodec");
        }
        f.push(y);
      }
    }
    return s;
  }
  static parseLevelPlaylist(e, t, n, i, s, a) {
    var o;
    const c = {
      url: t
    }, l = new S3(t), u = l.fragments, d = [];
    let f = null, h = 0, g = 0, m = 0, p = 0, v = 0, y = null, b = new zu(i, c), x, S, A, T = -1, I = !1, L = null, _;
    if (Qu.lastIndex = 0, l.m3u8 = e, l.hasVariableRefs = Yy(e), ((o = Qu.exec(e)) == null ? void 0 : o[0]) !== "#EXTM3U")
      return l.playlistParsingError = new Error("Missing format identifier #EXTM3U"), l;
    for (; (x = Qu.exec(e)) !== null; ) {
      I && (I = !1, b = new zu(i, c), b.playlistOffset = m, b.start = m, b.sn = h, b.cc = p, v && (b.bitrate = v), b.level = n, f && (b.initSegment = f, f.rawProgramDateTime && (b.rawProgramDateTime = f.rawProgramDateTime, f.rawProgramDateTime = null), L && (b.setByteRange(L), L = null)));
      const B = x[1];
      if (B) {
        b.duration = parseFloat(B);
        const j = (" " + x[2]).slice(1);
        b.title = j || null, b.tagList.push(j ? ["INF", B, j] : ["INF", B]);
      } else if (x[3]) {
        if (X(b.duration)) {
          b.playlistOffset = m, b.start = m, A && ab(b, A, l), b.sn = h, b.level = n, b.cc = p, u.push(b);
          const j = (" " + x[3]).slice(1);
          b.relurl = bf(l, j), Sf(b, y, d), y = b, m += b.duration, h++, g = 0, I = !0;
        }
      } else {
        if (x = x[0].match(D3), !x) {
          Ae.warn("No matches on slow regex match for level playlist!");
          continue;
        }
        for (S = 1; S < x.length && x[S] === void 0; S++)
          ;
        const j = (" " + x[S]).slice(1), U = (" " + x[S + 1]).slice(1), K = x[S + 2] ? (" " + x[S + 2]).slice(1) : null;
        switch (j) {
          case "BYTERANGE":
            y ? b.setByteRange(U, y) : b.setByteRange(U);
            break;
          case "PROGRAM-DATE-TIME":
            b.rawProgramDateTime = U, b.tagList.push(["PROGRAM-DATE-TIME", U]), T === -1 && (T = u.length);
            break;
          case "PLAYLIST-TYPE":
            l.type && Hr(l, j, x), l.type = U.toUpperCase();
            break;
          case "MEDIA-SEQUENCE":
            l.startSN !== 0 ? Hr(l, j, x) : u.length > 0 && ob(l, j, x), h = l.startSN = parseInt(U);
            break;
          case "SKIP": {
            l.skippedSegments && Hr(l, j, x);
            const G = new ze(U, l), Y = G.decimalInteger("SKIPPED-SEGMENTS");
            if (X(Y)) {
              l.skippedSegments += Y;
              for (let H = Y; H--; )
                u.push(null);
              h += Y;
            }
            const Q = G.enumeratedString("RECENTLY-REMOVED-DATERANGES");
            Q && (l.recentlyRemovedDateranges = (l.recentlyRemovedDateranges || []).concat(Q.split("	")));
            break;
          }
          case "TARGETDURATION":
            l.targetduration !== 0 && Hr(l, j, x), l.targetduration = Math.max(parseInt(U), 1);
            break;
          case "VERSION":
            l.version !== null && Hr(l, j, x), l.version = parseInt(U);
            break;
          case "INDEPENDENT-SEGMENTS":
            break;
          case "ENDLIST":
            l.live || Hr(l, j, x), l.live = !1;
            break;
          case "#":
            (U || K) && b.tagList.push(K ? [U, K] : [U]);
            break;
          case "DISCONTINUITY":
            p++, b.tagList.push(["DIS"]);
            break;
          case "GAP":
            b.gap = !0, b.tagList.push([j]);
            break;
          case "BITRATE":
            b.tagList.push([j, U]), v = parseInt(U) * 1e3, X(v) ? b.bitrate = v : v = 0;
            break;
          case "DATERANGE": {
            const G = new ze(U, l), Y = new ew(G, l.dateRanges[G.ID], l.dateRangeTagCount);
            l.dateRangeTagCount++, Y.isValid || l.skippedSegments ? l.dateRanges[Y.id] = Y : Ae.warn(`Ignoring invalid DATERANGE tag: "${U}"`), b.tagList.push(["EXT-X-DATERANGE", U]);
            break;
          }
          case "DEFINE": {
            {
              const G = new ze(U, l);
              "IMPORT" in G ? p3(l, G, a) : Xy(l, G, t);
            }
            break;
          }
          case "DISCONTINUITY-SEQUENCE":
            l.startCC !== 0 ? Hr(l, j, x) : u.length > 0 && ob(l, j, x), l.startCC = p = parseInt(U);
            break;
          case "KEY": {
            const G = tb(U, t, l);
            if (G.isSupported()) {
              if (G.method === "NONE") {
                A = void 0;
                break;
              }
              A || (A = {});
              const Y = A[G.keyFormat];
              Y != null && Y.matches(G) || (Y && (A = Ce({}, A)), A[G.keyFormat] = G);
            } else
              Ae.warn(`[Keys] Ignoring invalid EXT-X-KEY tag: "${U}"`);
            break;
          }
          case "START":
            l.startTimeOffset = rb(U);
            break;
          case "MAP": {
            const G = new ze(U, l);
            if (b.duration) {
              const Y = new zu(i, c);
              sb(Y, G, n, A), f = Y, b.initSegment = f, f.rawProgramDateTime && !b.rawProgramDateTime && (b.rawProgramDateTime = f.rawProgramDateTime);
            } else {
              const Y = b.byteRangeEndOffset;
              if (Y) {
                const Q = b.byteRangeStartOffset;
                L = `${Y - Q}@${Q}`;
              } else
                L = null;
              sb(b, G, n, A), f = b, I = !0;
            }
            f.cc = p;
            break;
          }
          case "SERVER-CONTROL": {
            _ && Hr(l, j, x), _ = new ze(U), l.canBlockReload = _.bool("CAN-BLOCK-RELOAD"), l.canSkipUntil = _.optionalFloat("CAN-SKIP-UNTIL", 0), l.canSkipDateRanges = l.canSkipUntil > 0 && _.bool("CAN-SKIP-DATERANGES"), l.partHoldBack = _.optionalFloat("PART-HOLD-BACK", 0), l.holdBack = _.optionalFloat("HOLD-BACK", 0);
            break;
          }
          case "PART-INF": {
            l.partTarget && Hr(l, j, x);
            const G = new ze(U);
            l.partTarget = G.decimalFloatingPoint("PART-TARGET");
            break;
          }
          case "PART": {
            let G = l.partList;
            G || (G = l.partList = []);
            const Y = g > 0 ? G[G.length - 1] : void 0, Q = g++, H = new ze(U, l), N = new xK(H, b, c, Q, Y);
            G.push(N), b.duration += N.duration;
            break;
          }
          case "PRELOAD-HINT": {
            const G = new ze(U, l);
            l.preloadHint = G;
            break;
          }
          case "RENDITION-REPORT": {
            const G = new ze(U, l);
            l.renditionReports = l.renditionReports || [], l.renditionReports.push(G);
            break;
          }
          default:
            Ae.warn(`line parsed but not handled: ${x}`);
            break;
        }
      }
    }
    y && !y.relurl ? (u.pop(), m -= y.duration, l.partList && (l.fragmentHint = y)) : l.partList && (Sf(b, y, d), b.cc = p, l.fragmentHint = b, A && ab(b, A, l)), l.targetduration || (l.playlistParsingError = new Error("#EXT-X-TARGETDURATION is required"));
    const R = u.length, D = u[0], F = u[R - 1];
    if (m += l.skippedSegments * l.targetduration, m > 0 && R && F) {
      l.averagetargetduration = m / R;
      const B = F.sn;
      l.endSN = B !== "initSegment" ? B : 0, l.live || (F.endList = !0), D && l.startCC === void 0 && (l.startCC = D.cc), T > 0 && (k3(u, T), D && d.unshift(D));
    } else
      l.endSN = 0, l.startCC = 0;
    return l.fragmentHint && (m += l.fragmentHint.duration), l.totalduration = m, d.length && l.dateRangeTagCount && D && nw(d, l), l.endCC = p, l;
  }
}
function nw(r, e) {
  const t = r.length;
  if (!t)
    return;
  const n = r[t - 1], i = e.live ? 1 / 0 : e.totalduration, s = Object.keys(e.dateRanges);
  for (let a = s.length; a--; ) {
    const o = e.dateRanges[s[a]], c = o.startDate.getTime();
    o.tagAnchor = n.ref;
    for (let l = t; l--; ) {
      const u = C3(e, c, r, l, i);
      if (u !== -1) {
        o.tagAnchor = e.fragments[u].ref;
        break;
      }
    }
  }
}
function C3(r, e, t, n, i) {
  const s = t[n];
  if (s) {
    const o = s.programDateTime;
    if (e >= o || n === 0) {
      var a;
      const c = (((a = t[n + 1]) == null ? void 0 : a.start) || i) - s.start;
      if (e <= o + c * 1e3) {
        const l = t[n].sn - r.startSN, u = r.fragments;
        if (u.length > t.length) {
          const f = (t[n + 1] || u[u.length - 1]).sn - r.startSN;
          for (let h = f; h > l; h--) {
            const g = u[h].programDateTime;
            if (e >= g && e < g + u[h].duration * 1e3)
              return h;
          }
        }
        return l;
      }
    }
  }
  return -1;
}
function tb(r, e, t) {
  var n, i;
  const s = new ze(r, t), a = (n = s.METHOD) != null ? n : "", o = s.URI, c = s.hexadecimalInteger("IV"), l = s.KEYFORMATVERSIONS, u = (i = s.KEYFORMAT) != null ? i : "identity";
  o && s.IV && !c && Ae.error(`Invalid IV: ${s.IV}`);
  const d = o ? Nr.resolve(o, e) : "", f = (l || "1").split("/").map(Number).filter(Number.isFinite);
  return new sc(a, d, u, f, c, s.KEYID);
}
function rb(r) {
  const t = new ze(r).decimalFloatingPoint("TIME-OFFSET");
  return X(t) ? t : null;
}
function nb(r, e) {
  let t = (r || "").split(/[ ,]+/).filter((n) => n);
  ["video", "audio", "text"].forEach((n) => {
    const i = t.filter((s) => Gg(s, n));
    i.length && (e[`${n}Codec`] = i.map((s) => s.split("/")[0]).join(","), t = t.filter((s) => i.indexOf(s) === -1));
  }), e.unknownCodecs = t;
}
function ib(r, e, t) {
  const n = e[t];
  n && (r[t] = n);
}
function k3(r, e) {
  let t = r[e];
  for (let n = e; n--; ) {
    const i = r[n];
    if (!i)
      return;
    i.programDateTime = t.programDateTime - i.duration * 1e3, t = i;
  }
}
function Sf(r, e, t) {
  r.rawProgramDateTime ? t.push(r) : e != null && e.programDateTime && (r.programDateTime = e.endProgramDateTime);
}
function sb(r, e, t, n) {
  r.relurl = e.URI, e.BYTERANGE && r.setByteRange(e.BYTERANGE), r.level = t, r.sn = "initSegment", n && (r.levelkeys = n), r.initSegment = null;
}
function ab(r, e, t) {
  r.levelkeys = e;
  const {
    encryptedFragments: n
  } = t;
  (!n.length || n[n.length - 1].levelkeys !== e) && Object.keys(e).some((i) => e[i].isCommonEncryption) && n.push(r);
}
function Hr(r, e, t) {
  r.playlistParsingError = new Error(`#EXT-X-${e} must not appear more than once (${t[0]})`);
}
function ob(r, e, t) {
  r.playlistParsingError = new Error(`#EXT-X-${e} must appear before the first Media Segment (${t[0]})`);
}
function Zu(r, e) {
  const t = e.startPTS;
  if (X(t)) {
    let n = 0, i;
    e.sn > r.sn ? (n = t - r.start, i = r) : (n = r.start - t, i = e), i.duration !== n && i.setDuration(n);
  } else e.sn > r.sn ? r.cc === e.cc && r.minEndPTS ? e.setStart(r.start + (r.minEndPTS - r.start)) : e.setStart(r.start + r.duration) : e.setStart(Math.max(r.start - e.duration, 0));
}
function iw(r, e, t, n, i, s) {
  n - t <= 0 && (Ae.warn("Fragment should have a positive duration", e), n = t + e.duration, s = i + e.duration);
  let o = t, c = n;
  const l = e.startPTS, u = e.endPTS;
  if (X(l)) {
    const p = Math.abs(l - t);
    X(e.deltaPTS) ? e.deltaPTS = Math.max(p, e.deltaPTS) : e.deltaPTS = p, o = Math.max(t, l), t = Math.min(t, l), i = Math.min(i, e.startDTS), c = Math.min(n, u), n = Math.max(n, u), s = Math.max(s, e.endDTS);
  }
  const d = t - e.start;
  e.start !== 0 && e.setStart(t), e.setDuration(n - e.start), e.startPTS = t, e.maxStartPTS = o, e.startDTS = i, e.endPTS = n, e.minEndPTS = c, e.endDTS = s;
  const f = e.sn;
  if (!r || f < r.startSN || f > r.endSN)
    return 0;
  let h;
  const g = f - r.startSN, m = r.fragments;
  for (m[g] = e, h = g; h > 0; h--)
    Zu(m[h], m[h - 1]);
  for (h = g; h < m.length - 1; h++)
    Zu(m[h], m[h + 1]);
  return r.fragmentHint && Zu(m[m.length - 1], r.fragmentHint), r.PTSKnown = r.alignedSliding = !0, d;
}
function M3(r, e) {
  if (r === e)
    return;
  let t = null;
  const n = r.fragments;
  for (let l = n.length - 1; l >= 0; l--) {
    const u = n[l].initSegment;
    if (u) {
      t = u;
      break;
    }
  }
  r.fragmentHint && delete r.fragmentHint.endPTS;
  let i;
  $3(r, e, (l, u, d, f) => {
    if ((!e.startCC || e.skippedSegments) && u.cc !== l.cc) {
      const h = l.cc - u.cc;
      for (let g = d; g < f.length; g++)
        f[g].cc += h;
      e.endCC = f[f.length - 1].cc;
    }
    X(l.startPTS) && X(l.endPTS) && (u.setStart(u.startPTS = l.startPTS), u.startDTS = l.startDTS, u.maxStartPTS = l.maxStartPTS, u.endPTS = l.endPTS, u.endDTS = l.endDTS, u.minEndPTS = l.minEndPTS, u.setDuration(l.endPTS - l.startPTS), u.duration && (i = u), e.PTSKnown = e.alignedSliding = !0), l.hasStreams && (u.elementaryStreams = l.elementaryStreams), u.loader = l.loader, l.hasStats && (u.stats = l.stats), l.initSegment && (u.initSegment = l.initSegment, t = l.initSegment);
  });
  const s = e.fragments, a = e.fragmentHint ? s.concat(e.fragmentHint) : s;
  if (t && a.forEach((l) => {
    var u;
    l && (!l.initSegment || l.initSegment.relurl === ((u = t) == null ? void 0 : u.relurl)) && (l.initSegment = t);
  }), e.skippedSegments) {
    if (e.deltaUpdateFailed = s.some((l) => !l), e.deltaUpdateFailed) {
      Ae.warn("[level-helper] Previous playlist missing segments skipped in delta playlist");
      for (let l = e.skippedSegments; l--; )
        s.shift();
      e.startSN = s[0].sn;
    } else {
      e.canSkipDateRanges && (e.dateRanges = N3(r.dateRanges, e));
      const l = r.fragments.filter((u) => u.rawProgramDateTime);
      if (r.hasProgramDateTime && !e.hasProgramDateTime)
        for (let u = 1; u < a.length; u++)
          a[u].programDateTime === null && Sf(a[u], a[u - 1], l);
      nw(l, e);
    }
    e.endCC = s[s.length - 1].cc;
  }
  if (!e.startCC) {
    var o;
    const l = ow(r, e.startSN - 1);
    e.startCC = (o = l == null ? void 0 : l.cc) != null ? o : s[0].cc;
  }
  F3(r.partList, e.partList, (l, u) => {
    u.elementaryStreams = l.elementaryStreams, u.stats = l.stats;
  }), i ? iw(e, i, i.startPTS, i.endPTS, i.startDTS, i.endDTS) : sw(r, e), s.length && (e.totalduration = e.edge - s[0].start), e.driftStartTime = r.driftStartTime, e.driftStart = r.driftStart;
  const c = e.advancedDateTime;
  if (e.advanced && c) {
    const l = e.edge;
    e.driftStart || (e.driftStartTime = c, e.driftStart = l), e.driftEndTime = c, e.driftEnd = l;
  } else
    e.driftEndTime = r.driftEndTime, e.driftEnd = r.driftEnd, e.advancedDateTime = r.advancedDateTime;
  e.requestScheduled === -1 && (e.requestScheduled = r.requestScheduled);
}
function N3(r, e) {
  const {
    dateRanges: t,
    recentlyRemovedDateranges: n
  } = e, i = Ce({}, r);
  n && n.forEach((o) => {
    delete i[o];
  });
  const a = Object.keys(i).length;
  return a && Object.keys(t).forEach((o) => {
    const c = i[o], l = new ew(t[o].attr, c);
    l.isValid ? (i[o] = l, c || (l.tagOrder += a)) : Ae.warn(`Ignoring invalid Playlist Delta Update DATERANGE tag: "${We(t[o].attr)}"`);
  }), i;
}
function F3(r, e, t) {
  if (r && e) {
    let n = 0;
    for (let i = 0, s = r.length; i <= s; i++) {
      const a = r[i], o = e[i + n];
      a && o && a.index === o.index && a.fragment.sn === o.fragment.sn ? t(a, o) : n--;
    }
  }
}
function $3(r, e, t) {
  const n = e.skippedSegments, i = Math.max(r.startSN, e.startSN) - e.startSN, s = (r.fragmentHint ? 1 : 0) + (n ? e.endSN : Math.min(r.endSN, e.endSN)) - e.startSN, a = e.startSN - r.startSN, o = e.fragmentHint ? e.fragments.concat(e.fragmentHint) : e.fragments, c = r.fragmentHint ? r.fragments.concat(r.fragmentHint) : r.fragments;
  for (let l = i; l <= s; l++) {
    const u = c[a + l];
    let d = o[l];
    if (n && !d && u && (d = e.fragments[l] = u), u && d) {
      if (t(u, d, l, o), u.url && u.url !== d.url) {
        e.playlistParsingError = lb(`media sequence mismatch ${d.sn}:`, r, e, u, d);
        return;
      } else if (u.cc !== d.cc) {
        e.playlistParsingError = lb(`discontinuity sequence mismatch (${u.cc}!=${d.cc})`, r, e, u, d);
        return;
      }
    }
  }
}
function lb(r, e, t, n, i) {
  return new Error(`${r} ${i.url}
Playlist starting @${e.startSN}
${e.m3u8}

Playlist starting @${t.startSN}
${t.m3u8}`);
}
function sw(r, e, t = !0) {
  const n = e.startSN + e.skippedSegments - r.startSN, i = r.fragments, s = n >= 0;
  let a = 0;
  if (s && n < i.length)
    a = i[n].start;
  else if (s && e.startSN === r.endSN + 1)
    a = r.fragmentEnd;
  else if (s && t)
    a = r.fragmentStart + n * e.levelTargetDuration;
  else if (!e.skippedSegments && e.fragmentStart === 0)
    a = r.fragmentStart;
  else
    return;
  Tf(e, a);
}
function Tf(r, e) {
  if (e) {
    const t = r.fragments;
    for (let n = r.skippedSegments; n < t.length; n++)
      t[n].addStart(e);
    r.fragmentHint && r.fragmentHint.addStart(e);
  }
}
function aw(r, e = 1 / 0) {
  let t = 1e3 * r.targetduration;
  if (r.updated) {
    const n = r.fragments;
    if (n.length && t * 4 > e) {
      const s = n[n.length - 1].duration * 1e3;
      s < t && (t = s);
    }
  } else
    t /= 2;
  return Math.round(t);
}
function ow(r, e, t) {
  if (!r)
    return null;
  let n = r.fragments[e - r.startSN];
  return n || (n = r.fragmentHint, n && n.sn === e) ? n : e < r.startSN && t && t.sn === e ? t : null;
}
function cb(r, e, t) {
  return r ? lw(r.partList, e, t) : null;
}
function lw(r, e, t) {
  if (r)
    for (let n = r.length; n--; ) {
      const i = r[n];
      if (i.index === t && i.fragment.sn === e)
        return i;
    }
  return null;
}
function cw(r) {
  r.forEach((e, t) => {
    var n;
    (n = e.details) == null || n.fragments.forEach((i) => {
      i.level = t, i.initSegment && (i.initSegment.level = t);
    });
  });
}
function $s(r, e) {
  for (let n = 0, i = r.length; n < i; n++) {
    var t;
    if (((t = r[n]) == null ? void 0 : t.cc) === e)
      return r[n];
  }
  return null;
}
function B3(r, e) {
  return !!(r && e.startCC < r.endCC && e.endCC > r.startCC);
}
function ub(r, e) {
  if (r) {
    const t = r.start + e;
    r.start = r.startPTS = t, r.endPTS = t + r.duration;
  }
}
function uw(r, e) {
  const t = e.fragments;
  for (let n = 0, i = t.length; n < i; n++)
    ub(t[n], r);
  e.fragmentHint && ub(e.fragmentHint, r), e.alignedSliding = !0;
}
function j3(r, e) {
  r && (dw(e, r), !e.alignedSliding && r && fl(e, r), !e.alignedSliding && r && !e.skippedSegments && sw(r, e, !1));
}
function dw(r, e) {
  if (!B3(e, r))
    return;
  const t = Math.min(e.endCC, r.endCC), n = $s(e.fragments, t), i = $s(r.fragments, t);
  if (!n || !i)
    return;
  Ae.log(`Aligning playlist at start of dicontinuity sequence ${t}`);
  const s = n.start - i.start;
  uw(s, r);
}
function fl(r, e) {
  if (!r.hasProgramDateTime || !e.hasProgramDateTime)
    return;
  const t = r.fragments, n = e.fragments;
  if (!t.length || !n.length)
    return;
  let i, s;
  const a = Math.min(e.endCC, r.endCC);
  e.startCC < a && r.startCC < a && (i = $s(n, a), s = $s(t, a)), (!i || !s) && (i = n[Math.floor(n.length / 2)], s = $s(t, i.cc) || t[Math.floor(t.length / 2)]);
  const o = i.programDateTime, c = s.programDateTime;
  if (!o || !c)
    return;
  const l = (c - o) / 1e3 - (s.start - i.start);
  uw(l, r);
}
const U3 = {
  toString: function(r) {
    let e = "";
    const t = r.length;
    for (let n = 0; n < t; n++)
      e += `[${r.start(n).toFixed(3)}-${r.end(n).toFixed(3)}]`;
    return e;
  }
}, $ = {
  STOPPED: "STOPPED",
  IDLE: "IDLE",
  KEY_LOADING: "KEY_LOADING",
  FRAG_LOADING: "FRAG_LOADING",
  FRAG_LOADING_WAITING_RETRY: "FRAG_LOADING_WAITING_RETRY",
  WAITING_TRACK: "WAITING_TRACK",
  PARSING: "PARSING",
  PARSED: "PARSED",
  ENDED: "ENDED",
  ERROR: "ERROR",
  WAITING_INIT_PTS: "WAITING_INIT_PTS",
  WAITING_LEVEL: "WAITING_LEVEL"
};
class zg extends ZA {
  constructor(e, t, n, i, s) {
    super(i, e.logger), this.hls = void 0, this.fragPrevious = null, this.fragCurrent = null, this.fragmentTracker = void 0, this.transmuxer = null, this._state = $.STOPPED, this.playlistType = void 0, this.media = null, this.mediaBuffer = null, this.config = void 0, this.bitrateTest = !1, this.lastCurrentTime = 0, this.nextLoadPosition = 0, this.startPosition = 0, this.startTimeOffset = null, this.retryDate = 0, this.levels = null, this.fragmentLoader = void 0, this.keyLoader = void 0, this.levelLastLoaded = null, this.startFragRequested = !1, this.decrypter = void 0, this.initPTS = [], this.buffering = !0, this.loadingParts = !1, this.loopSn = void 0, this.onMediaSeeking = () => {
      const {
        config: a,
        fragCurrent: o,
        media: c,
        mediaBuffer: l,
        state: u
      } = this, d = c ? c.currentTime : 0, f = ue.bufferInfo(l || c, d, a.maxBufferHole), h = !f.len;
      if (this.log(`Media seeking to ${X(d) ? d.toFixed(3) : d}, state: ${u}, ${h ? "out of" : "in"} buffer`), this.state === $.ENDED)
        this.resetLoadingState();
      else if (o) {
        const g = a.maxFragLookUpTolerance, m = o.start - g, p = o.start + o.duration + g;
        if (h || p < f.start || m > f.end) {
          const v = d > p;
          (d < m || v) && (v && o.loader && (this.log(`Cancelling fragment load for seek (sn: ${o.sn})`), o.abortRequests(), this.resetLoadingState()), this.fragPrevious = null);
        }
      }
      if (c) {
        this.fragmentTracker.removeFragmentsInRange(d, 1 / 0, this.playlistType, !0);
        const g = this.lastCurrentTime;
        if (d > g && (this.lastCurrentTime = d), !this.loadingParts) {
          const m = Math.max(f.end, d), p = this.shouldLoadParts(this.getLevelDetails(), m);
          p && (this.log(`LL-Part loading ON after seeking to ${d.toFixed(2)} with buffer @${m.toFixed(2)}`), this.loadingParts = p);
        }
      }
      this.hls.hasEnoughToStart || (this.log(`Setting ${h ? "startPosition" : "nextLoadPosition"} to ${d} for seek without enough to start`), this.nextLoadPosition = d, h && (this.startPosition = d)), this.tickImmediate();
    }, this.onMediaEnded = () => {
      this.log("setting startPosition to 0 because media ended"), this.startPosition = this.lastCurrentTime = 0;
    }, this.playlistType = s, this.hls = e, this.fragmentLoader = new g3(e.config), this.keyLoader = n, this.fragmentTracker = t, this.config = e.config, this.decrypter = new Wg(e.config);
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e.on(E.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(E.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(E.MANIFEST_LOADING, this.onManifestLoading, this), e.on(E.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(E.ERROR, this.onError, this);
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off(E.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(E.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(E.MANIFEST_LOADING, this.onManifestLoading, this), e.off(E.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(E.ERROR, this.onError, this);
  }
  doTick() {
    this.onTickEnd();
  }
  onTickEnd() {
  }
  startLoad(e) {
  }
  stopLoad() {
    if (this.state === $.STOPPED)
      return;
    this.fragmentLoader.abort(), this.keyLoader.abort(this.playlistType);
    const e = this.fragCurrent;
    e != null && e.loader && (e.abortRequests(), this.fragmentTracker.removeFragment(e)), this.resetTransmuxer(), this.fragCurrent = null, this.fragPrevious = null, this.clearInterval(), this.clearNextTick(), this.state = $.STOPPED;
  }
  get startPositionValue() {
    const {
      nextLoadPosition: e,
      startPosition: t
    } = this;
    return t === -1 && e ? e : t;
  }
  get bufferingEnabled() {
    return this.buffering;
  }
  pauseBuffering() {
    this.buffering = !1;
  }
  resumeBuffering() {
    this.buffering = !0;
  }
  get inFlightFrag() {
    return {
      frag: this.fragCurrent,
      state: this.state
    };
  }
  _streamEnded(e, t) {
    if (t.live || !this.media)
      return !1;
    const n = e.end || 0, i = this.config.timelineOffset || 0;
    if (n <= i)
      return !1;
    const s = e.buffered;
    this.config.maxBufferHole && s && s.length > 1 && (e = ue.bufferedInfo(s, e.start, 0));
    const a = e.nextStart;
    if (a && a > i && a < t.edge || this.media.currentTime < e.start)
      return !1;
    const c = t.partList;
    if (c != null && c.length) {
      const u = c[c.length - 1];
      return ue.isBuffered(this.media, u.start + u.duration / 2);
    }
    const l = t.fragments[t.fragments.length - 1].type;
    return this.fragmentTracker.isEndListAppended(l);
  }
  getLevelDetails() {
    if (this.levels && this.levelLastLoaded !== null) {
      var e;
      return (e = this.levelLastLoaded) == null ? void 0 : e.details;
    }
  }
  get timelineOffset() {
    const e = this.config.timelineOffset;
    if (e) {
      var t;
      return ((t = this.getLevelDetails()) == null ? void 0 : t.appliedTimelineOffset) || e;
    }
    return 0;
  }
  onMediaAttached(e, t) {
    const n = this.media = this.mediaBuffer = t.media;
    n.removeEventListener("seeking", this.onMediaSeeking), n.removeEventListener("ended", this.onMediaEnded), n.addEventListener("seeking", this.onMediaSeeking), n.addEventListener("ended", this.onMediaEnded);
    const i = this.config;
    this.levels && i.autoStartLoad && this.state === $.STOPPED && this.startLoad(i.startPosition);
  }
  onMediaDetaching(e, t) {
    const n = !!t.transferMedia, i = this.media;
    if (i !== null) {
      if (i.ended && (this.log("MSE detaching and video ended, reset startPosition"), this.startPosition = this.lastCurrentTime = 0), i.removeEventListener("seeking", this.onMediaSeeking), i.removeEventListener("ended", this.onMediaEnded), this.keyLoader && !n && this.keyLoader.detach(), this.media = this.mediaBuffer = null, this.loopSn = void 0, n) {
        this.resetLoadingState(), this.resetTransmuxer();
        return;
      }
      this.loadingParts = !1, this.fragmentTracker.removeAllFragments(), this.stopLoad();
    }
  }
  onManifestLoading() {
    this.initPTS = [], this.levels = this.levelLastLoaded = this.fragCurrent = null, this.lastCurrentTime = this.startPosition = 0, this.startFragRequested = !1;
  }
  onError(e, t) {
  }
  onManifestLoaded(e, t) {
    this.startTimeOffset = t.startTimeOffset;
  }
  onHandlerDestroying() {
    this.stopLoad(), this.transmuxer && (this.transmuxer.destroy(), this.transmuxer = null), super.onHandlerDestroying(), this.hls = this.onMediaSeeking = this.onMediaEnded = null;
  }
  onHandlerDestroyed() {
    this.state = $.STOPPED, this.fragmentLoader && this.fragmentLoader.destroy(), this.keyLoader && this.keyLoader.destroy(), this.decrypter && this.decrypter.destroy(), this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null, super.onHandlerDestroyed();
  }
  loadFragment(e, t, n) {
    this.startFragRequested = !0, this._loadFragForPlayback(e, t, n);
  }
  _loadFragForPlayback(e, t, n) {
    const i = (s) => {
      const a = s.frag;
      if (this.fragContextChanged(a)) {
        this.warn(`${a.type} sn: ${a.sn}${s.part ? " part: " + s.part.index : ""} of ${this.fragInfo(a, !1, s.part)}) was dropped during download.`), this.fragmentTracker.removeFragment(a);
        return;
      }
      a.stats.chunkCount++, this._handleFragmentLoadProgress(s);
    };
    this._doFragLoad(e, t, n, i).then((s) => {
      if (!s)
        return;
      const a = this.state, o = s.frag;
      if (this.fragContextChanged(o)) {
        (a === $.FRAG_LOADING || !this.fragCurrent && a === $.PARSING) && (this.fragmentTracker.removeFragment(o), this.state = $.IDLE);
        return;
      }
      "payload" in s && (this.log(`Loaded ${o.type} sn: ${o.sn} of ${this.playlistLabel()} ${o.level}`), this.hls.trigger(E.FRAG_LOADED, s)), this._handleFragmentLoadComplete(s);
    }).catch((s) => {
      this.state === $.STOPPED || this.state === $.ERROR || (this.warn(`Frag error: ${(s == null ? void 0 : s.message) || s}`), this.resetFragmentLoading(e));
    });
  }
  clearTrackerIfNeeded(e) {
    var t;
    const {
      fragmentTracker: n
    } = this;
    if (n.getState(e) === ct.APPENDING) {
      const s = e.type, a = this.getFwdBufferInfo(this.mediaBuffer, s), o = Math.max(e.duration, a ? a.len : this.config.maxBufferLength), c = this.backtrackFragment;
      ((c ? e.sn - c.sn : 0) === 1 || this.reduceMaxBufferLength(o, e.duration)) && n.removeFragment(e);
    } else ((t = this.mediaBuffer) == null ? void 0 : t.buffered.length) === 0 ? n.removeAllFragments() : n.hasParts(e.type) && (n.detectPartialFragments({
      frag: e,
      part: null,
      stats: e.stats,
      id: e.type
    }), n.getState(e) === ct.PARTIAL && n.removeFragment(e));
  }
  checkLiveUpdate(e) {
    if (e.updated && !e.live) {
      const t = e.fragments[e.fragments.length - 1];
      this.fragmentTracker.detectPartialFragments({
        frag: t,
        part: null,
        stats: t.stats,
        id: t.type
      });
    }
    e.fragments[0] || (e.deltaUpdateFailed = !0);
  }
  waitForLive(e) {
    const t = e.details;
    return (t == null ? void 0 : t.live) && t.type !== "EVENT" && (this.levelLastLoaded !== e || t.expired);
  }
  flushMainBuffer(e, t, n = null) {
    if (!(e - t))
      return;
    const i = {
      startOffset: e,
      endOffset: t,
      type: n
    };
    this.hls.trigger(E.BUFFER_FLUSHING, i);
  }
  _loadInitSegment(e, t) {
    this._doFragLoad(e, t).then((n) => {
      const i = n == null ? void 0 : n.frag;
      if (!i || this.fragContextChanged(i) || !this.levels)
        throw new Error("init load aborted");
      return n;
    }).then((n) => {
      const {
        hls: i
      } = this, {
        frag: s,
        payload: a
      } = n, o = s.decryptdata;
      if (a && a.byteLength > 0 && o != null && o.key && o.iv && Bi(o.method)) {
        const c = self.performance.now();
        return this.decrypter.decrypt(new Uint8Array(a), o.key.buffer, o.iv.buffer, qg(o.method)).catch((l) => {
          throw i.trigger(E.ERROR, {
            type: ne.MEDIA_ERROR,
            details: k.FRAG_DECRYPT_ERROR,
            fatal: !1,
            error: l,
            reason: l.message,
            frag: s
          }), l;
        }).then((l) => {
          const u = self.performance.now();
          return i.trigger(E.FRAG_DECRYPTED, {
            frag: s,
            payload: l,
            stats: {
              tstart: c,
              tdecrypt: u
            }
          }), n.payload = l, this.completeInitSegmentLoad(n);
        });
      }
      return this.completeInitSegmentLoad(n);
    }).catch((n) => {
      this.state === $.STOPPED || this.state === $.ERROR || (this.warn(n), this.resetFragmentLoading(e));
    });
  }
  completeInitSegmentLoad(e) {
    const {
      levels: t
    } = this;
    if (!t)
      throw new Error("init load aborted, missing levels");
    const n = e.frag.stats;
    this.state !== $.STOPPED && (this.state = $.IDLE), e.frag.data = new Uint8Array(e.payload), n.parsing.start = n.buffering.start = self.performance.now(), n.parsing.end = n.buffering.end = self.performance.now(), this.tick();
  }
  fragContextChanged(e) {
    const {
      fragCurrent: t
    } = this;
    return !e || !t || e.sn !== t.sn || e.level !== t.level;
  }
  fragBufferedComplete(e, t) {
    const n = this.mediaBuffer ? this.mediaBuffer : this.media;
    if (this.log(`Buffered ${e.type} sn: ${e.sn}${t ? " part: " + t.index : ""} of ${this.fragInfo(e, !1, t)} > buffer:${n ? U3.toString(ue.getBuffered(n)) : "(detached)"})`), it(e)) {
      var i;
      if (e.type !== ee.SUBTITLE) {
        const a = e.elementaryStreams;
        if (!Object.keys(a).some((o) => !!a[o])) {
          this.state = $.IDLE;
          return;
        }
      }
      const s = (i = this.levels) == null ? void 0 : i[e.level];
      s != null && s.fragmentError && (this.log(`Resetting level fragment error count of ${s.fragmentError} on frag buffered`), s.fragmentError = 0);
    }
    this.state = $.IDLE;
  }
  _handleFragmentLoadComplete(e) {
    const {
      transmuxer: t
    } = this;
    if (!t)
      return;
    const {
      frag: n,
      part: i,
      partsLoaded: s
    } = e, a = !s || s.length === 0 || s.some((c) => !c), o = new Hg(n.level, n.sn, n.stats.chunkCount + 1, 0, i ? i.index : -1, !a);
    t.flush(o);
  }
  _handleFragmentLoadProgress(e) {
  }
  _doFragLoad(e, t, n = null, i) {
    var s;
    this.fragCurrent = e;
    const a = t == null ? void 0 : t.details;
    if (!this.levels || !a)
      throw new Error(`frag load aborted, missing level${a ? "" : " detail"}s`);
    let o = null;
    e.encrypted && !((s = e.decryptdata) != null && s.key) ? (this.log(`Loading key for ${e.sn} of [${a.startSN}-${a.endSN}], ${this.playlistLabel()} ${e.level}`), this.state = $.KEY_LOADING, this.fragCurrent = e, o = this.keyLoader.load(e).then((d) => {
      if (!this.fragContextChanged(d.frag))
        return this.hls.trigger(E.KEY_LOADED, d), this.state === $.KEY_LOADING && (this.state = $.IDLE), d;
    }), this.hls.trigger(E.KEY_LOADING, {
      frag: e
    }), this.fragCurrent === null && (o = Promise.reject(new Error("frag load aborted, context changed in KEY_LOADING")))) : e.encrypted || (o = this.keyLoader.loadClear(e, a.encryptedFragments, this.startFragRequested), o && this.log("[eme] blocking frag load until media-keys acquired"));
    const c = this.fragPrevious;
    if (it(e) && (!c || e.sn !== c.sn)) {
      const d = this.shouldLoadParts(t.details, e.end);
      d !== this.loadingParts && (this.log(`LL-Part loading ${d ? "ON" : "OFF"} loading sn ${c == null ? void 0 : c.sn}->${e.sn}`), this.loadingParts = d);
    }
    if (n = Math.max(e.start, n || 0), this.loadingParts && it(e)) {
      const d = a.partList;
      if (d && i) {
        n > e.end && a.fragmentHint && (e = a.fragmentHint);
        const f = this.getNextPart(d, e, n);
        if (f > -1) {
          const h = d[f];
          e = this.fragCurrent = h.fragment, this.log(`Loading ${e.type} sn: ${e.sn} part: ${h.index} (${f}/${d.length - 1}) of ${this.fragInfo(e, !1, h)}) cc: ${e.cc} [${a.startSN}-${a.endSN}], target: ${parseFloat(n.toFixed(3))}`), this.nextLoadPosition = h.start + h.duration, this.state = $.FRAG_LOADING;
          let g;
          return o ? g = o.then((m) => !m || this.fragContextChanged(m.frag) ? null : this.doFragPartsLoad(e, h, t, i)).catch((m) => this.handleFragLoadError(m)) : g = this.doFragPartsLoad(e, h, t, i).catch((m) => this.handleFragLoadError(m)), this.hls.trigger(E.FRAG_LOADING, {
            frag: e,
            part: h,
            targetBufferTime: n
          }), this.fragCurrent === null ? Promise.reject(new Error("frag load aborted, context changed in FRAG_LOADING parts")) : g;
        } else if (!e.url || this.loadedEndOfParts(d, n))
          return Promise.resolve(null);
      }
    }
    if (it(e) && this.loadingParts)
      this.log(`LL-Part loading OFF after next part miss @${n.toFixed(2)}`), this.loadingParts = !1;
    else if (!e.url)
      return Promise.resolve(null);
    this.log(`Loading ${e.type} sn: ${e.sn} of ${this.fragInfo(e, !1)}) cc: ${e.cc} ${a ? "[" + a.startSN + "-" + a.endSN + "]" : ""}, target: ${parseFloat(n.toFixed(3))}`), X(e.sn) && !this.bitrateTest && (this.nextLoadPosition = e.start + e.duration), this.state = $.FRAG_LOADING;
    const l = this.config.progressive;
    let u;
    return l && o ? u = o.then((d) => !d || this.fragContextChanged(d == null ? void 0 : d.frag) ? null : this.fragmentLoader.load(e, i)).catch((d) => this.handleFragLoadError(d)) : u = Promise.all([this.fragmentLoader.load(e, l ? i : void 0), o]).then(([d]) => (!l && d && i && i(d), d)).catch((d) => this.handleFragLoadError(d)), this.hls.trigger(E.FRAG_LOADING, {
      frag: e,
      targetBufferTime: n
    }), this.fragCurrent === null ? Promise.reject(new Error("frag load aborted, context changed in FRAG_LOADING")) : u;
  }
  doFragPartsLoad(e, t, n, i) {
    return new Promise((s, a) => {
      var o;
      const c = [], l = (o = n.details) == null ? void 0 : o.partList, u = (d) => {
        this.fragmentLoader.loadPart(e, d, i).then((f) => {
          c[d.index] = f;
          const h = f.part;
          this.hls.trigger(E.FRAG_LOADED, f);
          const g = cb(n.details, e.sn, d.index + 1) || lw(l, e.sn, d.index + 1);
          if (g)
            u(g);
          else
            return s({
              frag: e,
              part: h,
              partsLoaded: c
            });
        }).catch(a);
      };
      u(t);
    });
  }
  handleFragLoadError(e) {
    if ("data" in e) {
      const t = e.data;
      e.data && t.details === k.INTERNAL_ABORTED ? this.handleFragLoadAborted(t.frag, t.part) : this.hls.trigger(E.ERROR, t);
    } else
      this.hls.trigger(E.ERROR, {
        type: ne.OTHER_ERROR,
        details: k.INTERNAL_EXCEPTION,
        err: e,
        error: e,
        fatal: !0
      });
    return null;
  }
  _handleTransmuxerFlush(e) {
    const t = this.getCurrentContext(e);
    if (!t || this.state !== $.PARSING) {
      !this.fragCurrent && this.state !== $.STOPPED && this.state !== $.ERROR && (this.state = $.IDLE);
      return;
    }
    const {
      frag: n,
      part: i,
      level: s
    } = t, a = self.performance.now();
    n.stats.parsing.end = a, i && (i.stats.parsing.end = a);
    const o = this.getLevelDetails(), l = o && n.sn > o.endSN || this.shouldLoadParts(o, n.end);
    l !== this.loadingParts && (this.log(`LL-Part loading ${l ? "ON" : "OFF"} after parsing segment ending @${n.end.toFixed(2)}`), this.loadingParts = l), this.updateLevelTiming(n, i, s, e.partial);
  }
  shouldLoadParts(e, t) {
    if (this.config.lowLatencyMode) {
      if (!e)
        return this.loadingParts;
      if (e != null && e.partList) {
        var n;
        const s = e.partList[0], a = s.end + (((n = e.fragmentHint) == null ? void 0 : n.duration) || 0);
        if (t >= a) {
          var i;
          if ((this.hls.hasEnoughToStart ? ((i = this.media) == null ? void 0 : i.currentTime) || this.lastCurrentTime : this.getLoadPosition()) > s.start - s.fragment.duration)
            return !0;
        }
      }
    }
    return !1;
  }
  getCurrentContext(e) {
    const {
      levels: t,
      fragCurrent: n
    } = this, {
      level: i,
      sn: s,
      part: a
    } = e;
    if (!(t != null && t[i]))
      return this.warn(`Levels object was unset while buffering fragment ${s} of ${this.playlistLabel()} ${i}. The current chunk will not be buffered.`), null;
    const o = t[i], c = o.details, l = a > -1 ? cb(c, s, a) : null, u = l ? l.fragment : ow(c, s, n);
    return u ? (n && n !== u && (u.stats = n.stats), {
      frag: u,
      part: l,
      level: o
    }) : null;
  }
  bufferFragmentData(e, t, n, i, s) {
    var a;
    if (!e || this.state !== $.PARSING)
      return;
    const {
      data1: o,
      data2: c
    } = e;
    let l = o;
    if (o && c && (l = yr(o, c)), !((a = l) != null && a.length))
      return;
    const u = this.initPTS[t.cc], d = u ? -u.baseTime / u.timescale : void 0, f = {
      type: e.type,
      frag: t,
      part: n,
      chunkMeta: i,
      offset: d,
      parent: t.type,
      data: l
    };
    if (this.hls.trigger(E.BUFFER_APPENDING, f), e.dropped && e.independent && !n) {
      if (s)
        return;
      this.flushBufferGap(t);
    }
  }
  flushBufferGap(e) {
    const t = this.media;
    if (!t)
      return;
    if (!ue.isBuffered(t, t.currentTime)) {
      this.flushMainBuffer(0, e.start);
      return;
    }
    const n = t.currentTime, i = ue.bufferInfo(t, n, 0), s = e.duration, a = Math.min(this.config.maxFragLookUpTolerance * 2, s * 0.25), o = Math.max(Math.min(e.start - a, i.end - a), n + a);
    e.start - o > a && this.flushMainBuffer(o, e.start);
  }
  getFwdBufferInfo(e, t) {
    var n;
    const i = this.getLoadPosition();
    if (!X(i))
      return null;
    const a = this.lastCurrentTime > i || (n = this.media) != null && n.paused ? 0 : this.config.maxBufferHole;
    return this.getFwdBufferInfoAtPos(e, i, t, a);
  }
  getFwdBufferInfoAtPos(e, t, n, i) {
    const s = ue.bufferInfo(e, t, i);
    if (s.len === 0 && s.nextStart !== void 0) {
      const a = this.fragmentTracker.getBufferedFrag(t, n);
      if (a && (s.nextStart <= a.end || a.gap)) {
        const o = Math.max(Math.min(s.nextStart, a.end) - t, i);
        return ue.bufferInfo(e, t, o);
      }
    }
    return s;
  }
  getMaxBufferLength(e) {
    const {
      config: t
    } = this;
    let n;
    return e ? n = Math.max(8 * t.maxBufferSize / e, t.maxBufferLength) : n = t.maxBufferLength, Math.min(n, t.maxMaxBufferLength);
  }
  reduceMaxBufferLength(e, t) {
    const n = this.config, i = Math.max(Math.min(e - t, n.maxBufferLength), t), s = Math.max(e - t * 3, n.maxMaxBufferLength / 2, i);
    return s >= i ? (n.maxMaxBufferLength = s, this.warn(`Reduce max buffer length to ${s}s`), !0) : !1;
  }
  getAppendedFrag(e, t = ee.MAIN) {
    var n;
    const i = (n = this.fragmentTracker) == null ? void 0 : n.getAppendedFrag(e, t);
    return i && "fragment" in i ? i.fragment : i;
  }
  getNextFragment(e, t) {
    const n = t.fragments, i = n.length;
    if (!i)
      return null;
    const {
      config: s
    } = this, a = n[0].start, o = s.lowLatencyMode && !!t.partList;
    let c = null;
    if (t.live) {
      const d = s.initialLiveManifestSize;
      if (i < d)
        return this.warn(`Not enough fragments to start playback (have: ${i}, need: ${d})`), null;
      if (!t.PTSKnown && !this.startFragRequested && this.startPosition === -1 || e < a) {
        var l;
        o && !this.loadingParts && (this.log("LL-Part loading ON for initial live fragment"), this.loadingParts = !0), c = this.getInitialLiveFragment(t);
        const f = this.hls.startPosition, h = this.hls.liveSyncPosition, g = c ? (f !== -1 && f >= a ? f : h) || c.start : e;
        this.log(`Setting startPosition to ${g} to match start frag at live edge. mainStart: ${f} liveSyncPosition: ${h} frag.start: ${(l = c) == null ? void 0 : l.start}`), this.startPosition = this.nextLoadPosition = g;
      }
    } else e <= a && (c = n[0]);
    if (!c) {
      const d = this.loadingParts ? t.partEnd : t.fragmentEnd;
      c = this.getFragmentAtPosition(e, d, t);
    }
    let u = this.filterReplacedPrimary(c, t);
    if (!u && c) {
      const d = c.sn - t.startSN;
      u = this.filterReplacedPrimary(n[d + 1] || null, t);
    }
    return this.mapToInitFragWhenRequired(u);
  }
  isLoopLoading(e, t) {
    const n = this.fragmentTracker.getState(e);
    return (n === ct.OK || n === ct.PARTIAL && !!e.gap) && this.nextLoadPosition > t;
  }
  getNextFragmentLoopLoading(e, t, n, i, s) {
    let a = null;
    if (e.gap && (a = this.getNextFragment(this.nextLoadPosition, t), a && !a.gap && n.nextStart)) {
      const o = this.getFwdBufferInfoAtPos(this.mediaBuffer ? this.mediaBuffer : this.media, n.nextStart, i, 0);
      if (o !== null && n.len + o.len >= s) {
        const c = a.sn;
        return this.loopSn !== c && (this.log(`buffer full after gaps in "${i}" playlist starting at sn: ${c}`), this.loopSn = c), null;
      }
    }
    return this.loopSn = void 0, a;
  }
  get primaryPrefetch() {
    if (db(this.hls.config)) {
      var e, t;
      if ((e = this.hls.interstitialsManager) == null || (t = e.playingItem) == null ? void 0 : t.event)
        return !0;
    }
    return !1;
  }
  filterReplacedPrimary(e, t) {
    if (!e)
      return e;
    if (db(this.hls.config) && e.type !== ee.SUBTITLE) {
      const n = this.hls.interstitialsManager, i = n == null ? void 0 : n.bufferingItem;
      if (i) {
        const a = i.event;
        if (a) {
          if (a.appendInPlace || Math.abs(e.start - i.start) > 1 || i.start === 0)
            return null;
        } else if (e.end <= i.start && (t == null ? void 0 : t.live) === !1 || e.start > i.end && i.nextEvent && (i.nextEvent.appendInPlace || e.start - i.end > 1))
          return null;
      }
      const s = n == null ? void 0 : n.playerQueue;
      if (s)
        for (let a = s.length; a--; ) {
          const o = s[a].interstitial;
          if (o.appendInPlace && e.start >= o.startTime && e.end <= o.resumeTime)
            return null;
        }
    }
    return e;
  }
  mapToInitFragWhenRequired(e) {
    return e != null && e.initSegment && !(e != null && e.initSegment.data) && !this.bitrateTest ? e.initSegment : e;
  }
  getNextPart(e, t, n) {
    let i = -1, s = !1, a = !0;
    for (let o = 0, c = e.length; o < c; o++) {
      const l = e[o];
      if (a = a && !l.independent, i > -1 && n < l.start)
        break;
      const u = l.loaded;
      u ? i = -1 : (s || l.independent || a) && l.fragment === t && (i = o), s = u;
    }
    return i;
  }
  loadedEndOfParts(e, t) {
    const n = e[e.length - 1];
    return n && t > n.start && n.loaded;
  }
  /*
   This method is used find the best matching first fragment for a live playlist. This fragment is used to calculate the
   "sliding" of the playlist, which is its offset from the start of playback. After sliding we can compute the real
   start and end times for each fragment in the playlist (after which this method will not need to be called).
  */
  getInitialLiveFragment(e) {
    const t = e.fragments, n = this.fragPrevious;
    let i = null;
    if (n) {
      if (e.hasProgramDateTime && (this.log(`Live playlist, switching playlist, load frag with same PDT: ${n.programDateTime}`), i = r3(t, n.endProgramDateTime, this.config.maxFragLookUpTolerance)), !i) {
        const s = n.sn + 1;
        if (s >= e.startSN && s <= e.endSN) {
          const a = t[s - e.startSN];
          n.cc === a.cc && (i = a, this.log(`Live playlist, switching playlist, load frag with next SN: ${i.sn}`));
        }
        i || (i = QA(e, n.cc, n.end), i && this.log(`Live playlist, switching playlist, load frag with same CC: ${i.sn}`));
      }
    } else {
      const s = this.hls.liveSyncPosition;
      s !== null && (i = this.getFragmentAtPosition(s, this.bitrateTest ? e.fragmentEnd : e.edge, e));
    }
    return i;
  }
  /*
  This method finds the best matching fragment given the provided position.
   */
  getFragmentAtPosition(e, t, n) {
    const {
      config: i
    } = this;
    let {
      fragPrevious: s
    } = this, {
      fragments: a,
      endSN: o
    } = n;
    const {
      fragmentHint: c
    } = n, {
      maxFragLookUpTolerance: l
    } = i, u = n.partList, d = !!(this.loadingParts && u != null && u.length && c);
    d && c && !this.bitrateTest && u[u.length - 1].fragment.sn === c.sn && (a = a.concat(c), o = c.sn);
    let f;
    if (e < t) {
      var h;
      const m = e < this.lastCurrentTime || e > t - l || (h = this.media) != null && h.paused || !this.startFragRequested ? 0 : l;
      f = mi(s, a, e, m);
    } else
      f = a[a.length - 1];
    if (f) {
      const g = f.sn - n.startSN, m = this.fragmentTracker.getState(f);
      if ((m === ct.OK || m === ct.PARTIAL && f.gap) && (s = f), s && f.sn === s.sn && (!d || u[0].fragment.sn > f.sn || !n.live && !d) && s && f.level === s.level) {
        const v = a[g + 1];
        f.sn < o && this.fragmentTracker.getState(v) !== ct.OK ? f = v : f = null;
      }
    }
    return f;
  }
  alignPlaylists(e, t, n) {
    const i = e.fragments.length;
    if (!i)
      return this.warn("No fragments in live playlist"), 0;
    const s = e.fragmentStart, a = !t, o = e.alignedSliding && X(s);
    if (a || !o && !s) {
      j3(n, e);
      const c = e.fragmentStart;
      return this.log(`Live playlist sliding: ${c.toFixed(2)} start-sn: ${t ? t.startSN : "na"}->${e.startSN} fragments: ${i}`), c;
    }
    return s;
  }
  waitForCdnTuneIn(e) {
    return e.live && e.canBlockReload && e.partTarget && e.tuneInGoal > Math.max(e.partHoldBack, e.partTarget * 3);
  }
  setStartPosition(e, t) {
    let n = this.startPosition;
    n < t && (n = -1);
    const i = this.timelineOffset;
    if (n === -1) {
      const s = this.startTimeOffset !== null, a = s ? this.startTimeOffset : e.startTimeOffset;
      a !== null && X(a) ? (n = t + a, a < 0 && (n += e.edge), n = Math.min(Math.max(t, n), t + e.totalduration), this.log(`Setting startPosition to ${n} for start time offset ${a} found in ${s ? "multivariant" : "media"} playlist`), this.startPosition = n) : e.live ? (n = this.hls.liveSyncPosition || t, this.log(`Setting startPosition to -1 to start at live edge ${n}`), this.startPosition = -1) : (this.log("setting startPosition to 0 by default"), this.startPosition = n = 0), this.lastCurrentTime = n + i;
    }
    this.nextLoadPosition = n + i;
  }
  getLoadPosition() {
    var e;
    const {
      media: t
    } = this;
    let n = 0;
    return (e = this.hls) != null && e.hasEnoughToStart && t ? n = t.currentTime : this.nextLoadPosition >= 0 && (n = this.nextLoadPosition), n;
  }
  handleFragLoadAborted(e, t) {
    this.transmuxer && e.type === this.playlistType && it(e) && e.stats.aborted && (this.log(`Fragment ${e.sn}${t ? " part " + t.index : ""} of ${this.playlistLabel()} ${e.level} was aborted`), this.resetFragmentLoading(e));
  }
  resetFragmentLoading(e) {
    (!this.fragCurrent || !this.fragContextChanged(e) && this.state !== $.FRAG_LOADING_WAITING_RETRY) && (this.state = $.IDLE);
  }
  onFragmentOrKeyLoadError(e, t) {
    if (t.chunkMeta && !t.frag) {
      const g = this.getCurrentContext(t.chunkMeta);
      g && (t.frag = g.frag);
    }
    const n = t.frag;
    if (!n || n.type !== e || !this.levels)
      return;
    if (this.fragContextChanged(n)) {
      var i;
      this.warn(`Frag load error must match current frag to retry ${n.url} > ${(i = this.fragCurrent) == null ? void 0 : i.url}`);
      return;
    }
    const s = t.details === k.FRAG_GAP;
    s && this.fragmentTracker.fragBuffered(n, !0);
    const a = t.errorAction, {
      action: o,
      flags: c,
      retryCount: l = 0,
      retryConfig: u
    } = a || {}, d = !!a && !!u, f = d && o === Pt.RetryRequest, h = d && !a.resolved && c === Ar.MoveAllAlternatesMatchingHost;
    if (!f && h && it(n) && !n.endList)
      this.resetFragmentErrors(e), this.treatAsGap(n), a.resolved = !0;
    else if ((f || h) && l < u.maxNumRetry) {
      this.resetStartWhenNotLoaded(this.levelLastLoaded);
      const g = Vg(u, l);
      this.warn(`Fragment ${n.sn} of ${e} ${n.level} errored with ${t.details}, retrying loading ${l + 1}/${u.maxNumRetry} in ${g}ms`), a.resolved = !0, this.retryDate = self.performance.now() + g, this.state = $.FRAG_LOADING_WAITING_RETRY;
    } else if (u && a)
      if (this.resetFragmentErrors(e), l < u.maxNumRetry)
        !s && o !== Pt.RemoveAlternatePermanently && (a.resolved = !0);
      else {
        this.warn(`${t.details} reached or exceeded max retry (${l})`);
        return;
      }
    else o === Pt.SendAlternateToPenaltyBox ? this.state = $.WAITING_LEVEL : this.state = $.ERROR;
    this.tickImmediate();
  }
  reduceLengthAndFlushBuffer(e) {
    if (this.state === $.PARSING || this.state === $.PARSED) {
      const t = e.frag, n = e.parent, i = this.getFwdBufferInfo(this.mediaBuffer, n), s = i && i.len > 0.5;
      s && this.reduceMaxBufferLength(i.len, (t == null ? void 0 : t.duration) || 10);
      const a = !s;
      return a && this.warn(`Buffer full error while media.currentTime is not buffered, flush ${n} buffer`), t && (this.fragmentTracker.removeFragment(t), this.nextLoadPosition = t.start), this.resetLoadingState(), a;
    }
    return !1;
  }
  resetFragmentErrors(e) {
    e === ee.AUDIO && (this.fragCurrent = null), this.hls.hasEnoughToStart || (this.startFragRequested = !1), this.state !== $.STOPPED && (this.state = $.IDLE);
  }
  afterBufferFlushed(e, t, n) {
    if (!e)
      return;
    const i = ue.getBuffered(e);
    this.fragmentTracker.detectEvictedFragments(t, i, n), this.state === $.ENDED && this.resetLoadingState();
  }
  resetLoadingState() {
    this.log("Reset loading state"), this.fragCurrent = null, this.fragPrevious = null, this.state !== $.STOPPED && (this.state = $.IDLE);
  }
  resetStartWhenNotLoaded(e) {
    if (!this.hls.hasEnoughToStart) {
      this.startFragRequested = !1;
      const t = e ? e.details : null;
      t != null && t.live ? (this.log("resetting startPosition for live start"), this.startPosition = -1, this.setStartPosition(t, t.fragmentStart), this.resetLoadingState()) : this.nextLoadPosition = this.startPosition;
    }
  }
  resetWhenMissingContext(e) {
    this.warn(`The loading context changed while buffering fragment ${e.sn} of ${this.playlistLabel()} ${e.level}. This chunk will not be buffered.`), this.removeUnbufferedFrags(), this.resetStartWhenNotLoaded(this.levelLastLoaded), this.resetLoadingState();
  }
  removeUnbufferedFrags(e = 0) {
    this.fragmentTracker.removeFragmentsInRange(e, 1 / 0, this.playlistType, !1, !0);
  }
  updateLevelTiming(e, t, n, i) {
    const s = n.details;
    if (!s) {
      this.warn("level.details undefined");
      return;
    }
    if (!Object.keys(e.elementaryStreams).reduce((c, l) => {
      const u = e.elementaryStreams[l];
      if (u) {
        const d = u.endPTS - u.startPTS;
        if (d <= 0)
          return this.warn(`Could not parse fragment ${e.sn} ${l} duration reliably (${d})`), c || !1;
        const f = i ? 0 : iw(s, e, u.startPTS, u.endPTS, u.startDTS, u.endDTS);
        return this.hls.trigger(E.LEVEL_PTS_UPDATED, {
          details: s,
          level: n,
          drift: f,
          type: l,
          frag: e,
          start: u.startPTS,
          end: u.endPTS
        }), !0;
      }
      return c;
    }, !1)) {
      var o;
      if (n.fragmentError === 0 && this.treatAsGap(e, n), ((o = this.transmuxer) == null ? void 0 : o.error) === null) {
        const c = new Error(`Found no media in fragment ${e.sn} of ${this.playlistLabel()} ${e.level} resetting transmuxer to fallback to playlist timing`);
        if (this.warn(c.message), this.hls.trigger(E.ERROR, {
          type: ne.MEDIA_ERROR,
          details: k.FRAG_PARSING_ERROR,
          fatal: !1,
          error: c,
          frag: e,
          reason: `Found no media in msn ${e.sn} of ${this.playlistLabel()} "${n.url}"`
        }), !this.hls)
          return;
        this.resetTransmuxer();
      }
    }
    this.state = $.PARSED, this.log(`Parsed ${e.type} sn: ${e.sn}${t ? " part: " + t.index : ""} of ${this.fragInfo(e, !1, t)})`), this.hls.trigger(E.FRAG_PARSED, {
      frag: e,
      part: t
    });
  }
  playlistLabel() {
    return this.playlistType === ee.MAIN ? "level" : "track";
  }
  fragInfo(e, t = !0, n) {
    var i, s;
    return `${this.playlistLabel()} ${e.level} (${n ? "part" : "frag"}:[${((i = t && !n ? e.startPTS : (n || e).start) != null ? i : NaN).toFixed(3)}-${((s = t && !n ? e.endPTS : (n || e).end) != null ? s : NaN).toFixed(3)}]${n && e.type === "main" ? "INDEPENDENT=" + (n.independent ? "YES" : "NO") : ""}`;
  }
  treatAsGap(e, t) {
    t && t.fragmentError++, e.gap = !0, this.fragmentTracker.removeFragment(e), this.fragmentTracker.fragBuffered(e, !0);
  }
  resetTransmuxer() {
    var e;
    (e = this.transmuxer) == null || e.reset();
  }
  recoverWorkerError(e) {
    e.event === "demuxerWorker" && (this.fragmentTracker.removeAllFragments(), this.transmuxer && (this.transmuxer.destroy(), this.transmuxer = null), this.resetStartWhenNotLoaded(this.levelLastLoaded), this.resetLoadingState());
  }
  set state(e) {
    const t = this._state;
    t !== e && (this._state = e, this.log(`${t}->${e}`));
  }
  get state() {
    return this._state;
  }
}
function db(r) {
  return !!r.interstitialsController && r.enableInterstitialPlayback !== !1;
}
class fw {
  constructor() {
    this.chunks = [], this.dataLength = 0;
  }
  push(e) {
    this.chunks.push(e), this.dataLength += e.length;
  }
  flush() {
    const {
      chunks: e,
      dataLength: t
    } = this;
    let n;
    if (e.length)
      e.length === 1 ? n = e[0] : n = G3(e, t);
    else return new Uint8Array(0);
    return this.reset(), n;
  }
  reset() {
    this.chunks.length = 0, this.dataLength = 0;
  }
}
function G3(r, e) {
  const t = new Uint8Array(e);
  let n = 0;
  for (let i = 0; i < r.length; i++) {
    const s = r[i];
    t.set(s, n), n += s.length;
  }
  return t;
}
var Ju = { exports: {} }, fb;
function K3() {
  return fb || (fb = 1, function(r) {
    var e = Object.prototype.hasOwnProperty, t = "~";
    function n() {
    }
    Object.create && (n.prototype = /* @__PURE__ */ Object.create(null), new n().__proto__ || (t = !1));
    function i(c, l, u) {
      this.fn = c, this.context = l, this.once = u || !1;
    }
    function s(c, l, u, d, f) {
      if (typeof u != "function")
        throw new TypeError("The listener must be a function");
      var h = new i(u, d || c, f), g = t ? t + l : l;
      return c._events[g] ? c._events[g].fn ? c._events[g] = [c._events[g], h] : c._events[g].push(h) : (c._events[g] = h, c._eventsCount++), c;
    }
    function a(c, l) {
      --c._eventsCount === 0 ? c._events = new n() : delete c._events[l];
    }
    function o() {
      this._events = new n(), this._eventsCount = 0;
    }
    o.prototype.eventNames = function() {
      var l = [], u, d;
      if (this._eventsCount === 0) return l;
      for (d in u = this._events)
        e.call(u, d) && l.push(t ? d.slice(1) : d);
      return Object.getOwnPropertySymbols ? l.concat(Object.getOwnPropertySymbols(u)) : l;
    }, o.prototype.listeners = function(l) {
      var u = t ? t + l : l, d = this._events[u];
      if (!d) return [];
      if (d.fn) return [d.fn];
      for (var f = 0, h = d.length, g = new Array(h); f < h; f++)
        g[f] = d[f].fn;
      return g;
    }, o.prototype.listenerCount = function(l) {
      var u = t ? t + l : l, d = this._events[u];
      return d ? d.fn ? 1 : d.length : 0;
    }, o.prototype.emit = function(l, u, d, f, h, g) {
      var m = t ? t + l : l;
      if (!this._events[m]) return !1;
      var p = this._events[m], v = arguments.length, y, b;
      if (p.fn) {
        switch (p.once && this.removeListener(l, p.fn, void 0, !0), v) {
          case 1:
            return p.fn.call(p.context), !0;
          case 2:
            return p.fn.call(p.context, u), !0;
          case 3:
            return p.fn.call(p.context, u, d), !0;
          case 4:
            return p.fn.call(p.context, u, d, f), !0;
          case 5:
            return p.fn.call(p.context, u, d, f, h), !0;
          case 6:
            return p.fn.call(p.context, u, d, f, h, g), !0;
        }
        for (b = 1, y = new Array(v - 1); b < v; b++)
          y[b - 1] = arguments[b];
        p.fn.apply(p.context, y);
      } else {
        var x = p.length, S;
        for (b = 0; b < x; b++)
          switch (p[b].once && this.removeListener(l, p[b].fn, void 0, !0), v) {
            case 1:
              p[b].fn.call(p[b].context);
              break;
            case 2:
              p[b].fn.call(p[b].context, u);
              break;
            case 3:
              p[b].fn.call(p[b].context, u, d);
              break;
            case 4:
              p[b].fn.call(p[b].context, u, d, f);
              break;
            default:
              if (!y) for (S = 1, y = new Array(v - 1); S < v; S++)
                y[S - 1] = arguments[S];
              p[b].fn.apply(p[b].context, y);
          }
      }
      return !0;
    }, o.prototype.on = function(l, u, d) {
      return s(this, l, u, d, !1);
    }, o.prototype.once = function(l, u, d) {
      return s(this, l, u, d, !0);
    }, o.prototype.removeListener = function(l, u, d, f) {
      var h = t ? t + l : l;
      if (!this._events[h]) return this;
      if (!u)
        return a(this, h), this;
      var g = this._events[h];
      if (g.fn)
        g.fn === u && (!f || g.once) && (!d || g.context === d) && a(this, h);
      else {
        for (var m = 0, p = [], v = g.length; m < v; m++)
          (g[m].fn !== u || f && !g[m].once || d && g[m].context !== d) && p.push(g[m]);
        p.length ? this._events[h] = p.length === 1 ? p[0] : p : a(this, h);
      }
      return this;
    }, o.prototype.removeAllListeners = function(l) {
      var u;
      return l ? (u = t ? t + l : l, this._events[u] && a(this, u)) : (this._events = new n(), this._eventsCount = 0), this;
    }, o.prototype.off = o.prototype.removeListener, o.prototype.addListener = o.prototype.on, o.prefixed = t, o.EventEmitter = o, r.exports = o;
  }(Ju)), Ju.exports;
}
var V3 = K3(), Yg = /* @__PURE__ */ yK(V3);
const na = "1.6.7", es = {};
function W3() {
  return typeof __HLS_WORKER_BUNDLE__ == "function";
}
function H3() {
  const r = es[na];
  if (r)
    return r.clientCount++, r;
  const e = new self.Blob([`var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(${__HLS_WORKER_BUNDLE__.toString()})(true);`], {
    type: "text/javascript"
  }), t = self.URL.createObjectURL(e), i = {
    worker: new self.Worker(t),
    objectURL: t,
    clientCount: 1
  };
  return es[na] = i, i;
}
function q3(r) {
  const e = es[r];
  if (e)
    return e.clientCount++, e;
  const t = new self.URL(r, self.location.href).href, i = {
    worker: new self.Worker(t),
    scriptURL: t,
    clientCount: 1
  };
  return es[r] = i, i;
}
function z3(r) {
  const e = es[r || na];
  if (e && e.clientCount-- === 1) {
    const {
      worker: n,
      objectURL: i
    } = e;
    delete es[r || na], i && self.URL.revokeObjectURL(i), n.terminate();
  }
}
function hw(r, e) {
  return e + 10 <= r.length && r[e] === 51 && r[e + 1] === 68 && r[e + 2] === 73 && r[e + 3] < 255 && r[e + 4] < 255 && r[e + 6] < 128 && r[e + 7] < 128 && r[e + 8] < 128 && r[e + 9] < 128;
}
function Xg(r, e) {
  return e + 10 <= r.length && r[e] === 73 && r[e + 1] === 68 && r[e + 2] === 51 && r[e + 3] < 255 && r[e + 4] < 255 && r[e + 6] < 128 && r[e + 7] < 128 && r[e + 8] < 128 && r[e + 9] < 128;
}
function ac(r, e) {
  let t = 0;
  return t = (r[e] & 127) << 21, t |= (r[e + 1] & 127) << 14, t |= (r[e + 2] & 127) << 7, t |= r[e + 3] & 127, t;
}
function ia(r, e) {
  const t = e;
  let n = 0;
  for (; Xg(r, e); ) {
    n += 10;
    const i = ac(r, e + 6);
    n += i, hw(r, e + 10) && (n += 10), e += n;
  }
  if (n > 0)
    return r.subarray(t, t + n);
}
function Y3(r, e, t, n) {
  const i = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350], s = e[t + 2], a = s >> 2 & 15;
  if (a > 12) {
    const h = new Error(`invalid ADTS sampling index:${a}`);
    r.emit(E.ERROR, E.ERROR, {
      type: ne.MEDIA_ERROR,
      details: k.FRAG_PARSING_ERROR,
      fatal: !0,
      error: h,
      reason: h.message
    });
    return;
  }
  const o = (s >> 6 & 3) + 1, c = e[t + 3] >> 6 & 3 | (s & 1) << 2, l = "mp4a.40." + o, u = i[a];
  let d = a;
  (o === 5 || o === 29) && (d -= 3);
  const f = [o << 3 | (d & 14) >> 1, (d & 1) << 7 | c << 3];
  return Ae.log(`manifest codec:${n}, parsed codec:${l}, channels:${c}, rate:${u} (ADTS object type:${o} sampling index:${a})`), {
    config: f,
    samplerate: u,
    channelCount: c,
    codec: l,
    parsedCodec: l,
    manifestCodec: n
  };
}
function gw(r, e) {
  return r[e] === 255 && (r[e + 1] & 246) === 240;
}
function mw(r, e) {
  return r[e + 1] & 1 ? 7 : 9;
}
function Qg(r, e) {
  return (r[e + 3] & 3) << 11 | r[e + 4] << 3 | (r[e + 5] & 224) >>> 5;
}
function X3(r, e) {
  return e + 5 < r.length;
}
function hl(r, e) {
  return e + 1 < r.length && gw(r, e);
}
function Q3(r, e) {
  return X3(r, e) && gw(r, e) && Qg(r, e) <= r.length - e;
}
function Z3(r, e) {
  if (hl(r, e)) {
    const t = mw(r, e);
    if (e + t >= r.length)
      return !1;
    const n = Qg(r, e);
    if (n <= t)
      return !1;
    const i = e + n;
    return i === r.length || hl(r, i);
  }
  return !1;
}
function pw(r, e, t, n, i) {
  if (!r.samplerate) {
    const s = Y3(e, t, n, i);
    if (!s)
      return;
    Ce(r, s);
  }
}
function vw(r) {
  return 1024 * 9e4 / r;
}
function J3(r, e) {
  const t = mw(r, e);
  if (e + t <= r.length) {
    const n = Qg(r, e) - t;
    if (n > 0)
      return {
        headerLength: t,
        frameLength: n
      };
  }
}
function yw(r, e, t, n, i) {
  const s = vw(r.samplerate), a = n + i * s, o = J3(e, t);
  let c;
  if (o) {
    const {
      frameLength: d,
      headerLength: f
    } = o, h = f + d, g = Math.max(0, t + h - e.length);
    g ? (c = new Uint8Array(h - f), c.set(e.subarray(t + f, e.length), 0)) : c = e.subarray(t + f, t + h);
    const m = {
      unit: c,
      pts: a
    };
    return g || r.samples.push(m), {
      sample: m,
      length: h,
      missing: g
    };
  }
  const l = e.length - t;
  return c = new Uint8Array(l), c.set(e.subarray(t, e.length), 0), {
    sample: {
      unit: c,
      pts: a
    },
    length: l,
    missing: -1
  };
}
function eV(r, e) {
  return Xg(r, e) && ac(r, e + 6) + 10 <= r.length - e;
}
function tV(r) {
  return r instanceof ArrayBuffer ? r : r.byteOffset == 0 && r.byteLength == r.buffer.byteLength ? r.buffer : new Uint8Array(r).buffer;
}
function ed(r, e = 0, t = 1 / 0) {
  return rV(r, e, t, Uint8Array);
}
function rV(r, e, t, n) {
  const i = nV(r);
  let s = 1;
  "BYTES_PER_ELEMENT" in n && (s = n.BYTES_PER_ELEMENT);
  const a = iV(r) ? r.byteOffset : 0, o = (a + r.byteLength) / s, c = (a + e) / s, l = Math.floor(Math.max(0, Math.min(c, o))), u = Math.floor(Math.min(l + Math.max(t, 0), o));
  return new n(i, l, u - l);
}
function nV(r) {
  return r instanceof ArrayBuffer ? r : r.buffer;
}
function iV(r) {
  return r && r.buffer instanceof ArrayBuffer && r.byteLength !== void 0 && r.byteOffset !== void 0;
}
function sV(r) {
  const e = {
    key: r.type,
    description: "",
    data: "",
    mimeType: null,
    pictureType: null
  }, t = 3;
  if (r.size < 2)
    return;
  if (r.data[0] !== t) {
    console.log("Ignore frame with unrecognized character encoding");
    return;
  }
  const n = r.data.subarray(1).indexOf(0);
  if (n === -1)
    return;
  const i = tr(ed(r.data, 1, n)), s = r.data[2 + n], a = r.data.subarray(3 + n).indexOf(0);
  if (a === -1)
    return;
  const o = tr(ed(r.data, 3 + n, a));
  let c;
  return i === "-->" ? c = tr(ed(r.data, 4 + n + a)) : c = tV(r.data.subarray(4 + n + a)), e.mimeType = i, e.pictureType = s, e.description = o, e.data = c, e;
}
function aV(r) {
  if (r.size < 2)
    return;
  const e = tr(r.data, !0), t = new Uint8Array(r.data.subarray(e.length + 1));
  return {
    key: r.type,
    info: e,
    data: t.buffer
  };
}
function oV(r) {
  if (r.size < 2)
    return;
  if (r.type === "TXXX") {
    let t = 1;
    const n = tr(r.data.subarray(t), !0);
    t += n.length + 1;
    const i = tr(r.data.subarray(t));
    return {
      key: r.type,
      info: n,
      data: i
    };
  }
  const e = tr(r.data.subarray(1));
  return {
    key: r.type,
    info: "",
    data: e
  };
}
function lV(r) {
  if (r.type === "WXXX") {
    if (r.size < 2)
      return;
    let t = 1;
    const n = tr(r.data.subarray(t), !0);
    t += n.length + 1;
    const i = tr(r.data.subarray(t));
    return {
      key: r.type,
      info: n,
      data: i
    };
  }
  const e = tr(r.data);
  return {
    key: r.type,
    info: "",
    data: e
  };
}
function cV(r) {
  return r.type === "PRIV" ? aV(r) : r.type[0] === "W" ? lV(r) : r.type === "APIC" ? sV(r) : oV(r);
}
function uV(r) {
  const e = String.fromCharCode(r[0], r[1], r[2], r[3]), t = ac(r, 4), n = 10;
  return {
    type: e,
    size: t,
    data: r.subarray(n, n + t)
  };
}
const io = 10, dV = 10;
function bw(r) {
  let e = 0;
  const t = [];
  for (; Xg(r, e); ) {
    const n = ac(r, e + 6);
    r[e + 5] >> 6 & 1 && (e += io), e += io;
    const i = e + n;
    for (; e + dV < i; ) {
      const s = uV(r.subarray(e)), a = cV(s);
      a && t.push(a), e += s.size + io;
    }
    hw(r, e) && (e += io);
  }
  return t;
}
function xw(r) {
  return r && r.key === "PRIV" && r.info === "com.apple.streaming.transportStreamTimestamp";
}
function fV(r) {
  if (r.data.byteLength === 8) {
    const e = new Uint8Array(r.data), t = e[3] & 1;
    let n = (e[4] << 23) + (e[5] << 15) + (e[6] << 7) + e[7];
    return n /= 45, t && (n += 4772185884e-2), Math.round(n);
  }
}
function Zg(r) {
  const e = bw(r);
  for (let t = 0; t < e.length; t++) {
    const n = e[t];
    if (xw(n))
      return fV(n);
  }
}
let Qt = /* @__PURE__ */ function(r) {
  return r.audioId3 = "org.id3", r.dateRange = "com.apple.quicktime.HLS", r.emsg = "https://aomedia.org/emsg/ID3", r.misbklv = "urn:misb:KLV:bin:1910.1", r;
}({});
function Cr(r = "", e = 9e4) {
  return {
    type: r,
    id: -1,
    pid: -1,
    inputTimeScale: e,
    sequenceNumber: -1,
    samples: [],
    dropped: 0
  };
}
class Jg {
  constructor() {
    this._audioTrack = void 0, this._id3Track = void 0, this.frameIndex = 0, this.cachedData = null, this.basePTS = null, this.initPTS = null, this.lastPTS = null;
  }
  resetInitSegment(e, t, n, i) {
    this._id3Track = {
      type: "id3",
      id: 3,
      pid: -1,
      inputTimeScale: 9e4,
      sequenceNumber: 0,
      samples: [],
      dropped: 0
    };
  }
  resetTimeStamp(e) {
    this.initPTS = e, this.resetContiguity();
  }
  resetContiguity() {
    this.basePTS = null, this.lastPTS = null, this.frameIndex = 0;
  }
  canParse(e, t) {
    return !1;
  }
  appendFrame(e, t, n) {
  }
  // feed incoming data to the front of the parsing pipeline
  demux(e, t) {
    this.cachedData && (e = yr(this.cachedData, e), this.cachedData = null);
    let n = ia(e, 0), i = n ? n.length : 0, s;
    const a = this._audioTrack, o = this._id3Track, c = n ? Zg(n) : void 0, l = e.length;
    for ((this.basePTS === null || this.frameIndex === 0 && X(c)) && (this.basePTS = hV(c, t, this.initPTS), this.lastPTS = this.basePTS), this.lastPTS === null && (this.lastPTS = this.basePTS), n && n.length > 0 && o.samples.push({
      pts: this.lastPTS,
      dts: this.lastPTS,
      data: n,
      type: Qt.audioId3,
      duration: Number.POSITIVE_INFINITY
    }); i < l; ) {
      if (this.canParse(e, i)) {
        const u = this.appendFrame(a, e, i);
        u ? (this.frameIndex++, this.lastPTS = u.sample.pts, i += u.length, s = i) : i = l;
      } else eV(e, i) ? (n = ia(e, i), o.samples.push({
        pts: this.lastPTS,
        dts: this.lastPTS,
        data: n,
        type: Qt.audioId3,
        duration: Number.POSITIVE_INFINITY
      }), i += n.length, s = i) : i++;
      if (i === l && s !== l) {
        const u = e.slice(s);
        this.cachedData ? this.cachedData = yr(this.cachedData, u) : this.cachedData = u;
      }
    }
    return {
      audioTrack: a,
      videoTrack: Cr(),
      id3Track: o,
      textTrack: Cr()
    };
  }
  demuxSampleAes(e, t, n) {
    return Promise.reject(new Error(`[${this}] This demuxer does not support Sample-AES decryption`));
  }
  flush(e) {
    const t = this.cachedData;
    return t && (this.cachedData = null, this.demux(t, 0)), {
      audioTrack: this._audioTrack,
      videoTrack: Cr(),
      id3Track: this._id3Track,
      textTrack: Cr()
    };
  }
  destroy() {
    this.cachedData = null, this._audioTrack = this._id3Track = void 0;
  }
}
const hV = (r, e, t) => {
  if (X(r))
    return r * 90;
  const n = t ? t.baseTime * 9e4 / t.timescale : 0;
  return e * 9e4 + n;
};
let so = null;
const gV = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160], mV = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3], pV = [
  // MPEG 2.5
  [
    0,
    // Reserved
    72,
    // Layer3
    144,
    // Layer2
    12
    // Layer1
  ],
  // Reserved
  [
    0,
    // Reserved
    0,
    // Layer3
    0,
    // Layer2
    0
    // Layer1
  ],
  // MPEG 2
  [
    0,
    // Reserved
    72,
    // Layer3
    144,
    // Layer2
    12
    // Layer1
  ],
  // MPEG 1
  [
    0,
    // Reserved
    144,
    // Layer3
    144,
    // Layer2
    12
    // Layer1
  ]
], vV = [
  0,
  // Reserved
  1,
  // Layer3
  1,
  // Layer2
  4
  // Layer1
];
function Ew(r, e, t, n, i) {
  if (t + 24 > e.length)
    return;
  const s = Sw(e, t);
  if (s && t + s.frameLength <= e.length) {
    const a = s.samplesPerFrame * 9e4 / s.sampleRate, o = n + i * a, c = {
      unit: e.subarray(t, t + s.frameLength),
      pts: o,
      dts: o
    };
    return r.config = [], r.channelCount = s.channelCount, r.samplerate = s.sampleRate, r.samples.push(c), {
      sample: c,
      length: s.frameLength,
      missing: 0
    };
  }
}
function Sw(r, e) {
  const t = r[e + 1] >> 3 & 3, n = r[e + 1] >> 1 & 3, i = r[e + 2] >> 4 & 15, s = r[e + 2] >> 2 & 3;
  if (t !== 1 && i !== 0 && i !== 15 && s !== 3) {
    const a = r[e + 2] >> 1 & 1, o = r[e + 3] >> 6, c = t === 3 ? 3 - n : n === 3 ? 3 : 4, l = gV[c * 14 + i - 1] * 1e3, d = mV[(t === 3 ? 0 : t === 2 ? 1 : 2) * 3 + s], f = o === 3 ? 1 : 2, h = pV[t][n], g = vV[n], m = h * 8 * g, p = Math.floor(h * l / d + a) * g;
    if (so === null) {
      const b = (navigator.userAgent || "").match(/Chrome\/(\d+)/i);
      so = b ? parseInt(b[1]) : 0;
    }
    return !!so && so <= 87 && n === 2 && l >= 224e3 && o === 0 && (r[e + 3] = r[e + 3] | 128), {
      sampleRate: d,
      channelCount: f,
      frameLength: p,
      samplesPerFrame: m
    };
  }
}
function em(r, e) {
  return r[e] === 255 && (r[e + 1] & 224) === 224 && (r[e + 1] & 6) !== 0;
}
function Tw(r, e) {
  return e + 1 < r.length && em(r, e);
}
function yV(r, e) {
  return em(r, e) && 4 <= r.length - e;
}
function Aw(r, e) {
  if (e + 1 < r.length && em(r, e)) {
    const n = Sw(r, e);
    let i = 4;
    n != null && n.frameLength && (i = n.frameLength);
    const s = e + i;
    return s === r.length || Tw(r, s);
  }
  return !1;
}
class bV extends Jg {
  constructor(e, t) {
    super(), this.observer = void 0, this.config = void 0, this.observer = e, this.config = t;
  }
  resetInitSegment(e, t, n, i) {
    super.resetInitSegment(e, t, n, i), this._audioTrack = {
      container: "audio/adts",
      type: "audio",
      id: 2,
      pid: -1,
      sequenceNumber: 0,
      segmentCodec: "aac",
      samples: [],
      manifestCodec: t,
      duration: i,
      inputTimeScale: 9e4,
      dropped: 0
    };
  }
  // Source for probe info - https://wiki.multimedia.cx/index.php?title=ADTS
  static probe(e, t) {
    if (!e)
      return !1;
    const n = ia(e, 0);
    let i = (n == null ? void 0 : n.length) || 0;
    if (Aw(e, i))
      return !1;
    for (let s = e.length; i < s; i++)
      if (Z3(e, i))
        return t.log("ADTS sync word found !"), !0;
    return !1;
  }
  canParse(e, t) {
    return Q3(e, t);
  }
  appendFrame(e, t, n) {
    pw(e, this.observer, t, n, e.manifestCodec);
    const i = yw(e, t, n, this.basePTS, this.frameIndex);
    if (i && i.missing === 0)
      return i;
  }
}
const ww = (r, e) => {
  let t = 0, n = 5;
  e += n;
  const i = new Uint32Array(1), s = new Uint32Array(1), a = new Uint8Array(1);
  for (; n > 0; ) {
    a[0] = r[e];
    const o = Math.min(n, 8), c = 8 - o;
    s[0] = 4278190080 >>> 24 + c << c, i[0] = (a[0] & s[0]) >> c, t = t ? t << o | i[0] : i[0], e += 1, n -= o;
  }
  return t;
};
class xV extends Jg {
  constructor(e) {
    super(), this.observer = void 0, this.observer = e;
  }
  resetInitSegment(e, t, n, i) {
    super.resetInitSegment(e, t, n, i), this._audioTrack = {
      container: "audio/ac-3",
      type: "audio",
      id: 2,
      pid: -1,
      sequenceNumber: 0,
      segmentCodec: "ac3",
      samples: [],
      manifestCodec: t,
      duration: i,
      inputTimeScale: 9e4,
      dropped: 0
    };
  }
  canParse(e, t) {
    return t + 64 < e.length;
  }
  appendFrame(e, t, n) {
    const i = Iw(e, t, n, this.basePTS, this.frameIndex);
    if (i !== -1)
      return {
        sample: e.samples[e.samples.length - 1],
        length: i,
        missing: 0
      };
  }
  static probe(e) {
    if (!e)
      return !1;
    const t = ia(e, 0);
    if (!t)
      return !1;
    const n = t.length;
    return e[n] === 11 && e[n + 1] === 119 && Zg(t) !== void 0 && // check the bsid to confirm ac-3
    ww(e, n) < 16;
  }
}
function Iw(r, e, t, n, i) {
  if (t + 8 > e.length || e[t] !== 11 || e[t + 1] !== 119)
    return -1;
  const s = e[t + 4] >> 6;
  if (s >= 3)
    return -1;
  const o = [48e3, 44100, 32e3][s], c = e[t + 4] & 63, u = [64, 69, 96, 64, 70, 96, 80, 87, 120, 80, 88, 120, 96, 104, 144, 96, 105, 144, 112, 121, 168, 112, 122, 168, 128, 139, 192, 128, 140, 192, 160, 174, 240, 160, 175, 240, 192, 208, 288, 192, 209, 288, 224, 243, 336, 224, 244, 336, 256, 278, 384, 256, 279, 384, 320, 348, 480, 320, 349, 480, 384, 417, 576, 384, 418, 576, 448, 487, 672, 448, 488, 672, 512, 557, 768, 512, 558, 768, 640, 696, 960, 640, 697, 960, 768, 835, 1152, 768, 836, 1152, 896, 975, 1344, 896, 976, 1344, 1024, 1114, 1536, 1024, 1115, 1536, 1152, 1253, 1728, 1152, 1254, 1728, 1280, 1393, 1920, 1280, 1394, 1920][c * 3 + s] * 2;
  if (t + u > e.length)
    return -1;
  const d = e[t + 6] >> 5;
  let f = 0;
  d === 2 ? f += 2 : (d & 1 && d !== 1 && (f += 2), d & 4 && (f += 2));
  const h = (e[t + 6] << 8 | e[t + 7]) >> 12 - f & 1, m = [2, 1, 2, 3, 3, 4, 4, 5][d] + h, p = e[t + 5] >> 3, v = e[t + 5] & 7, y = new Uint8Array([s << 6 | p << 1 | v >> 2, (v & 3) << 6 | d << 3 | h << 2 | c >> 4, c << 4 & 224]), b = 1536 / o * 9e4, x = n + i * b, S = e.subarray(t, t + u);
  return r.config = y, r.channelCount = m, r.samplerate = o, r.samples.push({
    unit: S,
    pts: x
  }), u;
}
class EV extends Jg {
  resetInitSegment(e, t, n, i) {
    super.resetInitSegment(e, t, n, i), this._audioTrack = {
      container: "audio/mpeg",
      type: "audio",
      id: 2,
      pid: -1,
      sequenceNumber: 0,
      segmentCodec: "mp3",
      samples: [],
      manifestCodec: t,
      duration: i,
      inputTimeScale: 9e4,
      dropped: 0
    };
  }
  static probe(e) {
    if (!e)
      return !1;
    const t = ia(e, 0);
    let n = (t == null ? void 0 : t.length) || 0;
    if (t && e[n] === 11 && e[n + 1] === 119 && Zg(t) !== void 0 && // check the bsid to confirm ac-3 or ec-3 (not mp3)
    ww(e, n) <= 16)
      return !1;
    for (let i = e.length; n < i; n++)
      if (Aw(e, n))
        return Ae.log("MPEG Audio sync word found !"), !0;
    return !1;
  }
  canParse(e, t) {
    return yV(e, t);
  }
  appendFrame(e, t, n) {
    if (this.basePTS !== null)
      return Ew(e, t, n, this.basePTS, this.frameIndex);
  }
}
const SV = /\/emsg[-/]ID3/i;
class TV {
  constructor(e, t) {
    this.remainderData = null, this.timeOffset = 0, this.config = void 0, this.videoTrack = void 0, this.audioTrack = void 0, this.id3Track = void 0, this.txtTrack = void 0, this.config = t;
  }
  resetTimeStamp() {
  }
  resetInitSegment(e, t, n, i) {
    const s = this.videoTrack = Cr("video", 1), a = this.audioTrack = Cr("audio", 1), o = this.txtTrack = Cr("text", 1);
    if (this.id3Track = Cr("id3", 1), this.timeOffset = 0, !(e != null && e.byteLength))
      return;
    const c = GA(e);
    if (c.video) {
      const {
        id: l,
        timescale: u,
        codec: d,
        supplemental: f
      } = c.video;
      s.id = l, s.timescale = o.timescale = u, s.codec = d, s.supplemental = f;
    }
    if (c.audio) {
      const {
        id: l,
        timescale: u,
        codec: d
      } = c.audio;
      a.id = l, a.timescale = u, a.codec = d;
    }
    o.id = BA.text, s.sampleDuration = 0, s.duration = a.duration = i;
  }
  resetContiguity() {
    this.remainderData = null;
  }
  static probe(e) {
    return TK(e);
  }
  demux(e, t) {
    this.timeOffset = t;
    let n = e;
    const i = this.videoTrack, s = this.txtTrack;
    if (this.config.progressive) {
      this.remainderData && (n = yr(this.remainderData, e));
      const o = OK(n);
      this.remainderData = o.remainder, i.samples = o.valid || new Uint8Array();
    } else
      i.samples = n;
    const a = this.extractID3Track(i, t);
    return s.samples = Dy(t, i), {
      videoTrack: i,
      audioTrack: this.audioTrack,
      id3Track: a,
      textTrack: this.txtTrack
    };
  }
  flush() {
    const e = this.timeOffset, t = this.videoTrack, n = this.txtTrack;
    t.samples = this.remainderData || new Uint8Array(), this.remainderData = null;
    const i = this.extractID3Track(t, this.timeOffset);
    return n.samples = Dy(e, t), {
      videoTrack: t,
      audioTrack: Cr(),
      id3Track: i,
      textTrack: Cr()
    };
  }
  extractID3Track(e, t) {
    const n = this.id3Track;
    if (e.samples.length) {
      const i = ge(e.samples, ["emsg"]);
      i && i.forEach((s) => {
        const a = DK(s);
        if (SV.test(a.schemeIdUri)) {
          const o = hb(a, t);
          let c = a.eventDuration === 4294967295 ? Number.POSITIVE_INFINITY : a.eventDuration / a.timeScale;
          c <= 1e-3 && (c = Number.POSITIVE_INFINITY);
          const l = a.payload;
          n.samples.push({
            data: l,
            len: l.byteLength,
            dts: o,
            pts: o,
            type: Qt.emsg,
            duration: c
          });
        } else if (this.config.enableEmsgKLVMetadata && a.schemeIdUri.startsWith("urn:misb:KLV:bin:1910.1")) {
          const o = hb(a, t);
          n.samples.push({
            data: a.payload,
            len: a.payload.byteLength,
            dts: o,
            pts: o,
            type: Qt.misbklv,
            duration: Number.POSITIVE_INFINITY
          });
        }
      });
    }
    return n;
  }
  demuxSampleAes(e, t, n) {
    return Promise.reject(new Error("The MP4 demuxer does not support SAMPLE-AES decryption"));
  }
  destroy() {
    this.config = null, this.remainderData = null, this.videoTrack = this.audioTrack = this.id3Track = this.txtTrack = void 0;
  }
}
function hb(r, e) {
  return X(r.presentationTime) ? r.presentationTime / r.timeScale : e + r.presentationTimeDelta / r.timeScale;
}
class AV {
  constructor(e, t, n) {
    this.keyData = void 0, this.decrypter = void 0, this.keyData = n, this.decrypter = new Wg(t, {
      removePKCS7Padding: !1
    });
  }
  decryptBuffer(e) {
    return this.decrypter.decrypt(e, this.keyData.key.buffer, this.keyData.iv.buffer, Fn.cbc);
  }
  // AAC - encrypt all full 16 bytes blocks starting from offset 16
  decryptAacSample(e, t, n) {
    const i = e[t].unit;
    if (i.length <= 16)
      return;
    const s = i.subarray(16, i.length - i.length % 16), a = s.buffer.slice(s.byteOffset, s.byteOffset + s.length);
    this.decryptBuffer(a).then((o) => {
      const c = new Uint8Array(o);
      i.set(c, 16), this.decrypter.isSync() || this.decryptAacSamples(e, t + 1, n);
    });
  }
  decryptAacSamples(e, t, n) {
    for (; ; t++) {
      if (t >= e.length) {
        n();
        return;
      }
      if (!(e[t].unit.length < 32) && (this.decryptAacSample(e, t, n), !this.decrypter.isSync()))
        return;
    }
  }
  // AVC - encrypt one 16 bytes block out of ten, starting from offset 32
  getAvcEncryptedData(e) {
    const t = Math.floor((e.length - 48) / 160) * 16 + 16, n = new Int8Array(t);
    let i = 0;
    for (let s = 32; s < e.length - 16; s += 160, i += 16)
      n.set(e.subarray(s, s + 16), i);
    return n;
  }
  getAvcDecryptedUnit(e, t) {
    const n = new Uint8Array(t);
    let i = 0;
    for (let s = 32; s < e.length - 16; s += 160, i += 16)
      e.set(n.subarray(i, i + 16), s);
    return e;
  }
  decryptAvcSample(e, t, n, i, s) {
    const a = KA(s.data), o = this.getAvcEncryptedData(a);
    this.decryptBuffer(o.buffer).then((c) => {
      s.data = this.getAvcDecryptedUnit(a, c), this.decrypter.isSync() || this.decryptAvcSamples(e, t, n + 1, i);
    });
  }
  decryptAvcSamples(e, t, n, i) {
    if (e instanceof Uint8Array)
      throw new Error("Cannot decrypt samples of type Uint8Array");
    for (; ; t++, n = 0) {
      if (t >= e.length) {
        i();
        return;
      }
      const s = e[t].units;
      for (; !(n >= s.length); n++) {
        const a = s[n];
        if (!(a.data.length <= 48 || a.type !== 1 && a.type !== 5) && (this.decryptAvcSample(e, t, n, i, a), !this.decrypter.isSync()))
          return;
      }
    }
  }
}
class Pw {
  constructor() {
    this.VideoSample = null;
  }
  createVideoSample(e, t, n) {
    return {
      key: e,
      frame: !1,
      pts: t,
      dts: n,
      units: [],
      length: 0
    };
  }
  getLastNalUnit(e) {
    var t;
    let n = this.VideoSample, i;
    if ((!n || n.units.length === 0) && (n = e[e.length - 1]), (t = n) != null && t.units) {
      const s = n.units;
      i = s[s.length - 1];
    }
    return i;
  }
  pushAccessUnit(e, t) {
    if (e.units.length && e.frame) {
      if (e.pts === void 0) {
        const n = t.samples, i = n.length;
        if (i) {
          const s = n[i - 1];
          e.pts = s.pts, e.dts = s.dts;
        } else {
          t.dropped++;
          return;
        }
      }
      t.samples.push(e);
    }
  }
  parseNALu(e, t, n) {
    const i = t.byteLength;
    let s = e.naluState || 0;
    const a = s, o = [];
    let c = 0, l, u, d, f = -1, h = 0;
    for (s === -1 && (f = 0, h = this.getNALuType(t, 0), s = 0, c = 1); c < i; ) {
      if (l = t[c++], !s) {
        s = l ? 0 : 1;
        continue;
      }
      if (s === 1) {
        s = l ? 0 : 2;
        continue;
      }
      if (!l)
        s = 3;
      else if (l === 1) {
        if (u = c - s - 1, f >= 0) {
          const g = {
            data: t.subarray(f, u),
            type: h
          };
          o.push(g);
        } else {
          const g = this.getLastNalUnit(e.samples);
          g && (a && c <= 4 - a && g.state && (g.data = g.data.subarray(0, g.data.byteLength - a)), u > 0 && (g.data = yr(g.data, t.subarray(0, u)), g.state = 0));
        }
        c < i ? (d = this.getNALuType(t, c), f = c, h = d, s = 0) : s = -1;
      } else
        s = 0;
    }
    if (f >= 0 && s >= 0) {
      const g = {
        data: t.subarray(f, i),
        type: h,
        state: s
      };
      o.push(g);
    }
    if (o.length === 0) {
      const g = this.getLastNalUnit(e.samples);
      g && (g.data = yr(g.data, t));
    }
    return e.naluState = s, o;
  }
}
class Bs {
  constructor(e) {
    this.data = void 0, this.bytesAvailable = void 0, this.word = void 0, this.bitsAvailable = void 0, this.data = e, this.bytesAvailable = e.byteLength, this.word = 0, this.bitsAvailable = 0;
  }
  // ():void
  loadWord() {
    const e = this.data, t = this.bytesAvailable, n = e.byteLength - t, i = new Uint8Array(4), s = Math.min(4, t);
    if (s === 0)
      throw new Error("no bytes available");
    i.set(e.subarray(n, n + s)), this.word = new DataView(i.buffer).getUint32(0), this.bitsAvailable = s * 8, this.bytesAvailable -= s;
  }
  // (count:int):void
  skipBits(e) {
    let t;
    e = Math.min(e, this.bytesAvailable * 8 + this.bitsAvailable), this.bitsAvailable > e ? (this.word <<= e, this.bitsAvailable -= e) : (e -= this.bitsAvailable, t = e >> 3, e -= t << 3, this.bytesAvailable -= t, this.loadWord(), this.word <<= e, this.bitsAvailable -= e);
  }
  // (size:int):uint
  readBits(e) {
    let t = Math.min(this.bitsAvailable, e);
    const n = this.word >>> 32 - t;
    if (e > 32 && Ae.error("Cannot read more than 32 bits at a time"), this.bitsAvailable -= t, this.bitsAvailable > 0)
      this.word <<= t;
    else if (this.bytesAvailable > 0)
      this.loadWord();
    else
      throw new Error("no bits available");
    return t = e - t, t > 0 && this.bitsAvailable ? n << t | this.readBits(t) : n;
  }
  // ():uint
  skipLZ() {
    let e;
    for (e = 0; e < this.bitsAvailable; ++e)
      if ((this.word & 2147483648 >>> e) !== 0)
        return this.word <<= e, this.bitsAvailable -= e, e;
    return this.loadWord(), e + this.skipLZ();
  }
  // ():void
  skipUEG() {
    this.skipBits(1 + this.skipLZ());
  }
  // ():void
  skipEG() {
    this.skipBits(1 + this.skipLZ());
  }
  // ():uint
  readUEG() {
    const e = this.skipLZ();
    return this.readBits(e + 1) - 1;
  }
  // ():int
  readEG() {
    const e = this.readUEG();
    return 1 & e ? 1 + e >>> 1 : -1 * (e >>> 1);
  }
  // Some convenience functions
  // :Boolean
  readBoolean() {
    return this.readBits(1) === 1;
  }
  // ():int
  readUByte() {
    return this.readBits(8);
  }
  // ():int
  readUShort() {
    return this.readBits(16);
  }
  // ():int
  readUInt() {
    return this.readBits(32);
  }
}
class gb extends Pw {
  parsePES(e, t, n, i) {
    const s = this.parseNALu(e, n.data, i);
    let a = this.VideoSample, o, c = !1;
    n.data = null, a && s.length && !e.audFound && (this.pushAccessUnit(a, e), a = this.VideoSample = this.createVideoSample(!1, n.pts, n.dts)), s.forEach((l) => {
      var u, d;
      switch (l.type) {
        // NDR
        case 1: {
          let m = !1;
          o = !0;
          const p = l.data;
          if (c && p.length > 4) {
            const v = this.readSliceType(p);
            (v === 2 || v === 4 || v === 7 || v === 9) && (m = !0);
          }
          if (m) {
            var f;
            (f = a) != null && f.frame && !a.key && (this.pushAccessUnit(a, e), a = this.VideoSample = null);
          }
          a || (a = this.VideoSample = this.createVideoSample(!0, n.pts, n.dts)), a.frame = !0, a.key = m;
          break;
        }
        case 5:
          o = !0, (u = a) != null && u.frame && !a.key && (this.pushAccessUnit(a, e), a = this.VideoSample = null), a || (a = this.VideoSample = this.createVideoSample(!0, n.pts, n.dts)), a.key = !0, a.frame = !0;
          break;
        // SEI
        case 6: {
          o = !0, Ug(l.data, 1, n.pts, t.samples);
          break;
        }
        case 7: {
          var h, g;
          o = !0, c = !0;
          const m = l.data, p = this.readSPS(m);
          if (!e.sps || e.width !== p.width || e.height !== p.height || ((h = e.pixelRatio) == null ? void 0 : h[0]) !== p.pixelRatio[0] || ((g = e.pixelRatio) == null ? void 0 : g[1]) !== p.pixelRatio[1]) {
            e.width = p.width, e.height = p.height, e.pixelRatio = p.pixelRatio, e.sps = [m];
            const v = m.subarray(1, 4);
            let y = "avc1.";
            for (let b = 0; b < 3; b++) {
              let x = v[b].toString(16);
              x.length < 2 && (x = "0" + x), y += x;
            }
            e.codec = y;
          }
          break;
        }
        // PPS
        case 8:
          o = !0, e.pps = [l.data];
          break;
        // AUD
        case 9:
          o = !0, e.audFound = !0, (d = a) != null && d.frame && (this.pushAccessUnit(a, e), a = null), a || (a = this.VideoSample = this.createVideoSample(!1, n.pts, n.dts));
          break;
        // Filler Data
        case 12:
          o = !0;
          break;
        default:
          o = !1;
          break;
      }
      a && o && a.units.push(l);
    }), i && a && (this.pushAccessUnit(a, e), this.VideoSample = null);
  }
  getNALuType(e, t) {
    return e[t] & 31;
  }
  readSliceType(e) {
    const t = new Bs(e);
    return t.readUByte(), t.readUEG(), t.readUEG();
  }
  /**
   * The scaling list is optionally transmitted as part of a sequence parameter
   * set and is not relevant to transmuxing.
   * @param count the number of entries in this scaling list
   * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1
   */
  skipScalingList(e, t) {
    let n = 8, i = 8, s;
    for (let a = 0; a < e; a++)
      i !== 0 && (s = t.readEG(), i = (n + s + 256) % 256), n = i === 0 ? n : i;
  }
  /**
   * Read a sequence parameter set and return some interesting video
   * properties. A sequence parameter set is the H264 metadata that
   * describes the properties of upcoming video frames.
   * @returns an object with configuration parsed from the
   * sequence parameter set, including the dimensions of the
   * associated video frames.
   */
  readSPS(e) {
    const t = new Bs(e);
    let n = 0, i = 0, s = 0, a = 0, o, c, l;
    const u = t.readUByte.bind(t), d = t.readBits.bind(t), f = t.readUEG.bind(t), h = t.readBoolean.bind(t), g = t.skipBits.bind(t), m = t.skipEG.bind(t), p = t.skipUEG.bind(t), v = this.skipScalingList.bind(this);
    u();
    const y = u();
    if (d(5), g(3), u(), p(), y === 100 || y === 110 || y === 122 || y === 244 || y === 44 || y === 83 || y === 86 || y === 118 || y === 128) {
      const I = f();
      if (I === 3 && g(1), p(), p(), g(1), h())
        for (c = I !== 3 ? 8 : 12, l = 0; l < c; l++)
          h() && (l < 6 ? v(16, t) : v(64, t));
    }
    p();
    const b = f();
    if (b === 0)
      f();
    else if (b === 1)
      for (g(1), m(), m(), o = f(), l = 0; l < o; l++)
        m();
    p(), g(1);
    const x = f(), S = f(), A = d(1);
    A === 0 && g(1), g(1), h() && (n = f(), i = f(), s = f(), a = f());
    let T = [1, 1];
    if (h() && h())
      switch (u()) {
        case 1:
          T = [1, 1];
          break;
        case 2:
          T = [12, 11];
          break;
        case 3:
          T = [10, 11];
          break;
        case 4:
          T = [16, 11];
          break;
        case 5:
          T = [40, 33];
          break;
        case 6:
          T = [24, 11];
          break;
        case 7:
          T = [20, 11];
          break;
        case 8:
          T = [32, 11];
          break;
        case 9:
          T = [80, 33];
          break;
        case 10:
          T = [18, 11];
          break;
        case 11:
          T = [15, 11];
          break;
        case 12:
          T = [64, 33];
          break;
        case 13:
          T = [160, 99];
          break;
        case 14:
          T = [4, 3];
          break;
        case 15:
          T = [3, 2];
          break;
        case 16:
          T = [2, 1];
          break;
        case 255: {
          T = [u() << 8 | u(), u() << 8 | u()];
          break;
        }
      }
    return {
      width: Math.ceil((x + 1) * 16 - n * 2 - i * 2),
      height: (2 - A) * (S + 1) * 16 - (A ? 2 : 4) * (s + a),
      pixelRatio: T
    };
  }
}
class mb extends Pw {
  constructor(...e) {
    super(...e), this.initVPS = null;
  }
  parsePES(e, t, n, i) {
    const s = this.parseNALu(e, n.data, i);
    let a = this.VideoSample, o, c = !1;
    n.data = null, a && s.length && !e.audFound && (this.pushAccessUnit(a, e), a = this.VideoSample = this.createVideoSample(!1, n.pts, n.dts)), s.forEach((l) => {
      var u, d;
      switch (l.type) {
        // NON-IDR, NON RANDOM ACCESS SLICE
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
          a || (a = this.VideoSample = this.createVideoSample(!1, n.pts, n.dts)), a.frame = !0, o = !0;
          break;
        // CRA, BLA (random access picture)
        case 16:
        case 17:
        case 18:
        case 21:
          if (o = !0, c) {
            var f;
            (f = a) != null && f.frame && !a.key && (this.pushAccessUnit(a, e), a = this.VideoSample = null);
          }
          a || (a = this.VideoSample = this.createVideoSample(!0, n.pts, n.dts)), a.key = !0, a.frame = !0;
          break;
        // IDR
        case 19:
        case 20:
          o = !0, (u = a) != null && u.frame && !a.key && (this.pushAccessUnit(a, e), a = this.VideoSample = null), a || (a = this.VideoSample = this.createVideoSample(!0, n.pts, n.dts)), a.key = !0, a.frame = !0;
          break;
        // SEI
        case 39:
          o = !0, Ug(
            l.data,
            2,
            // NALu header size
            n.pts,
            t.samples
          );
          break;
        // VPS
        case 32:
          o = !0, e.vps || (typeof e.params != "object" && (e.params = {}), e.params = Ce(e.params, this.readVPS(l.data)), this.initVPS = l.data), e.vps = [l.data];
          break;
        // SPS
        case 33:
          if (o = !0, c = !0, e.vps !== void 0 && e.vps[0] !== this.initVPS && e.sps !== void 0 && !this.matchSPS(e.sps[0], l.data) && (this.initVPS = e.vps[0], e.sps = e.pps = void 0), !e.sps) {
            const h = this.readSPS(l.data);
            e.width = h.width, e.height = h.height, e.pixelRatio = h.pixelRatio, e.codec = h.codecString, e.sps = [], typeof e.params != "object" && (e.params = {});
            for (const g in h.params)
              e.params[g] = h.params[g];
          }
          this.pushParameterSet(e.sps, l.data, e.vps), a || (a = this.VideoSample = this.createVideoSample(!0, n.pts, n.dts)), a.key = !0;
          break;
        // PPS
        case 34:
          if (o = !0, typeof e.params == "object") {
            if (!e.pps) {
              e.pps = [];
              const h = this.readPPS(l.data);
              for (const g in h)
                e.params[g] = h[g];
            }
            this.pushParameterSet(e.pps, l.data, e.vps);
          }
          break;
        // ACCESS UNIT DELIMITER
        case 35:
          o = !0, e.audFound = !0, (d = a) != null && d.frame && (this.pushAccessUnit(a, e), a = null), a || (a = this.VideoSample = this.createVideoSample(!1, n.pts, n.dts));
          break;
        default:
          o = !1;
          break;
      }
      a && o && a.units.push(l);
    }), i && a && (this.pushAccessUnit(a, e), this.VideoSample = null);
  }
  pushParameterSet(e, t, n) {
    (n && n[0] === this.initVPS || !n && !e.length) && e.push(t);
  }
  getNALuType(e, t) {
    return (e[t] & 126) >>> 1;
  }
  ebsp2rbsp(e) {
    const t = new Uint8Array(e.byteLength);
    let n = 0;
    for (let i = 0; i < e.byteLength; i++)
      i >= 2 && e[i] === 3 && e[i - 1] === 0 && e[i - 2] === 0 || (t[n] = e[i], n++);
    return new Uint8Array(t.buffer, 0, n);
  }
  pushAccessUnit(e, t) {
    super.pushAccessUnit(e, t), this.initVPS && (this.initVPS = null);
  }
  readVPS(e) {
    const t = new Bs(e);
    t.readUByte(), t.readUByte(), t.readBits(4), t.skipBits(2), t.readBits(6);
    const n = t.readBits(3), i = t.readBoolean();
    return {
      numTemporalLayers: n + 1,
      temporalIdNested: i
    };
  }
  readSPS(e) {
    const t = new Bs(this.ebsp2rbsp(e));
    t.readUByte(), t.readUByte(), t.readBits(4);
    const n = t.readBits(3);
    t.readBoolean();
    const i = t.readBits(2), s = t.readBoolean(), a = t.readBits(5), o = t.readUByte(), c = t.readUByte(), l = t.readUByte(), u = t.readUByte(), d = t.readUByte(), f = t.readUByte(), h = t.readUByte(), g = t.readUByte(), m = t.readUByte(), p = t.readUByte(), v = t.readUByte(), y = [], b = [];
    for (let se = 0; se < n; se++)
      y.push(t.readBoolean()), b.push(t.readBoolean());
    if (n > 0)
      for (let se = n; se < 8; se++)
        t.readBits(2);
    for (let se = 0; se < n; se++)
      y[se] && (t.readUByte(), t.readUByte(), t.readUByte(), t.readUByte(), t.readUByte(), t.readUByte(), t.readUByte(), t.readUByte(), t.readUByte(), t.readUByte(), t.readUByte()), b[se] && t.readUByte();
    t.readUEG();
    const x = t.readUEG();
    x == 3 && t.skipBits(1);
    const S = t.readUEG(), A = t.readUEG(), T = t.readBoolean();
    let I = 0, L = 0, _ = 0, R = 0;
    T && (I += t.readUEG(), L += t.readUEG(), _ += t.readUEG(), R += t.readUEG());
    const D = t.readUEG(), F = t.readUEG(), B = t.readUEG(), j = t.readBoolean();
    for (let se = j ? 0 : n; se <= n; se++)
      t.skipUEG(), t.skipUEG(), t.skipUEG();
    if (t.skipUEG(), t.skipUEG(), t.skipUEG(), t.skipUEG(), t.skipUEG(), t.skipUEG(), t.readBoolean() && t.readBoolean())
      for (let $e = 0; $e < 4; $e++)
        for (let ft = 0; ft < ($e === 3 ? 2 : 6); ft++)
          if (!t.readBoolean())
            t.readUEG();
          else {
            const Wt = Math.min(64, 1 << 4 + ($e << 1));
            $e > 1 && t.readEG();
            for (let xn = 0; xn < Wt; xn++)
              t.readEG();
          }
    t.readBoolean(), t.readBoolean(), t.readBoolean() && (t.readUByte(), t.skipUEG(), t.skipUEG(), t.readBoolean());
    const G = t.readUEG();
    let Y = 0;
    for (let se = 0; se < G; se++) {
      let $e = !1;
      if (se !== 0 && ($e = t.readBoolean()), $e) {
        se === G && t.readUEG(), t.readBoolean(), t.readUEG();
        let ft = 0;
        for (let ir = 0; ir <= Y; ir++) {
          const Wt = t.readBoolean();
          let xn = !1;
          Wt || (xn = t.readBoolean()), (Wt || xn) && ft++;
        }
        Y = ft;
      } else {
        const ft = t.readUEG(), ir = t.readUEG();
        Y = ft + ir;
        for (let Wt = 0; Wt < ft; Wt++)
          t.readUEG(), t.readBoolean();
        for (let Wt = 0; Wt < ir; Wt++)
          t.readUEG(), t.readBoolean();
      }
    }
    if (t.readBoolean()) {
      const se = t.readUEG();
      for (let $e = 0; $e < se; $e++) {
        for (let ft = 0; ft < B + 4; ft++)
          t.readBits(1);
        t.readBits(1);
      }
    }
    let H = 0, N = 1, re = 1, oe = !0, le = 1, he = 0;
    t.readBoolean(), t.readBoolean();
    let Re = !1;
    if (t.readBoolean()) {
      if (t.readBoolean()) {
        const Sr = t.readUByte(), Ra = [1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2], Ei = [1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33, 99, 3, 2, 1];
        Sr > 0 && Sr < 16 ? (N = Ra[Sr - 1], re = Ei[Sr - 1]) : Sr === 255 && (N = t.readBits(16), re = t.readBits(16));
      }
      if (t.readBoolean() && t.readBoolean(), t.readBoolean() && (t.readBits(3), t.readBoolean(), t.readBoolean() && (t.readUByte(), t.readUByte(), t.readUByte())), t.readBoolean() && (t.readUEG(), t.readUEG()), t.readBoolean(), t.readBoolean(), t.readBoolean(), Re = t.readBoolean(), Re && (I += t.readUEG(), L += t.readUEG(), _ += t.readUEG(), R += t.readUEG()), t.readBoolean() && (le = t.readBits(32), he = t.readBits(32), t.readBoolean() && t.readUEG(), t.readBoolean())) {
        const Ei = t.readBoolean(), gs = t.readBoolean();
        let En = !1;
        (Ei || gs) && (En = t.readBoolean(), En && (t.readUByte(), t.readBits(5), t.readBoolean(), t.readBits(5)), t.readBits(4), t.readBits(4), En && t.readBits(4), t.readBits(5), t.readBits(5), t.readBits(5));
        for (let ms = 0; ms <= n; ms++) {
          oe = t.readBoolean();
          const oc = oe || t.readBoolean();
          let ps = !1;
          oc ? t.readEG() : ps = t.readBoolean();
          const vs = ps ? 1 : t.readUEG() + 1;
          if (Ei)
            for (let Kn = 0; Kn < vs; Kn++)
              t.readUEG(), t.readUEG(), En && (t.readUEG(), t.readUEG()), t.skipBits(1);
          if (gs)
            for (let Kn = 0; Kn < vs; Kn++)
              t.readUEG(), t.readUEG(), En && (t.readUEG(), t.readUEG()), t.skipBits(1);
        }
      }
      t.readBoolean() && (t.readBoolean(), t.readBoolean(), t.readBoolean(), H = t.readUEG());
    }
    let q = S, ie = A;
    if (T || Re) {
      let se = 1, $e = 1;
      x === 1 ? se = $e = 2 : x == 2 && (se = 2), q = S - se * L - se * I, ie = A - $e * R - $e * _;
    }
    const fe = i ? ["A", "B", "C"][i] : "", V = o << 24 | c << 16 | l << 8 | u;
    let tt = 0;
    for (let se = 0; se < 32; se++)
      tt = (tt | (V >> se & 1) << 31 - se) >>> 0;
    let Te = tt.toString(16);
    return a === 1 && Te === "2" && (Te = "6"), {
      codecString: `hvc1.${fe}${a}.${Te}.${s ? "H" : "L"}${v}.B0`,
      params: {
        general_tier_flag: s,
        general_profile_idc: a,
        general_profile_space: i,
        general_profile_compatibility_flags: [o, c, l, u],
        general_constraint_indicator_flags: [d, f, h, g, m, p],
        general_level_idc: v,
        bit_depth: D + 8,
        bit_depth_luma_minus8: D,
        bit_depth_chroma_minus8: F,
        min_spatial_segmentation_idc: H,
        chroma_format_idc: x,
        frame_rate: {
          fixed: oe,
          fps: he / le
        }
      },
      width: q,
      height: ie,
      pixelRatio: [N, re]
    };
  }
  readPPS(e) {
    const t = new Bs(this.ebsp2rbsp(e));
    t.readUByte(), t.readUByte(), t.skipUEG(), t.skipUEG(), t.skipBits(2), t.skipBits(3), t.skipBits(2), t.skipUEG(), t.skipUEG(), t.skipEG(), t.skipBits(2), t.readBoolean() && t.skipUEG(), t.skipEG(), t.skipEG(), t.skipBits(4);
    const i = t.readBoolean(), s = t.readBoolean();
    let a = 1;
    return s && i ? a = 0 : s ? a = 3 : i && (a = 2), {
      parallelismType: a
    };
  }
  matchSPS(e, t) {
    return String.fromCharCode.apply(null, e).substr(3) === String.fromCharCode.apply(null, t).substr(3);
  }
}
const ht = 188;
class Ln {
  constructor(e, t, n, i) {
    this.logger = void 0, this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.sampleAes = null, this.pmtParsed = !1, this.audioCodec = void 0, this.videoCodec = void 0, this._pmtId = -1, this._videoTrack = void 0, this._audioTrack = void 0, this._id3Track = void 0, this._txtTrack = void 0, this.aacOverFlow = null, this.remainderData = null, this.videoParser = void 0, this.observer = e, this.config = t, this.typeSupported = n, this.logger = i, this.videoParser = null;
  }
  static probe(e, t) {
    const n = Ln.syncOffset(e);
    return n > 0 && t.warn(`MPEG2-TS detected but first sync word found @ offset ${n}`), n !== -1;
  }
  static syncOffset(e) {
    const t = e.length;
    let n = Math.min(ht * 5, t - ht) + 1, i = 0;
    for (; i < n; ) {
      let s = !1, a = -1, o = 0;
      for (let c = i; c < t; c += ht)
        if (e[c] === 71 && (t - c === ht || e[c + ht] === 71)) {
          if (o++, a === -1 && (a = c, a !== 0 && (n = Math.min(a + ht * 99, e.length - ht) + 1)), s || (s = Af(e, c) === 0), s && o > 1 && (a === 0 && o > 2 || c + ht > n))
            return a;
        } else {
          if (o)
            return -1;
          break;
        }
      i++;
    }
    return -1;
  }
  /**
   * Creates a track model internal to demuxer used to drive remuxing input
   */
  static createTrack(e, t) {
    return {
      container: e === "video" || e === "audio" ? "video/mp2t" : void 0,
      type: e,
      id: BA[e],
      pid: -1,
      inputTimeScale: 9e4,
      sequenceNumber: 0,
      samples: [],
      dropped: 0,
      duration: e === "audio" ? t : void 0
    };
  }
  /**
   * Initializes a new init segment on the demuxer/remuxer interface. Needed for discontinuities/track-switches (or at stream start)
   * Resets all internal track instances of the demuxer.
   */
  resetInitSegment(e, t, n, i) {
    this.pmtParsed = !1, this._pmtId = -1, this._videoTrack = Ln.createTrack("video"), this._videoTrack.duration = i, this._audioTrack = Ln.createTrack("audio", i), this._id3Track = Ln.createTrack("id3"), this._txtTrack = Ln.createTrack("text"), this._audioTrack.segmentCodec = "aac", this.aacOverFlow = null, this.remainderData = null, this.audioCodec = t, this.videoCodec = n;
  }
  resetTimeStamp() {
  }
  resetContiguity() {
    const {
      _audioTrack: e,
      _videoTrack: t,
      _id3Track: n
    } = this;
    e && (e.pesData = null), t && (t.pesData = null), n && (n.pesData = null), this.aacOverFlow = null, this.remainderData = null;
  }
  demux(e, t, n = !1, i = !1) {
    n || (this.sampleAes = null);
    let s;
    const a = this._videoTrack, o = this._audioTrack, c = this._id3Track, l = this._txtTrack;
    let u = a.pid, d = a.pesData, f = o.pid, h = c.pid, g = o.pesData, m = c.pesData, p = null, v = this.pmtParsed, y = this._pmtId, b = e.length;
    if (this.remainderData && (e = yr(this.remainderData, e), b = e.length, this.remainderData = null), b < ht && !i)
      return this.remainderData = e, {
        audioTrack: o,
        videoTrack: a,
        id3Track: c,
        textTrack: l
      };
    const x = Math.max(0, Ln.syncOffset(e));
    b -= (b - x) % ht, b < e.byteLength && !i && (this.remainderData = new Uint8Array(e.buffer, b, e.buffer.byteLength - b));
    let S = 0;
    for (let T = x; T < b; T += ht)
      if (e[T] === 71) {
        const I = !!(e[T + 1] & 64), L = Af(e, T), _ = (e[T + 3] & 48) >> 4;
        let R;
        if (_ > 1) {
          if (R = T + 5 + e[T + 4], R === T + ht)
            continue;
        } else
          R = T + 4;
        switch (L) {
          case u:
            if (I) {
              if (d && (s = Li(d, this.logger))) {
                if (this.videoParser === null)
                  switch (a.segmentCodec) {
                    case "avc":
                      this.videoParser = new gb();
                      break;
                    case "hevc":
                      this.videoParser = new mb();
                      break;
                  }
                this.videoParser !== null && this.videoParser.parsePES(a, l, s, !1);
              }
              d = {
                data: [],
                size: 0
              };
            }
            d && (d.data.push(e.subarray(R, T + ht)), d.size += T + ht - R);
            break;
          case f:
            if (I) {
              if (g && (s = Li(g, this.logger)))
                switch (o.segmentCodec) {
                  case "aac":
                    this.parseAACPES(o, s);
                    break;
                  case "mp3":
                    this.parseMPEGPES(o, s);
                    break;
                  case "ac3":
                    this.parseAC3PES(o, s);
                    break;
                }
              g = {
                data: [],
                size: 0
              };
            }
            g && (g.data.push(e.subarray(R, T + ht)), g.size += T + ht - R);
            break;
          case h:
            I && (m && (s = Li(m, this.logger)) && this.parseID3PES(c, s), m = {
              data: [],
              size: 0
            }), m && (m.data.push(e.subarray(R, T + ht)), m.size += T + ht - R);
            break;
          case 0:
            I && (R += e[R] + 1), y = this._pmtId = wV(e, R);
            break;
          case y: {
            I && (R += e[R] + 1);
            const D = IV(e, R, this.typeSupported, n, this.observer, this.logger);
            u = D.videoPid, u > 0 && (a.pid = u, a.segmentCodec = D.segmentVideoCodec), f = D.audioPid, f > 0 && (o.pid = f, o.segmentCodec = D.segmentAudioCodec), h = D.id3Pid, h > 0 && (c.pid = h), p !== null && !v && (this.logger.warn(`MPEG-TS PMT found at ${T} after unknown PID '${p}'. Backtracking to sync byte @${x} to parse all TS packets.`), p = null, T = x - 188), v = this.pmtParsed = !0;
            break;
          }
          case 17:
          case 8191:
            break;
          default:
            p = L;
            break;
        }
      } else
        S++;
    S > 0 && wf(this.observer, new Error(`Found ${S} TS packet/s that do not start with 0x47`), void 0, this.logger), a.pesData = d, o.pesData = g, c.pesData = m;
    const A = {
      audioTrack: o,
      videoTrack: a,
      id3Track: c,
      textTrack: l
    };
    return i && this.extractRemainingSamples(A), A;
  }
  flush() {
    const {
      remainderData: e
    } = this;
    this.remainderData = null;
    let t;
    return e ? t = this.demux(e, -1, !1, !0) : t = {
      videoTrack: this._videoTrack,
      audioTrack: this._audioTrack,
      id3Track: this._id3Track,
      textTrack: this._txtTrack
    }, this.extractRemainingSamples(t), this.sampleAes ? this.decrypt(t, this.sampleAes) : t;
  }
  extractRemainingSamples(e) {
    const {
      audioTrack: t,
      videoTrack: n,
      id3Track: i,
      textTrack: s
    } = e, a = n.pesData, o = t.pesData, c = i.pesData;
    let l;
    if (a && (l = Li(a, this.logger))) {
      if (this.videoParser === null)
        switch (n.segmentCodec) {
          case "avc":
            this.videoParser = new gb();
            break;
          case "hevc":
            this.videoParser = new mb();
            break;
        }
      this.videoParser !== null && (this.videoParser.parsePES(n, s, l, !0), n.pesData = null);
    } else
      n.pesData = a;
    if (o && (l = Li(o, this.logger))) {
      switch (t.segmentCodec) {
        case "aac":
          this.parseAACPES(t, l);
          break;
        case "mp3":
          this.parseMPEGPES(t, l);
          break;
        case "ac3":
          this.parseAC3PES(t, l);
          break;
      }
      t.pesData = null;
    } else
      o != null && o.size && this.logger.log("last AAC PES packet truncated,might overlap between fragments"), t.pesData = o;
    c && (l = Li(c, this.logger)) ? (this.parseID3PES(i, l), i.pesData = null) : i.pesData = c;
  }
  demuxSampleAes(e, t, n) {
    const i = this.demux(e, n, !0, !this.config.progressive), s = this.sampleAes = new AV(this.observer, this.config, t);
    return this.decrypt(i, s);
  }
  decrypt(e, t) {
    return new Promise((n) => {
      const {
        audioTrack: i,
        videoTrack: s
      } = e;
      i.samples && i.segmentCodec === "aac" ? t.decryptAacSamples(i.samples, 0, () => {
        s.samples ? t.decryptAvcSamples(s.samples, 0, 0, () => {
          n(e);
        }) : n(e);
      }) : s.samples && t.decryptAvcSamples(s.samples, 0, 0, () => {
        n(e);
      });
    });
  }
  destroy() {
    this.observer && this.observer.removeAllListeners(), this.config = this.logger = this.observer = null, this.aacOverFlow = this.videoParser = this.remainderData = this.sampleAes = null, this._videoTrack = this._audioTrack = this._id3Track = this._txtTrack = void 0;
  }
  parseAACPES(e, t) {
    let n = 0;
    const i = this.aacOverFlow;
    let s = t.data;
    if (i) {
      this.aacOverFlow = null;
      const d = i.missing, f = i.sample.unit.byteLength;
      if (d === -1)
        s = yr(i.sample.unit, s);
      else {
        const h = f - d;
        i.sample.unit.set(s.subarray(0, d), h), e.samples.push(i.sample), n = i.missing;
      }
    }
    let a, o;
    for (a = n, o = s.length; a < o - 1 && !hl(s, a); a++)
      ;
    if (a !== n) {
      let d;
      const f = a < o - 1;
      if (f ? d = `AAC PES did not start with ADTS header,offset:${a}` : d = "No ADTS header found in AAC PES", wf(this.observer, new Error(d), f, this.logger), !f)
        return;
    }
    pw(e, this.observer, s, a, this.audioCodec);
    let c;
    if (t.pts !== void 0)
      c = t.pts;
    else if (i) {
      const d = vw(e.samplerate);
      c = i.sample.pts + d;
    } else {
      this.logger.warn("[tsdemuxer]: AAC PES unknown PTS");
      return;
    }
    let l = 0, u;
    for (; a < o; )
      if (u = yw(e, s, a, c, l), a += u.length, u.missing) {
        this.aacOverFlow = u;
        break;
      } else
        for (l++; a < o - 1 && !hl(s, a); a++)
          ;
  }
  parseMPEGPES(e, t) {
    const n = t.data, i = n.length;
    let s = 0, a = 0;
    const o = t.pts;
    if (o === void 0) {
      this.logger.warn("[tsdemuxer]: MPEG PES unknown PTS");
      return;
    }
    for (; a < i; )
      if (Tw(n, a)) {
        const c = Ew(e, n, a, o, s);
        if (c)
          a += c.length, s++;
        else
          break;
      } else
        a++;
  }
  parseAC3PES(e, t) {
    {
      const n = t.data, i = t.pts;
      if (i === void 0) {
        this.logger.warn("[tsdemuxer]: AC3 PES unknown PTS");
        return;
      }
      const s = n.length;
      let a = 0, o = 0, c;
      for (; o < s && (c = Iw(e, n, o, i, a++)) > 0; )
        o += c;
    }
  }
  parseID3PES(e, t) {
    if (t.pts === void 0) {
      this.logger.warn("[tsdemuxer]: ID3 PES unknown PTS");
      return;
    }
    const n = Ce({}, t, {
      type: this._videoTrack ? Qt.emsg : Qt.audioId3,
      duration: Number.POSITIVE_INFINITY
    });
    e.samples.push(n);
  }
}
function Af(r, e) {
  return ((r[e + 1] & 31) << 8) + r[e + 2];
}
function wV(r, e) {
  return (r[e + 10] & 31) << 8 | r[e + 11];
}
function IV(r, e, t, n, i, s) {
  const a = {
    audioPid: -1,
    videoPid: -1,
    id3Pid: -1,
    segmentVideoCodec: "avc",
    segmentAudioCodec: "aac"
  }, o = (r[e + 1] & 15) << 8 | r[e + 2], c = e + 3 + o - 4, l = (r[e + 10] & 15) << 8 | r[e + 11];
  for (e += 12 + l; e < c; ) {
    const u = Af(r, e), d = (r[e + 3] & 15) << 8 | r[e + 4];
    switch (r[e]) {
      case 207:
        if (!n) {
          td("ADTS AAC", s);
          break;
        }
      /* falls through */
      case 15:
        a.audioPid === -1 && (a.audioPid = u);
        break;
      // Packetized metadata (ID3)
      case 21:
        a.id3Pid === -1 && (a.id3Pid = u);
        break;
      case 219:
        if (!n) {
          td("H.264", s);
          break;
        }
      /* falls through */
      case 27:
        a.videoPid === -1 && (a.videoPid = u);
        break;
      // ISO/IEC 11172-3 (MPEG-1 audio)
      // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)
      case 3:
      case 4:
        !t.mpeg && !t.mp3 ? s.log("MPEG audio found, not supported in this browser") : a.audioPid === -1 && (a.audioPid = u, a.segmentAudioCodec = "mp3");
        break;
      case 193:
        if (!n) {
          td("AC-3", s);
          break;
        }
      /* falls through */
      case 129:
        t.ac3 ? a.audioPid === -1 && (a.audioPid = u, a.segmentAudioCodec = "ac3") : s.log("AC-3 audio found, not supported in this browser");
        break;
      case 6:
        if (a.audioPid === -1 && d > 0) {
          let f = e + 5, h = d;
          for (; h > 2; ) {
            switch (r[f]) {
              case 106:
                t.ac3 !== !0 ? s.log("AC-3 audio found, not supported in this browser for now") : (a.audioPid = u, a.segmentAudioCodec = "ac3");
                break;
            }
            const m = r[f + 1] + 2;
            f += m, h -= m;
          }
        }
        break;
      case 194:
      // SAMPLE-AES EC3
      /* falls through */
      case 135:
        return wf(i, new Error("Unsupported EC-3 in M2TS found"), void 0, s), a;
      case 36:
        a.videoPid === -1 && (a.videoPid = u, a.segmentVideoCodec = "hevc", s.log("HEVC in M2TS found"));
        break;
    }
    e += d + 5;
  }
  return a;
}
function wf(r, e, t, n) {
  n.warn(`parsing error: ${e.message}`), r.emit(E.ERROR, E.ERROR, {
    type: ne.MEDIA_ERROR,
    details: k.FRAG_PARSING_ERROR,
    fatal: !1,
    levelRetry: t,
    error: e,
    reason: e.message
  });
}
function td(r, e) {
  e.log(`${r} with AES-128-CBC encryption found in unencrypted stream`);
}
function Li(r, e) {
  let t = 0, n, i, s, a, o;
  const c = r.data;
  if (!r || r.size === 0)
    return null;
  for (; c[0].length < 19 && c.length > 1; )
    c[0] = yr(c[0], c[1]), c.splice(1, 1);
  if (n = c[0], (n[0] << 16) + (n[1] << 8) + n[2] === 1) {
    if (i = (n[4] << 8) + n[5], i && i > r.size - 6)
      return null;
    const u = n[7];
    u & 192 && (a = (n[9] & 14) * 536870912 + // 1 << 29
    (n[10] & 255) * 4194304 + // 1 << 22
    (n[11] & 254) * 16384 + // 1 << 14
    (n[12] & 255) * 128 + // 1 << 7
    (n[13] & 254) / 2, u & 64 ? (o = (n[14] & 14) * 536870912 + // 1 << 29
    (n[15] & 255) * 4194304 + // 1 << 22
    (n[16] & 254) * 16384 + // 1 << 14
    (n[17] & 255) * 128 + // 1 << 7
    (n[18] & 254) / 2, a - o > 60 * 9e4 && (e.warn(`${Math.round((a - o) / 9e4)}s delta between PTS and DTS, align them`), a = o)) : o = a), s = n[8];
    let d = s + 9;
    if (r.size <= d)
      return null;
    r.size -= d;
    const f = new Uint8Array(r.size);
    for (let h = 0, g = c.length; h < g; h++) {
      n = c[h];
      let m = n.byteLength;
      if (d)
        if (d > m) {
          d -= m;
          continue;
        } else
          n = n.subarray(d), m -= d, d = 0;
      f.set(n, t), t += m;
    }
    return i && (i -= s + 3), {
      data: f,
      pts: a,
      dts: o,
      len: i
    };
  }
  return null;
}
class PV {
  static getSilentFrame(e, t) {
    switch (e) {
      case "mp4a.40.2":
        if (t === 1)
          return new Uint8Array([0, 200, 0, 128, 35, 128]);
        if (t === 2)
          return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
        if (t === 3)
          return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);
        if (t === 4)
          return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);
        if (t === 5)
          return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);
        if (t === 6)
          return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]);
        break;
      // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)
      default:
        if (t === 1)
          return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
        if (t === 2)
          return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
        if (t === 3)
          return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
        break;
    }
  }
}
const An = Math.pow(2, 32) - 1;
class C {
  static init() {
    C.types = {
      avc1: [],
      // codingname
      avcC: [],
      hvc1: [],
      hvcC: [],
      btrt: [],
      dinf: [],
      dref: [],
      esds: [],
      ftyp: [],
      hdlr: [],
      mdat: [],
      mdhd: [],
      mdia: [],
      mfhd: [],
      minf: [],
      moof: [],
      moov: [],
      mp4a: [],
      ".mp3": [],
      dac3: [],
      "ac-3": [],
      mvex: [],
      mvhd: [],
      pasp: [],
      sdtp: [],
      stbl: [],
      stco: [],
      stsc: [],
      stsd: [],
      stsz: [],
      stts: [],
      tfdt: [],
      tfhd: [],
      traf: [],
      trak: [],
      trun: [],
      trex: [],
      tkhd: [],
      vmhd: [],
      smhd: []
    };
    let e;
    for (e in C.types)
      C.types.hasOwnProperty(e) && (C.types[e] = [e.charCodeAt(0), e.charCodeAt(1), e.charCodeAt(2), e.charCodeAt(3)]);
    const t = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0,
      // pre_defined
      118,
      105,
      100,
      101,
      // handler_type: 'vide'
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      86,
      105,
      100,
      101,
      111,
      72,
      97,
      110,
      100,
      108,
      101,
      114,
      0
      // name: 'VideoHandler'
    ]), n = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0,
      // pre_defined
      115,
      111,
      117,
      110,
      // handler_type: 'soun'
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      83,
      111,
      117,
      110,
      100,
      72,
      97,
      110,
      100,
      108,
      101,
      114,
      0
      // name: 'SoundHandler'
    ]);
    C.HDLR_TYPES = {
      video: t,
      audio: n
    };
    const i = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      1,
      // entry_count
      0,
      0,
      0,
      12,
      // entry_size
      117,
      114,
      108,
      32,
      // 'url' type
      0,
      // version 0
      0,
      0,
      1
      // entry_flags
    ]), s = new Uint8Array([
      0,
      // version
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0
      // entry_count
    ]);
    C.STTS = C.STSC = C.STCO = s, C.STSZ = new Uint8Array([
      0,
      // version
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0,
      // sample_size
      0,
      0,
      0,
      0
      // sample_count
    ]), C.VMHD = new Uint8Array([
      0,
      // version
      0,
      0,
      1,
      // flags
      0,
      0,
      // graphicsmode
      0,
      0,
      0,
      0,
      0,
      0
      // opcolor
    ]), C.SMHD = new Uint8Array([
      0,
      // version
      0,
      0,
      0,
      // flags
      0,
      0,
      // balance
      0,
      0
      // reserved
    ]), C.STSD = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      1
    ]);
    const a = new Uint8Array([105, 115, 111, 109]), o = new Uint8Array([97, 118, 99, 49]), c = new Uint8Array([0, 0, 0, 1]);
    C.FTYP = C.box(C.types.ftyp, a, c, a, o), C.DINF = C.box(C.types.dinf, C.box(C.types.dref, i));
  }
  static box(e, ...t) {
    let n = 8, i = t.length;
    const s = i;
    for (; i--; )
      n += t[i].byteLength;
    const a = new Uint8Array(n);
    for (a[0] = n >> 24 & 255, a[1] = n >> 16 & 255, a[2] = n >> 8 & 255, a[3] = n & 255, a.set(e, 4), i = 0, n = 8; i < s; i++)
      a.set(t[i], n), n += t[i].byteLength;
    return a;
  }
  static hdlr(e) {
    return C.box(C.types.hdlr, C.HDLR_TYPES[e]);
  }
  static mdat(e) {
    return C.box(C.types.mdat, e);
  }
  static mdhd(e, t) {
    t *= e;
    const n = Math.floor(t / (An + 1)), i = Math.floor(t % (An + 1));
    return C.box(C.types.mdhd, new Uint8Array([
      1,
      // version 1
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      2,
      // creation_time
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      3,
      // modification_time
      e >> 24 & 255,
      e >> 16 & 255,
      e >> 8 & 255,
      e & 255,
      // timescale
      n >> 24,
      n >> 16 & 255,
      n >> 8 & 255,
      n & 255,
      i >> 24,
      i >> 16 & 255,
      i >> 8 & 255,
      i & 255,
      85,
      196,
      // 'und' language (undetermined)
      0,
      0
    ]));
  }
  static mdia(e) {
    return C.box(C.types.mdia, C.mdhd(e.timescale || 0, e.duration || 0), C.hdlr(e.type), C.minf(e));
  }
  static mfhd(e) {
    return C.box(C.types.mfhd, new Uint8Array([
      0,
      0,
      0,
      0,
      // flags
      e >> 24,
      e >> 16 & 255,
      e >> 8 & 255,
      e & 255
      // sequence_number
    ]));
  }
  static minf(e) {
    return e.type === "audio" ? C.box(C.types.minf, C.box(C.types.smhd, C.SMHD), C.DINF, C.stbl(e)) : C.box(C.types.minf, C.box(C.types.vmhd, C.VMHD), C.DINF, C.stbl(e));
  }
  static moof(e, t, n) {
    return C.box(C.types.moof, C.mfhd(e), C.traf(n, t));
  }
  static moov(e) {
    let t = e.length;
    const n = [];
    for (; t--; )
      n[t] = C.trak(e[t]);
    return C.box.apply(null, [C.types.moov, C.mvhd(e[0].timescale || 0, e[0].duration || 0)].concat(n).concat(C.mvex(e)));
  }
  static mvex(e) {
    let t = e.length;
    const n = [];
    for (; t--; )
      n[t] = C.trex(e[t]);
    return C.box.apply(null, [C.types.mvex, ...n]);
  }
  static mvhd(e, t) {
    t *= e;
    const n = Math.floor(t / (An + 1)), i = Math.floor(t % (An + 1)), s = new Uint8Array([
      1,
      // version 1
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      2,
      // creation_time
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      3,
      // modification_time
      e >> 24 & 255,
      e >> 16 & 255,
      e >> 8 & 255,
      e & 255,
      // timescale
      n >> 24,
      n >> 16 & 255,
      n >> 8 & 255,
      n & 255,
      i >> 24,
      i >> 16 & 255,
      i >> 8 & 255,
      i & 255,
      0,
      1,
      0,
      0,
      // 1.0 rate
      1,
      0,
      // 1.0 volume
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      64,
      0,
      0,
      0,
      // transformation: unity matrix
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // pre_defined
      255,
      255,
      255,
      255
      // next_track_ID
    ]);
    return C.box(C.types.mvhd, s);
  }
  static sdtp(e) {
    const t = e.samples || [], n = new Uint8Array(4 + t.length);
    let i, s;
    for (i = 0; i < t.length; i++)
      s = t[i].flags, n[i + 4] = s.dependsOn << 4 | s.isDependedOn << 2 | s.hasRedundancy;
    return C.box(C.types.sdtp, n);
  }
  static stbl(e) {
    return C.box(C.types.stbl, C.stsd(e), C.box(C.types.stts, C.STTS), C.box(C.types.stsc, C.STSC), C.box(C.types.stsz, C.STSZ), C.box(C.types.stco, C.STCO));
  }
  static avc1(e) {
    let t = [], n = [], i, s, a;
    for (i = 0; i < e.sps.length; i++)
      s = e.sps[i], a = s.byteLength, t.push(a >>> 8 & 255), t.push(a & 255), t = t.concat(Array.prototype.slice.call(s));
    for (i = 0; i < e.pps.length; i++)
      s = e.pps[i], a = s.byteLength, n.push(a >>> 8 & 255), n.push(a & 255), n = n.concat(Array.prototype.slice.call(s));
    const o = C.box(C.types.avcC, new Uint8Array([
      1,
      // version
      t[3],
      // profile
      t[4],
      // profile compat
      t[5],
      // level
      255,
      // lengthSizeMinusOne, hard-coded to 4 bytes
      224 | e.sps.length
      // 3bit reserved (111) + numOfSequenceParameterSets
    ].concat(t).concat([
      e.pps.length
      // numOfPictureParameterSets
    ]).concat(n))), c = e.width, l = e.height, u = e.pixelRatio[0], d = e.pixelRatio[1];
    return C.box(
      C.types.avc1,
      new Uint8Array([
        0,
        0,
        0,
        // reserved
        0,
        0,
        0,
        // reserved
        0,
        1,
        // data_reference_index
        0,
        0,
        // pre_defined
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // pre_defined
        c >> 8 & 255,
        c & 255,
        // width
        l >> 8 & 255,
        l & 255,
        // height
        0,
        72,
        0,
        0,
        // horizresolution
        0,
        72,
        0,
        0,
        // vertresolution
        0,
        0,
        0,
        0,
        // reserved
        0,
        1,
        // frame_count
        18,
        100,
        97,
        105,
        108,
        // dailymotion/hls.js
        121,
        109,
        111,
        116,
        105,
        111,
        110,
        47,
        104,
        108,
        115,
        46,
        106,
        115,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // compressorname
        0,
        24,
        // depth = 24
        17,
        17
      ]),
      // pre_defined = -1
      o,
      C.box(C.types.btrt, new Uint8Array([
        0,
        28,
        156,
        128,
        // bufferSizeDB
        0,
        45,
        198,
        192,
        // maxBitrate
        0,
        45,
        198,
        192
      ])),
      // avgBitrate
      C.box(C.types.pasp, new Uint8Array([
        u >> 24,
        // hSpacing
        u >> 16 & 255,
        u >> 8 & 255,
        u & 255,
        d >> 24,
        // vSpacing
        d >> 16 & 255,
        d >> 8 & 255,
        d & 255
      ]))
    );
  }
  static esds(e) {
    const t = e.config;
    return new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      3,
      // descriptor_type
      25,
      // length
      0,
      1,
      // es_id
      0,
      // stream_priority
      4,
      // descriptor_type
      17,
      // length
      64,
      // codec : mpeg4_audio
      21,
      // stream_type
      0,
      0,
      0,
      // buffer_size
      0,
      0,
      0,
      0,
      // maxBitrate
      0,
      0,
      0,
      0,
      // avgBitrate
      5,
      // descriptor_type
      2,
      // length
      ...t,
      6,
      1,
      2
      // GASpecificConfig)); // length + audio config descriptor
    ]);
  }
  static audioStsd(e) {
    const t = e.samplerate || 0;
    return new Uint8Array([
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      // reserved
      0,
      1,
      // data_reference_index
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // reserved
      0,
      e.channelCount || 0,
      // channelcount
      0,
      16,
      // sampleSize:16bits
      0,
      0,
      0,
      0,
      // reserved2
      t >> 8 & 255,
      t & 255,
      //
      0,
      0
    ]);
  }
  static mp4a(e) {
    return C.box(C.types.mp4a, C.audioStsd(e), C.box(C.types.esds, C.esds(e)));
  }
  static mp3(e) {
    return C.box(C.types[".mp3"], C.audioStsd(e));
  }
  static ac3(e) {
    return C.box(C.types["ac-3"], C.audioStsd(e), C.box(C.types.dac3, e.config));
  }
  static stsd(e) {
    const {
      segmentCodec: t
    } = e;
    if (e.type === "audio") {
      if (t === "aac")
        return C.box(C.types.stsd, C.STSD, C.mp4a(e));
      if (t === "ac3" && e.config)
        return C.box(C.types.stsd, C.STSD, C.ac3(e));
      if (t === "mp3" && e.codec === "mp3")
        return C.box(C.types.stsd, C.STSD, C.mp3(e));
    } else if (e.pps && e.sps) {
      if (t === "avc")
        return C.box(C.types.stsd, C.STSD, C.avc1(e));
      if (t === "hevc" && e.vps)
        return C.box(C.types.stsd, C.STSD, C.hvc1(e));
    } else
      throw new Error("video track missing pps or sps");
    throw new Error(`unsupported ${e.type} segment codec (${t}/${e.codec})`);
  }
  static tkhd(e) {
    const t = e.id, n = (e.duration || 0) * (e.timescale || 0), i = e.width || 0, s = e.height || 0, a = Math.floor(n / (An + 1)), o = Math.floor(n % (An + 1));
    return C.box(C.types.tkhd, new Uint8Array([
      1,
      // version 1
      0,
      0,
      7,
      // flags
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      2,
      // creation_time
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      3,
      // modification_time
      t >> 24 & 255,
      t >> 16 & 255,
      t >> 8 & 255,
      t & 255,
      // track_ID
      0,
      0,
      0,
      0,
      // reserved
      a >> 24,
      a >> 16 & 255,
      a >> 8 & 255,
      a & 255,
      o >> 24,
      o >> 16 & 255,
      o >> 8 & 255,
      o & 255,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      // layer
      0,
      0,
      // alternate_group
      0,
      0,
      // non-audio track volume
      0,
      0,
      // reserved
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      64,
      0,
      0,
      0,
      // transformation: unity matrix
      i >> 8 & 255,
      i & 255,
      0,
      0,
      // width
      s >> 8 & 255,
      s & 255,
      0,
      0
      // height
    ]));
  }
  static traf(e, t) {
    const n = C.sdtp(e), i = e.id, s = Math.floor(t / (An + 1)), a = Math.floor(t % (An + 1));
    return C.box(
      C.types.traf,
      C.box(C.types.tfhd, new Uint8Array([
        0,
        // version 0
        0,
        0,
        0,
        // flags
        i >> 24,
        i >> 16 & 255,
        i >> 8 & 255,
        i & 255
        // track_ID
      ])),
      C.box(C.types.tfdt, new Uint8Array([
        1,
        // version 1
        0,
        0,
        0,
        // flags
        s >> 24,
        s >> 16 & 255,
        s >> 8 & 255,
        s & 255,
        a >> 24,
        a >> 16 & 255,
        a >> 8 & 255,
        a & 255
      ])),
      C.trun(e, n.length + 16 + // tfhd
      20 + // tfdt
      8 + // traf header
      16 + // mfhd
      8 + // moof header
      8),
      // mdat header
      n
    );
  }
  /**
   * Generate a track box.
   * @param track a track definition
   */
  static trak(e) {
    return e.duration = e.duration || 4294967295, C.box(C.types.trak, C.tkhd(e), C.mdia(e));
  }
  static trex(e) {
    const t = e.id;
    return C.box(C.types.trex, new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      t >> 24,
      t >> 16 & 255,
      t >> 8 & 255,
      t & 255,
      // track_ID
      0,
      0,
      0,
      1,
      // default_sample_description_index
      0,
      0,
      0,
      0,
      // default_sample_duration
      0,
      0,
      0,
      0,
      // default_sample_size
      0,
      1,
      0,
      1
      // default_sample_flags
    ]));
  }
  static trun(e, t) {
    const n = e.samples || [], i = n.length, s = 12 + 16 * i, a = new Uint8Array(s);
    let o, c, l, u, d, f;
    for (t += 8 + s, a.set([
      e.type === "video" ? 1 : 0,
      // version 1 for video with signed-int sample_composition_time_offset
      0,
      15,
      1,
      // flags
      i >>> 24 & 255,
      i >>> 16 & 255,
      i >>> 8 & 255,
      i & 255,
      // sample_count
      t >>> 24 & 255,
      t >>> 16 & 255,
      t >>> 8 & 255,
      t & 255
      // data_offset
    ], 0), o = 0; o < i; o++)
      c = n[o], l = c.duration, u = c.size, d = c.flags, f = c.cts, a.set([
        l >>> 24 & 255,
        l >>> 16 & 255,
        l >>> 8 & 255,
        l & 255,
        // sample_duration
        u >>> 24 & 255,
        u >>> 16 & 255,
        u >>> 8 & 255,
        u & 255,
        // sample_size
        d.isLeading << 2 | d.dependsOn,
        d.isDependedOn << 6 | d.hasRedundancy << 4 | d.paddingValue << 1 | d.isNonSync,
        d.degradPrio & 61440,
        d.degradPrio & 15,
        // sample_flags
        f >>> 24 & 255,
        f >>> 16 & 255,
        f >>> 8 & 255,
        f & 255
        // sample_composition_time_offset
      ], 12 + 16 * o);
    return C.box(C.types.trun, a);
  }
  static initSegment(e) {
    C.types || C.init();
    const t = C.moov(e);
    return yr(C.FTYP, t);
  }
  static hvc1(e) {
    const t = e.params, n = [e.vps, e.sps, e.pps], i = 4, s = new Uint8Array([1, t.general_profile_space << 6 | (t.general_tier_flag ? 32 : 0) | t.general_profile_idc, t.general_profile_compatibility_flags[0], t.general_profile_compatibility_flags[1], t.general_profile_compatibility_flags[2], t.general_profile_compatibility_flags[3], t.general_constraint_indicator_flags[0], t.general_constraint_indicator_flags[1], t.general_constraint_indicator_flags[2], t.general_constraint_indicator_flags[3], t.general_constraint_indicator_flags[4], t.general_constraint_indicator_flags[5], t.general_level_idc, 240 | t.min_spatial_segmentation_idc >> 8, 255 & t.min_spatial_segmentation_idc, 252 | t.parallelismType, 252 | t.chroma_format_idc, 248 | t.bit_depth_luma_minus8, 248 | t.bit_depth_chroma_minus8, 0, parseInt(t.frame_rate.fps), i - 1 | t.temporal_id_nested << 2 | t.num_temporal_layers << 3 | (t.frame_rate.fixed ? 64 : 0), n.length]);
    let a = s.length;
    for (let g = 0; g < n.length; g += 1) {
      a += 3;
      for (let m = 0; m < n[g].length; m += 1)
        a += 2 + n[g][m].length;
    }
    const o = new Uint8Array(a);
    o.set(s, 0), a = s.length;
    const c = n.length - 1;
    for (let g = 0; g < n.length; g += 1) {
      o.set(new Uint8Array([32 + g | (g === c ? 128 : 0), 0, n[g].length]), a), a += 3;
      for (let m = 0; m < n[g].length; m += 1)
        o.set(new Uint8Array([n[g][m].length >> 8, n[g][m].length & 255]), a), a += 2, o.set(n[g][m], a), a += n[g][m].length;
    }
    const l = C.box(C.types.hvcC, o), u = e.width, d = e.height, f = e.pixelRatio[0], h = e.pixelRatio[1];
    return C.box(
      C.types.hvc1,
      new Uint8Array([
        0,
        0,
        0,
        // reserved
        0,
        0,
        0,
        // reserved
        0,
        1,
        // data_reference_index
        0,
        0,
        // pre_defined
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // pre_defined
        u >> 8 & 255,
        u & 255,
        // width
        d >> 8 & 255,
        d & 255,
        // height
        0,
        72,
        0,
        0,
        // horizresolution
        0,
        72,
        0,
        0,
        // vertresolution
        0,
        0,
        0,
        0,
        // reserved
        0,
        1,
        // frame_count
        18,
        100,
        97,
        105,
        108,
        // dailymotion/hls.js
        121,
        109,
        111,
        116,
        105,
        111,
        110,
        47,
        104,
        108,
        115,
        46,
        106,
        115,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // compressorname
        0,
        24,
        // depth = 24
        17,
        17
      ]),
      // pre_defined = -1
      l,
      C.box(C.types.btrt, new Uint8Array([
        0,
        28,
        156,
        128,
        // bufferSizeDB
        0,
        45,
        198,
        192,
        // maxBitrate
        0,
        45,
        198,
        192
      ])),
      // avgBitrate
      C.box(C.types.pasp, new Uint8Array([
        f >> 24,
        // hSpacing
        f >> 16 & 255,
        f >> 8 & 255,
        f & 255,
        h >> 24,
        // vSpacing
        h >> 16 & 255,
        h >> 8 & 255,
        h & 255
      ]))
    );
  }
}
C.types = void 0;
C.HDLR_TYPES = void 0;
C.STTS = void 0;
C.STSC = void 0;
C.STCO = void 0;
C.STSZ = void 0;
C.VMHD = void 0;
C.SMHD = void 0;
C.STSD = void 0;
C.FTYP = void 0;
C.DINF = void 0;
const _w = 9e4;
function tm(r, e, t = 1, n = !1) {
  const i = r * e * t;
  return n ? Math.round(i) : i;
}
function _V(r, e, t = 1, n = !1) {
  return tm(r, e, 1 / t, n);
}
function Os(r, e = !1) {
  return tm(r, 1e3, 1 / _w, e);
}
function LV(r, e = 1) {
  return tm(r, _w, 1 / e);
}
const OV = 10 * 1e3, RV = 1024, DV = 1152, CV = 1536;
let Oi = null, rd = null;
function pb(r, e, t, n) {
  return {
    duration: e,
    size: t,
    cts: n,
    flags: {
      isLeading: 0,
      isDependedOn: 0,
      hasRedundancy: 0,
      degradPrio: 0,
      dependsOn: r ? 2 : 1,
      isNonSync: r ? 0 : 1
    }
  };
}
class bo extends Or {
  constructor(e, t, n, i) {
    if (super("mp4-remuxer", i), this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.ISGenerated = !1, this._initPTS = null, this._initDTS = null, this.nextVideoTs = null, this.nextAudioTs = null, this.videoSampleDuration = null, this.isAudioContiguous = !1, this.isVideoContiguous = !1, this.videoTrackConfig = void 0, this.observer = e, this.config = t, this.typeSupported = n, this.ISGenerated = !1, Oi === null) {
      const a = (navigator.userAgent || "").match(/Chrome\/(\d+)/i);
      Oi = a ? parseInt(a[1]) : 0;
    }
    if (rd === null) {
      const s = navigator.userAgent.match(/Safari\/(\d+)/i);
      rd = s ? parseInt(s[1]) : 0;
    }
  }
  destroy() {
    this.config = this.videoTrackConfig = this._initPTS = this._initDTS = null;
  }
  resetTimeStamp(e) {
    this.log("initPTS & initDTS reset"), this._initPTS = this._initDTS = e;
  }
  resetNextTimestamp() {
    this.log("reset next timestamp"), this.isVideoContiguous = !1, this.isAudioContiguous = !1;
  }
  resetInitSegment() {
    this.log("ISGenerated flag reset"), this.ISGenerated = !1, this.videoTrackConfig = void 0;
  }
  getVideoStartPts(e) {
    let t = !1;
    const n = e[0].pts, i = e.reduce((s, a) => {
      let o = a.pts, c = o - s;
      return c < -4294967296 && (t = !0, o = dr(o, n), c = o - s), c > 0 ? s : o;
    }, n);
    return t && this.debug("PTS rollover detected"), i;
  }
  remux(e, t, n, i, s, a, o, c) {
    let l, u, d, f, h, g, m = s, p = s;
    const v = e.pid > -1, y = t.pid > -1, b = t.samples.length, x = e.samples.length > 0, S = o && b > 0 || b > 1;
    if ((!v || x) && (!y || S) || this.ISGenerated || o) {
      if (this.ISGenerated) {
        var T, I, L, _;
        const B = this.videoTrackConfig;
        (B && (t.width !== B.width || t.height !== B.height || ((T = t.pixelRatio) == null ? void 0 : T[0]) !== ((I = B.pixelRatio) == null ? void 0 : I[0]) || ((L = t.pixelRatio) == null ? void 0 : L[1]) !== ((_ = B.pixelRatio) == null ? void 0 : _[1])) || !B && S || this.nextAudioTs === null && x) && this.resetInitSegment();
      }
      this.ISGenerated || (d = this.generateIS(e, t, s, a));
      const R = this.isVideoContiguous;
      let D = -1, F;
      if (S && (D = kV(t.samples), !R && this.config.forceKeyFrameOnDiscontinuity))
        if (g = !0, D > 0) {
          this.warn(`Dropped ${D} out of ${b} video samples due to a missing keyframe`);
          const B = this.getVideoStartPts(t.samples);
          t.samples = t.samples.slice(D), t.dropped += D, p += (t.samples[0].pts - B) / t.inputTimeScale, F = p;
        } else D === -1 && (this.warn(`No keyframe found out of ${b} video samples`), g = !1);
      if (this.ISGenerated) {
        if (x && S) {
          const B = this.getVideoStartPts(t.samples), U = (dr(e.samples[0].pts, B) - B) / t.inputTimeScale;
          m += Math.max(0, U), p += Math.max(0, -U);
        }
        if (x) {
          if (e.samplerate || (this.warn("regenerate InitSegment as audio detected"), d = this.generateIS(e, t, s, a)), u = this.remuxAudio(e, m, this.isAudioContiguous, a, y || S || c === ee.AUDIO ? p : void 0), S) {
            const B = u ? u.endPTS - u.startPTS : 0;
            t.inputTimeScale || (this.warn("regenerate InitSegment as video detected"), d = this.generateIS(e, t, s, a)), l = this.remuxVideo(t, p, R, B);
          }
        } else S && (l = this.remuxVideo(t, p, R, 0));
        l && (l.firstKeyFrame = D, l.independent = D !== -1, l.firstKeyFramePTS = F);
      }
    }
    return this.ISGenerated && this._initPTS && this._initDTS && (n.samples.length && (h = Lw(n, s, this._initPTS, this._initDTS)), i.samples.length && (f = Ow(i, s, this._initPTS))), {
      audio: u,
      video: l,
      initSegment: d,
      independent: g,
      text: f,
      id3: h
    };
  }
  generateIS(e, t, n, i) {
    const s = e.samples, a = t.samples, o = this.typeSupported, c = {}, l = this._initPTS;
    let u = !l || i, d = "audio/mp4", f, h, g, m;
    if (u && (f = h = 1 / 0), e.config && s.length) {
      switch (e.timescale = e.samplerate, e.segmentCodec) {
        case "mp3":
          o.mpeg ? (d = "audio/mpeg", e.codec = "") : o.mp3 && (e.codec = "mp3");
          break;
        case "ac3":
          e.codec = "ac-3";
          break;
      }
      c.audio = {
        id: "audio",
        container: d,
        codec: e.codec,
        initSegment: e.segmentCodec === "mp3" && o.mpeg ? new Uint8Array(0) : C.initSegment([e]),
        metadata: {
          channelCount: e.channelCount
        }
      }, u && (m = e.id, g = e.inputTimeScale, !l || g !== l.timescale ? f = h = s[0].pts - Math.round(g * n) : u = !1);
    }
    if (t.sps && t.pps && a.length) {
      if (t.timescale = t.inputTimeScale, c.video = {
        id: "main",
        container: "video/mp4",
        codec: t.codec,
        initSegment: C.initSegment([t]),
        metadata: {
          width: t.width,
          height: t.height
        }
      }, u)
        if (m = t.id, g = t.inputTimeScale, !l || g !== l.timescale) {
          const p = this.getVideoStartPts(a), v = Math.round(g * n);
          h = Math.min(h, dr(a[0].dts, p) - v), f = Math.min(f, p - v);
        } else
          u = !1;
      this.videoTrackConfig = {
        width: t.width,
        height: t.height,
        pixelRatio: t.pixelRatio
      };
    }
    if (Object.keys(c).length)
      return this.ISGenerated = !0, u ? (this._initPTS = {
        baseTime: f,
        timescale: g
      }, this._initDTS = {
        baseTime: h,
        timescale: g
      }) : f = g = void 0, {
        tracks: c,
        initPTS: f,
        timescale: g,
        trackId: m
      };
  }
  remuxVideo(e, t, n, i) {
    const s = e.inputTimeScale, a = e.samples, o = [], c = a.length, l = this._initPTS, u = l.baseTime * s / l.timescale;
    let d = this.nextVideoTs, f = 8, h = this.videoSampleDuration, g, m, p = Number.POSITIVE_INFINITY, v = Number.NEGATIVE_INFINITY, y = !1;
    if (!n || d === null) {
      const H = u + t * s, N = a[0].pts - dr(a[0].dts, a[0].pts);
      Oi && d !== null && Math.abs(H - N - (d + u)) < 15e3 ? n = !0 : d = H - N - u;
    }
    const b = d + u;
    for (let H = 0; H < c; H++) {
      const N = a[H];
      N.pts = dr(N.pts, b), N.dts = dr(N.dts, b), N.dts < a[H > 0 ? H - 1 : H].dts && (y = !0);
    }
    y && a.sort(function(H, N) {
      const re = H.dts - N.dts, oe = H.pts - N.pts;
      return re || oe;
    }), g = a[0].dts, m = a[a.length - 1].dts;
    const x = m - g, S = x ? Math.round(x / (c - 1)) : h || e.inputTimeScale / 30;
    if (n) {
      const H = g - b, N = H > S, re = H < -1;
      if ((N || re) && (N ? this.warn(`${(e.segmentCodec || "").toUpperCase()}: ${Os(H, !0)} ms (${H}dts) hole between fragments detected at ${t.toFixed(3)}`) : this.warn(`${(e.segmentCodec || "").toUpperCase()}: ${Os(-H, !0)} ms (${H}dts) overlapping between fragments detected at ${t.toFixed(3)}`), !re || b >= a[0].pts || Oi)) {
        g = b;
        const oe = a[0].pts - H;
        if (N)
          a[0].dts = g, a[0].pts = oe;
        else {
          let le = !0;
          for (let he = 0; he < a.length && !(a[he].dts > oe && le); he++) {
            const Re = a[he].pts;
            if (a[he].dts -= H, a[he].pts -= H, he < a.length - 1) {
              const et = a[he + 1].pts, q = a[he].pts, ie = et <= q, fe = et <= Re;
              le = ie == fe;
            }
          }
        }
        this.log(`Video: Initial PTS/DTS adjusted: ${Os(oe, !0)}/${Os(g, !0)}, delta: ${Os(H, !0)} ms`);
      }
    }
    g = Math.max(0, g);
    let A = 0, T = 0, I = g;
    for (let H = 0; H < c; H++) {
      const N = a[H], re = N.units, oe = re.length;
      let le = 0;
      for (let he = 0; he < oe; he++)
        le += re[he].data.length;
      T += le, A += oe, N.length = le, N.dts < I ? (N.dts = I, I += S / 4 | 0 || 1) : I = N.dts, p = Math.min(N.pts, p), v = Math.max(N.pts, v);
    }
    m = a[c - 1].dts;
    const L = T + 4 * A + 8;
    let _;
    try {
      _ = new Uint8Array(L);
    } catch (H) {
      this.observer.emit(E.ERROR, E.ERROR, {
        type: ne.MUX_ERROR,
        details: k.REMUX_ALLOC_ERROR,
        fatal: !1,
        error: H,
        bytes: L,
        reason: `fail allocating video mdat ${L}`
      });
      return;
    }
    const R = new DataView(_.buffer);
    R.setUint32(0, L), _.set(C.types.mdat, 4);
    let D = !1, F = Number.POSITIVE_INFINITY, B = Number.POSITIVE_INFINITY, j = Number.NEGATIVE_INFINITY, U = Number.NEGATIVE_INFINITY;
    for (let H = 0; H < c; H++) {
      const N = a[H], re = N.units;
      let oe = 0;
      for (let Re = 0, et = re.length; Re < et; Re++) {
        const q = re[Re], ie = q.data, fe = q.data.byteLength;
        R.setUint32(f, fe), f += 4, _.set(ie, f), f += fe, oe += 4 + fe;
      }
      let le;
      if (H < c - 1)
        h = a[H + 1].dts - N.dts, le = a[H + 1].pts - N.pts;
      else {
        const Re = this.config, et = H > 0 ? N.dts - a[H - 1].dts : S;
        if (le = H > 0 ? N.pts - a[H - 1].pts : S, Re.stretchShortVideoTrack && this.nextAudioTs !== null) {
          const q = Math.floor(Re.maxBufferHole * s), ie = (i ? p + i * s : this.nextAudioTs + u) - N.pts;
          ie > q ? (h = ie - et, h < 0 ? h = et : D = !0, this.log(`It is approximately ${ie / 90} ms to the next segment; using duration ${h / 90} ms for the last video frame.`)) : h = et;
        } else
          h = et;
      }
      const he = Math.round(N.pts - N.dts);
      F = Math.min(F, h), j = Math.max(j, h), B = Math.min(B, le), U = Math.max(U, le), o.push(pb(N.key, h, oe, he));
    }
    if (o.length) {
      if (Oi) {
        if (Oi < 70) {
          const H = o[0].flags;
          H.dependsOn = 2, H.isNonSync = 0;
        }
      } else if (rd && U - B < j - F && S / j < 0.025 && o[0].cts === 0) {
        this.warn("Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.");
        let H = g;
        for (let N = 0, re = o.length; N < re; N++) {
          const oe = H + o[N].duration, le = H + o[N].cts;
          if (N < re - 1) {
            const he = oe + o[N + 1].cts;
            o[N].duration = he - le;
          } else
            o[N].duration = N ? o[N - 1].duration : S;
          o[N].cts = 0, H = oe;
        }
      }
    }
    h = D || !h ? S : h;
    const K = m + h;
    this.nextVideoTs = d = K - u, this.videoSampleDuration = h, this.isVideoContiguous = !0;
    const Q = {
      data1: C.moof(e.sequenceNumber++, g, Ce(e, {
        samples: o
      })),
      data2: _,
      startPTS: (p - u) / s,
      endPTS: (v + h - u) / s,
      startDTS: (g - u) / s,
      endDTS: d / s,
      type: "video",
      hasAudio: !1,
      hasVideo: !0,
      nb: o.length,
      dropped: e.dropped
    };
    return e.samples = [], e.dropped = 0, Q;
  }
  getSamplesPerFrame(e) {
    switch (e.segmentCodec) {
      case "mp3":
        return DV;
      case "ac3":
        return CV;
      default:
        return RV;
    }
  }
  remuxAudio(e, t, n, i, s) {
    const a = e.inputTimeScale, o = e.samplerate ? e.samplerate : a, c = a / o, l = this.getSamplesPerFrame(e), u = l * c, d = this._initPTS, f = e.segmentCodec === "mp3" && this.typeSupported.mpeg, h = [], g = s !== void 0;
    let m = e.samples, p = f ? 0 : 8, v = this.nextAudioTs || -1;
    const y = d.baseTime * a / d.timescale, b = y + t * a;
    if (this.isAudioContiguous = n = n || m.length && v > 0 && (i && Math.abs(b - (v + y)) < 9e3 || Math.abs(dr(m[0].pts, b) - (v + y)) < 20 * u), m.forEach(function(U) {
      U.pts = dr(U.pts, b);
    }), !n || v < 0) {
      if (m = m.filter((U) => U.pts >= 0), !m.length)
        return;
      s === 0 ? v = 0 : i && !g ? v = Math.max(0, b - y) : v = m[0].pts - y;
    }
    if (e.segmentCodec === "aac") {
      const U = this.config.maxAudioFramesDrift;
      for (let K = 0, G = v + y; K < m.length; K++) {
        const Y = m[K], Q = Y.pts, H = Q - G, N = Math.abs(1e3 * H / a);
        if (H <= -U * u && g)
          K === 0 && (this.warn(`Audio frame @ ${(Q / a).toFixed(3)}s overlaps marker by ${Math.round(1e3 * H / a)} ms.`), this.nextAudioTs = v = Q - y, G = Q);
        else if (H >= U * u && N < OV && g) {
          let re = Math.round(H / u);
          for (G = Q - re * u; G < 0 && re && u; )
            re--, G += u;
          K === 0 && (this.nextAudioTs = v = G - y), this.warn(`Injecting ${re} audio frames @ ${((G - y) / a).toFixed(3)}s due to ${Math.round(1e3 * H / a)} ms gap.`);
          for (let oe = 0; oe < re; oe++) {
            let le = PV.getSilentFrame(e.parsedCodec || e.manifestCodec || e.codec, e.channelCount);
            le || (this.log("Unable to get silent frame for given audio codec; duplicating last frame instead."), le = Y.unit.subarray()), m.splice(K, 0, {
              unit: le,
              pts: G
            }), G += u, K++;
          }
        }
        Y.pts = G, G += u;
      }
    }
    let x = null, S = null, A, T = 0, I = m.length;
    for (; I--; )
      T += m[I].unit.byteLength;
    for (let U = 0, K = m.length; U < K; U++) {
      const G = m[U], Y = G.unit;
      let Q = G.pts;
      if (S !== null) {
        const N = h[U - 1];
        N.duration = Math.round((Q - S) / c);
      } else if (n && e.segmentCodec === "aac" && (Q = v + y), x = Q, T > 0) {
        T += p;
        try {
          A = new Uint8Array(T);
        } catch (N) {
          this.observer.emit(E.ERROR, E.ERROR, {
            type: ne.MUX_ERROR,
            details: k.REMUX_ALLOC_ERROR,
            fatal: !1,
            error: N,
            bytes: T,
            reason: `fail allocating audio mdat ${T}`
          });
          return;
        }
        f || (new DataView(A.buffer).setUint32(0, T), A.set(C.types.mdat, 4));
      } else
        return;
      A.set(Y, p);
      const H = Y.byteLength;
      p += H, h.push(pb(!0, l, H, 0)), S = Q;
    }
    const L = h.length;
    if (!L)
      return;
    const _ = h[h.length - 1];
    v = S - y, this.nextAudioTs = v + c * _.duration;
    const R = f ? new Uint8Array(0) : C.moof(e.sequenceNumber++, x / c, Ce({}, e, {
      samples: h
    }));
    e.samples = [];
    const D = (x - y) / a, F = v / a, j = {
      data1: R,
      data2: A,
      startPTS: D,
      endPTS: F,
      startDTS: D,
      endDTS: F,
      type: "audio",
      hasAudio: !0,
      hasVideo: !1,
      nb: L
    };
    return this.isAudioContiguous = !0, j;
  }
}
function dr(r, e) {
  let t;
  if (e === null)
    return r;
  for (e < r ? t = -8589934592 : t = 8589934592; Math.abs(r - e) > 4294967296; )
    r += t;
  return r;
}
function kV(r) {
  for (let e = 0; e < r.length; e++)
    if (r[e].key)
      return e;
  return -1;
}
function Lw(r, e, t, n) {
  const i = r.samples.length;
  if (!i)
    return;
  const s = r.inputTimeScale;
  for (let o = 0; o < i; o++) {
    const c = r.samples[o];
    c.pts = dr(c.pts - t.baseTime * s / t.timescale, e * s) / s, c.dts = dr(c.dts - n.baseTime * s / n.timescale, e * s) / s;
  }
  const a = r.samples;
  return r.samples = [], {
    samples: a
  };
}
function Ow(r, e, t) {
  const n = r.samples.length;
  if (!n)
    return;
  const i = r.inputTimeScale;
  for (let a = 0; a < n; a++) {
    const o = r.samples[a];
    o.pts = dr(o.pts - t.baseTime * i / t.timescale, e * i) / i;
  }
  r.samples.sort((a, o) => a.pts - o.pts);
  const s = r.samples;
  return r.samples = [], {
    samples: s
  };
}
class MV extends Or {
  constructor(e, t, n, i) {
    super("passthrough-remuxer", i), this.emitInitSegment = !1, this.audioCodec = void 0, this.videoCodec = void 0, this.initData = void 0, this.initPTS = null, this.initTracks = void 0, this.lastEndTime = null, this.isVideoContiguous = !1;
  }
  destroy() {
  }
  resetTimeStamp(e) {
    this.lastEndTime = null;
    const t = this.initPTS;
    t && e && t.baseTime === e.baseTime && t.timescale === e.timescale || (this.initPTS = e);
  }
  resetNextTimestamp() {
    this.isVideoContiguous = !1, this.lastEndTime = null;
  }
  resetInitSegment(e, t, n, i) {
    this.audioCodec = t, this.videoCodec = n, this.generateInitSegment(PK(e, i)), this.emitInitSegment = !0;
  }
  generateInitSegment(e) {
    let {
      audioCodec: t,
      videoCodec: n
    } = this;
    if (!(e != null && e.byteLength)) {
      this.initTracks = void 0, this.initData = void 0;
      return;
    }
    const i = this.initData = GA(e);
    i.audio && (t = vb(i.audio, je.AUDIO, this)), i.video && (n = vb(i.video, je.VIDEO, this));
    const s = {};
    i.audio && i.video ? s.audiovideo = {
      container: "video/mp4",
      codec: t + "," + n,
      supplemental: i.video.supplemental,
      initSegment: e,
      id: "main"
    } : i.audio ? s.audio = {
      container: "audio/mp4",
      codec: t,
      initSegment: e,
      id: "audio"
    } : i.video ? s.video = {
      container: "video/mp4",
      codec: n,
      supplemental: i.video.supplemental,
      initSegment: e,
      id: "main"
    } : this.warn("initSegment does not contain moov or trak boxes."), this.initTracks = s;
  }
  remux(e, t, n, i, s, a) {
    var o, c;
    let {
      initPTS: l,
      lastEndTime: u
    } = this;
    const d = {
      audio: void 0,
      video: void 0,
      text: i,
      id3: n,
      initSegment: void 0
    };
    X(u) || (u = this.lastEndTime = s || 0);
    const f = t.samples;
    if (!(f != null && f.length))
      return d;
    const h = {
      initPTS: void 0,
      timescale: void 0,
      trackId: void 0
    };
    let g = this.initData;
    if ((o = g) != null && o.length || (this.generateInitSegment(f), g = this.initData), !((c = g) != null && c.length))
      return this.warn("Failed to generate initSegment."), d;
    this.emitInitSegment && (h.tracks = this.initTracks, this.emitInitSegment = !1);
    const m = LK(f, g, this), p = g.audio ? m[g.audio.id] : null, v = g.video ? m[g.video.id] : null, y = ao(v, 1 / 0), b = ao(p, 1 / 0), x = ao(v, 0, !0), S = ao(p, 0, !0);
    let A, T = s, I = 0;
    if (p && (!v || !l && b < y || l && l.trackId === g.audio.id) ? (h.trackId = g.audio.id, A = p, I = S - b) : v && (h.trackId = g.video.id, A = v, I = x - y), A) {
      const U = A.timescale;
      T = A.start / U, h.initPTS = A.start - s * U, h.timescale = U, l || (this.initPTS = l = {
        baseTime: h.initPTS,
        timescale: U,
        trackId: h.trackId
      });
    }
    (a || !l) && (NV(l, T, s, I) || h.timescale !== l.timescale) && (h.initPTS = T - s, h.timescale = 1, l && l.timescale === 1 && this.warn(`Adjusting initPTS @${s} from ${l.baseTime / l.timescale} to ${h.initPTS}`), this.initPTS = l = {
      baseTime: h.initPTS,
      timescale: 1
    });
    const L = e ? T - l.baseTime / l.timescale : u, _ = L + I;
    I > 0 ? this.lastEndTime = _ : (this.warn("Duration parsed from mp4 should be greater than zero"), this.resetNextTimestamp());
    const R = !!g.audio, D = !!g.video;
    let F = "";
    R && (F += "audio"), D && (F += "video");
    const B = {
      data1: f,
      startPTS: L,
      startDTS: L,
      endPTS: _,
      endDTS: _,
      type: F,
      hasAudio: R,
      hasVideo: D,
      nb: 1,
      dropped: 0
    };
    d.audio = R && !D ? B : void 0, d.video = D ? B : void 0;
    const j = v == null ? void 0 : v.sampleCount;
    if (j) {
      const U = v.keyFrameIndex, K = U !== -1;
      B.nb = j, B.dropped = U === 0 || this.isVideoContiguous ? 0 : K ? U : j, B.independent = K, B.firstKeyFrame = U, K && v.keyFrameStart && (B.firstKeyFramePTS = (v.keyFrameStart - l.baseTime) / l.timescale), this.isVideoContiguous || (d.independent = K), this.isVideoContiguous || (this.isVideoContiguous = K), B.dropped && this.warn(`fmp4 does not start with IDR: firstIDR ${U}/${j} dropped: ${B.dropped} start: ${B.firstKeyFramePTS || "NA"}`);
    }
    return d.initSegment = h, d.id3 = Lw(n, s, l, l), i.samples.length && (d.text = Ow(i, s, l)), d;
  }
}
function ao(r, e, t = !1) {
  return (r == null ? void 0 : r.start) !== void 0 ? (r.start + (t ? r.duration : 0)) / r.timescale : e;
}
function NV(r, e, t, n) {
  if (r === null)
    return !0;
  const i = Math.max(n, 1), s = e - r.baseTime / r.timescale;
  return Math.abs(s - t) > i;
}
function vb(r, e, t) {
  const n = r == null ? void 0 : r.codec;
  return n && n.length > 4 ? n : e === je.AUDIO ? n === "ec-3" || n === "ac-3" || n === "alac" ? n : n === "fLaC" || n === "Opus" ? al(n, !1) : (t.warn(`Unhandled audio codec "${n}" in mp4 MAP`), n || "mp4a") : (t.warn(`Unhandled video codec "${n}" in mp4 MAP`), n || "avc1");
}
let Yr;
try {
  Yr = self.performance.now.bind(self.performance);
} catch {
  Yr = Date.now;
}
const xo = [{
  demux: TV,
  remux: MV
}, {
  demux: Ln,
  remux: bo
}, {
  demux: bV,
  remux: bo
}, {
  demux: EV,
  remux: bo
}];
xo.splice(2, 0, {
  demux: xV,
  remux: bo
});
class yb {
  constructor(e, t, n, i, s, a) {
    this.asyncResult = !1, this.logger = void 0, this.observer = void 0, this.typeSupported = void 0, this.config = void 0, this.id = void 0, this.demuxer = void 0, this.remuxer = void 0, this.decrypter = void 0, this.probe = void 0, this.decryptionPromise = null, this.transmuxConfig = void 0, this.currentTransmuxState = void 0, this.observer = e, this.typeSupported = t, this.config = n, this.id = s, this.logger = a;
  }
  configure(e) {
    this.transmuxConfig = e, this.decrypter && this.decrypter.reset();
  }
  push(e, t, n, i) {
    const s = n.transmuxing;
    s.executeStart = Yr();
    let a = new Uint8Array(e);
    const {
      currentTransmuxState: o,
      transmuxConfig: c
    } = this;
    i && (this.currentTransmuxState = i);
    const {
      contiguous: l,
      discontinuity: u,
      trackSwitch: d,
      accurateTimeOffset: f,
      timeOffset: h,
      initSegmentChange: g
    } = i || o, {
      audioCodec: m,
      videoCodec: p,
      defaultInitPts: v,
      duration: y,
      initSegmentData: b
    } = c, x = FV(a, t);
    if (x && Bi(x.method)) {
      const I = this.getDecrypter(), L = qg(x.method);
      if (I.isSync()) {
        let _ = I.softwareDecrypt(a, x.key.buffer, x.iv.buffer, L);
        if (n.part > -1) {
          const D = I.flush();
          _ = D && D.buffer;
        }
        if (!_)
          return s.executeEnd = Yr(), nd(n);
        a = new Uint8Array(_);
      } else
        return this.asyncResult = !0, this.decryptionPromise = I.webCryptoDecrypt(a, x.key.buffer, x.iv.buffer, L).then((_) => {
          const R = this.push(_, null, n);
          return this.decryptionPromise = null, R;
        }), this.decryptionPromise;
    }
    const S = this.needsProbing(u, d);
    if (S) {
      const I = this.configureTransmuxer(a);
      if (I)
        return this.logger.warn(`[transmuxer] ${I.message}`), this.observer.emit(E.ERROR, E.ERROR, {
          type: ne.MEDIA_ERROR,
          details: k.FRAG_PARSING_ERROR,
          fatal: !1,
          error: I,
          reason: I.message
        }), s.executeEnd = Yr(), nd(n);
    }
    (u || d || g || S) && this.resetInitSegment(b, m, p, y, t), (u || g || S) && this.resetInitialTimestamp(v), l || this.resetContiguity();
    const A = this.transmux(a, x, h, f, n);
    this.asyncResult = sa(A);
    const T = this.currentTransmuxState;
    return T.contiguous = !0, T.discontinuity = !1, T.trackSwitch = !1, s.executeEnd = Yr(), A;
  }
  // Due to data caching, flush calls can produce more than one TransmuxerResult (hence the Array type)
  flush(e) {
    const t = e.transmuxing;
    t.executeStart = Yr();
    const {
      decrypter: n,
      currentTransmuxState: i,
      decryptionPromise: s
    } = this;
    if (s)
      return this.asyncResult = !0, s.then(() => this.flush(e));
    const a = [], {
      timeOffset: o
    } = i;
    if (n) {
      const d = n.flush();
      d && a.push(this.push(d.buffer, null, e));
    }
    const {
      demuxer: c,
      remuxer: l
    } = this;
    if (!c || !l) {
      t.executeEnd = Yr();
      const d = [nd(e)];
      return this.asyncResult ? Promise.resolve(d) : d;
    }
    const u = c.flush(o);
    return sa(u) ? (this.asyncResult = !0, u.then((d) => (this.flushRemux(a, d, e), a))) : (this.flushRemux(a, u, e), this.asyncResult ? Promise.resolve(a) : a);
  }
  flushRemux(e, t, n) {
    const {
      audioTrack: i,
      videoTrack: s,
      id3Track: a,
      textTrack: o
    } = t, {
      accurateTimeOffset: c,
      timeOffset: l
    } = this.currentTransmuxState;
    this.logger.log(`[transmuxer.ts]: Flushed ${this.id} sn: ${n.sn}${n.part > -1 ? " part: " + n.part : ""} of ${this.id === ee.MAIN ? "level" : "track"} ${n.level}`);
    const u = this.remuxer.remux(i, s, a, o, l, c, !0, this.id);
    e.push({
      remuxResult: u,
      chunkMeta: n
    }), n.transmuxing.executeEnd = Yr();
  }
  resetInitialTimestamp(e) {
    const {
      demuxer: t,
      remuxer: n
    } = this;
    !t || !n || (t.resetTimeStamp(e), n.resetTimeStamp(e));
  }
  resetContiguity() {
    const {
      demuxer: e,
      remuxer: t
    } = this;
    !e || !t || (e.resetContiguity(), t.resetNextTimestamp());
  }
  resetInitSegment(e, t, n, i, s) {
    const {
      demuxer: a,
      remuxer: o
    } = this;
    !a || !o || (a.resetInitSegment(e, t, n, i), o.resetInitSegment(e, t, n, s));
  }
  destroy() {
    this.demuxer && (this.demuxer.destroy(), this.demuxer = void 0), this.remuxer && (this.remuxer.destroy(), this.remuxer = void 0);
  }
  transmux(e, t, n, i, s) {
    let a;
    return t && t.method === "SAMPLE-AES" ? a = this.transmuxSampleAes(e, t, n, i, s) : a = this.transmuxUnencrypted(e, n, i, s), a;
  }
  transmuxUnencrypted(e, t, n, i) {
    const {
      audioTrack: s,
      videoTrack: a,
      id3Track: o,
      textTrack: c
    } = this.demuxer.demux(e, t, !1, !this.config.progressive);
    return {
      remuxResult: this.remuxer.remux(s, a, o, c, t, n, !1, this.id),
      chunkMeta: i
    };
  }
  transmuxSampleAes(e, t, n, i, s) {
    return this.demuxer.demuxSampleAes(e, t, n).then((a) => ({
      remuxResult: this.remuxer.remux(a.audioTrack, a.videoTrack, a.id3Track, a.textTrack, n, i, !1, this.id),
      chunkMeta: s
    }));
  }
  configureTransmuxer(e) {
    const {
      config: t,
      observer: n,
      typeSupported: i
    } = this;
    let s;
    for (let d = 0, f = xo.length; d < f; d++) {
      var a;
      if ((a = xo[d].demux) != null && a.probe(e, this.logger)) {
        s = xo[d];
        break;
      }
    }
    if (!s)
      return new Error("Failed to find demuxer by probing fragment data");
    const o = this.demuxer, c = this.remuxer, l = s.remux, u = s.demux;
    (!c || !(c instanceof l)) && (this.remuxer = new l(n, t, i, this.logger)), (!o || !(o instanceof u)) && (this.demuxer = new u(n, t, i, this.logger), this.probe = u.probe);
  }
  needsProbing(e, t) {
    return !this.demuxer || !this.remuxer || e || t;
  }
  getDecrypter() {
    let e = this.decrypter;
    return e || (e = this.decrypter = new Wg(this.config)), e;
  }
}
function FV(r, e) {
  let t = null;
  return r.byteLength > 0 && (e == null ? void 0 : e.key) != null && e.iv !== null && e.method != null && (t = e), t;
}
const nd = (r) => ({
  remuxResult: {},
  chunkMeta: r
});
function sa(r) {
  return "then" in r && r.then instanceof Function;
}
class $V {
  constructor(e, t, n, i, s) {
    this.audioCodec = void 0, this.videoCodec = void 0, this.initSegmentData = void 0, this.duration = void 0, this.defaultInitPts = void 0, this.audioCodec = e, this.videoCodec = t, this.initSegmentData = n, this.duration = i, this.defaultInitPts = s || null;
  }
}
class BV {
  constructor(e, t, n, i, s, a) {
    this.discontinuity = void 0, this.contiguous = void 0, this.accurateTimeOffset = void 0, this.trackSwitch = void 0, this.timeOffset = void 0, this.initSegmentChange = void 0, this.discontinuity = e, this.contiguous = t, this.accurateTimeOffset = n, this.trackSwitch = i, this.timeOffset = s, this.initSegmentChange = a;
  }
}
let bb = 0;
class Rw {
  constructor(e, t, n, i) {
    this.error = null, this.hls = void 0, this.id = void 0, this.instanceNo = bb++, this.observer = void 0, this.frag = null, this.part = null, this.useWorker = void 0, this.workerContext = null, this.transmuxer = null, this.onTransmuxComplete = void 0, this.onFlush = void 0, this.onWorkerMessage = (c) => {
      const l = c.data, u = this.hls;
      if (!(!u || !(l != null && l.event) || l.instanceNo !== this.instanceNo))
        switch (l.event) {
          case "init": {
            var d;
            const f = (d = this.workerContext) == null ? void 0 : d.objectURL;
            f && self.URL.revokeObjectURL(f);
            break;
          }
          case "transmuxComplete": {
            this.handleTransmuxComplete(l.data);
            break;
          }
          case "flush": {
            this.onFlush(l.data);
            break;
          }
          // pass logs from the worker thread to the main logger
          case "workerLog": {
            u.logger[l.data.logType] && u.logger[l.data.logType](l.data.message);
            break;
          }
          default: {
            l.data = l.data || {}, l.data.frag = this.frag, l.data.part = this.part, l.data.id = this.id, u.trigger(l.event, l.data);
            break;
          }
        }
    }, this.onWorkerError = (c) => {
      if (!this.hls)
        return;
      const l = new Error(`${c.message}  (${c.filename}:${c.lineno})`);
      this.hls.config.enableWorker = !1, this.hls.logger.warn(`Error in "${this.id}" Web Worker, fallback to inline`), this.hls.trigger(E.ERROR, {
        type: ne.OTHER_ERROR,
        details: k.INTERNAL_EXCEPTION,
        fatal: !1,
        event: "demuxerWorker",
        error: l
      });
    };
    const s = e.config;
    this.hls = e, this.id = t, this.useWorker = !!s.enableWorker, this.onTransmuxComplete = n, this.onFlush = i;
    const a = (c, l) => {
      l = l || {}, l.frag = this.frag || void 0, c === E.ERROR && (l = l, l.parent = this.id, l.part = this.part, this.error = l.error), this.hls.trigger(c, l);
    };
    this.observer = new Yg(), this.observer.on(E.FRAG_DECRYPTED, a), this.observer.on(E.ERROR, a);
    const o = My(s.preferManagedMediaSource);
    if (this.useWorker && typeof Worker < "u") {
      const c = this.hls.logger;
      if (s.workerPath || W3()) {
        try {
          s.workerPath ? (c.log(`loading Web Worker ${s.workerPath} for "${t}"`), this.workerContext = q3(s.workerPath)) : (c.log(`injecting Web Worker for "${t}"`), this.workerContext = H3());
          const {
            worker: u
          } = this.workerContext;
          u.addEventListener("message", this.onWorkerMessage), u.addEventListener("error", this.onWorkerError), u.postMessage({
            instanceNo: this.instanceNo,
            cmd: "init",
            typeSupported: o,
            id: t,
            config: We(s)
          });
        } catch (u) {
          c.warn(`Error setting up "${t}" Web Worker, fallback to inline`, u), this.terminateWorker(), this.error = null, this.transmuxer = new yb(this.observer, o, s, "", t, e.logger);
        }
        return;
      }
    }
    this.transmuxer = new yb(this.observer, o, s, "", t, e.logger);
  }
  reset() {
    if (this.frag = null, this.part = null, this.workerContext) {
      const e = this.instanceNo;
      this.instanceNo = bb++;
      const t = this.hls.config, n = My(t.preferManagedMediaSource);
      this.workerContext.worker.postMessage({
        instanceNo: this.instanceNo,
        cmd: "reset",
        resetNo: e,
        typeSupported: n,
        id: this.id,
        config: We(t)
      });
    }
  }
  terminateWorker() {
    if (this.workerContext) {
      const {
        worker: e
      } = this.workerContext;
      this.workerContext = null, e.removeEventListener("message", this.onWorkerMessage), e.removeEventListener("error", this.onWorkerError), z3(this.hls.config.workerPath);
    }
  }
  destroy() {
    if (this.workerContext)
      this.terminateWorker(), this.onWorkerMessage = this.onWorkerError = null;
    else {
      const t = this.transmuxer;
      t && (t.destroy(), this.transmuxer = null);
    }
    const e = this.observer;
    e && e.removeAllListeners(), this.frag = null, this.part = null, this.observer = null, this.hls = null;
  }
  push(e, t, n, i, s, a, o, c, l, u) {
    var d, f;
    l.transmuxing.start = self.performance.now();
    const {
      instanceNo: h,
      transmuxer: g
    } = this, m = a ? a.start : s.start, p = s.decryptdata, v = this.frag, y = !(v && s.cc === v.cc), b = !(v && l.level === v.level), x = v ? l.sn - v.sn : -1, S = this.part ? l.part - this.part.index : -1, A = x === 0 && l.id > 1 && l.id === (v == null ? void 0 : v.stats.chunkCount), T = !b && (x === 1 || x === 0 && (S === 1 || A && S <= 0)), I = self.performance.now();
    (b || x || s.stats.parsing.start === 0) && (s.stats.parsing.start = I), a && (S || !T) && (a.stats.parsing.start = I);
    const L = !(v && ((d = s.initSegment) == null ? void 0 : d.url) === ((f = v.initSegment) == null ? void 0 : f.url)), _ = new BV(y, T, c, b, m, L);
    if (!T || y || L) {
      this.hls.logger.log(`[transmuxer-interface]: Starting new transmux session for ${s.type} sn: ${l.sn}${l.part > -1 ? " part: " + l.part : ""} ${this.id === ee.MAIN ? "level" : "track"}: ${l.level} id: ${l.id}
        discontinuity: ${y}
        trackSwitch: ${b}
        contiguous: ${T}
        accurateTimeOffset: ${c}
        timeOffset: ${m}
        initSegmentChange: ${L}`);
      const R = new $V(n, i, t, o, u);
      this.configureTransmuxer(R);
    }
    if (this.frag = s, this.part = a, this.workerContext)
      this.workerContext.worker.postMessage({
        instanceNo: h,
        cmd: "demux",
        data: e,
        decryptdata: p,
        chunkMeta: l,
        state: _
      }, e instanceof ArrayBuffer ? [e] : []);
    else if (g) {
      const R = g.push(e, p, l, _);
      sa(R) ? R.then((D) => {
        this.handleTransmuxComplete(D);
      }).catch((D) => {
        this.transmuxerError(D, l, "transmuxer-interface push error");
      }) : this.handleTransmuxComplete(R);
    }
  }
  flush(e) {
    e.transmuxing.start = self.performance.now();
    const {
      instanceNo: t,
      transmuxer: n
    } = this;
    if (this.workerContext)
      this.workerContext.worker.postMessage({
        instanceNo: t,
        cmd: "flush",
        chunkMeta: e
      });
    else if (n) {
      const i = n.flush(e);
      sa(i) ? i.then((s) => {
        this.handleFlushResult(s, e);
      }).catch((s) => {
        this.transmuxerError(s, e, "transmuxer-interface flush error");
      }) : this.handleFlushResult(i, e);
    }
  }
  transmuxerError(e, t, n) {
    this.hls && (this.error = e, this.hls.trigger(E.ERROR, {
      type: ne.MEDIA_ERROR,
      details: k.FRAG_PARSING_ERROR,
      chunkMeta: t,
      frag: this.frag || void 0,
      part: this.part || void 0,
      fatal: !1,
      error: e,
      err: e,
      reason: n
    }));
  }
  handleFlushResult(e, t) {
    e.forEach((n) => {
      this.handleTransmuxComplete(n);
    }), this.onFlush(t);
  }
  configureTransmuxer(e) {
    const {
      instanceNo: t,
      transmuxer: n
    } = this;
    this.workerContext ? this.workerContext.worker.postMessage({
      instanceNo: t,
      cmd: "configure",
      config: e
    }) : n && n.configure(e);
  }
  handleTransmuxComplete(e) {
    e.chunkMeta.transmuxing.end = self.performance.now(), this.onTransmuxComplete(e);
  }
}
const xb = 100;
class jV extends zg {
  constructor(e, t, n) {
    super(e, t, n, "audio-stream-controller", ee.AUDIO), this.mainAnchor = null, this.mainFragLoading = null, this.audioOnly = !1, this.bufferedTrack = null, this.switchingTrack = null, this.trackId = -1, this.waitingData = null, this.mainDetails = null, this.flushing = !1, this.bufferFlushed = !1, this.cachedTrackLoadedData = null, this.registerListeners();
  }
  onHandlerDestroying() {
    this.unregisterListeners(), super.onHandlerDestroying(), this.resetItem();
  }
  resetItem() {
    this.mainDetails = this.mainAnchor = this.mainFragLoading = this.bufferedTrack = this.switchingTrack = this.waitingData = this.cachedTrackLoadedData = null;
  }
  registerListeners() {
    super.registerListeners();
    const {
      hls: e
    } = this;
    e.on(E.LEVEL_LOADED, this.onLevelLoaded, this), e.on(E.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), e.on(E.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on(E.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.on(E.BUFFER_RESET, this.onBufferReset, this), e.on(E.BUFFER_CREATED, this.onBufferCreated, this), e.on(E.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(E.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on(E.INIT_PTS_FOUND, this.onInitPtsFound, this), e.on(E.FRAG_LOADING, this.onFragLoading, this), e.on(E.FRAG_BUFFERED, this.onFragBuffered, this);
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e && (super.unregisterListeners(), e.off(E.LEVEL_LOADED, this.onLevelLoaded, this), e.off(E.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), e.off(E.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off(E.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.off(E.BUFFER_RESET, this.onBufferReset, this), e.off(E.BUFFER_CREATED, this.onBufferCreated, this), e.off(E.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(E.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off(E.INIT_PTS_FOUND, this.onInitPtsFound, this), e.off(E.FRAG_LOADING, this.onFragLoading, this), e.off(E.FRAG_BUFFERED, this.onFragBuffered, this));
  }
  // INIT_PTS_FOUND is triggered when the video track parsed in the stream-controller has a new PTS value
  onInitPtsFound(e, {
    frag: t,
    id: n,
    initPTS: i,
    timescale: s
  }) {
    if (n === ee.MAIN) {
      const a = t.cc, o = this.fragCurrent;
      if (this.initPTS[a] = {
        baseTime: i,
        timescale: s
      }, this.log(`InitPTS for cc: ${a} found from main: ${i}/${s}`), this.mainAnchor = t, this.state === $.WAITING_INIT_PTS) {
        const c = this.waitingData;
        (!c && !this.loadingParts || c && c.frag.cc !== a) && this.syncWithAnchor(t, c == null ? void 0 : c.frag);
      } else !this.hls.hasEnoughToStart && o && o.cc !== a ? (o.abortRequests(), this.syncWithAnchor(t, o)) : this.state === $.IDLE && this.tick();
    }
  }
  getLoadPosition() {
    return !this.startFragRequested && this.nextLoadPosition >= 0 ? this.nextLoadPosition : super.getLoadPosition();
  }
  syncWithAnchor(e, t) {
    var n;
    const i = ((n = this.mainFragLoading) == null ? void 0 : n.frag) || null;
    if (t && (i == null ? void 0 : i.cc) === t.cc)
      return;
    const s = (i || e).cc, a = this.getLevelDetails(), o = this.getLoadPosition(), c = QA(a, s, o);
    c && (this.log(`Syncing with main frag at ${c.start} cc ${c.cc}`), this.startFragRequested = !1, this.nextLoadPosition = c.start, this.resetLoadingState(), this.state === $.IDLE && this.doTickIdle());
  }
  startLoad(e, t) {
    if (!this.levels) {
      this.startPosition = e, this.state = $.STOPPED;
      return;
    }
    const n = this.lastCurrentTime;
    this.stopLoad(), this.setInterval(xb), n > 0 && e === -1 ? (this.log(`Override startPosition with lastCurrentTime @${n.toFixed(3)}`), e = n, this.state = $.IDLE) : this.state = $.WAITING_TRACK, this.nextLoadPosition = this.lastCurrentTime = e + this.timelineOffset, this.startPosition = t ? -1 : e, this.tick();
  }
  doTick() {
    switch (this.state) {
      case $.IDLE:
        this.doTickIdle();
        break;
      case $.WAITING_TRACK: {
        const {
          levels: t,
          trackId: n
        } = this, i = t == null ? void 0 : t[n], s = i == null ? void 0 : i.details;
        if (s && !this.waitForLive(i)) {
          if (this.waitForCdnTuneIn(s))
            break;
          this.state = $.WAITING_INIT_PTS;
        }
        break;
      }
      case $.FRAG_LOADING_WAITING_RETRY: {
        var e;
        const t = performance.now(), n = this.retryDate;
        if (!n || t >= n || (e = this.media) != null && e.seeking) {
          const {
            levels: i,
            trackId: s
          } = this;
          this.log("RetryDate reached, switch back to IDLE state"), this.resetStartWhenNotLoaded((i == null ? void 0 : i[s]) || null), this.state = $.IDLE;
        }
        break;
      }
      case $.WAITING_INIT_PTS: {
        const t = this.waitingData;
        if (t) {
          const {
            frag: n,
            part: i,
            cache: s,
            complete: a
          } = t, o = this.mainAnchor;
          if (this.initPTS[n.cc] !== void 0) {
            this.waitingData = null, this.state = $.FRAG_LOADING;
            const c = s.flush().buffer, l = {
              frag: n,
              part: i,
              payload: c,
              networkDetails: null
            };
            this._handleFragmentLoadProgress(l), a && super._handleFragmentLoadComplete(l);
          } else o && o.cc !== t.frag.cc && this.syncWithAnchor(o, t.frag);
        } else
          this.state = $.IDLE;
      }
    }
    this.onTickEnd();
  }
  resetLoadingState() {
    const e = this.waitingData;
    e && (this.fragmentTracker.removeFragment(e.frag), this.waitingData = null), super.resetLoadingState();
  }
  onTickEnd() {
    const {
      media: e
    } = this;
    e != null && e.readyState && (this.lastCurrentTime = e.currentTime);
  }
  doTickIdle() {
    var e;
    const {
      hls: t,
      levels: n,
      media: i,
      trackId: s
    } = this, a = t.config;
    if (!this.buffering || !i && !this.primaryPrefetch && (this.startFragRequested || !a.startFragPrefetch) || !(n != null && n[s]))
      return;
    const o = n[s], c = o.details;
    if (!c || this.waitForLive(o) || this.waitForCdnTuneIn(c)) {
      this.state = $.WAITING_TRACK, this.startFragRequested = !1;
      return;
    }
    const l = this.mediaBuffer ? this.mediaBuffer : this.media;
    this.bufferFlushed && l && (this.bufferFlushed = !1, this.afterBufferFlushed(l, je.AUDIO, ee.AUDIO));
    const u = this.getFwdBufferInfo(l, ee.AUDIO);
    if (u === null)
      return;
    if (!this.switchingTrack && this._streamEnded(u, c)) {
      t.trigger(E.BUFFER_EOS, {
        type: "audio"
      }), this.state = $.ENDED;
      return;
    }
    const d = u.len, f = t.maxBufferLength, h = c.fragments, g = h[0].start, m = this.getLoadPosition(), p = this.flushing ? m : u.end;
    if (this.switchingTrack && i) {
      const b = m;
      c.PTSKnown && b < g && (u.end > g || u.nextStart) && (this.log("Alt audio track ahead of main track, seek to start of alt audio track"), i.currentTime = g + 0.05);
    }
    if (d >= f && !this.switchingTrack && p < h[h.length - 1].start)
      return;
    let v = this.getNextFragment(p, c);
    if (v && this.isLoopLoading(v, p) && (v = this.getNextFragmentLoopLoading(v, c, u, ee.MAIN, f)), !v) {
      this.bufferFlushed = !0;
      return;
    }
    let y = ((e = this.mainFragLoading) == null ? void 0 : e.frag) || null;
    if (!this.audioOnly && this.startFragRequested && y && it(v) && !v.endList && (!c.live || !this.loadingParts && p < this.hls.liveSyncPosition) && (this.fragmentTracker.getState(y) === ct.OK && (this.mainFragLoading = y = null), y && it(y))) {
      if (v.start > y.end) {
        const x = this.fragmentTracker.getFragAtPos(p, ee.MAIN);
        x && x.end > y.end && (y = x, this.mainFragLoading = {
          frag: x,
          targetBufferTime: null
        });
      }
      if (v.start > y.end)
        return;
    }
    this.loadFragment(v, o, p);
  }
  onMediaDetaching(e, t) {
    this.bufferFlushed = this.flushing = !1, super.onMediaDetaching(e, t);
  }
  onAudioTracksUpdated(e, {
    audioTracks: t
  }) {
    this.resetTransmuxer(), this.levels = t.map((n) => new ta(n));
  }
  onAudioTrackSwitching(e, t) {
    const n = !!t.url;
    this.trackId = t.id;
    const {
      fragCurrent: i
    } = this;
    i && (i.abortRequests(), this.removeUnbufferedFrags(i.start)), this.resetLoadingState(), n ? (this.switchingTrack = t, this.flushAudioIfNeeded(t), this.state !== $.STOPPED && (this.setInterval(xb), this.state = $.IDLE, this.tick())) : (this.resetTransmuxer(), this.switchingTrack = null, this.bufferedTrack = t, this.clearInterval());
  }
  onManifestLoading() {
    super.onManifestLoading(), this.bufferFlushed = this.flushing = this.audioOnly = !1, this.resetItem(), this.trackId = -1;
  }
  onLevelLoaded(e, t) {
    this.mainDetails = t.details;
    const n = this.cachedTrackLoadedData;
    n && (this.cachedTrackLoadedData = null, this.onAudioTrackLoaded(E.AUDIO_TRACK_LOADED, n));
  }
  onAudioTrackLoaded(e, t) {
    var n;
    const {
      levels: i
    } = this, {
      details: s,
      id: a,
      groupId: o,
      track: c
    } = t;
    if (!i) {
      this.warn(`Audio tracks reset while loading track ${a} "${c.name}" of "${o}"`);
      return;
    }
    const l = this.mainDetails;
    if (!l || s.endCC > l.endCC || l.expired) {
      this.cachedTrackLoadedData = t, this.state !== $.STOPPED && (this.state = $.WAITING_TRACK);
      return;
    }
    this.cachedTrackLoadedData = null, this.log(`Audio track ${a} "${c.name}" of "${o}" loaded [${s.startSN},${s.endSN}]${s.lastPartSn ? `[part-${s.lastPartSn}-${s.lastPartIndex}]` : ""},duration:${s.totalduration}`);
    const u = i[a];
    let d = 0;
    if (s.live || (n = u.details) != null && n.live) {
      if (this.checkLiveUpdate(s), s.deltaUpdateFailed)
        return;
      if (u.details) {
        var f;
        d = this.alignPlaylists(s, u.details, (f = this.levelLastLoaded) == null ? void 0 : f.details);
      }
      s.alignedSliding || (dw(s, l), s.alignedSliding || fl(s, l), d = s.fragmentStart);
    }
    u.details = s, this.levelLastLoaded = u, this.startFragRequested || this.setStartPosition(l, d), this.hls.trigger(E.AUDIO_TRACK_UPDATED, {
      details: s,
      id: a,
      groupId: t.groupId
    }), this.state === $.WAITING_TRACK && !this.waitForCdnTuneIn(s) && (this.state = $.IDLE), this.tick();
  }
  _handleFragmentLoadProgress(e) {
    var t;
    const n = e.frag, {
      part: i,
      payload: s
    } = e, {
      config: a,
      trackId: o,
      levels: c
    } = this;
    if (!c) {
      this.warn(`Audio tracks were reset while fragment load was in progress. Fragment ${n.sn} of level ${n.level} will not be buffered`);
      return;
    }
    const l = c[o];
    if (!l) {
      this.warn("Audio track is undefined on fragment load progress");
      return;
    }
    const u = l.details;
    if (!u) {
      this.warn("Audio track details undefined on fragment load progress"), this.removeUnbufferedFrags(n.start);
      return;
    }
    const d = a.defaultAudioCodec || l.audioCodec || "mp4a.40.2";
    let f = this.transmuxer;
    f || (f = this.transmuxer = new Rw(this.hls, ee.AUDIO, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)));
    const h = this.initPTS[n.cc], g = (t = n.initSegment) == null ? void 0 : t.data;
    if (h !== void 0) {
      const p = i ? i.index : -1, v = p !== -1, y = new Hg(n.level, n.sn, n.stats.chunkCount, s.byteLength, p, v);
      f.push(s, g, d, "", n, i, u.totalduration, !1, y, h);
    } else {
      this.log(`Unknown video PTS for cc ${n.cc}, waiting for video PTS before demuxing audio frag ${n.sn} of [${u.startSN} ,${u.endSN}],track ${o}`);
      const {
        cache: m
      } = this.waitingData = this.waitingData || {
        frag: n,
        part: i,
        cache: new fw(),
        complete: !1
      };
      m.push(new Uint8Array(s)), this.state !== $.STOPPED && (this.state = $.WAITING_INIT_PTS);
    }
  }
  _handleFragmentLoadComplete(e) {
    if (this.waitingData) {
      this.waitingData.complete = !0;
      return;
    }
    super._handleFragmentLoadComplete(e);
  }
  onBufferReset() {
    this.mediaBuffer = null;
  }
  onBufferCreated(e, t) {
    this.bufferFlushed = this.flushing = !1;
    const n = t.tracks.audio;
    n && (this.mediaBuffer = n.buffer || null);
  }
  onFragLoading(e, t) {
    !this.audioOnly && t.frag.type === ee.MAIN && it(t.frag) && (this.mainFragLoading = t, this.state === $.IDLE && this.tick());
  }
  onFragBuffered(e, t) {
    const {
      frag: n,
      part: i
    } = t;
    if (n.type !== ee.AUDIO) {
      !this.audioOnly && n.type === ee.MAIN && !n.elementaryStreams.video && !n.elementaryStreams.audiovideo && (this.audioOnly = !0, this.mainFragLoading = null);
      return;
    }
    if (this.fragContextChanged(n)) {
      this.warn(`Fragment ${n.sn}${i ? " p: " + i.index : ""} of level ${n.level} finished buffering, but was aborted. state: ${this.state}, audioSwitch: ${this.switchingTrack ? this.switchingTrack.name : "false"}`);
      return;
    }
    if (it(n)) {
      this.fragPrevious = n;
      const s = this.switchingTrack;
      s && (this.bufferedTrack = s, this.switchingTrack = null, this.hls.trigger(E.AUDIO_TRACK_SWITCHED, Ne({}, s)));
    }
    this.fragBufferedComplete(n, i), this.media && this.tick();
  }
  onError(e, t) {
    var n;
    if (t.fatal) {
      this.state = $.ERROR;
      return;
    }
    switch (t.details) {
      case k.FRAG_GAP:
      case k.FRAG_PARSING_ERROR:
      case k.FRAG_DECRYPT_ERROR:
      case k.FRAG_LOAD_ERROR:
      case k.FRAG_LOAD_TIMEOUT:
      case k.KEY_LOAD_ERROR:
      case k.KEY_LOAD_TIMEOUT:
        this.onFragmentOrKeyLoadError(ee.AUDIO, t);
        break;
      case k.AUDIO_TRACK_LOAD_ERROR:
      case k.AUDIO_TRACK_LOAD_TIMEOUT:
      case k.LEVEL_PARSING_ERROR:
        !t.levelRetry && this.state === $.WAITING_TRACK && ((n = t.context) == null ? void 0 : n.type) === me.AUDIO_TRACK && (this.state = $.IDLE);
        break;
      case k.BUFFER_ADD_CODEC_ERROR:
      case k.BUFFER_APPEND_ERROR:
        if (t.parent !== "audio")
          return;
        this.reduceLengthAndFlushBuffer(t) || this.resetLoadingState();
        break;
      case k.BUFFER_FULL_ERROR:
        if (t.parent !== "audio")
          return;
        this.reduceLengthAndFlushBuffer(t) && (this.bufferedTrack = null, super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio"));
        break;
      case k.INTERNAL_EXCEPTION:
        this.recoverWorkerError(t);
        break;
    }
  }
  onBufferFlushing(e, {
    type: t
  }) {
    t !== je.VIDEO && (this.flushing = !0);
  }
  onBufferFlushed(e, {
    type: t
  }) {
    if (t !== je.VIDEO) {
      this.flushing = !1, this.bufferFlushed = !0, this.state === $.ENDED && (this.state = $.IDLE);
      const n = this.mediaBuffer || this.media;
      n && (this.afterBufferFlushed(n, t, ee.AUDIO), this.tick());
    }
  }
  _handleTransmuxComplete(e) {
    var t;
    const n = "audio", {
      hls: i
    } = this, {
      remuxResult: s,
      chunkMeta: a
    } = e, o = this.getCurrentContext(a);
    if (!o) {
      this.resetWhenMissingContext(a);
      return;
    }
    const {
      frag: c,
      part: l,
      level: u
    } = o, {
      details: d
    } = u, {
      audio: f,
      text: h,
      id3: g,
      initSegment: m
    } = s;
    if (this.fragContextChanged(c) || !d) {
      this.fragmentTracker.removeFragment(c);
      return;
    }
    if (this.state = $.PARSING, this.switchingTrack && f && this.completeAudioSwitch(this.switchingTrack), m != null && m.tracks) {
      const p = c.initSegment || c;
      this._bufferInitSegment(u, m.tracks, p, a), i.trigger(E.FRAG_PARSING_INIT_SEGMENT, {
        frag: p,
        id: n,
        tracks: m.tracks
      });
    }
    if (f) {
      const {
        startPTS: p,
        endPTS: v,
        startDTS: y,
        endDTS: b
      } = f;
      l && (l.elementaryStreams[je.AUDIO] = {
        startPTS: p,
        endPTS: v,
        startDTS: y,
        endDTS: b
      }), c.setElementaryStreamInfo(je.AUDIO, p, v, y, b), this.bufferFragmentData(f, c, l, a);
    }
    if (g != null && (t = g.samples) != null && t.length) {
      const p = Ce({
        id: n,
        frag: c,
        details: d
      }, g);
      i.trigger(E.FRAG_PARSING_METADATA, p);
    }
    if (h) {
      const p = Ce({
        id: n,
        frag: c,
        details: d
      }, h);
      i.trigger(E.FRAG_PARSING_USERDATA, p);
    }
  }
  _bufferInitSegment(e, t, n, i) {
    if (this.state !== $.PARSING || (t.video && delete t.video, t.audiovideo && delete t.audiovideo, !t.audio))
      return;
    const s = t.audio;
    s.id = ee.AUDIO;
    const a = e.audioCodec;
    this.log(`Init audio buffer, container:${s.container}, codecs[level/parsed]=[${a}/${s.codec}]`), a && a.split(",").length === 1 && (s.levelCodec = a), this.hls.trigger(E.BUFFER_CODECS, t);
    const o = s.initSegment;
    if (o != null && o.byteLength) {
      const c = {
        type: "audio",
        frag: n,
        part: null,
        chunkMeta: i,
        parent: n.type,
        data: o
      };
      this.hls.trigger(E.BUFFER_APPENDING, c);
    }
    this.tickImmediate();
  }
  loadFragment(e, t, n) {
    const i = this.fragmentTracker.getState(e);
    if (this.switchingTrack || i === ct.NOT_LOADED || i === ct.PARTIAL) {
      var s;
      if (!it(e))
        this._loadInitSegment(e, t);
      else if ((s = t.details) != null && s.live && !this.initPTS[e.cc]) {
        this.log(`Waiting for video PTS in continuity counter ${e.cc} of live stream before loading audio fragment ${e.sn} of level ${this.trackId}`), this.state = $.WAITING_INIT_PTS;
        const a = this.mainDetails;
        a && a.fragmentStart !== t.details.fragmentStart && fl(t.details, a);
      } else
        super.loadFragment(e, t, n);
    } else
      this.clearTrackerIfNeeded(e);
  }
  flushAudioIfNeeded(e) {
    if (this.media && this.bufferedTrack) {
      const {
        name: t,
        lang: n,
        assocLang: i,
        characteristics: s,
        audioCodec: a,
        channels: o
      } = this.bufferedTrack;
      ci({
        name: t,
        lang: n,
        assocLang: i,
        characteristics: s,
        audioCodec: a,
        channels: o
      }, e, Yn) || (ll(e.url, this.hls) ? (this.log("Switching audio track : flushing all audio"), super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio"), this.bufferedTrack = null) : this.bufferedTrack = e);
    }
  }
  completeAudioSwitch(e) {
    const {
      hls: t
    } = this;
    this.flushAudioIfNeeded(e), this.bufferedTrack = e, this.switchingTrack = null, t.trigger(E.AUDIO_TRACK_SWITCHED, Ne({}, e));
  }
}
class rm extends Or {
  constructor(e, t) {
    super(t, e.logger), this.hls = void 0, this.canLoad = !1, this.timer = -1, this.hls = e;
  }
  destroy() {
    this.clearTimer(), this.hls = this.log = this.warn = null;
  }
  clearTimer() {
    this.timer !== -1 && (self.clearTimeout(this.timer), this.timer = -1);
  }
  startLoad() {
    this.canLoad = !0, this.loadPlaylist();
  }
  stopLoad() {
    this.canLoad = !1, this.clearTimer();
  }
  switchParams(e, t, n) {
    const i = t == null ? void 0 : t.renditionReports;
    if (i) {
      let s = -1;
      for (let a = 0; a < i.length; a++) {
        const o = i[a];
        let c;
        try {
          c = new self.URL(o.URI, t.url).href;
        } catch (l) {
          this.warn(`Could not construct new URL for Rendition Report: ${l}`), c = o.URI || "";
        }
        if (c === e) {
          s = a;
          break;
        } else c === e.substring(0, c.length) && (s = a);
      }
      if (s !== -1) {
        const a = i[s], o = parseInt(a["LAST-MSN"]) || (t == null ? void 0 : t.lastPartSn);
        let c = parseInt(a["LAST-PART"]) || (t == null ? void 0 : t.lastPartIndex);
        if (this.hls.config.lowLatencyMode) {
          const u = Math.min(t.age - t.partTarget, t.targetduration);
          c >= 0 && u > t.partTarget && (c += 1);
        }
        const l = n && Ny(n);
        return new Fy(o, c >= 0 ? c : void 0, l);
      }
    }
  }
  loadPlaylist(e) {
    this.clearTimer();
  }
  loadingPlaylist(e, t) {
    this.clearTimer();
  }
  shouldLoadPlaylist(e) {
    return this.canLoad && !!e && !!e.url && (!e.details || e.details.live);
  }
  getUrlWithDirectives(e, t) {
    if (t)
      try {
        return t.addDirectives(e);
      } catch (n) {
        this.warn(`Could not construct new URL with HLS Delivery Directives: ${n}`);
      }
    return e;
  }
  playlistLoaded(e, t, n) {
    const {
      details: i,
      stats: s
    } = t, a = self.performance.now(), o = s.loading.first ? Math.max(0, a - s.loading.first) : 0;
    i.advancedDateTime = Date.now() - o;
    const c = this.hls.config.timelineOffset;
    if (c !== i.appliedTimelineOffset) {
      const u = Math.max(c || 0, 0);
      i.appliedTimelineOffset = u, i.fragments.forEach((d) => {
        d.start = d.playlistOffset + u;
      });
    }
    if (i.live || n != null && n.live) {
      const u = "levelInfo" in t ? t.levelInfo : t.track;
      if (i.reloaded(n), n && i.fragments.length > 0) {
        M3(n, i);
        const y = i.playlistParsingError;
        if (y) {
          this.warn(y);
          const b = this.hls;
          if (!b.config.ignorePlaylistParsingErrors) {
            var l;
            const {
              networkDetails: x
            } = t;
            b.trigger(E.ERROR, {
              type: ne.NETWORK_ERROR,
              details: k.LEVEL_PARSING_ERROR,
              fatal: !1,
              url: i.url,
              error: y,
              reason: y.message,
              level: t.level || void 0,
              parent: (l = i.fragments[0]) == null ? void 0 : l.type,
              networkDetails: x,
              stats: s
            });
            return;
          }
          i.playlistParsingError = null;
        }
      }
      i.requestScheduled === -1 && (i.requestScheduled = s.loading.start);
      const d = this.hls.mainForwardBufferInfo, f = d ? d.end - d.len : 0, h = (i.edge - f) * 1e3, g = aw(i, h);
      if (i.requestScheduled + g < a ? i.requestScheduled = a : i.requestScheduled += g, this.log(`live playlist ${e} ${i.advanced ? "REFRESHED " + i.lastPartSn + "-" + i.lastPartIndex : i.updated ? "UPDATED" : "MISSED"}`), !this.canLoad || !i.live)
        return;
      let m, p, v;
      if (i.canBlockReload && i.endSN && i.advanced) {
        const y = this.hls.config.lowLatencyMode, b = i.lastPartSn, x = i.endSN, S = i.lastPartIndex, A = S !== -1, T = b === x;
        A ? T ? (p = x + 1, v = y ? 0 : S) : (p = b, v = y ? S + 1 : i.maxPartIndex) : p = x + 1;
        const I = i.age, L = I + i.ageHeader;
        let _ = Math.min(L - i.partTarget, i.targetduration * 1.5);
        if (_ > 0) {
          if (L > i.targetduration * 3)
            this.log(`Playlist last advanced ${I.toFixed(2)}s ago. Omitting segment and part directives.`), p = void 0, v = void 0;
          else if (n != null && n.tuneInGoal && L - i.partTarget > n.tuneInGoal)
            this.warn(`CDN Tune-in goal increased from: ${n.tuneInGoal} to: ${_} with playlist age: ${i.age}`), _ = 0;
          else {
            const R = Math.floor(_ / i.targetduration);
            if (p += R, v !== void 0) {
              const D = Math.round(_ % i.targetduration / i.partTarget);
              v += D;
            }
            this.log(`CDN Tune-in age: ${i.ageHeader}s last advanced ${I.toFixed(2)}s goal: ${_} skip sn ${R} to part ${v}`);
          }
          i.tuneInGoal = _;
        }
        if (m = this.getDeliveryDirectives(i, t.deliveryDirectives, p, v), y || !T) {
          i.requestScheduled = a, this.loadingPlaylist(u, m);
          return;
        }
      } else (i.canBlockReload || i.canSkipUntil) && (m = this.getDeliveryDirectives(i, t.deliveryDirectives, p, v));
      m && p !== void 0 && i.canBlockReload && (i.requestScheduled = s.loading.first + Math.max(g - o * 2, g / 2)), this.scheduleLoading(u, m, i);
    } else
      this.clearTimer();
  }
  scheduleLoading(e, t, n) {
    const i = n || e.details;
    if (!i) {
      this.loadingPlaylist(e, t);
      return;
    }
    const s = self.performance.now(), a = i.requestScheduled;
    if (s >= a) {
      this.loadingPlaylist(e, t);
      return;
    }
    const o = a - s;
    this.log(`reload live playlist ${e.name || e.bitrate + "bps"} in ${Math.round(o)} ms`), this.clearTimer(), this.timer = self.setTimeout(() => this.loadingPlaylist(e, t), o);
  }
  getDeliveryDirectives(e, t, n, i) {
    let s = Ny(e);
    return t != null && t.skip && e.deltaUpdateFailed && (n = t.msn, i = t.part, s = vo.No), new Fy(n, i, s);
  }
  checkRetry(e) {
    const t = e.details, n = cl(e), i = e.errorAction, {
      action: s,
      retryCount: a = 0,
      retryConfig: o
    } = i || {}, c = !!i && !!o && (s === Pt.RetryRequest || !i.resolved && s === Pt.SendAlternateToPenaltyBox);
    if (c) {
      var l;
      if (a >= o.maxNumRetry)
        return !1;
      if (n && (l = e.context) != null && l.deliveryDirectives)
        this.warn(`Retrying playlist loading ${a + 1}/${o.maxNumRetry} after "${t}" without delivery-directives`), this.loadPlaylist();
      else {
        const u = Vg(o, a);
        this.clearTimer(), this.timer = self.setTimeout(() => this.loadPlaylist(), u), this.warn(`Retrying playlist loading ${a + 1}/${o.maxNumRetry} after "${t}" in ${u}ms`);
      }
      e.levelRetry = !0, i.resolved = !0;
    }
    return c;
  }
}
function Dw(r, e) {
  if (r.length !== e.length)
    return !1;
  for (let t = 0; t < r.length; t++)
    if (!aa(r[t].attrs, e[t].attrs))
      return !1;
  return !0;
}
function aa(r, e, t) {
  const n = r["STABLE-RENDITION-ID"];
  return n && !t ? n === e["STABLE-RENDITION-ID"] : !(t || ["LANGUAGE", "NAME", "CHARACTERISTICS", "AUTOSELECT", "DEFAULT", "FORCED", "ASSOC-LANGUAGE"]).some((i) => r[i] !== e[i]);
}
function If(r, e) {
  return e.label.toLowerCase() === r.name.toLowerCase() && (!e.language || e.language.toLowerCase() === (r.lang || "").toLowerCase());
}
class UV extends rm {
  constructor(e) {
    super(e, "audio-track-controller"), this.tracks = [], this.groupIds = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0, this.registerListeners();
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e.on(E.MANIFEST_LOADING, this.onManifestLoading, this), e.on(E.MANIFEST_PARSED, this.onManifestParsed, this), e.on(E.LEVEL_LOADING, this.onLevelLoading, this), e.on(E.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(E.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.on(E.ERROR, this.onError, this);
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off(E.MANIFEST_LOADING, this.onManifestLoading, this), e.off(E.MANIFEST_PARSED, this.onManifestParsed, this), e.off(E.LEVEL_LOADING, this.onLevelLoading, this), e.off(E.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(E.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.off(E.ERROR, this.onError, this);
  }
  destroy() {
    this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, this.currentTrack = null, super.destroy();
  }
  onManifestLoading() {
    this.tracks = [], this.tracksInGroup = [], this.groupIds = null, this.currentTrack = null, this.trackId = -1, this.selectDefaultTrack = !0;
  }
  onManifestParsed(e, t) {
    this.tracks = t.audioTracks || [];
  }
  onAudioTrackLoaded(e, t) {
    const {
      id: n,
      groupId: i,
      details: s
    } = t, a = this.tracksInGroup[n];
    if (!a || a.groupId !== i) {
      this.warn(`Audio track with id:${n} and group:${i} not found in active group ${a == null ? void 0 : a.groupId}`);
      return;
    }
    const o = a.details;
    a.details = t.details, this.log(`Audio track ${n} "${a.name}" lang:${a.lang} group:${i} loaded [${s.startSN}-${s.endSN}]`), n === this.trackId && this.playlistLoaded(n, t, o);
  }
  onLevelLoading(e, t) {
    this.switchLevel(t.level);
  }
  onLevelSwitching(e, t) {
    this.switchLevel(t.level);
  }
  switchLevel(e) {
    const t = this.hls.levels[e];
    if (!t)
      return;
    const n = t.audioGroups || null, i = this.groupIds;
    let s = this.currentTrack;
    if (!n || (i == null ? void 0 : i.length) !== (n == null ? void 0 : n.length) || n != null && n.some((o) => (i == null ? void 0 : i.indexOf(o)) === -1)) {
      this.groupIds = n, this.trackId = -1, this.currentTrack = null;
      const o = this.tracks.filter((f) => !n || n.indexOf(f.groupId) !== -1);
      if (o.length)
        this.selectDefaultTrack && !o.some((f) => f.default) && (this.selectDefaultTrack = !1), o.forEach((f, h) => {
          f.id = h;
        });
      else if (!s && !this.tracksInGroup.length)
        return;
      this.tracksInGroup = o;
      const c = this.hls.config.audioPreference;
      if (!s && c) {
        const f = Mr(c, o, Yn);
        if (f > -1)
          s = o[f];
        else {
          const h = Mr(c, this.tracks);
          s = this.tracks[h];
        }
      }
      let l = this.findTrackId(s);
      l === -1 && s && (l = this.findTrackId(null));
      const u = {
        audioTracks: o
      };
      this.log(`Updating audio tracks, ${o.length} track(s) found in group(s): ${n == null ? void 0 : n.join(",")}`), this.hls.trigger(E.AUDIO_TRACKS_UPDATED, u);
      const d = this.trackId;
      if (l !== -1 && d === -1)
        this.setAudioTrack(l);
      else if (o.length && d === -1) {
        var a;
        const f = new Error(`No audio track selected for current audio group-ID(s): ${(a = this.groupIds) == null ? void 0 : a.join(",")} track count: ${o.length}`);
        this.warn(f.message), this.hls.trigger(E.ERROR, {
          type: ne.MEDIA_ERROR,
          details: k.AUDIO_TRACK_LOAD_ERROR,
          fatal: !0,
          error: f
        });
      }
    }
  }
  onError(e, t) {
    t.fatal || !t.context || t.context.type === me.AUDIO_TRACK && t.context.id === this.trackId && (!this.groupIds || this.groupIds.indexOf(t.context.groupId) !== -1) && this.checkRetry(t);
  }
  get allAudioTracks() {
    return this.tracks;
  }
  get audioTracks() {
    return this.tracksInGroup;
  }
  get audioTrack() {
    return this.trackId;
  }
  set audioTrack(e) {
    this.selectDefaultTrack = !1, this.setAudioTrack(e);
  }
  setAudioOption(e) {
    const t = this.hls;
    if (t.config.audioPreference = e, e) {
      const n = this.allAudioTracks;
      if (this.selectDefaultTrack = !1, n.length) {
        const i = this.currentTrack;
        if (i && ci(e, i, Yn))
          return i;
        const s = Mr(e, this.tracksInGroup, Yn);
        if (s > -1) {
          const a = this.tracksInGroup[s];
          return this.setAudioTrack(s), a;
        } else if (i) {
          let a = t.loadLevel;
          a === -1 && (a = t.firstAutoLevel);
          const o = e3(e, t.levels, n, a, Yn);
          if (o === -1)
            return null;
          t.nextLoadLevel = o;
        }
        if (e.channels || e.audioCodec) {
          const a = Mr(e, n);
          if (a > -1)
            return n[a];
        }
      }
    }
    return null;
  }
  setAudioTrack(e) {
    const t = this.tracksInGroup;
    if (e < 0 || e >= t.length) {
      this.warn(`Invalid audio track id: ${e}`);
      return;
    }
    this.selectDefaultTrack = !1;
    const n = this.currentTrack, i = t[e], s = i.details && !i.details.live;
    if (e === this.trackId && i === n && s || (this.log(`Switching to audio-track ${e} "${i.name}" lang:${i.lang} group:${i.groupId} channels:${i.channels}`), this.trackId = e, this.currentTrack = i, this.hls.trigger(E.AUDIO_TRACK_SWITCHING, Ne({}, i)), s))
      return;
    const a = this.switchParams(i.url, n == null ? void 0 : n.details, i.details);
    this.loadPlaylist(a);
  }
  findTrackId(e) {
    const t = this.tracksInGroup;
    for (let n = 0; n < t.length; n++) {
      const i = t[n];
      if (!(this.selectDefaultTrack && !i.default) && (!e || ci(e, i, Yn)))
        return n;
    }
    if (e) {
      const {
        name: n,
        lang: i,
        assocLang: s,
        characteristics: a,
        audioCodec: o,
        channels: c
      } = e;
      for (let l = 0; l < t.length; l++) {
        const u = t[l];
        if (ci({
          name: n,
          lang: i,
          assocLang: s,
          characteristics: a,
          audioCodec: o,
          channels: c
        }, u, Yn))
          return l;
      }
      for (let l = 0; l < t.length; l++) {
        const u = t[l];
        if (aa(e.attrs, u.attrs, ["LANGUAGE", "ASSOC-LANGUAGE", "CHARACTERISTICS"]))
          return l;
      }
      for (let l = 0; l < t.length; l++) {
        const u = t[l];
        if (aa(e.attrs, u.attrs, ["LANGUAGE"]))
          return l;
      }
    }
    return -1;
  }
  loadPlaylist(e) {
    super.loadPlaylist();
    const t = this.currentTrack;
    this.shouldLoadPlaylist(t) && ll(t.url, this.hls) && this.scheduleLoading(t, e);
  }
  loadingPlaylist(e, t) {
    super.loadingPlaylist(e, t);
    const n = e.id, i = e.groupId, s = this.getUrlWithDirectives(e.url, t), a = e.details, o = a == null ? void 0 : a.age;
    this.log(`Loading audio-track ${n} "${e.name}" lang:${e.lang} group:${i}${(t == null ? void 0 : t.msn) !== void 0 ? " at sn " + t.msn + " part " + t.part : ""}${o && a.live ? " age " + o.toFixed(1) + (a.type && " " + a.type || "") : ""} ${s}`), this.hls.trigger(E.AUDIO_TRACK_LOADING, {
      url: s,
      id: n,
      groupId: i,
      deliveryDirectives: t || null,
      track: e
    });
  }
}
class GV {
  constructor(e) {
    this.tracks = void 0, this.queues = {
      video: [],
      audio: [],
      audiovideo: []
    }, this.tracks = e;
  }
  destroy() {
    this.tracks = this.queues = null;
  }
  append(e, t, n) {
    if (this.queues === null || this.tracks === null)
      return;
    const i = this.queues[t];
    i.push(e), i.length === 1 && !n && this.executeNext(t);
  }
  appendBlocker(e) {
    return new Promise((t) => {
      const n = {
        label: "async-blocker",
        execute: t,
        onStart: () => {
        },
        onComplete: () => {
        },
        onError: () => {
        }
      };
      this.append(n, e);
    });
  }
  prependBlocker(e) {
    return new Promise((t) => {
      if (this.queues) {
        const n = {
          label: "async-blocker-prepend",
          execute: t,
          onStart: () => {
          },
          onComplete: () => {
          },
          onError: () => {
          }
        };
        this.queues[e].unshift(n);
      }
    });
  }
  removeBlockers() {
    this.queues !== null && [this.queues.video, this.queues.audio, this.queues.audiovideo].forEach((e) => {
      var t;
      const n = (t = e[0]) == null ? void 0 : t.label;
      (n === "async-blocker" || n === "async-blocker-prepend") && (e[0].execute(), e.splice(0, 1));
    });
  }
  unblockAudio(e) {
    if (this.queues === null)
      return;
    this.queues.audio[0] === e && this.shiftAndExecuteNext("audio");
  }
  executeNext(e) {
    if (this.queues === null || this.tracks === null)
      return;
    const t = this.queues[e];
    if (t.length) {
      const i = t[0];
      try {
        i.execute();
      } catch (s) {
        var n;
        if (i.onError(s), this.queues === null || this.tracks === null)
          return;
        const a = (n = this.tracks[e]) == null ? void 0 : n.buffer;
        a != null && a.updating || this.shiftAndExecuteNext(e);
      }
    }
  }
  shiftAndExecuteNext(e) {
    this.queues !== null && (this.queues[e].shift(), this.executeNext(e));
  }
  current(e) {
    var t;
    return ((t = this.queues) == null ? void 0 : t[e][0]) || null;
  }
  toString() {
    const {
      queues: e,
      tracks: t
    } = this;
    return e === null || t === null ? "<destroyed>" : `
${this.list("video")}
${this.list("audio")}
${this.list("audiovideo")}}`;
  }
  list(e) {
    var t, n;
    return (t = this.queues) != null && t[e] || (n = this.tracks) != null && n[e] ? `${e}: (${this.listSbInfo(e)}) ${this.listOps(e)}` : "";
  }
  listSbInfo(e) {
    var t;
    const n = (t = this.tracks) == null ? void 0 : t[e], i = n == null ? void 0 : n.buffer;
    return i ? `SourceBuffer${i.updating ? " updating" : ""}${n.ended ? " ended" : ""}${n.ending ? " ending" : ""}` : "none";
  }
  listOps(e) {
    var t;
    return ((t = this.queues) == null ? void 0 : t[e].map((n) => n.label).join(", ")) || "";
  }
}
const Eb = /(avc[1234]|hvc1|hev1|dvh[1e]|vp09|av01)(?:\.[^.,]+)+/, Cw = "HlsJsTrackRemovedError";
class KV extends Error {
  constructor(e) {
    super(e), this.name = Cw;
  }
}
class VV extends Or {
  constructor(e, t) {
    super("buffer-controller", e.logger), this.hls = void 0, this.fragmentTracker = void 0, this.details = null, this._objectUrl = null, this.operationQueue = null, this.bufferCodecEventsTotal = 0, this.media = null, this.mediaSource = null, this.lastMpegAudioChunk = null, this.blockedAudioAppend = null, this.lastVideoAppendEnd = 0, this.appendSource = void 0, this.transferData = void 0, this.overrides = void 0, this.appendErrors = {
      audio: 0,
      video: 0,
      audiovideo: 0
    }, this.tracks = {}, this.sourceBuffers = [[null, null], [null, null]], this._onEndStreaming = (n) => {
      var i;
      this.hls && ((i = this.mediaSource) == null ? void 0 : i.readyState) === "open" && this.hls.pauseBuffering();
    }, this._onStartStreaming = (n) => {
      this.hls && this.hls.resumeBuffering();
    }, this._onMediaSourceOpen = (n) => {
      const {
        media: i,
        mediaSource: s
      } = this;
      n && this.log("Media source opened"), !(!i || !s) && (s.removeEventListener("sourceopen", this._onMediaSourceOpen), i.removeEventListener("emptied", this._onMediaEmptied), this.updateDuration(), this.hls.trigger(E.MEDIA_ATTACHED, {
        media: i,
        mediaSource: s
      }), this.mediaSource !== null && this.checkPendingTracks());
    }, this._onMediaSourceClose = () => {
      this.log("Media source closed");
    }, this._onMediaSourceEnded = () => {
      this.log("Media source ended");
    }, this._onMediaEmptied = () => {
      const {
        mediaSrc: n,
        _objectUrl: i
      } = this;
      n !== i && this.error(`Media element src was set while attaching MediaSource (${i} > ${n})`);
    }, this.hls = e, this.fragmentTracker = t, this.appendSource = vK(Nn(e.config.preferManagedMediaSource)), this.initTracks(), this.registerListeners();
  }
  hasSourceTypes() {
    return Object.keys(this.tracks).length > 0;
  }
  destroy() {
    this.unregisterListeners(), this.details = null, this.lastMpegAudioChunk = this.blockedAudioAppend = null, this.transferData = this.overrides = void 0, this.operationQueue && (this.operationQueue.destroy(), this.operationQueue = null), this.hls = this.fragmentTracker = null, this._onMediaSourceOpen = this._onMediaSourceClose = null, this._onMediaSourceEnded = null, this._onStartStreaming = this._onEndStreaming = null;
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e.on(E.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(E.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(E.MANIFEST_LOADING, this.onManifestLoading, this), e.on(E.MANIFEST_PARSED, this.onManifestParsed, this), e.on(E.BUFFER_RESET, this.onBufferReset, this), e.on(E.BUFFER_APPENDING, this.onBufferAppending, this), e.on(E.BUFFER_CODECS, this.onBufferCodecs, this), e.on(E.BUFFER_EOS, this.onBufferEos, this), e.on(E.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(E.LEVEL_UPDATED, this.onLevelUpdated, this), e.on(E.FRAG_PARSED, this.onFragParsed, this), e.on(E.FRAG_CHANGED, this.onFragChanged, this), e.on(E.ERROR, this.onError, this);
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off(E.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(E.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(E.MANIFEST_LOADING, this.onManifestLoading, this), e.off(E.MANIFEST_PARSED, this.onManifestParsed, this), e.off(E.BUFFER_RESET, this.onBufferReset, this), e.off(E.BUFFER_APPENDING, this.onBufferAppending, this), e.off(E.BUFFER_CODECS, this.onBufferCodecs, this), e.off(E.BUFFER_EOS, this.onBufferEos, this), e.off(E.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(E.LEVEL_UPDATED, this.onLevelUpdated, this), e.off(E.FRAG_PARSED, this.onFragParsed, this), e.off(E.FRAG_CHANGED, this.onFragChanged, this), e.off(E.ERROR, this.onError, this);
  }
  transferMedia() {
    const {
      media: e,
      mediaSource: t
    } = this;
    if (!e)
      return null;
    const n = {};
    if (this.operationQueue) {
      const s = this.isUpdating();
      s || this.operationQueue.removeBlockers();
      const a = this.isQueued();
      (s || a) && this.warn(`Transfering MediaSource with${a ? " operations in queue" : ""}${s ? " updating SourceBuffer(s)" : ""} ${this.operationQueue}`), this.operationQueue.destroy();
    }
    const i = this.transferData;
    return !this.sourceBufferCount && i && i.mediaSource === t ? Ce(n, i.tracks) : this.sourceBuffers.forEach((s) => {
      const [a] = s;
      a && (n[a] = Ce({}, this.tracks[a]), this.removeBuffer(a)), s[0] = s[1] = null;
    }), {
      media: e,
      mediaSource: t,
      tracks: n
    };
  }
  initTracks() {
    const e = {};
    this.sourceBuffers = [[null, null], [null, null]], this.tracks = e, this.resetQueue(), this.resetAppendErrors(), this.lastMpegAudioChunk = this.blockedAudioAppend = null, this.lastVideoAppendEnd = 0;
  }
  onManifestLoading() {
    this.bufferCodecEventsTotal = 0, this.details = null;
  }
  onManifestParsed(e, t) {
    var n;
    let i = 2;
    (t.audio && !t.video || !t.altAudio) && (i = 1), this.bufferCodecEventsTotal = i, this.log(`${i} bufferCodec event(s) expected.`), (n = this.transferData) != null && n.mediaSource && this.sourceBufferCount && i && this.bufferCreated();
  }
  onMediaAttaching(e, t) {
    const n = this.media = t.media, i = Nn(this.appendSource);
    if (this.transferData = this.overrides = void 0, n && i) {
      const s = !!t.mediaSource;
      (s || t.overrides) && (this.transferData = t, this.overrides = t.overrides);
      const a = this.mediaSource = t.mediaSource || new i();
      if (this.assignMediaSource(a), s)
        this._objectUrl = n.src, this.attachTransferred();
      else {
        const o = this._objectUrl = self.URL.createObjectURL(a);
        if (this.appendSource)
          try {
            n.removeAttribute("src");
            const c = self.ManagedMediaSource;
            n.disableRemotePlayback = n.disableRemotePlayback || c && a instanceof c, Sb(n), WV(n, o), n.load();
          } catch {
            n.src = o;
          }
        else
          n.src = o;
      }
      n.addEventListener("emptied", this._onMediaEmptied);
    }
  }
  assignMediaSource(e) {
    var t, n;
    this.log(`${((t = this.transferData) == null ? void 0 : t.mediaSource) === e ? "transferred" : "created"} media source: ${(n = e.constructor) == null ? void 0 : n.name}`), e.addEventListener("sourceopen", this._onMediaSourceOpen), e.addEventListener("sourceended", this._onMediaSourceEnded), e.addEventListener("sourceclose", this._onMediaSourceClose), this.appendSource && (e.addEventListener("startstreaming", this._onStartStreaming), e.addEventListener("endstreaming", this._onEndStreaming));
  }
  attachTransferred() {
    const e = this.media, t = this.transferData;
    if (!t || !e)
      return;
    const n = this.tracks, i = t.tracks, s = i ? Object.keys(i) : null, a = s ? s.length : 0, o = () => {
      this.media && this.mediaSourceOpenOrEnded && this._onMediaSourceOpen();
    };
    if (i && s && a) {
      if (!this.tracksReady) {
        this.hls.config.startFragPrefetch = !0, this.log("attachTransferred: waiting for SourceBuffer track info");
        return;
      }
      if (this.log(`attachTransferred: (bufferCodecEventsTotal ${this.bufferCodecEventsTotal})
required tracks: ${We(n, (c, l) => c === "initSegment" ? void 0 : l)};
transfer tracks: ${We(i, (c, l) => c === "initSegment" ? void 0 : l)}}`), !MA(i, n)) {
        t.mediaSource = null, t.tracks = void 0;
        const c = e.currentTime, l = this.details, u = Math.max(c, (l == null ? void 0 : l.fragments[0].start) || 0);
        if (u - c > 1) {
          this.log(`attachTransferred: waiting for playback to reach new tracks start time ${c} -> ${u}`);
          return;
        }
        this.warn(`attachTransferred: resetting MediaSource for incompatible tracks ("${Object.keys(i)}"->"${Object.keys(n)}") start time: ${u} currentTime: ${c}`), this.onMediaDetaching(E.MEDIA_DETACHING, {}), this.onMediaAttaching(E.MEDIA_ATTACHING, t), e.currentTime = u;
        return;
      }
      this.transferData = void 0, s.forEach((c) => {
        const l = c, u = i[l];
        if (u) {
          const d = u.buffer;
          if (d) {
            const f = this.fragmentTracker, h = u.id;
            if (f.hasFragments(h) || f.hasParts(h)) {
              const p = ue.getBuffered(d);
              f.detectEvictedFragments(l, p, h, null, !0);
            }
            const g = id(l), m = [l, d];
            this.sourceBuffers[g] = m, d.updating && this.operationQueue && this.operationQueue.prependBlocker(l), this.trackSourceBuffer(l, u);
          }
        }
      }), o(), this.bufferCreated();
    } else
      this.log("attachTransferred: MediaSource w/o SourceBuffers"), o();
  }
  get mediaSourceOpenOrEnded() {
    var e;
    const t = (e = this.mediaSource) == null ? void 0 : e.readyState;
    return t === "open" || t === "ended";
  }
  onMediaDetaching(e, t) {
    const n = !!t.transferMedia;
    this.transferData = this.overrides = void 0;
    const {
      media: i,
      mediaSource: s,
      _objectUrl: a
    } = this;
    if (s) {
      if (this.log(`media source ${n ? "transferring" : "detaching"}`), n)
        this.sourceBuffers.forEach(([o]) => {
          o && this.removeBuffer(o);
        }), this.resetQueue();
      else {
        if (this.mediaSourceOpenOrEnded) {
          const o = s.readyState === "open";
          try {
            const c = s.sourceBuffers;
            for (let l = c.length; l--; )
              o && c[l].abort(), s.removeSourceBuffer(c[l]);
            o && s.endOfStream();
          } catch (c) {
            this.warn(`onMediaDetaching: ${c.message} while calling endOfStream`);
          }
        }
        this.sourceBufferCount && this.onBufferReset();
      }
      s.removeEventListener("sourceopen", this._onMediaSourceOpen), s.removeEventListener("sourceended", this._onMediaSourceEnded), s.removeEventListener("sourceclose", this._onMediaSourceClose), this.appendSource && (s.removeEventListener("startstreaming", this._onStartStreaming), s.removeEventListener("endstreaming", this._onEndStreaming)), this.mediaSource = null, this._objectUrl = null;
    }
    i && (i.removeEventListener("emptied", this._onMediaEmptied), n || (a && self.URL.revokeObjectURL(a), this.mediaSrc === a ? (i.removeAttribute("src"), this.appendSource && Sb(i), i.load()) : this.warn("media|source.src was changed by a third party - skip cleanup")), this.media = null), this.hls.trigger(E.MEDIA_DETACHED, t);
  }
  onBufferReset() {
    this.sourceBuffers.forEach(([e]) => {
      e && this.resetBuffer(e);
    }), this.initTracks();
  }
  resetBuffer(e) {
    var t;
    const n = (t = this.tracks[e]) == null ? void 0 : t.buffer;
    if (this.removeBuffer(e), n)
      try {
        var i;
        (i = this.mediaSource) != null && i.sourceBuffers.length && this.mediaSource.removeSourceBuffer(n);
      } catch (s) {
        this.warn(`onBufferReset ${e}`, s);
      }
    delete this.tracks[e];
  }
  removeBuffer(e) {
    this.removeBufferListeners(e), this.sourceBuffers[id(e)] = [null, null];
    const t = this.tracks[e];
    t && (t.buffer = void 0);
  }
  resetQueue() {
    this.operationQueue && this.operationQueue.destroy(), this.operationQueue = new GV(this.tracks);
  }
  onBufferCodecs(e, t) {
    const n = this.tracks, i = Object.keys(t);
    this.log(`BUFFER_CODECS: "${i}" (current SB count ${this.sourceBufferCount})`);
    const s = "audiovideo" in t && (n.audio || n.video) || n.audiovideo && ("audio" in t || "video" in t), a = !s && this.sourceBufferCount && this.media && i.some((o) => !n[o]);
    if (s || a) {
      this.warn(`Unsupported transition between "${Object.keys(n)}" and "${i}" SourceBuffers`);
      return;
    }
    i.forEach((o) => {
      var c, l, u;
      const d = t[o], {
        id: f,
        codec: h,
        levelCodec: g,
        container: m,
        metadata: p,
        supplemental: v
      } = d;
      let y = n[o];
      const b = (c = this.transferData) == null || (l = c.tracks) == null ? void 0 : l[o], x = b != null && b.buffer ? b : y, S = (x == null ? void 0 : x.pendingCodec) || (x == null ? void 0 : x.codec), A = x == null ? void 0 : x.levelCodec;
      y || (y = n[o] = {
        buffer: void 0,
        listeners: [],
        codec: h,
        supplemental: v,
        container: m,
        levelCodec: g,
        metadata: p,
        id: f
      });
      const T = po(S, A), I = T == null ? void 0 : T.replace(Eb, "$1");
      let L = po(h, g);
      const _ = (u = L) == null ? void 0 : u.replace(Eb, "$1");
      L && T && I !== _ && (o.slice(0, 5) === "audio" && (L = al(L, this.appendSource)), this.log(`switching codec ${S} to ${L}`), L !== (y.pendingCodec || y.codec) && (y.pendingCodec = L), y.container = m, this.appendChangeType(o, m, L));
    }), (this.tracksReady || this.sourceBufferCount) && (t.tracks = this.sourceBufferTracks), !this.sourceBufferCount && this.mediaSourceOpenOrEnded && this.checkPendingTracks();
  }
  get sourceBufferTracks() {
    return Object.keys(this.tracks).reduce((e, t) => {
      const n = this.tracks[t];
      return e[t] = {
        id: n.id,
        container: n.container,
        codec: n.codec,
        levelCodec: n.levelCodec
      }, e;
    }, {});
  }
  appendChangeType(e, t, n) {
    const i = `${t};codecs=${n}`, s = {
      label: `change-type=${i}`,
      execute: () => {
        const a = this.tracks[e];
        if (a) {
          const o = a.buffer;
          o != null && o.changeType && (this.log(`changing ${e} sourceBuffer type to ${i}`), o.changeType(i), a.codec = n, a.container = t);
        }
        this.shiftAndExecuteNext(e);
      },
      onStart: () => {
      },
      onComplete: () => {
      },
      onError: (a) => {
        this.warn(`Failed to change ${e} SourceBuffer type`, a);
      }
    };
    this.append(s, e, this.isPending(this.tracks[e]));
  }
  blockAudio(e) {
    var t;
    const n = e.start, i = n + e.duration * 0.05;
    if (((t = this.fragmentTracker.getAppendedFrag(n, ee.MAIN)) == null ? void 0 : t.gap) === !0)
      return;
    const a = {
      label: "block-audio",
      execute: () => {
        var o;
        const c = this.tracks.video;
        (this.lastVideoAppendEnd > i || c != null && c.buffer && ue.isBuffered(c.buffer, i) || ((o = this.fragmentTracker.getAppendedFrag(i, ee.MAIN)) == null ? void 0 : o.gap) === !0) && (this.blockedAudioAppend = null, this.shiftAndExecuteNext("audio"));
      },
      onStart: () => {
      },
      onComplete: () => {
      },
      onError: (o) => {
        this.warn("Error executing block-audio operation", o);
      }
    };
    this.blockedAudioAppend = {
      op: a,
      frag: e
    }, this.append(a, "audio", !0);
  }
  unblockAudio() {
    const {
      blockedAudioAppend: e,
      operationQueue: t
    } = this;
    e && t && (this.blockedAudioAppend = null, t.unblockAudio(e.op));
  }
  onBufferAppending(e, t) {
    const {
      tracks: n
    } = this, {
      data: i,
      type: s,
      parent: a,
      frag: o,
      part: c,
      chunkMeta: l,
      offset: u
    } = t, d = l.buffering[s], {
      sn: f,
      cc: h
    } = o, g = self.performance.now();
    d.start = g;
    const m = o.stats.buffering, p = c ? c.stats.buffering : null;
    m.start === 0 && (m.start = g), p && p.start === 0 && (p.start = g);
    const v = n.audio;
    let y = !1;
    s === "audio" && (v == null ? void 0 : v.container) === "audio/mpeg" && (y = !this.lastMpegAudioChunk || l.id === 1 || this.lastMpegAudioChunk.sn !== l.sn, this.lastMpegAudioChunk = l);
    const b = n.video, x = b == null ? void 0 : b.buffer;
    if (x && f !== "initSegment") {
      const T = c || o, I = this.blockedAudioAppend;
      if (s === "audio" && a !== "main" && !this.blockedAudioAppend) {
        const _ = T.start + T.duration * 0.05, R = x.buffered, D = this.currentOp("video");
        !R.length && !D ? this.blockAudio(T) : !D && !ue.isBuffered(x, _) && this.lastVideoAppendEnd < _ && this.blockAudio(T);
      } else if (s === "video") {
        const L = T.end;
        if (I) {
          const _ = I.frag.start;
          (L > _ || L < this.lastVideoAppendEnd || ue.isBuffered(x, _)) && this.unblockAudio();
        }
        this.lastVideoAppendEnd = L;
      }
    }
    const S = (c || o).start, A = {
      label: `append-${s}`,
      execute: () => {
        var T;
        d.executeStart = self.performance.now();
        const I = (T = this.tracks[s]) == null ? void 0 : T.buffer;
        I && (y ? this.updateTimestampOffset(I, S, 0.1, s, f, h) : u !== void 0 && X(u) && this.updateTimestampOffset(I, u, 1e-6, s, f, h)), this.appendExecutor(i, s);
      },
      onStart: () => {
      },
      onComplete: () => {
        const T = self.performance.now();
        d.executeEnd = d.end = T, m.first === 0 && (m.first = T), p && p.first === 0 && (p.first = T);
        const I = {};
        this.sourceBuffers.forEach(([L, _]) => {
          L && (I[L] = ue.getBuffered(_));
        }), this.appendErrors[s] = 0, s === "audio" || s === "video" ? this.appendErrors.audiovideo = 0 : (this.appendErrors.audio = 0, this.appendErrors.video = 0), this.hls.trigger(E.BUFFER_APPENDED, {
          type: s,
          frag: o,
          part: c,
          chunkMeta: l,
          parent: o.type,
          timeRanges: I
        });
      },
      onError: (T) => {
        var I;
        const L = {
          type: ne.MEDIA_ERROR,
          parent: o.type,
          details: k.BUFFER_APPEND_ERROR,
          sourceBufferName: s,
          frag: o,
          part: c,
          chunkMeta: l,
          error: T,
          err: T,
          fatal: !1
        }, _ = (I = this.media) == null ? void 0 : I.error;
        if (T.code === DOMException.QUOTA_EXCEEDED_ERR || T.name == "QuotaExceededError" || "quota" in T)
          L.details = k.BUFFER_FULL_ERROR;
        else if (T.code === DOMException.INVALID_STATE_ERR && this.mediaSourceOpenOrEnded && !_)
          L.errorAction = ra(!0);
        else if (T.name === Cw && this.sourceBufferCount === 0)
          L.errorAction = ra(!0);
        else {
          const R = ++this.appendErrors[s];
          this.warn(`Failed ${R}/${this.hls.config.appendErrorMaxRetry} times to append segment in "${s}" sourceBuffer (${_ || "no media error"})`), (R >= this.hls.config.appendErrorMaxRetry || _) && (L.fatal = !0);
        }
        this.hls.trigger(E.ERROR, L);
      }
    };
    this.append(A, s, this.isPending(this.tracks[s]));
  }
  getFlushOp(e, t, n) {
    return this.log(`queuing "${e}" remove ${t}-${n}`), {
      label: "remove",
      execute: () => {
        this.removeExecutor(e, t, n);
      },
      onStart: () => {
      },
      onComplete: () => {
        this.hls.trigger(E.BUFFER_FLUSHED, {
          type: e
        });
      },
      onError: (i) => {
        this.warn(`Failed to remove ${t}-${n} from "${e}" SourceBuffer`, i);
      }
    };
  }
  onBufferFlushing(e, t) {
    const {
      type: n,
      startOffset: i,
      endOffset: s
    } = t;
    n ? this.append(this.getFlushOp(n, i, s), n) : this.sourceBuffers.forEach(([a]) => {
      a && this.append(this.getFlushOp(a, i, s), a);
    });
  }
  onFragParsed(e, t) {
    const {
      frag: n,
      part: i
    } = t, s = [], a = i ? i.elementaryStreams : n.elementaryStreams;
    a[je.AUDIOVIDEO] ? s.push("audiovideo") : (a[je.AUDIO] && s.push("audio"), a[je.VIDEO] && s.push("video"));
    const o = () => {
      const c = self.performance.now();
      n.stats.buffering.end = c, i && (i.stats.buffering.end = c);
      const l = i ? i.stats : n.stats;
      this.hls.trigger(E.FRAG_BUFFERED, {
        frag: n,
        part: i,
        stats: l,
        id: n.type
      });
    };
    s.length === 0 && this.warn(`Fragments must have at least one ElementaryStreamType set. type: ${n.type} level: ${n.level} sn: ${n.sn}`), this.blockBuffers(o, s).catch((c) => {
      this.warn(`Fragment buffered callback ${c}`), this.stepOperationQueue(this.sourceBufferTypes);
    });
  }
  onFragChanged(e, t) {
    this.trimBuffers();
  }
  get bufferedToEnd() {
    return this.sourceBufferCount > 0 && !this.sourceBuffers.some(([e]) => {
      var t, n;
      return e && (!((t = this.tracks[e]) != null && t.ended) || ((n = this.tracks[e]) == null ? void 0 : n.ending));
    });
  }
  // on BUFFER_EOS mark matching sourcebuffer(s) as "ending" and "ended" and queue endOfStream after remaining operations(s)
  // an undefined data.type will mark all buffers as EOS.
  onBufferEos(e, t) {
    var n;
    this.sourceBuffers.forEach(([a]) => {
      if (a) {
        const o = this.tracks[a];
        (!t.type || t.type === a) && (o.ending = !0, o.ended || (o.ended = !0, this.log(`${a} buffer reached EOS`)));
      }
    });
    const i = ((n = this.overrides) == null ? void 0 : n.endOfStream) !== !1;
    this.sourceBufferCount > 0 && !this.sourceBuffers.some(([a]) => {
      var o;
      return a && !((o = this.tracks[a]) != null && o.ended);
    }) && (i ? (this.log("Queueing EOS"), this.blockUntilOpen(() => {
      this.tracksEnded();
      const {
        mediaSource: a
      } = this;
      if (!a || a.readyState !== "open") {
        a && this.log(`Could not call mediaSource.endOfStream(). mediaSource.readyState: ${a.readyState}`);
        return;
      }
      this.log("Calling mediaSource.endOfStream()"), a.endOfStream(), this.hls.trigger(E.BUFFERED_TO_END, void 0);
    })) : (this.tracksEnded(), this.hls.trigger(E.BUFFERED_TO_END, void 0)));
  }
  tracksEnded() {
    this.sourceBuffers.forEach(([e]) => {
      if (e !== null) {
        const t = this.tracks[e];
        t && (t.ending = !1);
      }
    });
  }
  onLevelUpdated(e, {
    details: t
  }) {
    t.fragments.length && (this.details = t, this.updateDuration());
  }
  updateDuration() {
    this.blockUntilOpen(() => {
      const e = this.getDurationAndRange();
      e && this.updateMediaSource(e);
    });
  }
  onError(e, t) {
    if (t.details === k.BUFFER_APPEND_ERROR && t.frag) {
      var n;
      const i = (n = t.errorAction) == null ? void 0 : n.nextAutoLevel;
      X(i) && i !== t.frag.level && this.resetAppendErrors();
    }
  }
  resetAppendErrors() {
    this.appendErrors = {
      audio: 0,
      video: 0,
      audiovideo: 0
    };
  }
  trimBuffers() {
    const {
      hls: e,
      details: t,
      media: n
    } = this;
    if (!n || t === null || !this.sourceBufferCount)
      return;
    const i = e.config, s = n.currentTime, a = t.levelTargetDuration, o = t.live && i.liveBackBufferLength !== null ? i.liveBackBufferLength : i.backBufferLength;
    if (X(o) && o >= 0) {
      const c = Math.max(o, a), l = Math.floor(s / a) * a - c;
      this.flushBackBuffer(s, a, l);
    }
    if (X(i.frontBufferFlushThreshold) && i.frontBufferFlushThreshold > 0) {
      const c = Math.max(i.maxBufferLength, i.frontBufferFlushThreshold), l = Math.max(c, a), u = Math.floor(s / a) * a + l;
      this.flushFrontBuffer(s, a, u);
    }
  }
  flushBackBuffer(e, t, n) {
    this.sourceBuffers.forEach(([i, s]) => {
      if (s) {
        const o = ue.getBuffered(s);
        if (o.length > 0 && n > o.start(0)) {
          var a;
          this.hls.trigger(E.BACK_BUFFER_REACHED, {
            bufferEnd: n
          });
          const c = this.tracks[i];
          if ((a = this.details) != null && a.live)
            this.hls.trigger(E.LIVE_BACK_BUFFER_REACHED, {
              bufferEnd: n
            });
          else if (c != null && c.ended) {
            this.log(`Cannot flush ${i} back buffer while SourceBuffer is in ended state`);
            return;
          }
          this.hls.trigger(E.BUFFER_FLUSHING, {
            startOffset: 0,
            endOffset: n,
            type: i
          });
        }
      }
    });
  }
  flushFrontBuffer(e, t, n) {
    this.sourceBuffers.forEach(([i, s]) => {
      if (s) {
        const a = ue.getBuffered(s), o = a.length;
        if (o < 2)
          return;
        const c = a.start(o - 1), l = a.end(o - 1);
        if (n > c || e >= c && e <= l)
          return;
        this.hls.trigger(E.BUFFER_FLUSHING, {
          startOffset: c,
          endOffset: 1 / 0,
          type: i
        });
      }
    });
  }
  /**
   * Update Media Source duration to current level duration or override to Infinity if configuration parameter
   * 'liveDurationInfinity` is set to `true`
   * More details: https://github.com/video-dev/hls.js/issues/355
   */
  getDurationAndRange() {
    var e;
    const {
      details: t,
      mediaSource: n
    } = this;
    if (!t || !this.media || (n == null ? void 0 : n.readyState) !== "open")
      return null;
    const i = t.edge;
    if (t.live && this.hls.config.liveDurationInfinity) {
      if (t.fragments.length && t.live && n.setLiveSeekableRange) {
        const l = Math.max(0, t.fragmentStart), u = Math.max(l, i);
        return {
          duration: 1 / 0,
          start: l,
          end: u
        };
      }
      return {
        duration: 1 / 0
      };
    }
    const s = (e = this.overrides) == null ? void 0 : e.duration;
    if (s)
      return X(s) ? {
        duration: s
      } : null;
    const a = this.media.duration, o = X(n.duration) ? n.duration : 0;
    return i > o && i > a || !X(a) ? {
      duration: i
    } : null;
  }
  updateMediaSource({
    duration: e,
    start: t,
    end: n
  }) {
    const i = this.mediaSource;
    !this.media || !i || i.readyState !== "open" || (i.duration !== e && (X(e) && this.log(`Updating MediaSource duration to ${e.toFixed(3)}`), i.duration = e), t !== void 0 && n !== void 0 && (this.log(`MediaSource duration is set to ${i.duration}. Setting seekable range to ${t}-${n}.`), i.setLiveSeekableRange(t, n)));
  }
  get tracksReady() {
    const e = this.pendingTrackCount;
    return e > 0 && (e >= this.bufferCodecEventsTotal || this.isPending(this.tracks.audiovideo));
  }
  checkPendingTracks() {
    const {
      bufferCodecEventsTotal: e,
      pendingTrackCount: t,
      tracks: n
    } = this;
    if (this.log(`checkPendingTracks (pending: ${t} codec events expected: ${e}) ${We(n)}`), this.tracksReady) {
      var i;
      const s = (i = this.transferData) == null ? void 0 : i.tracks;
      s && Object.keys(s).length ? this.attachTransferred() : this.createSourceBuffers();
    }
  }
  bufferCreated() {
    if (this.sourceBufferCount) {
      const e = {};
      this.sourceBuffers.forEach(([t, n]) => {
        if (t) {
          const i = this.tracks[t];
          e[t] = {
            buffer: n,
            container: i.container,
            codec: i.codec,
            supplemental: i.supplemental,
            levelCodec: i.levelCodec,
            id: i.id,
            metadata: i.metadata
          };
        }
      }), this.hls.trigger(E.BUFFER_CREATED, {
        tracks: e
      }), this.log(`SourceBuffers created. Running queue: ${this.operationQueue}`), this.sourceBuffers.forEach(([t]) => {
        this.executeNext(t);
      });
    } else {
      const e = new Error("could not create source buffer for media codec(s)");
      this.hls.trigger(E.ERROR, {
        type: ne.MEDIA_ERROR,
        details: k.BUFFER_INCOMPATIBLE_CODECS_ERROR,
        fatal: !0,
        error: e,
        reason: e.message
      });
    }
  }
  createSourceBuffers() {
    const {
      tracks: e,
      sourceBuffers: t,
      mediaSource: n
    } = this;
    if (!n)
      throw new Error("createSourceBuffers called when mediaSource was null");
    for (const s in e) {
      const a = s, o = e[a];
      if (this.isPending(o)) {
        const c = this.getTrackCodec(o, a), l = `${o.container};codecs=${c}`;
        o.codec = c, this.log(`creating sourceBuffer(${l})${this.currentOp(a) ? " Queued" : ""} ${We(o)}`);
        try {
          const u = n.addSourceBuffer(l), d = id(a), f = [a, u];
          t[d] = f, o.buffer = u;
        } catch (u) {
          var i;
          this.error(`error while trying to add sourceBuffer: ${u.message}`), this.shiftAndExecuteNext(a), (i = this.operationQueue) == null || i.removeBlockers(), delete this.tracks[a], this.hls.trigger(E.ERROR, {
            type: ne.MEDIA_ERROR,
            details: k.BUFFER_ADD_CODEC_ERROR,
            fatal: !1,
            error: u,
            sourceBufferName: a,
            mimeType: l,
            parent: o.id
          });
          return;
        }
        this.trackSourceBuffer(a, o);
      }
    }
    this.bufferCreated();
  }
  getTrackCodec(e, t) {
    const n = e.supplemental;
    let i = e.codec;
    n && (t === "video" || t === "audiovideo") && pf(n, "video") && (i = FK(i, n));
    const s = po(i, e.levelCodec);
    return s ? t.slice(0, 5) === "audio" ? al(s, this.appendSource) : s : "";
  }
  trackSourceBuffer(e, t) {
    const n = t.buffer;
    if (!n)
      return;
    const i = this.getTrackCodec(t, e);
    this.tracks[e] = {
      buffer: n,
      codec: i,
      container: t.container,
      levelCodec: t.levelCodec,
      supplemental: t.supplemental,
      metadata: t.metadata,
      id: t.id,
      listeners: []
    }, this.removeBufferListeners(e), this.addBufferListener(e, "updatestart", this.onSBUpdateStart), this.addBufferListener(e, "updateend", this.onSBUpdateEnd), this.addBufferListener(e, "error", this.onSBUpdateError), this.appendSource && this.addBufferListener(e, "bufferedchange", (s, a) => {
      const o = a.removedRanges;
      o != null && o.length && this.hls.trigger(E.BUFFER_FLUSHED, {
        type: s
      });
    });
  }
  get mediaSrc() {
    var e, t;
    const n = ((e = this.media) == null || (t = e.querySelector) == null ? void 0 : t.call(e, "source")) || this.media;
    return n == null ? void 0 : n.src;
  }
  onSBUpdateStart(e) {
    const t = this.currentOp(e);
    t && t.onStart();
  }
  onSBUpdateEnd(e) {
    var t;
    if (((t = this.mediaSource) == null ? void 0 : t.readyState) === "closed") {
      this.resetBuffer(e);
      return;
    }
    const n = this.currentOp(e);
    n && (n.onComplete(), this.shiftAndExecuteNext(e));
  }
  onSBUpdateError(e, t) {
    var n;
    const i = new Error(`${e} SourceBuffer error. MediaSource readyState: ${(n = this.mediaSource) == null ? void 0 : n.readyState}`);
    this.error(`${i}`, t), this.hls.trigger(E.ERROR, {
      type: ne.MEDIA_ERROR,
      details: k.BUFFER_APPENDING_ERROR,
      sourceBufferName: e,
      error: i,
      fatal: !1
    });
    const s = this.currentOp(e);
    s && s.onError(i);
  }
  updateTimestampOffset(e, t, n, i, s, a) {
    const o = t - e.timestampOffset;
    Math.abs(o) >= n && (this.log(`Updating ${i} SourceBuffer timestampOffset to ${t} (sn: ${s} cc: ${a})`), e.timestampOffset = t);
  }
  // This method must result in an updateend event; if remove is not called, onSBUpdateEnd must be called manually
  removeExecutor(e, t, n) {
    const {
      media: i,
      mediaSource: s
    } = this, a = this.tracks[e], o = a == null ? void 0 : a.buffer;
    if (!i || !s || !o) {
      this.warn(`Attempting to remove from the ${e} SourceBuffer, but it does not exist`), this.shiftAndExecuteNext(e);
      return;
    }
    const c = X(i.duration) ? i.duration : 1 / 0, l = X(s.duration) ? s.duration : 1 / 0, u = Math.max(0, t), d = Math.min(n, c, l);
    d > u && (!a.ending || a.ended) ? (a.ended = !1, this.log(`Removing [${u},${d}] from the ${e} SourceBuffer`), o.remove(u, d)) : this.shiftAndExecuteNext(e);
  }
  // This method must result in an updateend event; if append is not called, onSBUpdateEnd must be called manually
  appendExecutor(e, t) {
    const n = this.tracks[t], i = n == null ? void 0 : n.buffer;
    if (!i)
      throw new KV(`Attempting to append to the ${t} SourceBuffer, but it does not exist`);
    n.ending = !1, n.ended = !1, i.appendBuffer(e);
  }
  blockUntilOpen(e) {
    if (this.isUpdating() || this.isQueued())
      this.blockBuffers(e).catch((t) => {
        this.warn(`SourceBuffer blocked callback ${t}`), this.stepOperationQueue(this.sourceBufferTypes);
      });
    else
      try {
        e();
      } catch (t) {
        this.warn(`Callback run without blocking ${this.operationQueue} ${t}`);
      }
  }
  isUpdating() {
    return this.sourceBuffers.some(([e, t]) => e && t.updating);
  }
  isQueued() {
    return this.sourceBuffers.some(([e]) => e && !!this.currentOp(e));
  }
  isPending(e) {
    return !!e && !e.buffer;
  }
  // Enqueues an operation to each SourceBuffer queue which, upon execution, resolves a promise. When all promises
  // resolve, the onUnblocked function is executed. Functions calling this method do not need to unblock the queue
  // upon completion, since we already do it here
  blockBuffers(e, t = this.sourceBufferTypes) {
    if (!t.length)
      return this.log("Blocking operation requested, but no SourceBuffers exist"), Promise.resolve().then(e);
    const {
      operationQueue: n
    } = this, i = t.map((a) => this.appendBlocker(a));
    return t.length > 1 && !!this.blockedAudioAppend && this.unblockAudio(), Promise.all(i).then((a) => {
      n === this.operationQueue && (e(), this.stepOperationQueue(this.sourceBufferTypes));
    });
  }
  stepOperationQueue(e) {
    e.forEach((t) => {
      var n;
      const i = (n = this.tracks[t]) == null ? void 0 : n.buffer;
      !i || i.updating || this.shiftAndExecuteNext(t);
    });
  }
  append(e, t, n) {
    this.operationQueue && this.operationQueue.append(e, t, n);
  }
  appendBlocker(e) {
    if (this.operationQueue)
      return this.operationQueue.appendBlocker(e);
  }
  currentOp(e) {
    return this.operationQueue ? this.operationQueue.current(e) : null;
  }
  executeNext(e) {
    e && this.operationQueue && this.operationQueue.executeNext(e);
  }
  shiftAndExecuteNext(e) {
    this.operationQueue && this.operationQueue.shiftAndExecuteNext(e);
  }
  get pendingTrackCount() {
    return Object.keys(this.tracks).reduce((e, t) => e + (this.isPending(this.tracks[t]) ? 1 : 0), 0);
  }
  get sourceBufferCount() {
    return this.sourceBuffers.reduce((e, [t]) => e + (t ? 1 : 0), 0);
  }
  get sourceBufferTypes() {
    return this.sourceBuffers.map(([e]) => e).filter((e) => !!e);
  }
  addBufferListener(e, t, n) {
    const i = this.tracks[e];
    if (!i)
      return;
    const s = i.buffer;
    if (!s)
      return;
    const a = n.bind(this, e);
    i.listeners.push({
      event: t,
      listener: a
    }), s.addEventListener(t, a);
  }
  removeBufferListeners(e) {
    const t = this.tracks[e];
    if (!t)
      return;
    const n = t.buffer;
    n && (t.listeners.forEach((i) => {
      n.removeEventListener(i.event, i.listener);
    }), t.listeners.length = 0);
  }
}
function Sb(r) {
  const e = r.querySelectorAll("source");
  [].slice.call(e).forEach((t) => {
    r.removeChild(t);
  });
}
function WV(r, e) {
  const t = self.document.createElement("source");
  t.type = "video/mp4", t.src = e, r.appendChild(t);
}
function id(r) {
  return r === "audio" ? 1 : 0;
}
class nm {
  constructor(e) {
    this.hls = void 0, this.autoLevelCapping = void 0, this.firstLevel = void 0, this.media = void 0, this.restrictedLevels = void 0, this.timer = void 0, this.clientRect = void 0, this.streamController = void 0, this.hls = e, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.firstLevel = -1, this.media = null, this.restrictedLevels = [], this.timer = void 0, this.clientRect = null, this.registerListeners();
  }
  setStreamController(e) {
    this.streamController = e;
  }
  destroy() {
    this.hls && this.unregisterListener(), this.timer && this.stopCapping(), this.media = null, this.clientRect = null, this.hls = this.streamController = null;
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e.on(E.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), e.on(E.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(E.MANIFEST_PARSED, this.onManifestParsed, this), e.on(E.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(E.BUFFER_CODECS, this.onBufferCodecs, this), e.on(E.MEDIA_DETACHING, this.onMediaDetaching, this);
  }
  unregisterListener() {
    const {
      hls: e
    } = this;
    e.off(E.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), e.off(E.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(E.MANIFEST_PARSED, this.onManifestParsed, this), e.off(E.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(E.BUFFER_CODECS, this.onBufferCodecs, this), e.off(E.MEDIA_DETACHING, this.onMediaDetaching, this);
  }
  onFpsDropLevelCapping(e, t) {
    const n = this.hls.levels[t.droppedLevel];
    this.isLevelAllowed(n) && this.restrictedLevels.push({
      bitrate: n.bitrate,
      height: n.height,
      width: n.width
    });
  }
  onMediaAttaching(e, t) {
    this.media = t.media instanceof HTMLVideoElement ? t.media : null, this.clientRect = null, this.timer && this.hls.levels.length && this.detectPlayerSize();
  }
  onManifestParsed(e, t) {
    const n = this.hls;
    this.restrictedLevels = [], this.firstLevel = t.firstLevel, n.config.capLevelToPlayerSize && t.video && this.startCapping();
  }
  onLevelsUpdated(e, t) {
    this.timer && X(this.autoLevelCapping) && this.detectPlayerSize();
  }
  // Only activate capping when playing a video stream; otherwise, multi-bitrate audio-only streams will be restricted
  // to the first level
  onBufferCodecs(e, t) {
    this.hls.config.capLevelToPlayerSize && t.video && this.startCapping();
  }
  onMediaDetaching() {
    this.stopCapping(), this.media = null;
  }
  detectPlayerSize() {
    if (this.media) {
      if (this.mediaHeight <= 0 || this.mediaWidth <= 0) {
        this.clientRect = null;
        return;
      }
      const e = this.hls.levels;
      if (e.length) {
        const t = this.hls, n = this.getMaxLevel(e.length - 1);
        n !== this.autoLevelCapping && t.logger.log(`Setting autoLevelCapping to ${n}: ${e[n].height}p@${e[n].bitrate} for media ${this.mediaWidth}x${this.mediaHeight}`), t.autoLevelCapping = n, t.autoLevelEnabled && t.autoLevelCapping > this.autoLevelCapping && this.streamController && this.streamController.nextLevelSwitch(), this.autoLevelCapping = t.autoLevelCapping;
      }
    }
  }
  /*
   * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)
   */
  getMaxLevel(e) {
    const t = this.hls.levels;
    if (!t.length)
      return -1;
    const n = t.filter((i, s) => this.isLevelAllowed(i) && s <= e);
    return this.clientRect = null, nm.getMaxLevelByMediaSize(n, this.mediaWidth, this.mediaHeight);
  }
  startCapping() {
    this.timer || (this.autoLevelCapping = Number.POSITIVE_INFINITY, self.clearInterval(this.timer), this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1e3), this.detectPlayerSize());
  }
  stopCapping() {
    this.restrictedLevels = [], this.firstLevel = -1, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.timer && (self.clearInterval(this.timer), this.timer = void 0);
  }
  getDimensions() {
    if (this.clientRect)
      return this.clientRect;
    const e = this.media, t = {
      width: 0,
      height: 0
    };
    if (e) {
      const n = e.getBoundingClientRect();
      t.width = n.width, t.height = n.height, !t.width && !t.height && (t.width = n.right - n.left || e.width || 0, t.height = n.bottom - n.top || e.height || 0);
    }
    return this.clientRect = t, t;
  }
  get mediaWidth() {
    return this.getDimensions().width * this.contentScaleFactor;
  }
  get mediaHeight() {
    return this.getDimensions().height * this.contentScaleFactor;
  }
  get contentScaleFactor() {
    let e = 1;
    if (!this.hls.config.ignoreDevicePixelRatio)
      try {
        e = self.devicePixelRatio;
      } catch {
      }
    return Math.min(e, this.hls.config.maxDevicePixelRatio);
  }
  isLevelAllowed(e) {
    return !this.restrictedLevels.some((n) => e.bitrate === n.bitrate && e.width === n.width && e.height === n.height);
  }
  static getMaxLevelByMediaSize(e, t, n) {
    if (!(e != null && e.length))
      return -1;
    const i = (o, c) => c ? o.width !== c.width || o.height !== c.height : !0;
    let s = e.length - 1;
    const a = Math.max(t, n);
    for (let o = 0; o < e.length; o += 1) {
      const c = e[o];
      if ((c.width >= a || c.height >= a) && i(c, e[o + 1])) {
        s = o;
        break;
      }
    }
    return s;
  }
}
const HV = {
  /**
   * text file, such as a manifest or playlist
   */
  MANIFEST: "m",
  /**
   * audio only
   */
  AUDIO: "a",
  /**
   * video only
   */
  VIDEO: "v",
  /**
   * muxed audio and video
   */
  MUXED: "av",
  /**
   * init segment
   */
  INIT: "i",
  /**
   * caption or subtitle
   */
  CAPTION: "c",
  /**
   * ISOBMFF timed text track
   */
  TIMED_TEXT: "tt",
  /**
   * cryptographic key, license or certificate.
   */
  KEY: "k",
  /**
   * other
   */
  OTHER: "o"
}, Mt = HV, qV = {
  /**
   * HTTP Live Streaming (HLS)
   */
  HLS: "h"
}, zV = qV, YV = "CMCD-Object", XV = "CMCD-Request", QV = "CMCD-Session", ZV = "CMCD-Status", ks = {
  /**
   * keys whose values vary with the object being requested.
   */
  OBJECT: YV,
  /**
   * keys whose values vary with each request.
   */
  REQUEST: XV,
  /**
   * keys whose values are expected to be invariant over the life of the session.
   */
  SESSION: QV,
  /**
   * keys whose values do not vary with every request or object.
   */
  STATUS: ZV
}, JV = {
  [ks.OBJECT]: ["br", "ab", "d", "ot", "tb", "tpb", "lb", "tab", "lab", "url"],
  [ks.REQUEST]: ["pb", "bl", "tbl", "dl", "ltc", "mtp", "nor", "nrr", "rc", "sn", "sta", "su", "ttfb", "ttfbb", "ttlb", "cmsdd", "cmsds", "smrt", "df", "cs"],
  [ks.SESSION]: ["cid", "pr", "sf", "sid", "st", "v", "msd"],
  [ks.STATUS]: ["bs", "bsd", "cdn", "rtp", "bg", "pt", "ec", "e"]
};
class ts {
  constructor(e, t) {
    Array.isArray(e) && (e = e.map((n) => n instanceof ts ? n : new ts(n))), this.value = e, this.params = t;
  }
}
const e8 = "Dict";
function t8(r) {
  return Array.isArray(r) ? JSON.stringify(r) : r instanceof Map ? "Map{}" : r instanceof Set ? "Set{}" : typeof r == "object" ? JSON.stringify(r) : String(r);
}
function r8(r, e, t, n) {
  return new Error(`failed to ${r} "${t8(e)}" as ${t}`, {
    cause: n
  });
}
function Gr(r, e, t) {
  return r8("serialize", r, e, t);
}
class kw {
  constructor(e) {
    this.description = e;
  }
}
const Tb = "Bare Item", n8 = "Boolean";
function i8(r) {
  if (typeof r != "boolean")
    throw Gr(r, n8);
  return r ? "?1" : "?0";
}
function s8(r) {
  return btoa(String.fromCharCode(...r));
}
const a8 = "Byte Sequence";
function o8(r) {
  if (ArrayBuffer.isView(r) === !1)
    throw Gr(r, a8);
  return `:${s8(r)}:`;
}
const l8 = "Integer";
function c8(r) {
  return r < -999999999999999 || 999999999999999 < r;
}
function Mw(r) {
  if (c8(r))
    throw Gr(r, l8);
  return r.toString();
}
function u8(r) {
  return `@${Mw(r.getTime() / 1e3)}`;
}
function Nw(r, e) {
  if (r < 0)
    return -Nw(-r, e);
  const t = Math.pow(10, e);
  if (Math.abs(r * t % 1 - 0.5) < Number.EPSILON) {
    const i = Math.floor(r * t);
    return (i % 2 === 0 ? i : i + 1) / t;
  } else
    return Math.round(r * t) / t;
}
const d8 = "Decimal";
function f8(r) {
  const e = Nw(r, 3);
  if (Math.floor(Math.abs(e)).toString().length > 12)
    throw Gr(r, d8);
  const t = e.toString();
  return t.includes(".") ? t : `${t}.0`;
}
const h8 = "String", g8 = /[\x00-\x1f\x7f]+/;
function m8(r) {
  if (g8.test(r))
    throw Gr(r, h8);
  return `"${r.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`;
}
function p8(r) {
  return r.description || r.toString().slice(7, -1);
}
const v8 = "Token";
function Ab(r) {
  const e = p8(r);
  if (/^([a-zA-Z*])([!#$%&'*+\-.^_`|~\w:/]*)$/.test(e) === !1)
    throw Gr(e, v8);
  return e;
}
function Pf(r) {
  switch (typeof r) {
    case "number":
      if (!X(r))
        throw Gr(r, Tb);
      return Number.isInteger(r) ? Mw(r) : f8(r);
    case "string":
      return m8(r);
    case "symbol":
      return Ab(r);
    case "boolean":
      return i8(r);
    case "object":
      if (r instanceof Date)
        return u8(r);
      if (r instanceof Uint8Array)
        return o8(r);
      if (r instanceof kw)
        return Ab(r);
    default:
      throw Gr(r, Tb);
  }
}
const y8 = "Key";
function _f(r) {
  if (/^[a-z*][a-z0-9\-_.*]*$/.test(r) === !1)
    throw Gr(r, y8);
  return r;
}
function im(r) {
  return r == null ? "" : Object.entries(r).map(([e, t]) => t === !0 ? `;${_f(e)}` : `;${_f(e)}=${Pf(t)}`).join("");
}
function Fw(r) {
  return r instanceof ts ? `${Pf(r.value)}${im(r.params)}` : Pf(r);
}
function b8(r) {
  return `(${r.value.map(Fw).join(" ")})${im(r.params)}`;
}
function x8(r, e = {
  whitespace: !0
}) {
  if (typeof r != "object")
    throw Gr(r, e8);
  const t = r instanceof Map ? r.entries() : Object.entries(r), n = e != null && e.whitespace ? " " : "";
  return Array.from(t).map(([i, s]) => {
    s instanceof ts || (s = new ts(s));
    let a = _f(i);
    return s.value === !0 ? a += im(s.params) : (a += "=", Array.isArray(s.value) ? a += b8(s) : a += Fw(s)), a;
  }).join(`,${n}`);
}
function E8(r, e) {
  return x8(r, e);
}
function S8(r) {
  return ["ot", "sf", "st", "e", "sta"].includes(r);
}
function T8(r) {
  return typeof r == "number" ? X(r) : r != null && r !== "" && r !== !1;
}
function A8(r, e) {
  const t = new URL(r), n = new URL(e);
  if (t.origin !== n.origin)
    return r;
  const i = t.pathname.split("/").slice(1), s = n.pathname.split("/").slice(1, -1);
  for (; i[0] === s[0]; )
    i.shift(), s.shift();
  for (; s.length; )
    s.shift(), i.unshift("..");
  return i.join("/");
}
const Eo = (r) => Math.round(r), w8 = (r, e) => (e != null && e.baseUrl && (r = A8(r, e.baseUrl)), encodeURIComponent(r)), oo = (r) => Eo(r / 100) * 100, I8 = {
  /**
   * Bitrate (kbps) rounded integer
   */
  br: Eo,
  /**
   * Duration (milliseconds) rounded integer
   */
  d: Eo,
  /**
   * Buffer Length (milliseconds) rounded nearest 100ms
   */
  bl: oo,
  /**
   * Deadline (milliseconds) rounded nearest 100ms
   */
  dl: oo,
  /**
   * Measured Throughput (kbps) rounded nearest 100kbps
   */
  mtp: oo,
  /**
   * Next Object Request URL encoded
   */
  nor: w8,
  /**
   * Requested maximum throughput (kbps) rounded nearest 100kbps
   */
  rtp: oo,
  /**
   * Top Bitrate (kbps) rounded integer
   */
  tb: Eo
};
function P8(r, e) {
  const t = {};
  if (r == null || typeof r != "object")
    return t;
  const n = Object.keys(r).sort(), i = Ce({}, I8, e == null ? void 0 : e.formatters), s = e == null ? void 0 : e.filter;
  return n.forEach((a) => {
    if ((s == null ? void 0 : s(a)) === !1)
      return;
    let o = r[a];
    const c = i[a];
    c && (o = c(o, e)), !(a === "v" && o === 1) && (a == "pr" && o === 1 || T8(o) && (S8(a) && typeof o == "string" && (o = new kw(o)), t[a] = o));
  }), t;
}
function $w(r, e = {}) {
  return r ? E8(P8(r, e), Ce({
    whitespace: !1
  }, e)) : "";
}
function _8(r, e = {}) {
  const t = {};
  if (!r)
    return t;
  const n = Object.entries(r), i = Object.entries(JV).concat(Object.entries((e == null ? void 0 : e.customHeaderMap) || {})), s = n.reduce((a, o) => {
    var c, l;
    const [u, d] = o, f = ((c = i.find((h) => h[1].includes(u))) === null || c === void 0 ? void 0 : c[0]) || ks.REQUEST;
    return (l = a[f]) !== null && l !== void 0 || (a[f] = {}), a[f][u] = d, a;
  }, {});
  return Object.entries(s).reduce((a, [o, c]) => (a[o] = $w(c, e), a), t);
}
function L8(r, e, t) {
  return Ce(r, _8(e, t));
}
const O8 = "CMCD";
function R8(r, e = {}) {
  if (!r)
    return "";
  const t = $w(r, e);
  return `${O8}=${encodeURIComponent(t)}`;
}
const wb = /CMCD=[^&#]+/;
function D8(r, e, t) {
  const n = R8(e, t);
  if (!n)
    return r;
  if (wb.test(r))
    return r.replace(wb, n);
  const i = r.includes("?") ? "&" : "?";
  return `${r}${i}${n}`;
}
class C8 {
  constructor(e) {
    this.hls = void 0, this.config = void 0, this.media = void 0, this.sid = void 0, this.cid = void 0, this.useHeaders = !1, this.includeKeys = void 0, this.initialized = !1, this.starved = !1, this.buffering = !0, this.audioBuffer = void 0, this.videoBuffer = void 0, this.onWaiting = () => {
      this.initialized && (this.starved = !0), this.buffering = !0;
    }, this.onPlaying = () => {
      this.initialized || (this.initialized = !0), this.buffering = !1;
    }, this.applyPlaylistData = (i) => {
      try {
        this.apply(i, {
          ot: Mt.MANIFEST,
          su: !this.initialized
        });
      } catch (s) {
        this.hls.logger.warn("Could not generate manifest CMCD data.", s);
      }
    }, this.applyFragmentData = (i) => {
      try {
        const {
          frag: s,
          part: a
        } = i, o = this.hls.levels[s.level], c = this.getObjectType(s), l = {
          d: (a || s).duration * 1e3,
          ot: c
        };
        (c === Mt.VIDEO || c === Mt.AUDIO || c == Mt.MUXED) && (l.br = o.bitrate / 1e3, l.tb = this.getTopBandwidth(c) / 1e3, l.bl = this.getBufferLength(c));
        const u = a ? this.getNextPart(a) : this.getNextFrag(s);
        u != null && u.url && u.url !== s.url && (l.nor = u.url), this.apply(i, l);
      } catch (s) {
        this.hls.logger.warn("Could not generate segment CMCD data.", s);
      }
    }, this.hls = e;
    const t = this.config = e.config, {
      cmcd: n
    } = t;
    n != null && (t.pLoader = this.createPlaylistLoader(), t.fLoader = this.createFragmentLoader(), this.sid = n.sessionId || e.sessionId, this.cid = n.contentId, this.useHeaders = n.useHeaders === !0, this.includeKeys = n.includeKeys, this.registerListeners());
  }
  registerListeners() {
    const e = this.hls;
    e.on(E.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(E.MEDIA_DETACHED, this.onMediaDetached, this), e.on(E.BUFFER_CREATED, this.onBufferCreated, this);
  }
  unregisterListeners() {
    const e = this.hls;
    e.off(E.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(E.MEDIA_DETACHED, this.onMediaDetached, this), e.off(E.BUFFER_CREATED, this.onBufferCreated, this);
  }
  destroy() {
    this.unregisterListeners(), this.onMediaDetached(), this.hls = this.config = this.audioBuffer = this.videoBuffer = null, this.onWaiting = this.onPlaying = this.media = null;
  }
  onMediaAttached(e, t) {
    this.media = t.media, this.media.addEventListener("waiting", this.onWaiting), this.media.addEventListener("playing", this.onPlaying);
  }
  onMediaDetached() {
    this.media && (this.media.removeEventListener("waiting", this.onWaiting), this.media.removeEventListener("playing", this.onPlaying), this.media = null);
  }
  onBufferCreated(e, t) {
    var n, i;
    this.audioBuffer = (n = t.tracks.audio) == null ? void 0 : n.buffer, this.videoBuffer = (i = t.tracks.video) == null ? void 0 : i.buffer;
  }
  /**
   * Create baseline CMCD data
   */
  createData() {
    var e;
    return {
      v: 1,
      sf: zV.HLS,
      sid: this.sid,
      cid: this.cid,
      pr: (e = this.media) == null ? void 0 : e.playbackRate,
      mtp: this.hls.bandwidthEstimate / 1e3
    };
  }
  /**
   * Apply CMCD data to a request.
   */
  apply(e, t = {}) {
    Ce(t, this.createData());
    const n = t.ot === Mt.INIT || t.ot === Mt.VIDEO || t.ot === Mt.MUXED;
    this.starved && n && (t.bs = !0, t.su = !0, this.starved = !1), t.su == null && (t.su = this.buffering);
    const {
      includeKeys: i
    } = this;
    i && (t = Object.keys(t).reduce((a, o) => (i.includes(o) && (a[o] = t[o]), a), {}));
    const s = {
      baseUrl: e.url
    };
    this.useHeaders ? (e.headers || (e.headers = {}), L8(e.headers, t, s)) : e.url = D8(e.url, t, s);
  }
  getNextFrag(e) {
    var t;
    const n = (t = this.hls.levels[e.level]) == null ? void 0 : t.details;
    if (n) {
      const i = e.sn - n.startSN;
      return n.fragments[i + 1];
    }
  }
  getNextPart(e) {
    var t, n;
    const {
      index: i,
      fragment: s
    } = e, a = (t = this.hls.levels[s.level]) == null || (n = t.details) == null ? void 0 : n.partList;
    if (a) {
      const {
        sn: o
      } = s;
      for (let c = a.length - 1; c >= 0; c--) {
        const l = a[c];
        if (l.index === i && l.fragment.sn === o)
          return a[c + 1];
      }
    }
  }
  /**
   * The CMCD object type.
   */
  getObjectType(e) {
    const {
      type: t
    } = e;
    if (t === "subtitle")
      return Mt.TIMED_TEXT;
    if (e.sn === "initSegment")
      return Mt.INIT;
    if (t === "audio")
      return Mt.AUDIO;
    if (t === "main")
      return this.hls.audioTracks.length ? Mt.VIDEO : Mt.MUXED;
  }
  /**
   * Get the highest bitrate.
   */
  getTopBandwidth(e) {
    let t = 0, n;
    const i = this.hls;
    if (e === Mt.AUDIO)
      n = i.audioTracks;
    else {
      const s = i.maxAutoLevel, a = s > -1 ? s + 1 : i.levels.length;
      n = i.levels.slice(0, a);
    }
    return n.forEach((s) => {
      s.bitrate > t && (t = s.bitrate);
    }), t > 0 ? t : NaN;
  }
  /**
   * Get the buffer length for a media type in milliseconds
   */
  getBufferLength(e) {
    const t = this.media, n = e === Mt.AUDIO ? this.audioBuffer : this.videoBuffer;
    return !n || !t ? NaN : ue.bufferInfo(n, t.currentTime, this.config.maxBufferHole).len * 1e3;
  }
  /**
   * Create a playlist loader
   */
  createPlaylistLoader() {
    const {
      pLoader: e
    } = this.config, t = this.applyPlaylistData, n = e || this.config.loader;
    return class {
      constructor(s) {
        this.loader = void 0, this.loader = new n(s);
      }
      get stats() {
        return this.loader.stats;
      }
      get context() {
        return this.loader.context;
      }
      destroy() {
        this.loader.destroy();
      }
      abort() {
        this.loader.abort();
      }
      load(s, a, o) {
        t(s), this.loader.load(s, a, o);
      }
    };
  }
  /**
   * Create a playlist loader
   */
  createFragmentLoader() {
    const {
      fLoader: e
    } = this.config, t = this.applyFragmentData, n = e || this.config.loader;
    return class {
      constructor(s) {
        this.loader = void 0, this.loader = new n(s);
      }
      get stats() {
        return this.loader.stats;
      }
      get context() {
        return this.loader.context;
      }
      destroy() {
        this.loader.destroy();
      }
      abort() {
        this.loader.abort();
      }
      load(s, a, o) {
        t(s), this.loader.load(s, a, o);
      }
    };
  }
}
const k8 = 3e5;
class M8 extends Or {
  constructor(e) {
    super("content-steering", e.logger), this.hls = void 0, this.loader = null, this.uri = null, this.pathwayId = ".", this._pathwayPriority = null, this.timeToLoad = 300, this.reloadTimer = -1, this.updated = 0, this.started = !1, this.enabled = !0, this.levels = null, this.audioTracks = null, this.subtitleTracks = null, this.penalizedPathways = {}, this.hls = e, this.registerListeners();
  }
  registerListeners() {
    const e = this.hls;
    e.on(E.MANIFEST_LOADING, this.onManifestLoading, this), e.on(E.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(E.MANIFEST_PARSED, this.onManifestParsed, this), e.on(E.ERROR, this.onError, this);
  }
  unregisterListeners() {
    const e = this.hls;
    e && (e.off(E.MANIFEST_LOADING, this.onManifestLoading, this), e.off(E.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(E.MANIFEST_PARSED, this.onManifestParsed, this), e.off(E.ERROR, this.onError, this));
  }
  pathways() {
    return (this.levels || []).reduce((e, t) => (e.indexOf(t.pathwayId) === -1 && e.push(t.pathwayId), e), []);
  }
  get pathwayPriority() {
    return this._pathwayPriority;
  }
  set pathwayPriority(e) {
    this.updatePathwayPriority(e);
  }
  startLoad() {
    if (this.started = !0, this.clearTimeout(), this.enabled && this.uri) {
      if (this.updated) {
        const e = this.timeToLoad * 1e3 - (performance.now() - this.updated);
        if (e > 0) {
          this.scheduleRefresh(this.uri, e);
          return;
        }
      }
      this.loadSteeringManifest(this.uri);
    }
  }
  stopLoad() {
    this.started = !1, this.loader && (this.loader.destroy(), this.loader = null), this.clearTimeout();
  }
  clearTimeout() {
    this.reloadTimer !== -1 && (self.clearTimeout(this.reloadTimer), this.reloadTimer = -1);
  }
  destroy() {
    this.unregisterListeners(), this.stopLoad(), this.hls = null, this.levels = this.audioTracks = this.subtitleTracks = null;
  }
  removeLevel(e) {
    const t = this.levels;
    t && (this.levels = t.filter((n) => n !== e));
  }
  onManifestLoading() {
    this.stopLoad(), this.enabled = !0, this.timeToLoad = 300, this.updated = 0, this.uri = null, this.pathwayId = ".", this.levels = this.audioTracks = this.subtitleTracks = null;
  }
  onManifestLoaded(e, t) {
    const {
      contentSteering: n
    } = t;
    n !== null && (this.pathwayId = n.pathwayId, this.uri = n.uri, this.started && this.startLoad());
  }
  onManifestParsed(e, t) {
    this.audioTracks = t.audioTracks, this.subtitleTracks = t.subtitleTracks;
  }
  onError(e, t) {
    const {
      errorAction: n
    } = t;
    if ((n == null ? void 0 : n.action) === Pt.SendAlternateToPenaltyBox && n.flags === Ar.MoveAllAlternatesMatchingHost) {
      const i = this.levels;
      let s = this._pathwayPriority, a = this.pathwayId;
      if (t.context) {
        const {
          groupId: o,
          pathwayId: c,
          type: l
        } = t.context;
        o && i ? a = this.getPathwayForGroupId(o, l, a) : c && (a = c);
      }
      a in this.penalizedPathways || (this.penalizedPathways[a] = performance.now()), !s && i && (s = this.pathways()), s && s.length > 1 && (this.updatePathwayPriority(s), n.resolved = this.pathwayId !== a), t.details === k.BUFFER_APPEND_ERROR && !t.fatal ? n.resolved = !0 : n.resolved || this.warn(`Could not resolve ${t.details} ("${t.error.message}") with content-steering for Pathway: ${a} levels: ${i && i.length} priorities: ${We(s)} penalized: ${We(this.penalizedPathways)}`);
    }
  }
  filterParsedLevels(e) {
    this.levels = e;
    let t = this.getLevelsForPathway(this.pathwayId);
    if (t.length === 0) {
      const n = e[0].pathwayId;
      this.log(`No levels found in Pathway ${this.pathwayId}. Setting initial Pathway to "${n}"`), t = this.getLevelsForPathway(n), this.pathwayId = n;
    }
    return t.length !== e.length && this.log(`Found ${t.length}/${e.length} levels in Pathway "${this.pathwayId}"`), t;
  }
  getLevelsForPathway(e) {
    return this.levels === null ? [] : this.levels.filter((t) => e === t.pathwayId);
  }
  updatePathwayPriority(e) {
    this._pathwayPriority = e;
    let t;
    const n = this.penalizedPathways, i = performance.now();
    Object.keys(n).forEach((s) => {
      i - n[s] > k8 && delete n[s];
    });
    for (let s = 0; s < e.length; s++) {
      const a = e[s];
      if (a in n)
        continue;
      if (a === this.pathwayId)
        return;
      const o = this.hls.nextLoadLevel, c = this.hls.levels[o];
      if (t = this.getLevelsForPathway(a), t.length > 0) {
        this.log(`Setting Pathway to "${a}"`), this.pathwayId = a, cw(t), this.hls.trigger(E.LEVELS_UPDATED, {
          levels: t
        });
        const l = this.hls.levels[o];
        c && l && this.levels && (l.attrs["STABLE-VARIANT-ID"] !== c.attrs["STABLE-VARIANT-ID"] && l.bitrate !== c.bitrate && this.log(`Unstable Pathways change from bitrate ${c.bitrate} to ${l.bitrate}`), this.hls.nextLoadLevel = o);
        break;
      }
    }
  }
  getPathwayForGroupId(e, t, n) {
    const i = this.getLevelsForPathway(n).concat(this.levels || []);
    for (let s = 0; s < i.length; s++)
      if (t === me.AUDIO_TRACK && i[s].hasAudioGroup(e) || t === me.SUBTITLE_TRACK && i[s].hasSubtitleGroup(e))
        return i[s].pathwayId;
    return n;
  }
  clonePathways(e) {
    const t = this.levels;
    if (!t)
      return;
    const n = {}, i = {};
    e.forEach((s) => {
      const {
        ID: a,
        "BASE-ID": o,
        "URI-REPLACEMENT": c
      } = s;
      if (t.some((u) => u.pathwayId === a))
        return;
      const l = this.getLevelsForPathway(o).map((u) => {
        const d = new ze(u.attrs);
        d["PATHWAY-ID"] = a;
        const f = d.AUDIO && `${d.AUDIO}_clone_${a}`, h = d.SUBTITLES && `${d.SUBTITLES}_clone_${a}`;
        f && (n[d.AUDIO] = f, d.AUDIO = f), h && (i[d.SUBTITLES] = h, d.SUBTITLES = h);
        const g = Bw(u.uri, d["STABLE-VARIANT-ID"], "PER-VARIANT-URIS", c), m = new ta({
          attrs: d,
          audioCodec: u.audioCodec,
          bitrate: u.bitrate,
          height: u.height,
          name: u.name,
          url: g,
          videoCodec: u.videoCodec,
          width: u.width
        });
        if (u.audioGroups)
          for (let p = 1; p < u.audioGroups.length; p++)
            m.addGroupId("audio", `${u.audioGroups[p]}_clone_${a}`);
        if (u.subtitleGroups)
          for (let p = 1; p < u.subtitleGroups.length; p++)
            m.addGroupId("text", `${u.subtitleGroups[p]}_clone_${a}`);
        return m;
      });
      t.push(...l), Ib(this.audioTracks, n, c, a), Ib(this.subtitleTracks, i, c, a);
    });
  }
  loadSteeringManifest(e) {
    const t = this.hls.config, n = t.loader;
    this.loader && this.loader.destroy(), this.loader = new n(t);
    let i;
    try {
      i = new self.URL(e);
    } catch {
      this.enabled = !1, this.log(`Failed to parse Steering Manifest URI: ${e}`);
      return;
    }
    if (i.protocol !== "data:") {
      const u = (this.hls.bandwidthEstimate || t.abrEwmaDefaultEstimate) | 0;
      i.searchParams.set("_HLS_pathway", this.pathwayId), i.searchParams.set("_HLS_throughput", "" + u);
    }
    const s = {
      responseType: "json",
      url: i.href
    }, a = t.steeringManifestLoadPolicy.default, o = a.errorRetry || a.timeoutRetry || {}, c = {
      loadPolicy: a,
      timeout: a.maxLoadTimeMs,
      maxRetry: o.maxNumRetry || 0,
      retryDelay: o.retryDelayMs || 0,
      maxRetryDelay: o.maxRetryDelayMs || 0
    }, l = {
      onSuccess: (u, d, f, h) => {
        this.log(`Loaded steering manifest: "${i}"`);
        const g = u.data;
        if ((g == null ? void 0 : g.VERSION) !== 1) {
          this.log(`Steering VERSION ${g.VERSION} not supported!`);
          return;
        }
        this.updated = performance.now(), this.timeToLoad = g.TTL;
        const {
          "RELOAD-URI": m,
          "PATHWAY-CLONES": p,
          "PATHWAY-PRIORITY": v
        } = g;
        if (m)
          try {
            this.uri = new self.URL(m, i).href;
          } catch {
            this.enabled = !1, this.log(`Failed to parse Steering Manifest RELOAD-URI: ${m}`);
            return;
          }
        this.scheduleRefresh(this.uri || f.url), p && this.clonePathways(p);
        const y = {
          steeringManifest: g,
          url: i.toString()
        };
        this.hls.trigger(E.STEERING_MANIFEST_LOADED, y), v && this.updatePathwayPriority(v);
      },
      onError: (u, d, f, h) => {
        if (this.log(`Error loading steering manifest: ${u.code} ${u.text} (${d.url})`), this.stopLoad(), u.code === 410) {
          this.enabled = !1, this.log(`Steering manifest ${d.url} no longer available`);
          return;
        }
        let g = this.timeToLoad * 1e3;
        if (u.code === 429) {
          const m = this.loader;
          if (typeof (m == null ? void 0 : m.getResponseHeader) == "function") {
            const p = m.getResponseHeader("Retry-After");
            p && (g = parseFloat(p) * 1e3);
          }
          this.log(`Steering manifest ${d.url} rate limited`);
          return;
        }
        this.scheduleRefresh(this.uri || d.url, g);
      },
      onTimeout: (u, d, f) => {
        this.log(`Timeout loading steering manifest (${d.url})`), this.scheduleRefresh(this.uri || d.url);
      }
    };
    this.log(`Requesting steering manifest: ${i}`), this.loader.load(s, c, l);
  }
  scheduleRefresh(e, t = this.timeToLoad * 1e3) {
    this.clearTimeout(), this.reloadTimer = self.setTimeout(() => {
      var n;
      const i = (n = this.hls) == null ? void 0 : n.media;
      if (i && !i.ended) {
        this.loadSteeringManifest(e);
        return;
      }
      this.scheduleRefresh(e, this.timeToLoad * 1e3);
    }, t);
  }
}
function Ib(r, e, t, n) {
  r && Object.keys(e).forEach((i) => {
    const s = r.filter((a) => a.groupId === i).map((a) => {
      const o = Ce({}, a);
      return o.details = void 0, o.attrs = new ze(o.attrs), o.url = o.attrs.URI = Bw(a.url, a.attrs["STABLE-RENDITION-ID"], "PER-RENDITION-URIS", t), o.groupId = o.attrs["GROUP-ID"] = e[i], o.attrs["PATHWAY-ID"] = n, o;
    });
    r.push(...s);
  });
}
function Bw(r, e, t, n) {
  const {
    HOST: i,
    PARAMS: s,
    [t]: a
  } = n;
  let o;
  e && (o = a == null ? void 0 : a[e], o && (r = o));
  const c = new self.URL(r);
  return i && !o && (c.host = i), s && Object.keys(s).sort().forEach((l) => {
    l && c.searchParams.set(l, s[l]);
  }), c.href;
}
function gr(r, e, t) {
  Pr(r, e, t), r.addEventListener(e, t);
}
function Pr(r, e, t) {
  r.removeEventListener(e, t);
}
class ji extends Or {
  constructor(e) {
    super("eme", e.logger), this.hls = void 0, this.config = void 0, this.media = null, this.keyFormatPromise = null, this.keySystemAccessPromises = {}, this._requestLicenseFailureCount = 0, this.mediaKeySessions = [], this.keyIdToKeySessionPromise = {}, this.mediaKeys = null, this.setMediaKeysQueue = ji.CDMCleanupPromise ? [ji.CDMCleanupPromise] : [], this.onWaitingForKey = (t) => {
      this.log(`"${t.type}" event`);
    }, this.hls = e, this.config = e.config, this.registerListeners();
  }
  destroy() {
    this.onDestroying(), this.onMediaDetached();
    const e = this.config;
    e.requestMediaKeySystemAccessFunc = null, e.licenseXhrSetup = e.licenseResponseCallback = void 0, e.drmSystems = e.drmSystemOptions = {}, this.hls = this.config = this.keyIdToKeySessionPromise = null, this.onWaitingForKey = null;
  }
  registerListeners() {
    this.hls.on(E.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.on(E.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.on(E.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.on(E.MANIFEST_LOADED, this.onManifestLoaded, this), this.hls.on(E.DESTROYING, this.onDestroying, this);
  }
  unregisterListeners() {
    this.hls.off(E.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.off(E.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.off(E.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.off(E.MANIFEST_LOADED, this.onManifestLoaded, this), this.hls.off(E.DESTROYING, this.onDestroying, this);
  }
  getLicenseServerUrl(e) {
    const {
      drmSystems: t,
      widevineLicenseUrl: n
    } = this.config, i = t[e];
    if (i)
      return i.licenseUrl;
    if (e === Qe.WIDEVINE && n)
      return n;
  }
  getLicenseServerUrlOrThrow(e) {
    const t = this.getLicenseServerUrl(e);
    if (t === void 0)
      throw new Error(`no license server URL configured for key-system "${e}"`);
    return t;
  }
  getServerCertificateUrl(e) {
    const {
      drmSystems: t
    } = this.config, n = t[e];
    if (n)
      return n.serverCertificateUrl;
    this.log(`No Server Certificate in config.drmSystems["${e}"]`);
  }
  attemptKeySystemAccess(e) {
    const t = this.hls.levels, n = (a, o, c) => !!a && c.indexOf(a) === o, i = t.map((a) => a.audioCodec).filter(n), s = t.map((a) => a.videoCodec).filter(n);
    return i.length + s.length === 0 && s.push("avc1.42e01e"), new Promise((a, o) => {
      const c = (l) => {
        const u = l.shift();
        this.getMediaKeysPromise(u, i, s).then((d) => a({
          keySystem: u,
          mediaKeys: d
        })).catch((d) => {
          l.length ? c(l) : d instanceof cr ? o(d) : o(new cr({
            type: ne.KEY_SYSTEM_ERROR,
            details: k.KEY_SYSTEM_NO_ACCESS,
            error: d,
            fatal: !0
          }, d.message));
        });
      };
      c(e);
    });
  }
  requestMediaKeySystemAccess(e, t) {
    const {
      requestMediaKeySystemAccessFunc: n
    } = this.config;
    if (typeof n != "function") {
      let i = `Configured requestMediaKeySystemAccess is not a function ${n}`;
      return rw === null && self.location.protocol === "http:" && (i = `navigator.requestMediaKeySystemAccess is not available over insecure protocol ${location.protocol}`), Promise.reject(new Error(i));
    }
    return n(e, t);
  }
  getMediaKeysPromise(e, t, n) {
    const i = I3(e, t, n, this.config.drmSystemOptions), s = this.keySystemAccessPromises[e];
    let a = s == null ? void 0 : s.keySystemAccess;
    if (!a) {
      this.log(`Requesting encrypted media "${e}" key-system access with config: ${We(i)}`), a = this.requestMediaKeySystemAccess(e, i);
      const o = this.keySystemAccessPromises[e] = {
        keySystemAccess: a
      };
      return a.catch((c) => {
        this.log(`Failed to obtain access to key-system "${e}": ${c}`);
      }), a.then((c) => {
        this.log(`Access for key-system "${c.keySystem}" obtained`);
        const l = this.fetchServerCertificate(e);
        return this.log(`Create media-keys for "${e}"`), o.mediaKeys = c.createMediaKeys().then((u) => (this.log(`Media-keys created for "${e}"`), o.hasMediaKeys = !0, l.then((d) => d ? this.setMediaKeysServerCertificate(u, e, d) : u))), o.mediaKeys.catch((u) => {
          this.error(`Failed to create media-keys for "${e}"}: ${u}`);
        }), o.mediaKeys;
      });
    }
    return a.then(() => s.mediaKeys);
  }
  createMediaKeySessionContext({
    decryptdata: e,
    keySystem: t,
    mediaKeys: n
  }) {
    this.log(`Creating key-system session "${t}" keyId: ${Xn.hexDump(e.keyId || [])}`);
    const i = n.createSession(), s = {
      decryptdata: e,
      keySystem: t,
      mediaKeys: n,
      mediaKeysSession: i,
      keyStatus: "status-pending"
    };
    return this.mediaKeySessions.push(s), s;
  }
  renewKeySession(e) {
    const t = e.decryptdata;
    if (t.pssh) {
      const n = this.createMediaKeySessionContext(e), i = this.getKeyIdString(t), s = "cenc";
      this.keyIdToKeySessionPromise[i] = this.generateRequestWithPreferredKeySession(n, s, t.pssh.buffer, "expired");
    } else
      this.warn("Could not renew expired session. Missing pssh initData.");
    this.removeSession(e);
  }
  getKeyIdString(e) {
    if (!e)
      throw new Error("Could not read keyId of undefined decryptdata");
    if (e.keyId === null)
      throw new Error("keyId is null");
    return Xn.hexDump(e.keyId);
  }
  updateKeySession(e, t) {
    var n;
    const i = e.mediaKeysSession;
    return this.log(`Updating key-session "${i.sessionId}" for keyID ${Xn.hexDump(((n = e.decryptdata) == null ? void 0 : n.keyId) || [])}
      } (data length: ${t && t.byteLength})`), i.update(t);
  }
  getSelectedKeySystemFormats() {
    return Object.keys(this.keySystemAccessPromises).map((e) => ({
      keySystem: e,
      hasMediaKeys: this.keySystemAccessPromises[e].hasMediaKeys
    })).filter(({
      hasMediaKeys: e
    }) => !!e).map(({
      keySystem: e
    }) => Zy(e)).filter((e) => !!e);
  }
  getKeySystemAccess(e) {
    return this.getKeySystemSelectionPromise(e).then(({
      keySystem: t,
      mediaKeys: n
    }) => this.attemptSetMediaKeys(t, n));
  }
  selectKeySystem(e) {
    return new Promise((t, n) => this.getKeySystemSelectionPromise(e).then(({
      keySystem: i
    }) => {
      const s = Zy(i);
      s ? t(s) : n(new Error(`Unable to find format for key-system "${i}"`));
    }).catch(n));
  }
  selectKeySystemFormat(e) {
    const t = Object.keys(e.levelkeys || {});
    return this.keyFormatPromise || (this.log(`Selecting key-system from fragment (sn: ${e.sn} ${e.type}: ${e.level}) key formats ${t.join(", ")}`), this.keyFormatPromise = this.getKeyFormatPromise(t)), this.keyFormatPromise;
  }
  getKeyFormatPromise(e) {
    const t = yo(this.config), n = e.map(Ef).filter((i) => !!i && t.indexOf(i) !== -1);
    return this.selectKeySystem(n);
  }
  loadKey(e) {
    const t = e.keyInfo.decryptdata, n = this.getKeyIdString(t), i = `(keyId: ${n} format: "${t.keyFormat}" method: ${t.method} uri: ${t.uri})`;
    this.log(`Starting session for key ${i}`);
    let s = this.keyIdToKeySessionPromise[n];
    return s || (s = this.getKeySystemForKeyPromise(t).then(({
      keySystem: o,
      mediaKeys: c
    }) => (this.throwIfDestroyed(), this.log(`Handle encrypted media sn: ${e.frag.sn} ${e.frag.type}: ${e.frag.level} using key ${i}`), this.attemptSetMediaKeys(o, c).then(() => (this.throwIfDestroyed(), this.createMediaKeySessionContext({
      keySystem: o,
      mediaKeys: c,
      decryptdata: t
    }))))), (this.keyIdToKeySessionPromise[n] = s.then((o) => {
      const c = "cenc", l = t.pssh ? t.pssh.buffer : null;
      return this.generateRequestWithPreferredKeySession(o, c, l, "playlist-key");
    })).catch((o) => this.handleError(o))), s;
  }
  throwIfDestroyed(e = "Invalid state") {
    if (!this.hls)
      throw new Error("invalid state");
  }
  handleError(e) {
    this.hls && (this.error(e.message), e instanceof cr ? this.hls.trigger(E.ERROR, e.data) : this.hls.trigger(E.ERROR, {
      type: ne.KEY_SYSTEM_ERROR,
      details: k.KEY_SYSTEM_NO_KEYS,
      error: e,
      fatal: !0
    }));
  }
  getKeySystemForKeyPromise(e) {
    const t = this.getKeyIdString(e), n = this.keyIdToKeySessionPromise[t];
    if (!n) {
      const i = Ef(e.keyFormat), s = i ? [i] : yo(this.config);
      return this.attemptKeySystemAccess(s);
    }
    return n;
  }
  getKeySystemSelectionPromise(e) {
    if (e.length || (e = yo(this.config)), e.length === 0)
      throw new cr({
        type: ne.KEY_SYSTEM_ERROR,
        details: k.KEY_SYSTEM_NO_CONFIGURED_LICENSE,
        fatal: !0
      }, `Missing key-system license configuration options ${We({
        drmSystems: this.config.drmSystems
      })}`);
    return this.attemptKeySystemAccess(e);
  }
  attemptSetMediaKeys(e, t) {
    if (this.mediaKeys === t)
      return Promise.resolve();
    const n = this.setMediaKeysQueue.slice();
    this.log(`Setting media-keys for "${e}"`);
    const i = Promise.all(n).then(() => {
      if (!this.media)
        throw this.mediaKeys = null, new Error("Attempted to set mediaKeys without media element attached");
      return this.media.setMediaKeys(t);
    });
    return this.mediaKeys = t, this.setMediaKeysQueue.push(i), i.then(() => {
      this.log(`Media-keys set for "${e}"`), n.push(i), this.setMediaKeysQueue = this.setMediaKeysQueue.filter((s) => n.indexOf(s) === -1);
    });
  }
  generateRequestWithPreferredKeySession(e, t, n, i) {
    var s, a;
    const o = (s = this.config.drmSystems) == null || (a = s[e.keySystem]) == null ? void 0 : a.generateRequest;
    if (o)
      try {
        const g = o.call(this.hls, t, n, e);
        if (!g)
          throw new Error("Invalid response from configured generateRequest filter");
        t = g.initDataType, n = g.initData ? g.initData : null, e.decryptdata.pssh = n ? new Uint8Array(n) : null;
      } catch (g) {
        var c;
        if (this.warn(g.message), (c = this.hls) != null && c.config.debug)
          throw g;
      }
    if (n === null)
      return this.log(`Skipping key-session request for "${i}" (no initData)`), Promise.resolve(e);
    const l = this.getKeyIdString(e.decryptdata);
    this.log(`Generating key-session request for "${i}": ${l} (init data type: ${t} length: ${n ? n.byteLength : null})`);
    const u = new Yg(), d = e._onmessage = (g) => {
      const m = e.mediaKeysSession;
      if (!m) {
        u.emit("error", new Error("invalid state"));
        return;
      }
      const {
        messageType: p,
        message: v
      } = g;
      this.log(`"${p}" message event for session "${m.sessionId}" message size: ${v.byteLength}`), p === "license-request" || p === "license-renewal" ? this.renewLicense(e, v).catch((y) => {
        u.eventNames().length ? u.emit("error", y) : this.handleError(y);
      }) : p === "license-release" ? e.keySystem === Qe.FAIRPLAY && (this.updateKeySession(e, xf("acknowledged")), this.removeSession(e)) : this.warn(`unhandled media key message type "${p}"`);
    }, f = e._onkeystatuseschange = (g) => {
      if (!e.mediaKeysSession) {
        u.emit("error", new Error("invalid state"));
        return;
      }
      this.onKeyStatusChange(e);
      const p = e.keyStatus;
      u.emit("keyStatus", p), p === "expired" && (this.warn(`${e.keySystem} expired for key ${l}`), this.renewKeySession(e));
    };
    gr(e.mediaKeysSession, "message", d), gr(e.mediaKeysSession, "keystatuseschange", f);
    const h = new Promise((g, m) => {
      u.on("error", m), u.on("keyStatus", (p) => {
        p.startsWith("usable") ? g() : p === "output-restricted" ? m(new cr({
          type: ne.KEY_SYSTEM_ERROR,
          details: k.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED,
          fatal: !1
        }, "HDCP level output restricted")) : p === "internal-error" ? m(new cr({
          type: ne.KEY_SYSTEM_ERROR,
          details: k.KEY_SYSTEM_STATUS_INTERNAL_ERROR,
          fatal: !0
        }, `key status changed to "${p}"`)) : p === "expired" ? m(new Error("key expired while generating request")) : this.warn(`unhandled key status change "${p}"`);
      });
    });
    return e.mediaKeysSession.generateRequest(t, n).then(() => {
      var g;
      this.log(`Request generated for key-session "${(g = e.mediaKeysSession) == null ? void 0 : g.sessionId}" keyId: ${l}`);
    }).catch((g) => {
      throw new cr({
        type: ne.KEY_SYSTEM_ERROR,
        details: k.KEY_SYSTEM_NO_SESSION,
        error: g,
        fatal: !1
      }, `Error generating key-session request: ${g}`);
    }).then(() => h).catch((g) => {
      throw u.removeAllListeners(), this.removeSession(e), g;
    }).then(() => (u.removeAllListeners(), e));
  }
  onKeyStatusChange(e) {
    e.mediaKeysSession.keyStatuses.forEach((t, n) => {
      if (typeof n == "string" && typeof t == "object") {
        const i = n;
        n = t, t = i;
      }
      this.log(`key status change "${t}" for keyStatuses keyId: ${Xn.hexDump("buffer" in n ? new Uint8Array(n.buffer, n.byteOffset, n.byteLength) : new Uint8Array(n))} session keyId: ${Xn.hexDump(new Uint8Array(e.decryptdata.keyId || []))} uri: ${e.decryptdata.uri}`), e.keyStatus = t;
    });
  }
  fetchServerCertificate(e) {
    const t = this.config, n = t.loader, i = new n(t), s = this.getServerCertificateUrl(e);
    return s ? (this.log(`Fetching server certificate for "${e}"`), new Promise((a, o) => {
      const c = {
        responseType: "arraybuffer",
        url: s
      }, l = t.certLoadPolicy.default, u = {
        loadPolicy: l,
        timeout: l.maxLoadTimeMs,
        maxRetry: 0,
        retryDelay: 0,
        maxRetryDelay: 0
      }, d = {
        onSuccess: (f, h, g, m) => {
          a(f.data);
        },
        onError: (f, h, g, m) => {
          o(new cr({
            type: ne.KEY_SYSTEM_ERROR,
            details: k.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
            fatal: !0,
            networkDetails: g,
            response: Ne({
              url: c.url,
              data: void 0
            }, f)
          }, `"${e}" certificate request failed (${s}). Status: ${f.code} (${f.text})`));
        },
        onTimeout: (f, h, g) => {
          o(new cr({
            type: ne.KEY_SYSTEM_ERROR,
            details: k.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
            fatal: !0,
            networkDetails: g,
            response: {
              url: c.url,
              data: void 0
            }
          }, `"${e}" certificate request timed out (${s})`));
        },
        onAbort: (f, h, g) => {
          o(new Error("aborted"));
        }
      };
      i.load(c, u, d);
    })) : Promise.resolve();
  }
  setMediaKeysServerCertificate(e, t, n) {
    return new Promise((i, s) => {
      e.setServerCertificate(n).then((a) => {
        this.log(`setServerCertificate ${a ? "success" : "not supported by CDM"} (${n == null ? void 0 : n.byteLength}) on "${t}"`), i(e);
      }).catch((a) => {
        s(new cr({
          type: ne.KEY_SYSTEM_ERROR,
          details: k.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED,
          error: a,
          fatal: !0
        }, a.message));
      });
    });
  }
  renewLicense(e, t) {
    return this.requestLicense(e, new Uint8Array(t)).then((n) => this.updateKeySession(e, new Uint8Array(n)).catch((i) => {
      throw new cr({
        type: ne.KEY_SYSTEM_ERROR,
        details: k.KEY_SYSTEM_SESSION_UPDATE_FAILED,
        error: i,
        fatal: !0
      }, i.message);
    }));
  }
  unpackPlayReadyKeyMessage(e, t) {
    const n = String.fromCharCode.apply(null, new Uint16Array(t.buffer));
    if (!n.includes("PlayReadyKeyMessage"))
      return e.setRequestHeader("Content-Type", "text/xml; charset=utf-8"), t;
    const i = new DOMParser().parseFromString(n, "application/xml"), s = i.querySelectorAll("HttpHeader");
    if (s.length > 0) {
      let u;
      for (let d = 0, f = s.length; d < f; d++) {
        var a, o;
        u = s[d];
        const h = (a = u.querySelector("name")) == null ? void 0 : a.textContent, g = (o = u.querySelector("value")) == null ? void 0 : o.textContent;
        h && g && e.setRequestHeader(h, g);
      }
    }
    const c = i.querySelector("Challenge"), l = c == null ? void 0 : c.textContent;
    if (!l)
      throw new Error("Cannot find <Challenge> in key message");
    return xf(atob(l));
  }
  setupLicenseXHR(e, t, n, i) {
    const s = this.config.licenseXhrSetup;
    return s ? Promise.resolve().then(() => {
      if (!n.decryptdata)
        throw new Error("Key removed");
      return s.call(this.hls, e, t, n, i);
    }).catch((a) => {
      if (!n.decryptdata)
        throw a;
      return e.open("POST", t, !0), s.call(this.hls, e, t, n, i);
    }).then((a) => (e.readyState || e.open("POST", t, !0), {
      xhr: e,
      licenseChallenge: a || i
    })) : (e.open("POST", t, !0), Promise.resolve({
      xhr: e,
      licenseChallenge: i
    }));
  }
  requestLicense(e, t) {
    const n = this.config.keyLoadPolicy.default;
    return new Promise((i, s) => {
      const a = this.getLicenseServerUrlOrThrow(e.keySystem);
      this.log(`Sending license request to URL: ${a}`);
      const o = new XMLHttpRequest();
      o.responseType = "arraybuffer", o.onreadystatechange = () => {
        if (!this.hls || !e.mediaKeysSession)
          return s(new Error("invalid state"));
        if (o.readyState === 4)
          if (o.status === 200) {
            this._requestLicenseFailureCount = 0;
            let c = o.response;
            this.log(`License received ${c instanceof ArrayBuffer ? c.byteLength : c}`);
            const l = this.config.licenseResponseCallback;
            if (l)
              try {
                c = l.call(this.hls, o, a, e);
              } catch (u) {
                this.error(u);
              }
            i(c);
          } else {
            const c = n.errorRetry, l = c ? c.maxNumRetry : 0;
            if (this._requestLicenseFailureCount++, this._requestLicenseFailureCount > l || o.status >= 400 && o.status < 500)
              s(new cr({
                type: ne.KEY_SYSTEM_ERROR,
                details: k.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
                fatal: !0,
                networkDetails: o,
                response: {
                  url: a,
                  data: void 0,
                  code: o.status,
                  text: o.statusText
                }
              }, `License Request XHR failed (${a}). Status: ${o.status} (${o.statusText})`));
            else {
              const u = l - this._requestLicenseFailureCount + 1;
              this.warn(`Retrying license request, ${u} attempts left`), this.requestLicense(e, t).then(i, s);
            }
          }
      }, e.licenseXhr && e.licenseXhr.readyState !== XMLHttpRequest.DONE && e.licenseXhr.abort(), e.licenseXhr = o, this.setupLicenseXHR(o, a, e, t).then(({
        xhr: c,
        licenseChallenge: l
      }) => {
        e.keySystem == Qe.PLAYREADY && (l = this.unpackPlayReadyKeyMessage(c, l)), c.send(l);
      });
    });
  }
  onDestroying() {
    this.unregisterListeners(), this._clear();
  }
  onMediaAttached(e, t) {
    if (!this.config.emeEnabled)
      return;
    const n = t.media;
    this.media = n, gr(n, "waitingforkey", this.onWaitingForKey);
  }
  onMediaDetached() {
    const e = this.media;
    e && (Pr(e, "waitingforkey", this.onWaitingForKey), this.media = null, this.mediaKeys = null);
  }
  _clear() {
    var e;
    if (this._requestLicenseFailureCount = 0, this.keyIdToKeySessionPromise = {}, !this.mediaKeys && !this.mediaKeySessions.length)
      return;
    const t = this.media, n = this.mediaKeySessions.slice();
    this.mediaKeySessions = [], this.mediaKeys = null, sc.clearKeyUriToKeyIdMap();
    const i = n.length;
    ji.CDMCleanupPromise = Promise.all(n.map((s) => this.removeSession(s)).concat(t == null || (e = t.setMediaKeys(null)) == null ? void 0 : e.catch((s) => {
      var a;
      this.log(`Could not clear media keys: ${s}`), (a = this.hls) == null || a.trigger(E.ERROR, {
        type: ne.OTHER_ERROR,
        details: k.KEY_SYSTEM_DESTROY_MEDIA_KEYS_ERROR,
        fatal: !1,
        error: new Error(`Could not clear media keys: ${s}`)
      });
    }))).catch((s) => {
      var a;
      this.log(`Could not close sessions and clear media keys: ${s}`), (a = this.hls) == null || a.trigger(E.ERROR, {
        type: ne.OTHER_ERROR,
        details: k.KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR,
        fatal: !1,
        error: new Error(`Could not close sessions and clear media keys: ${s}`)
      });
    }).then(() => {
      i && this.log("finished closing key sessions and clearing media keys");
    });
  }
  onManifestLoading() {
    this.keyFormatPromise = null;
  }
  onManifestLoaded(e, {
    sessionKeys: t
  }) {
    if (!(!t || !this.config.emeEnabled) && !this.keyFormatPromise) {
      const n = t.reduce((i, s) => (i.indexOf(s.keyFormat) === -1 && i.push(s.keyFormat), i), []);
      this.log(`Selecting key-system from session-keys ${n.join(", ")}`), this.keyFormatPromise = this.getKeyFormatPromise(n);
    }
  }
  removeSession(e) {
    const {
      mediaKeysSession: t,
      licenseXhr: n
    } = e;
    if (t) {
      this.log(`Remove licenses and keys and close session ${t.sessionId}`), e._onmessage && (t.removeEventListener("message", e._onmessage), e._onmessage = void 0), e._onkeystatuseschange && (t.removeEventListener("keystatuseschange", e._onkeystatuseschange), e._onkeystatuseschange = void 0), n && n.readyState !== XMLHttpRequest.DONE && n.abort(), e.mediaKeysSession = e.decryptdata = e.licenseXhr = void 0;
      const i = this.mediaKeySessions.indexOf(e);
      i > -1 && this.mediaKeySessions.splice(i, 1);
      const {
        drmSystemOptions: s
      } = this.config;
      return (_3(s) ? new Promise((o, c) => {
        self.setTimeout(() => c(new Error("MediaKeySession.remove() timeout")), 8e3), t.remove().then(o);
      }) : Promise.resolve()).catch((o) => {
        var c;
        this.log(`Could not remove session: ${o}`), (c = this.hls) == null || c.trigger(E.ERROR, {
          type: ne.OTHER_ERROR,
          details: k.KEY_SYSTEM_DESTROY_REMOVE_SESSION_ERROR,
          fatal: !1,
          error: new Error(`Could not remove session: ${o}`)
        });
      }).then(() => t.close()).catch((o) => {
        var c;
        this.log(`Could not close session: ${o}`), (c = this.hls) == null || c.trigger(E.ERROR, {
          type: ne.OTHER_ERROR,
          details: k.KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR,
          fatal: !1,
          error: new Error(`Could not close session: ${o}`)
        });
      });
    }
  }
}
ji.CDMCleanupPromise = void 0;
class cr extends Error {
  constructor(e, t) {
    super(t), this.data = void 0, e.error || (e.error = new Error(t)), this.data = e, e.err = e.error;
  }
}
class N8 {
  constructor(e) {
    this.hls = void 0, this.isVideoPlaybackQualityAvailable = !1, this.timer = void 0, this.media = null, this.lastTime = void 0, this.lastDroppedFrames = 0, this.lastDecodedFrames = 0, this.streamController = void 0, this.hls = e, this.registerListeners();
  }
  setStreamController(e) {
    this.streamController = e;
  }
  registerListeners() {
    this.hls.on(E.MEDIA_ATTACHING, this.onMediaAttaching, this), this.hls.on(E.MEDIA_DETACHING, this.onMediaDetaching, this);
  }
  unregisterListeners() {
    this.hls.off(E.MEDIA_ATTACHING, this.onMediaAttaching, this), this.hls.off(E.MEDIA_DETACHING, this.onMediaDetaching, this);
  }
  destroy() {
    this.timer && clearInterval(this.timer), this.unregisterListeners(), this.isVideoPlaybackQualityAvailable = !1, this.media = null;
  }
  onMediaAttaching(e, t) {
    const n = this.hls.config;
    if (n.capLevelOnFPSDrop) {
      const i = t.media instanceof self.HTMLVideoElement ? t.media : null;
      this.media = i, i && typeof i.getVideoPlaybackQuality == "function" && (this.isVideoPlaybackQualityAvailable = !0), self.clearInterval(this.timer), this.timer = self.setInterval(this.checkFPSInterval.bind(this), n.fpsDroppedMonitoringPeriod);
    }
  }
  onMediaDetaching() {
    this.media = null;
  }
  checkFPS(e, t, n) {
    const i = performance.now();
    if (t) {
      if (this.lastTime) {
        const s = i - this.lastTime, a = n - this.lastDroppedFrames, o = t - this.lastDecodedFrames, c = 1e3 * a / s, l = this.hls;
        if (l.trigger(E.FPS_DROP, {
          currentDropped: a,
          currentDecoded: o,
          totalDroppedFrames: n
        }), c > 0 && a > l.config.fpsDroppedMonitoringThreshold * o) {
          let u = l.currentLevel;
          l.logger.warn("drop FPS ratio greater than max allowed value for currentLevel: " + u), u > 0 && (l.autoLevelCapping === -1 || l.autoLevelCapping >= u) && (u = u - 1, l.trigger(E.FPS_DROP_LEVEL_CAPPING, {
            level: u,
            droppedLevel: l.currentLevel
          }), l.autoLevelCapping = u, this.streamController.nextLevelSwitch());
        }
      }
      this.lastTime = i, this.lastDroppedFrames = n, this.lastDecodedFrames = t;
    }
  }
  checkFPSInterval() {
    const e = this.media;
    if (e)
      if (this.isVideoPlaybackQualityAvailable) {
        const t = e.getVideoPlaybackQuality();
        this.checkFPS(e, t.totalVideoFrames, t.droppedVideoFrames);
      } else
        this.checkFPS(e, e.webkitDecodedFrameCount, e.webkitDroppedFrameCount);
  }
}
function jw(r, e) {
  let t;
  try {
    t = new Event("addtrack");
  } catch {
    t = document.createEvent("Event"), t.initEvent("addtrack", !1, !1);
  }
  t.track = r, e.dispatchEvent(t);
}
function Uw(r, e) {
  const t = r.mode;
  if (t === "disabled" && (r.mode = "hidden"), r.cues && !r.cues.getCueById(e.id))
    try {
      if (r.addCue(e), !r.cues.getCueById(e.id))
        throw new Error(`addCue is failed for: ${e}`);
    } catch (n) {
      Ae.debug(`[texttrack-utils]: ${n}`);
      try {
        const i = new self.TextTrackCue(e.startTime, e.endTime, e.text);
        i.id = e.id, r.addCue(i);
      } catch (i) {
        Ae.debug(`[texttrack-utils]: Legacy TextTrackCue fallback failed: ${i}`);
      }
    }
  t === "disabled" && (r.mode = t);
}
function Ni(r, e) {
  const t = r.mode;
  if (t === "disabled" && (r.mode = "hidden"), r.cues)
    for (let n = r.cues.length; n--; )
      e && r.cues[n].removeEventListener("enter", e), r.removeCue(r.cues[n]);
  t === "disabled" && (r.mode = t);
}
function Lf(r, e, t, n) {
  const i = r.mode;
  if (i === "disabled" && (r.mode = "hidden"), r.cues && r.cues.length > 0) {
    const s = $8(r.cues, e, t);
    for (let a = 0; a < s.length; a++)
      (!n || n(s[a])) && r.removeCue(s[a]);
  }
  i === "disabled" && (r.mode = i);
}
function F8(r, e) {
  if (e <= r[0].startTime)
    return 0;
  const t = r.length - 1;
  if (e > r[t].endTime)
    return -1;
  let n = 0, i = t, s;
  for (; n <= i; )
    if (s = Math.floor((i + n) / 2), e < r[s].startTime)
      i = s - 1;
    else if (e > r[s].startTime && n < t)
      n = s + 1;
    else
      return s;
  return r[n].startTime - e < e - r[i].startTime ? n : i;
}
function $8(r, e, t) {
  const n = [], i = F8(r, e);
  if (i > -1)
    for (let s = i, a = r.length; s < a; s++) {
      const o = r[s];
      if (o.startTime >= e && o.endTime <= t)
        n.push(o);
      else if (o.startTime > t)
        return n;
    }
  return n;
}
function So(r) {
  const e = [];
  for (let t = 0; t < r.length; t++) {
    const n = r[t];
    (n.kind === "subtitles" || n.kind === "captions") && n.label && e.push(r[t]);
  }
  return e;
}
class B8 extends rm {
  constructor(e) {
    super(e, "subtitle-track-controller"), this.media = null, this.tracks = [], this.groupIds = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0, this.queuedDefaultTrack = -1, this.useTextTrackPolling = !1, this.subtitlePollingInterval = -1, this._subtitleDisplay = !0, this.asyncPollTrackChange = () => this.pollTrackChange(0), this.onTextTracksChanged = () => {
      if (this.useTextTrackPolling || self.clearInterval(this.subtitlePollingInterval), !this.media || !this.hls.config.renderTextTracksNatively)
        return;
      let t = null;
      const n = So(this.media.textTracks);
      for (let s = 0; s < n.length; s++)
        if (n[s].mode === "hidden")
          t = n[s];
        else if (n[s].mode === "showing") {
          t = n[s];
          break;
        }
      const i = this.findTrackForTextTrack(t);
      this.subtitleTrack !== i && this.setSubtitleTrack(i);
    }, this.registerListeners();
  }
  destroy() {
    this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, this.currentTrack = null, this.onTextTracksChanged = this.asyncPollTrackChange = null, super.destroy();
  }
  get subtitleDisplay() {
    return this._subtitleDisplay;
  }
  set subtitleDisplay(e) {
    this._subtitleDisplay = e, this.trackId > -1 && this.toggleTrackModes();
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e.on(E.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(E.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(E.MANIFEST_LOADING, this.onManifestLoading, this), e.on(E.MANIFEST_PARSED, this.onManifestParsed, this), e.on(E.LEVEL_LOADING, this.onLevelLoading, this), e.on(E.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(E.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.on(E.ERROR, this.onError, this);
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off(E.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(E.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(E.MANIFEST_LOADING, this.onManifestLoading, this), e.off(E.MANIFEST_PARSED, this.onManifestParsed, this), e.off(E.LEVEL_LOADING, this.onLevelLoading, this), e.off(E.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(E.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.off(E.ERROR, this.onError, this);
  }
  // Listen for subtitle track change, then extract the current track ID.
  onMediaAttached(e, t) {
    this.media = t.media, this.media && (this.queuedDefaultTrack > -1 && (this.subtitleTrack = this.queuedDefaultTrack, this.queuedDefaultTrack = -1), this.useTextTrackPolling = !(this.media.textTracks && "onchange" in this.media.textTracks), this.useTextTrackPolling ? this.pollTrackChange(500) : this.media.textTracks.addEventListener("change", this.asyncPollTrackChange));
  }
  pollTrackChange(e) {
    self.clearInterval(this.subtitlePollingInterval), this.subtitlePollingInterval = self.setInterval(this.onTextTracksChanged, e);
  }
  onMediaDetaching(e, t) {
    const n = this.media;
    if (!n)
      return;
    const i = !!t.transferMedia;
    if (self.clearInterval(this.subtitlePollingInterval), this.useTextTrackPolling || n.textTracks.removeEventListener("change", this.asyncPollTrackChange), this.trackId > -1 && (this.queuedDefaultTrack = this.trackId), this.subtitleTrack = -1, this.media = null, i)
      return;
    So(n.textTracks).forEach((a) => {
      Ni(a);
    });
  }
  onManifestLoading() {
    this.tracks = [], this.groupIds = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0;
  }
  // Fired whenever a new manifest is loaded.
  onManifestParsed(e, t) {
    this.tracks = t.subtitleTracks;
  }
  onSubtitleTrackLoaded(e, t) {
    const {
      id: n,
      groupId: i,
      details: s
    } = t, a = this.tracksInGroup[n];
    if (!a || a.groupId !== i) {
      this.warn(`Subtitle track with id:${n} and group:${i} not found in active group ${a == null ? void 0 : a.groupId}`);
      return;
    }
    const o = a.details;
    a.details = t.details, this.log(`Subtitle track ${n} "${a.name}" lang:${a.lang} group:${i} loaded [${s.startSN}-${s.endSN}]`), n === this.trackId && this.playlistLoaded(n, t, o);
  }
  onLevelLoading(e, t) {
    this.switchLevel(t.level);
  }
  onLevelSwitching(e, t) {
    this.switchLevel(t.level);
  }
  switchLevel(e) {
    const t = this.hls.levels[e];
    if (!t)
      return;
    const n = t.subtitleGroups || null, i = this.groupIds;
    let s = this.currentTrack;
    if (!n || (i == null ? void 0 : i.length) !== (n == null ? void 0 : n.length) || n != null && n.some((a) => (i == null ? void 0 : i.indexOf(a)) === -1)) {
      this.groupIds = n, this.trackId = -1, this.currentTrack = null;
      const a = this.tracks.filter((u) => !n || n.indexOf(u.groupId) !== -1);
      if (a.length)
        this.selectDefaultTrack && !a.some((u) => u.default) && (this.selectDefaultTrack = !1), a.forEach((u, d) => {
          u.id = d;
        });
      else if (!s && !this.tracksInGroup.length)
        return;
      this.tracksInGroup = a;
      const o = this.hls.config.subtitlePreference;
      if (!s && o) {
        this.selectDefaultTrack = !1;
        const u = Mr(o, a);
        if (u > -1)
          s = a[u];
        else {
          const d = Mr(o, this.tracks);
          s = this.tracks[d];
        }
      }
      let c = this.findTrackId(s);
      c === -1 && s && (c = this.findTrackId(null));
      const l = {
        subtitleTracks: a
      };
      this.log(`Updating subtitle tracks, ${a.length} track(s) found in "${n == null ? void 0 : n.join(",")}" group-id`), this.hls.trigger(E.SUBTITLE_TRACKS_UPDATED, l), c !== -1 && this.trackId === -1 && this.setSubtitleTrack(c);
    }
  }
  findTrackId(e) {
    const t = this.tracksInGroup, n = this.selectDefaultTrack;
    for (let i = 0; i < t.length; i++) {
      const s = t[i];
      if (!(n && !s.default || !n && !e) && (!e || ci(s, e)))
        return i;
    }
    if (e) {
      for (let i = 0; i < t.length; i++) {
        const s = t[i];
        if (aa(e.attrs, s.attrs, ["LANGUAGE", "ASSOC-LANGUAGE", "CHARACTERISTICS"]))
          return i;
      }
      for (let i = 0; i < t.length; i++) {
        const s = t[i];
        if (aa(e.attrs, s.attrs, ["LANGUAGE"]))
          return i;
      }
    }
    return -1;
  }
  findTrackForTextTrack(e) {
    if (e) {
      const t = this.tracksInGroup;
      for (let n = 0; n < t.length; n++) {
        const i = t[n];
        if (If(i, e))
          return n;
      }
    }
    return -1;
  }
  onError(e, t) {
    t.fatal || !t.context || t.context.type === me.SUBTITLE_TRACK && t.context.id === this.trackId && (!this.groupIds || this.groupIds.indexOf(t.context.groupId) !== -1) && this.checkRetry(t);
  }
  get allSubtitleTracks() {
    return this.tracks;
  }
  /** get alternate subtitle tracks list from playlist **/
  get subtitleTracks() {
    return this.tracksInGroup;
  }
  /** get/set index of the selected subtitle track (based on index in subtitle track lists) **/
  get subtitleTrack() {
    return this.trackId;
  }
  set subtitleTrack(e) {
    this.selectDefaultTrack = !1, this.setSubtitleTrack(e);
  }
  setSubtitleOption(e) {
    if (this.hls.config.subtitlePreference = e, e) {
      if (e.id === -1)
        return this.setSubtitleTrack(-1), null;
      const t = this.allSubtitleTracks;
      if (this.selectDefaultTrack = !1, t.length) {
        const n = this.currentTrack;
        if (n && ci(e, n))
          return n;
        const i = Mr(e, this.tracksInGroup);
        if (i > -1) {
          const s = this.tracksInGroup[i];
          return this.setSubtitleTrack(i), s;
        } else {
          if (n)
            return null;
          {
            const s = Mr(e, t);
            if (s > -1)
              return t[s];
          }
        }
      }
    }
    return null;
  }
  loadPlaylist(e) {
    super.loadPlaylist(), this.shouldLoadPlaylist(this.currentTrack) && this.scheduleLoading(this.currentTrack, e);
  }
  loadingPlaylist(e, t) {
    super.loadingPlaylist(e, t);
    const n = e.id, i = e.groupId, s = this.getUrlWithDirectives(e.url, t), a = e.details, o = a == null ? void 0 : a.age;
    this.log(`Loading subtitle ${n} "${e.name}" lang:${e.lang} group:${i}${(t == null ? void 0 : t.msn) !== void 0 ? " at sn " + t.msn + " part " + t.part : ""}${o && a.live ? " age " + o.toFixed(1) + (a.type && " " + a.type || "") : ""} ${s}`), this.hls.trigger(E.SUBTITLE_TRACK_LOADING, {
      url: s,
      id: n,
      groupId: i,
      deliveryDirectives: t || null,
      track: e
    });
  }
  /**
   * Disables the old subtitleTrack and sets current mode on the next subtitleTrack.
   * This operates on the DOM textTracks.
   * A value of -1 will disable all subtitle tracks.
   */
  toggleTrackModes() {
    const {
      media: e
    } = this;
    if (!e)
      return;
    const t = So(e.textTracks), n = this.currentTrack;
    let i;
    if (n && (i = t.filter((s) => If(n, s))[0], i || this.warn(`Unable to find subtitle TextTrack with name "${n.name}" and language "${n.lang}"`)), [].slice.call(t).forEach((s) => {
      s.mode !== "disabled" && s !== i && (s.mode = "disabled");
    }), i) {
      const s = this.subtitleDisplay ? "showing" : "hidden";
      i.mode !== s && (i.mode = s);
    }
  }
  /**
   * This method is responsible for validating the subtitle index and periodically reloading if live.
   * Dispatches the SUBTITLE_TRACK_SWITCH event, which instructs the subtitle-stream-controller to load the selected track.
   */
  setSubtitleTrack(e) {
    const t = this.tracksInGroup;
    if (!this.media) {
      this.queuedDefaultTrack = e;
      return;
    }
    if (e < -1 || e >= t.length || !X(e)) {
      this.warn(`Invalid subtitle track id: ${e}`);
      return;
    }
    this.selectDefaultTrack = !1;
    const n = this.currentTrack, i = t[e] || null;
    if (this.trackId = e, this.currentTrack = i, this.toggleTrackModes(), !i) {
      this.hls.trigger(E.SUBTITLE_TRACK_SWITCH, {
        id: e
      });
      return;
    }
    const s = !!i.details && !i.details.live;
    if (e === this.trackId && i === n && s)
      return;
    this.log(`Switching to subtitle-track ${e}` + (i ? ` "${i.name}" lang:${i.lang} group:${i.groupId}` : ""));
    const {
      id: a,
      groupId: o = "",
      name: c,
      type: l,
      url: u
    } = i;
    this.hls.trigger(E.SUBTITLE_TRACK_SWITCH, {
      id: a,
      groupId: o,
      name: c,
      type: l,
      url: u
    });
    const d = this.switchParams(i.url, n == null ? void 0 : n.details, i.details);
    this.loadPlaylist(d);
  }
}
function j8() {
  try {
    return crypto.randomUUID();
  } catch {
    try {
      const e = URL.createObjectURL(new Blob()), t = e.toString();
      return URL.revokeObjectURL(e), t.slice(t.lastIndexOf("/") + 1);
    } catch {
      let t = (/* @__PURE__ */ new Date()).getTime();
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (i) => {
        const s = (t + Math.random() * 16) % 16 | 0;
        return t = Math.floor(t / 16), (i == "x" ? s : s & 3 | 8).toString(16);
      });
    }
  }
}
function js(r) {
  let e = 5381, t = r.length;
  for (; t; )
    e = e * 33 ^ r.charCodeAt(--t);
  return (e >>> 0).toString();
}
const Ui = 0.025;
let gl = /* @__PURE__ */ function(r) {
  return r[r.Point = 0] = "Point", r[r.Range = 1] = "Range", r;
}({});
function U8(r, e, t) {
  return `${r.identifier}-${t + 1}-${js(e)}`;
}
class G8 {
  constructor(e, t) {
    this.base = void 0, this._duration = null, this._timelineStart = null, this.appendInPlaceDisabled = void 0, this.appendInPlaceStarted = void 0, this.dateRange = void 0, this.hasPlayed = !1, this.cumulativeDuration = 0, this.resumeOffset = NaN, this.playoutLimit = NaN, this.restrictions = {
      skip: !1,
      jump: !1
    }, this.snapOptions = {
      out: !1,
      in: !1
    }, this.assetList = [], this.assetListLoader = void 0, this.assetListResponse = null, this.resumeAnchor = void 0, this.error = void 0, this.resetOnResume = void 0, this.base = t, this.dateRange = e, this.setDateRange(e);
  }
  setDateRange(e) {
    this.dateRange = e, this.resumeOffset = e.attr.optionalFloat("X-RESUME-OFFSET", this.resumeOffset), this.playoutLimit = e.attr.optionalFloat("X-PLAYOUT-LIMIT", this.playoutLimit), this.restrictions = e.attr.enumeratedStringList("X-RESTRICT", this.restrictions), this.snapOptions = e.attr.enumeratedStringList("X-SNAP", this.snapOptions);
  }
  reset() {
    var e;
    this.appendInPlaceStarted = !1, (e = this.assetListLoader) == null || e.destroy(), this.assetListLoader = void 0, this.supplementsPrimary || (this.assetListResponse = null, this.assetList = [], this._duration = null);
  }
  isAssetPastPlayoutLimit(e) {
    var t;
    if (e > 0 && e >= this.assetList.length)
      return !0;
    const n = this.playoutLimit;
    return e <= 0 || isNaN(n) ? !1 : n === 0 ? !0 : (((t = this.assetList[e]) == null ? void 0 : t.startOffset) || 0) > n;
  }
  findAssetIndex(e) {
    return this.assetList.indexOf(e);
  }
  get identifier() {
    return this.dateRange.id;
  }
  get startDate() {
    return this.dateRange.startDate;
  }
  get startTime() {
    const e = this.dateRange.startTime;
    if (this.snapOptions.out) {
      const t = this.dateRange.tagAnchor;
      if (t)
        return sd(e, t);
    }
    return e;
  }
  get startOffset() {
    return this.cue.pre ? 0 : this.startTime;
  }
  get startIsAligned() {
    if (this.startTime === 0 || this.snapOptions.out)
      return !0;
    const e = this.dateRange.tagAnchor;
    if (e) {
      const t = this.dateRange.startTime, n = sd(t, e);
      return t - n < 0.1;
    }
    return !1;
  }
  get resumptionOffset() {
    const e = this.resumeOffset, t = X(e) ? e : this.duration;
    return this.cumulativeDuration + t;
  }
  get resumeTime() {
    const e = this.startOffset + this.resumptionOffset;
    if (this.snapOptions.in) {
      const t = this.resumeAnchor;
      if (t)
        return sd(e, t);
    }
    return e;
  }
  get appendInPlace() {
    return this.appendInPlaceStarted ? !0 : this.appendInPlaceDisabled ? !1 : !!(!this.cue.once && !this.cue.pre && // preroll starts at startPosition before startPosition is known (live)
    this.startIsAligned && (isNaN(this.playoutLimit) && isNaN(this.resumeOffset) || this.resumeOffset && this.duration && Math.abs(this.resumeOffset - this.duration) < Ui));
  }
  set appendInPlace(e) {
    if (this.appendInPlaceStarted) {
      this.resetOnResume = !e;
      return;
    }
    this.appendInPlaceDisabled = !e;
  }
  // Extended timeline start time
  get timelineStart() {
    return this._timelineStart !== null ? this._timelineStart : this.startTime;
  }
  set timelineStart(e) {
    this._timelineStart = e;
  }
  get duration() {
    const e = this.playoutLimit;
    let t;
    return this._duration !== null ? t = this._duration : this.dateRange.duration ? t = this.dateRange.duration : t = this.dateRange.plannedDuration || 0, !isNaN(e) && e < t && (t = e), t;
  }
  set duration(e) {
    this._duration = e;
  }
  get cue() {
    return this.dateRange.cue;
  }
  get timelineOccupancy() {
    return this.dateRange.attr["X-TIMELINE-OCCUPIES"] === "RANGE" ? gl.Range : gl.Point;
  }
  get supplementsPrimary() {
    return this.dateRange.attr["X-TIMELINE-STYLE"] === "PRIMARY";
  }
  get contentMayVary() {
    return this.dateRange.attr["X-CONTENT-MAY-VARY"] !== "NO";
  }
  get assetUrl() {
    return this.dateRange.attr["X-ASSET-URI"];
  }
  get assetListUrl() {
    return this.dateRange.attr["X-ASSET-LIST"];
  }
  get baseUrl() {
    return this.base.url;
  }
  get assetListLoaded() {
    return this.assetList.length > 0 || this.assetListResponse !== null;
  }
  toString() {
    return K8(this);
  }
}
function sd(r, e) {
  return r - e.start < e.duration / 2 && !(Math.abs(r - (e.start + e.duration)) < Ui) ? e.start : e.start + e.duration;
}
function Gw(r, e, t) {
  const n = new self.URL(r, t);
  return n.protocol !== "data:" && n.searchParams.set("_HLS_primary_id", e), n;
}
function ad(r, e) {
  for (; (t = r.assetList[++e]) != null && t.error; )
    var t;
  return e;
}
function K8(r) {
  return `["${r.identifier}" ${r.cue.pre ? "<pre>" : r.cue.post ? "<post>" : ""}${r.timelineStart.toFixed(2)}-${r.resumeTime.toFixed(2)}]`;
}
function Ri(r) {
  const e = r.timelineStart, t = r.duration || 0;
  return `["${r.identifier}" ${e.toFixed(2)}-${(e + t).toFixed(2)}]`;
}
class V8 {
  constructor(e, t, n, i) {
    this.hls = void 0, this.interstitial = void 0, this.assetItem = void 0, this.tracks = null, this.hasDetails = !1, this.mediaAttached = null, this._currentTime = void 0, this._bufferedEosTime = void 0, this.checkPlayout = () => {
      this.reachedPlayout(this.currentTime) && this.hls.trigger(E.PLAYOUT_LIMIT_REACHED, {});
    };
    const s = this.hls = new e(t);
    this.interstitial = n, this.assetItem = i;
    let a = i.uri;
    try {
      a = Gw(a, t.primarySessionId).href;
    } catch {
    }
    s.loadSource(a);
    const o = () => {
      this.hasDetails = !0;
    };
    s.once(E.LEVEL_LOADED, o), s.once(E.AUDIO_TRACK_LOADED, o), s.once(E.SUBTITLE_TRACK_LOADED, o), s.on(E.MEDIA_ATTACHING, (c, {
      media: l
    }) => {
      this.removeMediaListeners(), this.mediaAttached = l, this.interstitial.playoutLimit && (l.addEventListener("timeupdate", this.checkPlayout), this.appendInPlace && s.on(E.BUFFER_APPENDED, () => {
        const d = this.bufferedEnd;
        this.reachedPlayout(d) && (this._bufferedEosTime = d, s.trigger(E.BUFFERED_TO_END, void 0));
      }));
    });
  }
  get appendInPlace() {
    var e;
    return ((e = this.interstitial) == null ? void 0 : e.appendInPlace) || !1;
  }
  bufferedInPlaceToEnd(e) {
    var t;
    if (!this.appendInPlace)
      return !1;
    if ((t = this.hls) != null && t.bufferedToEnd)
      return !0;
    if (!e || !this._bufferedEosTime)
      return !1;
    const n = this.timelineOffset, i = ue.bufferInfo(e, n, 0);
    return this.getAssetTime(i.end) >= this._bufferedEosTime - 0.02;
  }
  reachedPlayout(e) {
    const n = this.interstitial.playoutLimit;
    return this.startOffset + e >= n;
  }
  get destroyed() {
    var e;
    return !((e = this.hls) != null && e.userConfig);
  }
  get assetId() {
    return this.assetItem.identifier;
  }
  get interstitialId() {
    return this.assetItem.parentIdentifier;
  }
  get media() {
    var e;
    return ((e = this.hls) == null ? void 0 : e.media) || null;
  }
  get bufferedEnd() {
    const e = this.media || this.mediaAttached;
    if (!e)
      return this._bufferedEosTime ? this._bufferedEosTime : this.currentTime;
    const t = ue.bufferInfo(e, e.currentTime, 1e-3);
    return this.getAssetTime(t.end);
  }
  get currentTime() {
    const e = this.media || this.mediaAttached;
    return e ? this.getAssetTime(e.currentTime) : this._currentTime || 0;
  }
  get duration() {
    const e = this.assetItem.duration;
    return e || 0;
  }
  get remaining() {
    const e = this.duration;
    return e ? Math.max(0, e - this.currentTime) : 0;
  }
  get startOffset() {
    return this.assetItem.startOffset;
  }
  get timelineOffset() {
    var e;
    return ((e = this.hls) == null ? void 0 : e.config.timelineOffset) || 0;
  }
  set timelineOffset(e) {
    const t = this.timelineOffset;
    if (e !== t) {
      const n = e - t;
      if (Math.abs(n) > 1 / 9e4) {
        if (this.hasDetails)
          throw new Error("Cannot set timelineOffset after playlists are loaded");
        this.hls.config.timelineOffset = e;
      }
    }
  }
  getAssetTime(e) {
    const t = this.timelineOffset, n = this.duration;
    return Math.min(Math.max(0, e - t), n);
  }
  removeMediaListeners() {
    const e = this.mediaAttached;
    e && (this._currentTime = e.currentTime, this.bufferSnapShot(), e.removeEventListener("timeupdate", this.checkPlayout));
  }
  bufferSnapShot() {
    if (this.mediaAttached) {
      var e;
      (e = this.hls) != null && e.bufferedToEnd && (this._bufferedEosTime = this.bufferedEnd);
    }
  }
  destroy() {
    this.removeMediaListeners(), this.hls.destroy(), this.hls = this.interstitial = null, this.tracks = this.mediaAttached = this.checkPlayout = null;
  }
  attachMedia(e) {
    this.hls.attachMedia(e);
  }
  detachMedia() {
    this.removeMediaListeners(), this.mediaAttached = null, this.hls.detachMedia();
  }
  resumeBuffering() {
    this.hls.resumeBuffering();
  }
  pauseBuffering() {
    this.hls.pauseBuffering();
  }
  transferMedia() {
    return this.bufferSnapShot(), this.hls.transferMedia();
  }
  resetDetails() {
    const e = this.hls;
    if (this.hasDetails) {
      e.stopLoad();
      const t = (n) => delete n.details;
      e.levels.forEach(t), e.allAudioTracks.forEach(t), e.allSubtitleTracks.forEach(t), this.hasDetails = !1;
    }
  }
  on(e, t, n) {
    this.hls.on(e, t);
  }
  once(e, t, n) {
    this.hls.once(e, t);
  }
  off(e, t, n) {
    this.hls.off(e, t);
  }
  toString() {
    var e;
    return `HlsAssetPlayer: ${Ri(this.assetItem)} ${(e = this.hls) == null ? void 0 : e.sessionId} ${this.appendInPlace ? "append-in-place" : ""}`;
  }
}
const Pb = 0.033;
class W8 extends Or {
  constructor(e, t) {
    super("interstitials-sched", t), this.onScheduleUpdate = void 0, this.eventMap = {}, this.events = null, this.items = null, this.durations = {
      primary: 0,
      playout: 0,
      integrated: 0
    }, this.onScheduleUpdate = e;
  }
  destroy() {
    this.reset(), this.onScheduleUpdate = null;
  }
  reset() {
    this.eventMap = {}, this.setDurations(0, 0, 0), this.events && this.events.forEach((e) => e.reset()), this.events = this.items = null;
  }
  resetErrorsInRange(e, t) {
    return this.events ? this.events.reduce((n, i) => e <= i.startOffset && t > i.startOffset ? (delete i.error, n + 1) : n, 0) : 0;
  }
  get duration() {
    const e = this.items;
    return e ? e[e.length - 1].end : 0;
  }
  get length() {
    return this.items ? this.items.length : 0;
  }
  getEvent(e) {
    return e && this.eventMap[e] || null;
  }
  hasEvent(e) {
    return e in this.eventMap;
  }
  findItemIndex(e, t) {
    if (e.event)
      return this.findEventIndex(e.event.identifier);
    let n = -1;
    e.nextEvent ? n = this.findEventIndex(e.nextEvent.identifier) - 1 : e.previousEvent && (n = this.findEventIndex(e.previousEvent.identifier) + 1);
    const i = this.items;
    if (i)
      for (i[n] || (t === void 0 && (t = e.start), n = this.findItemIndexAtTime(t)); n >= 0 && (s = i[n]) != null && s.event; ) {
        var s;
        n--;
      }
    return n;
  }
  findItemIndexAtTime(e, t) {
    const n = this.items;
    if (n)
      for (let i = 0; i < n.length; i++) {
        let s = n[i];
        if (t && t !== "primary" && (s = s[t]), e === s.start || e > s.start && e < s.end)
          return i;
      }
    return -1;
  }
  findJumpRestrictedIndex(e, t) {
    const n = this.items;
    if (n)
      for (let i = e; i <= t && n[i]; i++) {
        const s = n[i].event;
        if (s != null && s.restrictions.jump && !s.appendInPlace)
          return i;
      }
    return -1;
  }
  findEventIndex(e) {
    const t = this.items;
    if (t)
      for (let i = t.length; i--; ) {
        var n;
        if (((n = t[i].event) == null ? void 0 : n.identifier) === e)
          return i;
      }
    return -1;
  }
  findAssetIndex(e, t) {
    const n = e.assetList, i = n.length;
    if (i > 1)
      for (let s = 0; s < i; s++) {
        const a = n[s];
        if (!a.error) {
          const o = a.timelineStart;
          if (t === o || t > o && t < o + (a.duration || 0))
            return s;
        }
      }
    return 0;
  }
  get assetIdAtEnd() {
    var e, t;
    const n = (e = this.items) == null || (t = e[this.length - 1]) == null ? void 0 : t.event;
    if (n) {
      const i = n.assetList, s = i[i.length - 1];
      if (s)
        return s.identifier;
    }
    return null;
  }
  parseInterstitialDateRanges(e, t) {
    const n = e.main.details, {
      dateRanges: i
    } = n, s = this.events, a = this.parseDateRanges(i, {
      url: n.url
    }, t), o = Object.keys(i), c = s ? s.filter((l) => !o.includes(l.identifier)) : [];
    a.length && a.sort((l, u) => {
      const d = l.cue.pre, f = l.cue.post, h = u.cue.pre, g = u.cue.post;
      if (d && !h)
        return -1;
      if (h && !d || f && !g)
        return 1;
      if (g && !f)
        return -1;
      if (!d && !h && !f && !g) {
        const m = l.startTime, p = u.startTime;
        if (m !== p)
          return m - p;
      }
      return l.dateRange.tagOrder - u.dateRange.tagOrder;
    }), this.events = a, c.forEach((l) => {
      this.removeEvent(l);
    }), this.updateSchedule(e, c);
  }
  updateSchedule(e, t = []) {
    const n = this.events || [];
    if (n.length || t.length || this.length < 2) {
      const i = this.items, s = this.parseSchedule(n, e);
      (t.length || (i == null ? void 0 : i.length) !== s.length || s.some((o, c) => Math.abs(o.playout.start - i[c].playout.start) > 5e-3 || Math.abs(o.playout.end - i[c].playout.end) > 5e-3)) && (this.items = s, this.onScheduleUpdate(t, i));
    }
  }
  parseDateRanges(e, t, n) {
    const i = [], s = Object.keys(e);
    for (let a = 0; a < s.length; a++) {
      const o = s[a], c = e[o];
      if (c.isInterstitial) {
        let l = this.eventMap[o];
        l ? l.setDateRange(c) : (l = new G8(c, t), this.eventMap[o] = l, n === !1 && (l.appendInPlace = n)), i.push(l);
      }
    }
    return i;
  }
  parseSchedule(e, t) {
    const n = [], i = t.main.details, s = i.live ? 1 / 0 : i.edge;
    let a = 0;
    if (e = e.filter((c) => !c.error && !(c.cue.once && c.hasPlayed)), e.length) {
      this.resolveOffsets(e, t);
      let c = 0, l = 0;
      if (e.forEach((u, d) => {
        const f = u.cue.pre, h = u.cue.post, g = e[d - 1] || null, m = u.appendInPlace, p = h ? s : u.startOffset, v = u.duration, y = u.timelineOccupancy === gl.Range ? v : 0, b = u.resumptionOffset, x = (g == null ? void 0 : g.startTime) === p, S = p + u.cumulativeDuration;
        let A = m ? S + v : p + b;
        if (f || !h && p <= 0) {
          const I = l;
          l += y, u.timelineStart = S;
          const L = a;
          a += v, n.push({
            event: u,
            start: S,
            end: A,
            playout: {
              start: L,
              end: a
            },
            integrated: {
              start: I,
              end: l
            }
          });
        } else if (p <= s) {
          if (!x) {
            const _ = p - c;
            if (_ > Pb) {
              const R = c, D = l;
              l += _;
              const F = a;
              a += _;
              const B = {
                previousEvent: e[d - 1] || null,
                nextEvent: u,
                start: R,
                end: R + _,
                playout: {
                  start: F,
                  end: a
                },
                integrated: {
                  start: D,
                  end: l
                }
              };
              n.push(B);
            } else _ > 0 && g && (g.cumulativeDuration += _, n[n.length - 1].end = p);
          }
          h && (A = S), u.timelineStart = S;
          const I = l;
          l += y;
          const L = a;
          a += v, n.push({
            event: u,
            start: S,
            end: A,
            playout: {
              start: L,
              end: a
            },
            integrated: {
              start: I,
              end: l
            }
          });
        } else
          return;
        const T = u.resumeTime;
        h || T > s ? c = s : c = T;
      }), c < s) {
        var o;
        const u = c, d = l, f = s - c;
        l += f;
        const h = a;
        a += f, n.push({
          previousEvent: ((o = n[n.length - 1]) == null ? void 0 : o.event) || null,
          nextEvent: null,
          start: c,
          end: u + f,
          playout: {
            start: h,
            end: a
          },
          integrated: {
            start: d,
            end: l
          }
        });
      }
      this.setDurations(s, a, l);
    } else
      n.push({
        previousEvent: null,
        nextEvent: null,
        start: 0,
        end: s,
        playout: {
          start: 0,
          end: s
        },
        integrated: {
          start: 0,
          end: s
        }
      }), this.setDurations(s, s, s);
    return n;
  }
  setDurations(e, t, n) {
    this.durations = {
      primary: e,
      playout: t,
      integrated: n
    };
  }
  resolveOffsets(e, t) {
    const n = t.main.details, i = n.live ? 1 / 0 : n.edge;
    let s = 0, a = -1;
    e.forEach((o, c) => {
      const l = o.cue.pre, u = o.cue.post, d = l ? 0 : u ? i : o.startTime;
      this.updateAssetDurations(o), a === d ? o.cumulativeDuration = s : (s = 0, a = d), !u && o.snapOptions.in && (o.resumeAnchor = mi(null, n.fragments, o.startOffset + o.resumptionOffset, 0, 0) || void 0), o.appendInPlace && !o.appendInPlaceStarted && (this.primaryCanResumeInPlaceAt(o, t) || (o.appendInPlace = !1)), !o.appendInPlace && c + 1 < e.length && e[c + 1].startTime - e[c].resumeTime < Pb && (e[c + 1].appendInPlace = !1, e[c + 1].appendInPlace && this.warn(`Could not change append strategy for abutting event ${o}`));
      const h = X(o.resumeOffset) ? o.resumeOffset : o.duration;
      s += h;
    });
  }
  primaryCanResumeInPlaceAt(e, t) {
    const n = e.resumeTime, i = e.startTime + e.resumptionOffset;
    return Math.abs(n - i) > Ui ? (this.log(`"${e.identifier}" resumption ${n} not aligned with estimated timeline end ${i}`), !1) : t ? !Object.keys(t).some((a) => {
      const o = t[a].details, c = o.edge;
      if (n >= c)
        return this.log(`"${e.identifier}" resumption ${n} past ${a} playlist end ${c}`), !1;
      const l = mi(null, o.fragments, n);
      if (!l)
        return this.log(`"${e.identifier}" resumption ${n} does not align with any fragments in ${a} playlist (${o.fragStart}-${o.fragmentEnd})`), !0;
      const u = a === "audio" ? 0.175 : 0;
      return Math.abs(l.start - n) < Ui + u || Math.abs(l.end - n) < Ui + u ? !1 : (this.log(`"${e.identifier}" resumption ${n} not aligned with ${a} fragment bounds (${l.start}-${l.end} sn: ${l.sn} cc: ${l.cc})`), !0);
    }) : (this.log(`"${e.identifier}" resumption ${n} can not be aligned with media (none selected)`), !1);
  }
  updateAssetDurations(e) {
    if (!e.assetListLoaded)
      return;
    const t = e.timelineStart;
    let n = 0, i = !1, s = !1;
    e.assetList.forEach((a, o) => {
      const c = t + n;
      a.startOffset = n, a.timelineStart = c, i || (i = a.duration === null), s || (s = !!a.error);
      const l = a.error ? 0 : a.duration || 0;
      n += l;
    }), i && !s ? e.duration = Math.max(n, e.duration) : e.duration = n;
  }
  removeEvent(e) {
    e.reset(), delete this.eventMap[e.identifier];
  }
}
function wn(r) {
  return `[${r.event ? '"' + r.event.identifier + '"' : "primary"}: ${r.start.toFixed(2)}-${r.end.toFixed(2)}]`;
}
class H8 {
  constructor(e) {
    this.hls = void 0, this.hls = e;
  }
  destroy() {
    this.hls = null;
  }
  loadAssetList(e, t) {
    const n = e.assetListUrl;
    let i;
    try {
      i = Gw(n, this.hls.sessionId, e.baseUrl);
    } catch (f) {
      const h = this.assignAssetListError(e, k.ASSET_LIST_LOAD_ERROR, f, n);
      this.hls.trigger(E.ERROR, h);
      return;
    }
    t && i.protocol !== "data:" && i.searchParams.set("_HLS_start_offset", "" + t);
    const s = this.hls.config, a = s.loader, o = new a(s), c = {
      responseType: "json",
      url: i.href
    }, l = s.interstitialAssetListLoadPolicy.default, u = {
      loadPolicy: l,
      timeout: l.maxLoadTimeMs,
      maxRetry: 0,
      retryDelay: 0,
      maxRetryDelay: 0
    }, d = {
      onSuccess: (f, h, g, m) => {
        const p = f.data, v = p == null ? void 0 : p.ASSETS;
        if (!Array.isArray(v)) {
          const y = this.assignAssetListError(e, k.ASSET_LIST_PARSING_ERROR, new Error("Invalid interstitial asset list"), g.url, h, m);
          this.hls.trigger(E.ERROR, y);
          return;
        }
        e.assetListResponse = p, this.hls.trigger(E.ASSET_LIST_LOADED, {
          event: e,
          assetListResponse: p,
          networkDetails: m
        });
      },
      onError: (f, h, g, m) => {
        const p = this.assignAssetListError(e, k.ASSET_LIST_LOAD_ERROR, new Error(`Error loading X-ASSET-LIST: HTTP status ${f.code} ${f.text} (${h.url})`), h.url, m, g);
        this.hls.trigger(E.ERROR, p);
      },
      onTimeout: (f, h, g) => {
        const m = this.assignAssetListError(e, k.ASSET_LIST_LOAD_TIMEOUT, new Error(`Timeout loading X-ASSET-LIST (${h.url})`), h.url, f, g);
        this.hls.trigger(E.ERROR, m);
      }
    };
    return o.load(c, u, d), this.hls.trigger(E.ASSET_LIST_LOADING, {
      event: e
    }), o;
  }
  assignAssetListError(e, t, n, i, s, a) {
    return e.error = n, {
      type: ne.NETWORK_ERROR,
      details: t,
      fatal: !1,
      interstitial: e,
      url: i,
      error: n,
      networkDetails: a,
      stats: s
    };
  }
}
function _b(r) {
  r == null || r.play().catch(() => {
  });
}
class q8 extends Or {
  constructor(e, t) {
    super("interstitials", e.logger), this.HlsPlayerClass = void 0, this.hls = void 0, this.assetListLoader = void 0, this.mediaSelection = null, this.altSelection = null, this.media = null, this.detachedData = null, this.requiredTracks = null, this.manager = null, this.playerQueue = [], this.bufferedPos = -1, this.timelinePos = -1, this.schedule = void 0, this.playingItem = null, this.bufferingItem = null, this.waitingItem = null, this.endedItem = null, this.playingAsset = null, this.endedAsset = null, this.bufferingAsset = null, this.shouldPlay = !1, this.onPlay = () => {
      this.shouldPlay = !0;
    }, this.onPause = () => {
      this.shouldPlay = !1;
    }, this.onSeeking = () => {
      const n = this.currentTime;
      if (n === void 0 || this.playbackDisabled)
        return;
      const i = n - this.timelinePos;
      if (Math.abs(i) < 1 / 7056e5)
        return;
      const a = i <= -0.01;
      this.timelinePos = n, this.bufferedPos = n;
      const o = this.playingItem;
      if (!o) {
        this.checkBuffer();
        return;
      }
      if (a && this.schedule.resetErrorsInRange(n, n - i) && this.updateSchedule(), this.checkBuffer(), a && n < o.start || n >= o.end) {
        var c;
        const f = this.schedule.findItemIndexAtTime(this.timelinePos);
        if (!this.isInterstitial(o) && (c = this.media) != null && c.paused && (this.shouldPlay = !1), !a) {
          const h = this.findItemIndex(o);
          if (f > h) {
            const g = this.schedule.findJumpRestrictedIndex(h + 1, f);
            if (g > h) {
              this.setSchedulePosition(g);
              return;
            }
          }
        }
        this.setSchedulePosition(f);
        return;
      }
      const l = this.playingAsset;
      if (!l) {
        if (this.playingLastItem && this.isInterstitial(o)) {
          const f = o.event.assetList[0];
          f && (this.endedItem = this.playingItem, this.playingItem = null, this.setScheduleToAssetAtTime(n, f));
        }
        return;
      }
      const u = l.timelineStart, d = l.duration || 0;
      (a && n < u || n >= u + d) && this.setScheduleToAssetAtTime(n, l);
    }, this.onTimeupdate = () => {
      const n = this.currentTime;
      if (n === void 0 || this.playbackDisabled)
        return;
      if (n > this.timelinePos)
        this.timelinePos = n, n > this.bufferedPos && this.checkBuffer();
      else
        return;
      const i = this.playingItem;
      if (!i || this.playingLastItem)
        return;
      if (n >= i.end) {
        this.timelinePos = i.end;
        const o = this.findItemIndex(i);
        this.setSchedulePosition(o + 1);
      }
      const s = this.playingAsset;
      if (!s)
        return;
      const a = s.timelineStart + (s.duration || 0);
      n >= a && this.setScheduleToAssetAtTime(n, s);
    }, this.onScheduleUpdate = (n, i) => {
      const s = this.schedule, a = this.playingItem, o = s.events || [], c = s.items || [], l = s.durations, u = n.map((g) => g.identifier), d = !!(o.length || u.length);
      (d || i) && this.log(`INTERSTITIALS_UPDATED (${o.length}): ${o}
Schedule: ${c.map((g) => wn(g))} pos: ${this.timelinePos}`), u.length && this.log(`Removed events ${u}`), this.playerQueue.forEach((g) => {
        if (g.interstitial.appendInPlace) {
          const m = g.assetItem.timelineStart, p = g.timelineOffset - m;
          if (p)
            try {
              g.timelineOffset = m;
            } catch (v) {
              Math.abs(p) > Ui && this.warn(`${v} ("${g.assetId}" ${g.timelineOffset}->${m})`);
            }
        }
      });
      let f = null;
      if (a) {
        const g = this.updateItem(a, this.timelinePos);
        this.itemsMatch(a, g) && (this.playingItem = g, this.waitingItem = this.endedItem = null, f = () => this.trimInPlace(g, a));
      } else
        this.waitingItem = this.updateItem(this.waitingItem), this.endedItem = this.updateItem(this.endedItem);
      const h = this.bufferingItem;
      if (h) {
        const g = this.updateItem(h, this.bufferedPos);
        this.itemsMatch(h, g) ? (this.bufferingItem = g, f || (f = () => this.trimInPlace(g, h))) : h.event && (this.bufferingItem = this.playingItem, this.clearInterstitial(h.event, null));
      }
      if (n.forEach((g) => {
        g.assetList.forEach((m) => {
          this.clearAssetPlayer(m.identifier, null);
        });
      }), d || i) {
        if (this.hls.trigger(E.INTERSTITIALS_UPDATED, {
          events: o.slice(0),
          schedule: c.slice(0),
          durations: l,
          removedIds: u
        }), this.isInterstitial(a) && u.includes(a.event.identifier)) {
          this.warn(`Interstitial "${a.event.identifier}" removed while playing`), this.primaryFallback(a.event);
          return;
        }
        f && f(), this.checkBuffer();
      }
    }, this.hls = e, this.HlsPlayerClass = t, this.assetListLoader = new H8(e), this.schedule = new W8(this.onScheduleUpdate, e.logger), this.registerListeners();
  }
  registerListeners() {
    const e = this.hls;
    e.on(E.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(E.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(E.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(E.MANIFEST_LOADING, this.onManifestLoading, this), e.on(E.LEVEL_UPDATED, this.onLevelUpdated, this), e.on(E.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on(E.AUDIO_TRACK_UPDATED, this.onAudioTrackUpdated, this), e.on(E.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.on(E.SUBTITLE_TRACK_UPDATED, this.onSubtitleTrackUpdated, this), e.on(E.EVENT_CUE_ENTER, this.onInterstitialCueEnter, this), e.on(E.ASSET_LIST_LOADED, this.onAssetListLoaded, this), e.on(E.BUFFER_APPENDED, this.onBufferAppended, this), e.on(E.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on(E.BUFFERED_TO_END, this.onBufferedToEnd, this), e.on(E.MEDIA_ENDED, this.onMediaEnded, this), e.on(E.ERROR, this.onError, this), e.on(E.DESTROYING, this.onDestroying, this);
  }
  unregisterListeners() {
    const e = this.hls;
    e && (e.off(E.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(E.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(E.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(E.MANIFEST_LOADING, this.onManifestLoading, this), e.off(E.LEVEL_UPDATED, this.onLevelUpdated, this), e.off(E.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off(E.AUDIO_TRACK_UPDATED, this.onAudioTrackUpdated, this), e.off(E.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.off(E.SUBTITLE_TRACK_UPDATED, this.onSubtitleTrackUpdated, this), e.off(E.EVENT_CUE_ENTER, this.onInterstitialCueEnter, this), e.off(E.ASSET_LIST_LOADED, this.onAssetListLoaded, this), e.off(E.BUFFER_CODECS, this.onBufferCodecs, this), e.off(E.BUFFER_APPENDED, this.onBufferAppended, this), e.off(E.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off(E.BUFFERED_TO_END, this.onBufferedToEnd, this), e.off(E.MEDIA_ENDED, this.onMediaEnded, this), e.off(E.ERROR, this.onError, this), e.off(E.DESTROYING, this.onDestroying, this));
  }
  startLoad() {
    this.resumeBuffering();
  }
  stopLoad() {
    this.pauseBuffering();
  }
  resumeBuffering() {
    var e;
    (e = this.getBufferingPlayer()) == null || e.resumeBuffering();
  }
  pauseBuffering() {
    var e;
    (e = this.getBufferingPlayer()) == null || e.pauseBuffering();
  }
  destroy() {
    this.unregisterListeners(), this.stopLoad(), this.assetListLoader && this.assetListLoader.destroy(), this.emptyPlayerQueue(), this.clearScheduleState(), this.schedule && this.schedule.destroy(), this.media = this.detachedData = this.mediaSelection = this.requiredTracks = this.altSelection = this.manager = null, this.hls = this.HlsPlayerClass = this.schedule = this.log = null, this.assetListLoader = null, this.onPlay = this.onPause = this.onSeeking = this.onTimeupdate = null, this.onScheduleUpdate = null;
  }
  onDestroying() {
    const e = this.primaryMedia || this.media;
    e && this.removeMediaListeners(e);
  }
  removeMediaListeners(e) {
    Pr(e, "play", this.onPlay), Pr(e, "pause", this.onPause), Pr(e, "seeking", this.onSeeking), Pr(e, "timeupdate", this.onTimeupdate);
  }
  onMediaAttaching(e, t) {
    const n = this.media = t.media;
    gr(n, "seeking", this.onSeeking), gr(n, "timeupdate", this.onTimeupdate), gr(n, "play", this.onPlay), gr(n, "pause", this.onPause);
  }
  onMediaAttached(e, t) {
    const n = this.effectivePlayingItem, i = this.detachedData;
    if (this.detachedData = null, n === null)
      this.checkStart();
    else if (!i) {
      this.clearScheduleState();
      const s = this.findItemIndex(n);
      this.setSchedulePosition(s);
    }
  }
  clearScheduleState() {
    this.playingItem = this.bufferingItem = this.waitingItem = this.endedItem = this.playingAsset = this.endedAsset = this.bufferingAsset = null;
  }
  onMediaDetaching(e, t) {
    const n = !!t.transferMedia, i = this.media;
    if (this.media = null, !n && (i && this.removeMediaListeners(i), this.detachedData)) {
      const s = this.getBufferingPlayer();
      s && (this.playingAsset = this.endedAsset = this.bufferingAsset = this.bufferingItem = this.waitingItem = this.detachedData = null, s.detachMedia()), this.shouldPlay = !1;
    }
  }
  get interstitialsManager() {
    if (!this.manager) {
      if (!this.hls)
        return null;
      const e = this, t = () => e.bufferingItem || e.waitingItem, n = (d) => d && e.getAssetPlayer(d.identifier), i = (d, f, h, g, m) => {
        if (d) {
          let p = d[f].start;
          const v = d.event;
          if (v) {
            if (f === "playout" || v.timelineOccupancy !== gl.Point) {
              const y = n(h);
              (y == null ? void 0 : y.interstitial) === v && (p += y.assetItem.startOffset + y[m]);
            }
          } else {
            const y = g === "bufferedPos" ? a() : e[g];
            p += y - d.start;
          }
          return p;
        }
        return 0;
      }, s = (d, f) => {
        if (d !== 0 && f !== "primary" && e.schedule.length) {
          var h;
          const g = e.schedule.findItemIndexAtTime(d), m = (h = e.schedule.items) == null ? void 0 : h[g];
          if (m) {
            const p = m[f].start - m.start;
            return d + p;
          }
        }
        return d;
      }, a = () => {
        const d = e.bufferedPos;
        return d === Number.MAX_VALUE ? o("primary") : Math.max(d, 0);
      }, o = (d) => {
        var f;
        return (f = e.primaryDetails) != null && f.live ? e.primaryDetails.edge : e.schedule.durations[d];
      }, c = (d, f) => {
        var h, g;
        const m = e.effectivePlayingItem;
        if (m != null && (h = m.event) != null && h.restrictions.skip)
          return;
        e.log(`seek to ${d} "${f}"`);
        const p = e.effectivePlayingItem, v = e.schedule.findItemIndexAtTime(d, f), y = (g = e.schedule.items) == null ? void 0 : g[v], b = e.getBufferingPlayer(), x = b == null ? void 0 : b.interstitial, S = x == null ? void 0 : x.appendInPlace, A = p && e.itemsMatch(p, y);
        if (p && (S || A)) {
          const I = n(e.playingAsset), L = (I == null ? void 0 : I.media) || e.primaryMedia;
          if (L) {
            const _ = f === "primary" ? L.currentTime : i(p, f, e.playingAsset, "timelinePos", "currentTime"), R = d - _, D = (S ? _ : L.currentTime) + R;
            if (D >= 0 && (!I || S || D <= I.duration)) {
              L.currentTime = D;
              return;
            }
          }
        }
        if (y) {
          let I = d;
          if (f !== "primary") {
            const _ = y[f].start, R = d - _;
            I = y.start + R;
          }
          const L = !e.isInterstitial(y);
          if ((!e.isInterstitial(p) || p.event.appendInPlace) && (L || y.event.appendInPlace)) {
            const _ = e.media || (S ? b == null ? void 0 : b.media : null);
            _ && (_.currentTime = I);
          } else if (p) {
            const _ = e.findItemIndex(p);
            if (v > _) {
              const D = e.schedule.findJumpRestrictedIndex(_ + 1, v);
              if (D > _) {
                e.setSchedulePosition(D);
                return;
              }
            }
            let R = 0;
            if (L)
              e.timelinePos = I, e.checkBuffer();
            else {
              var T;
              const D = y == null || (T = y.event) == null ? void 0 : T.assetList;
              if (D) {
                const F = d - (y[f] || y).start;
                for (let B = D.length; B--; ) {
                  const j = D[B];
                  if (j.duration && F >= j.startOffset && F < j.startOffset + j.duration) {
                    R = B;
                    break;
                  }
                }
              }
            }
            e.setSchedulePosition(v, R);
          }
        }
      }, l = () => {
        const d = e.effectivePlayingItem;
        if (e.isInterstitial(d))
          return d;
        const f = t();
        return e.isInterstitial(f) ? f : null;
      }, u = {
        get currentTime() {
          const d = l(), f = e.effectivePlayingItem;
          return f && f === d ? i(f, "playout", e.effectivePlayingAsset, "timelinePos", "currentTime") - f.playout.start : 0;
        },
        set currentTime(d) {
          const f = l(), h = e.effectivePlayingItem;
          h && h === f && c(d + h.playout.start, "playout");
        },
        get duration() {
          const d = l();
          return d ? d.playout.end - d.playout.start : 0;
        },
        get assetPlayers() {
          var d;
          const f = (d = l()) == null ? void 0 : d.event.assetList;
          return f ? f.map((h) => e.getAssetPlayer(h.identifier)) : [];
        },
        get playingIndex() {
          var d;
          const f = (d = l()) == null ? void 0 : d.event;
          return f && e.effectivePlayingAsset ? f.findAssetIndex(e.effectivePlayingAsset) : -1;
        },
        get scheduleItem() {
          return l();
        }
      };
      this.manager = {
        get events() {
          var d, f;
          return ((d = e.schedule) == null || (f = d.events) == null ? void 0 : f.slice(0)) || [];
        },
        get schedule() {
          var d, f;
          return ((d = e.schedule) == null || (f = d.items) == null ? void 0 : f.slice(0)) || [];
        },
        get interstitialPlayer() {
          return l() ? u : null;
        },
        get playerQueue() {
          return e.playerQueue.slice(0);
        },
        get bufferingAsset() {
          return e.bufferingAsset;
        },
        get bufferingItem() {
          return t();
        },
        get bufferingIndex() {
          const d = t();
          return e.findItemIndex(d);
        },
        get playingAsset() {
          return e.effectivePlayingAsset;
        },
        get playingItem() {
          return e.effectivePlayingItem;
        },
        get playingIndex() {
          const d = e.effectivePlayingItem;
          return e.findItemIndex(d);
        },
        primary: {
          get bufferedEnd() {
            return a();
          },
          get currentTime() {
            const d = e.timelinePos;
            return d > 0 ? d : 0;
          },
          set currentTime(d) {
            c(d, "primary");
          },
          get duration() {
            return o("primary");
          },
          get seekableStart() {
            var d;
            return ((d = e.primaryDetails) == null ? void 0 : d.fragmentStart) || 0;
          }
        },
        integrated: {
          get bufferedEnd() {
            return i(t(), "integrated", e.bufferingAsset, "bufferedPos", "bufferedEnd");
          },
          get currentTime() {
            return i(e.effectivePlayingItem, "integrated", e.effectivePlayingAsset, "timelinePos", "currentTime");
          },
          set currentTime(d) {
            c(d, "integrated");
          },
          get duration() {
            return o("integrated");
          },
          get seekableStart() {
            var d;
            return s(((d = e.primaryDetails) == null ? void 0 : d.fragmentStart) || 0, "integrated");
          }
        },
        skip: () => {
          const d = e.effectivePlayingItem, f = d == null ? void 0 : d.event;
          if (f && !f.restrictions.skip) {
            const h = e.findItemIndex(d);
            if (f.appendInPlace) {
              const g = d.playout.start + d.event.duration;
              c(g + 1e-3, "playout");
            } else
              e.advanceAfterAssetEnded(f, h, 1 / 0);
          }
        }
      };
    }
    return this.manager;
  }
  // Schedule getters
  get effectivePlayingItem() {
    return this.waitingItem || this.playingItem || this.endedItem;
  }
  get effectivePlayingAsset() {
    return this.playingAsset || this.endedAsset;
  }
  get playingLastItem() {
    var e;
    const t = this.playingItem, n = (e = this.schedule) == null ? void 0 : e.items;
    return !this.playbackStarted || !t || !n ? !1 : this.findItemIndex(t) === n.length - 1;
  }
  get playbackStarted() {
    return this.effectivePlayingItem !== null;
  }
  // Media getters and event callbacks
  get currentTime() {
    var e, t, n;
    if (this.mediaSelection === null)
      return;
    const i = this.waitingItem || this.playingItem;
    if (this.isInterstitial(i) && !i.event.appendInPlace)
      return;
    let s = this.media;
    !s && (e = this.bufferingItem) != null && (t = e.event) != null && t.appendInPlace && (s = this.primaryMedia);
    const a = (n = s) == null ? void 0 : n.currentTime;
    if (!(a === void 0 || !X(a)))
      return a;
  }
  get primaryMedia() {
    var e;
    return this.media || ((e = this.detachedData) == null ? void 0 : e.media) || null;
  }
  isInterstitial(e) {
    return !!(e != null && e.event);
  }
  retreiveMediaSource(e, t) {
    const n = this.getAssetPlayer(e);
    n && this.transferMediaFromPlayer(n, t);
  }
  transferMediaFromPlayer(e, t) {
    const n = e.interstitial.appendInPlace, i = e.media;
    if (n && i === this.primaryMedia) {
      if (this.bufferingAsset = null, (!t || this.isInterstitial(t) && !t.event.appendInPlace) && t && i) {
        this.detachedData = {
          media: i
        };
        return;
      }
      const s = e.transferMedia();
      this.log(`transfer MediaSource from ${e} ${We(s)}`), this.detachedData = s;
    } else t && i && (this.shouldPlay || (this.shouldPlay = !i.paused));
  }
  transferMediaTo(e, t) {
    var n, i;
    if (e.media === t)
      return;
    let s = null;
    const a = this.hls, o = e !== a, c = o && e.interstitial.appendInPlace, l = (n = this.detachedData) == null ? void 0 : n.mediaSource;
    let u;
    if (a.media)
      c && (s = a.transferMedia(), this.detachedData = s), u = "Primary";
    else if (l) {
      const h = this.getBufferingPlayer();
      h ? (s = h.transferMedia(), u = `${h}`) : u = "detached MediaSource";
    } else
      u = "detached media";
    if (!s) {
      if (l)
        s = this.detachedData, this.log(`using detachedData: MediaSource ${We(s)}`);
      else if (!this.detachedData || a.media === t) {
        const h = this.playerQueue;
        h.length > 1 && h.forEach((g) => {
          if (o && g.interstitial.appendInPlace !== c) {
            const m = g.interstitial;
            this.clearInterstitial(g.interstitial, null), m.appendInPlace = !1, m.appendInPlace && this.warn(`Could not change append strategy for queued assets ${m}`);
          }
        }), this.hls.detachMedia(), this.detachedData = {
          media: t
        };
      }
    }
    const d = s && "mediaSource" in s && ((i = s.mediaSource) == null ? void 0 : i.readyState) !== "closed", f = d && s ? s : t;
    if (this.log(`${d ? "transfering MediaSource" : "attaching media"} to ${o ? e : "Primary"} from ${u}`), f === s) {
      const h = o && e.assetId === this.schedule.assetIdAtEnd;
      f.overrides = {
        duration: this.schedule.duration,
        endOfStream: !o || h,
        cueRemoval: !o
      };
    }
    e.attachMedia(f);
  }
  onInterstitialCueEnter() {
    this.onTimeupdate();
  }
  // Scheduling methods
  checkStart() {
    const e = this.schedule, t = e.events;
    if (!t || this.playbackDisabled || !this.media)
      return;
    this.bufferedPos === -1 && (this.bufferedPos = 0);
    const n = this.timelinePos, i = this.effectivePlayingItem;
    if (n === -1) {
      const s = this.hls.startPosition;
      if (this.timelinePos = s, t.length && t[0].cue.pre) {
        const a = e.findEventIndex(t[0].identifier);
        this.setSchedulePosition(a);
      } else if (s >= 0 || !this.primaryLive) {
        const a = this.timelinePos = s > 0 ? s : 0, o = e.findItemIndexAtTime(a);
        this.setSchedulePosition(o);
      }
    } else if (i && !this.playingItem) {
      const s = e.findItemIndex(i);
      this.setSchedulePosition(s);
    }
  }
  advanceAfterAssetEnded(e, t, n) {
    const i = ad(e, n);
    if (!e.isAssetPastPlayoutLimit(i))
      this.setSchedulePosition(t, i);
    else {
      const s = this.schedule.items;
      if (s) {
        const a = t + 1, o = s.length;
        if (a >= o) {
          this.setSchedulePosition(-1);
          return;
        }
        const c = e.resumeTime;
        this.timelinePos < c && (this.timelinePos = c, this.checkBuffer()), this.setSchedulePosition(a);
      }
    }
  }
  setScheduleToAssetAtTime(e, t) {
    const n = this.schedule, i = t.parentIdentifier, s = n.getEvent(i);
    if (s) {
      const a = n.findEventIndex(i), o = n.findAssetIndex(s, e);
      this.advanceAfterAssetEnded(s, a, o - 1);
    }
  }
  setSchedulePosition(e, t) {
    const n = this.schedule.items;
    if (!n || this.playbackDisabled)
      return;
    this.log(`setSchedulePosition ${e}, ${t}`);
    const i = e >= 0 ? n[e] : null, s = this.playingItem, a = this.playingLastItem;
    if (this.isInterstitial(s)) {
      var o;
      const l = s.event, u = this.playingAsset, d = u == null ? void 0 : u.identifier, f = d ? this.getAssetPlayer(d) : null;
      if (f && d && (!this.eventItemsMatch(s, i) || t !== void 0 && d !== ((o = l.assetList) == null ? void 0 : o[t].identifier))) {
        var c;
        const h = l.findAssetIndex(u);
        if (this.log(`INTERSTITIAL_ASSET_ENDED ${h + 1}/${l.assetList.length} ${Ri(u)}`), this.endedAsset = u, this.playingAsset = null, this.hls.trigger(E.INTERSTITIAL_ASSET_ENDED, {
          asset: u,
          assetListIndex: h,
          event: l,
          schedule: n.slice(0),
          scheduleIndex: e,
          player: f
        }), s !== this.playingItem) {
          this.itemsMatch(s, this.playingItem) && !this.playingAsset && this.advanceAfterAssetEnded(l, this.findItemIndex(this.playingItem), h);
          return;
        }
        this.retreiveMediaSource(d, i), f.media && !((c = this.detachedData) != null && c.mediaSource) && f.detachMedia();
      }
      if (!this.eventItemsMatch(s, i) && (this.endedItem = s, this.playingItem = null, this.log(`INTERSTITIAL_ENDED ${l} ${wn(s)}`), l.hasPlayed = !0, this.hls.trigger(E.INTERSTITIAL_ENDED, {
        event: l,
        schedule: n.slice(0),
        scheduleIndex: e
      }), l.cue.once)) {
        this.updateSchedule();
        const h = this.schedule.items;
        if (i && h) {
          const g = this.findItemIndex(i);
          this.advanceSchedule(g, h, t, s, a);
        }
        return;
      }
    }
    this.advanceSchedule(e, n, t, s, a);
  }
  advanceSchedule(e, t, n, i, s) {
    const a = e >= 0 ? t[e] : null, o = this.primaryMedia, c = this.playerQueue;
    if (c.length && c.forEach((l) => {
      const u = l.interstitial, d = this.schedule.findEventIndex(u.identifier);
      (d < e || d > e + 1) && this.clearInterstitial(u, a);
    }), this.isInterstitial(a)) {
      this.timelinePos = Math.min(Math.max(this.timelinePos, a.start), a.end);
      const l = a.event;
      if (n === void 0) {
        n = this.schedule.findAssetIndex(l, this.timelinePos);
        const h = ad(l, n - 1);
        if (l.isAssetPastPlayoutLimit(h)) {
          this.advanceAfterAssetEnded(l, e, n);
          return;
        }
        n = h;
      }
      const u = this.waitingItem;
      this.assetsBuffered(a, o) || this.setBufferingItem(a);
      let d = this.preloadAssets(l, n);
      if (this.eventItemsMatch(a, u || i) || (this.waitingItem = a, this.log(`INTERSTITIAL_STARTED ${wn(a)} ${l.appendInPlace ? "append in place" : ""}`), this.hls.trigger(E.INTERSTITIAL_STARTED, {
        event: l,
        schedule: t.slice(0),
        scheduleIndex: e
      })), !l.assetListLoaded) {
        this.log(`Waiting for ASSET-LIST to complete loading ${l}`);
        return;
      }
      if (l.assetListLoader && (l.assetListLoader.destroy(), l.assetListLoader = void 0), !o) {
        this.log(`Waiting for attachMedia to start Interstitial ${l}`);
        return;
      }
      this.waitingItem = this.endedItem = null, this.playingItem = a;
      const f = l.assetList[n];
      if (!f) {
        const h = t[e + 1], g = this.media;
        h && g && !this.isInterstitial(h) && g.currentTime < h.start && (g.currentTime = this.timelinePos = h.start), this.advanceAfterAssetEnded(l, e, n || 0);
        return;
      }
      if (d || (d = this.getAssetPlayer(f.identifier)), d === null || d.destroyed) {
        const h = l.assetList.length;
        this.warn(`asset ${n + 1}/${h} player destroyed ${l}`), d = this.createAssetPlayer(l, f, n);
      }
      if (!this.eventItemsMatch(a, this.bufferingItem) && l.appendInPlace && this.isAssetBuffered(f))
        return;
      this.startAssetPlayer(d, n, t, e, o), this.shouldPlay && _b(d.media);
    } else a !== null ? (this.resumePrimary(a, e, i), this.shouldPlay && _b(this.hls.media)) : s && this.isInterstitial(i) && (this.endedItem = null, this.playingItem = i, i.event.appendInPlace || this.attachPrimary(this.schedule.durations.primary, null));
  }
  get playbackDisabled() {
    return this.hls.config.enableInterstitialPlayback === !1;
  }
  get primaryDetails() {
    var e, t;
    return (e = this.mediaSelection) == null || (t = e.main) == null ? void 0 : t.details;
  }
  get primaryLive() {
    var e;
    return !!((e = this.primaryDetails) != null && e.live);
  }
  resumePrimary(e, t, n) {
    var i;
    if (this.playingItem = e, this.playingAsset = this.endedAsset = null, this.waitingItem = this.endedItem = null, this.bufferedToItem(e), this.log(`resuming ${wn(e)}`), !((i = this.detachedData) != null && i.mediaSource)) {
      let a = this.timelinePos;
      (a < e.start || a >= e.end) && (a = this.getPrimaryResumption(e, t), this.timelinePos = a), this.attachPrimary(a, e);
    }
    if (!n)
      return;
    const s = this.schedule.items;
    s && (this.log(`INTERSTITIALS_PRIMARY_RESUMED ${wn(e)}`), this.hls.trigger(E.INTERSTITIALS_PRIMARY_RESUMED, {
      schedule: s.slice(0),
      scheduleIndex: t
    }), this.checkBuffer());
  }
  getPrimaryResumption(e, t) {
    const n = e.start;
    if (this.primaryLive) {
      const i = this.primaryDetails;
      if (t === 0)
        return this.hls.startPosition;
      if (i && (n < i.fragmentStart || n > i.edge))
        return this.hls.liveSyncPosition || -1;
    }
    return n;
  }
  isAssetBuffered(e) {
    const t = this.getAssetPlayer(e.identifier);
    return t != null && t.hls ? t.hls.bufferedToEnd : ue.bufferInfo(this.primaryMedia, this.timelinePos, 0).end + 1 >= e.timelineStart + (e.duration || 0);
  }
  attachPrimary(e, t, n) {
    t ? this.setBufferingItem(t) : this.bufferingItem = this.playingItem, this.bufferingAsset = null;
    const i = this.primaryMedia;
    if (!i)
      return;
    const s = this.hls;
    s.media ? this.checkBuffer() : (this.transferMediaTo(s, i), n && this.startLoadingPrimaryAt(e, n)), n || (this.timelinePos = e, this.startLoadingPrimaryAt(e, n));
  }
  startLoadingPrimaryAt(e, t) {
    var n;
    const i = this.hls;
    !i.loadingEnabled || !i.media || Math.abs((((n = i.mainForwardBufferInfo) == null ? void 0 : n.start) || i.media.currentTime) - e) > 0.5 ? i.startLoad(e, t) : i.bufferingEnabled || i.resumeBuffering();
  }
  // HLS.js event callbacks
  onManifestLoading() {
    this.stopLoad(), this.schedule.reset(), this.emptyPlayerQueue(), this.clearScheduleState(), this.shouldPlay = !1, this.bufferedPos = this.timelinePos = -1, this.mediaSelection = this.altSelection = this.manager = this.requiredTracks = null, this.hls.off(E.BUFFER_CODECS, this.onBufferCodecs, this), this.hls.on(E.BUFFER_CODECS, this.onBufferCodecs, this);
  }
  onLevelUpdated(e, t) {
    if (t.level === -1)
      return;
    const n = this.hls.levels[t.level], i = Ne(Ne({}, this.mediaSelection || this.altSelection), {}, {
      main: n
    });
    this.mediaSelection = i, this.schedule.parseInterstitialDateRanges(i, this.hls.config.interstitialAppendInPlace), !this.effectivePlayingItem && this.schedule.items && this.checkStart();
  }
  onAudioTrackUpdated(e, t) {
    const n = this.hls.audioTracks[t.id], i = this.mediaSelection;
    if (!i) {
      this.altSelection = Ne(Ne({}, this.altSelection), {}, {
        audio: n
      });
      return;
    }
    const s = Ne(Ne({}, i), {}, {
      audio: n
    });
    this.mediaSelection = s;
  }
  onSubtitleTrackUpdated(e, t) {
    const n = this.hls.subtitleTracks[t.id], i = this.mediaSelection;
    if (!i) {
      this.altSelection = Ne(Ne({}, this.altSelection), {}, {
        subtitles: n
      });
      return;
    }
    const s = Ne(Ne({}, i), {}, {
      subtitles: n
    });
    this.mediaSelection = s;
  }
  onAudioTrackSwitching(e, t) {
    const n = By(t);
    this.playerQueue.forEach((i) => i.hls.setAudioOption(t) || i.hls.setAudioOption(n));
  }
  onSubtitleTrackSwitch(e, t) {
    const n = By(t);
    this.playerQueue.forEach((i) => i.hls.setSubtitleOption(t) || t.id !== -1 && i.hls.setSubtitleOption(n));
  }
  onBufferCodecs(e, t) {
    const n = t.tracks;
    n && (this.requiredTracks = n);
  }
  onBufferAppended(e, t) {
    this.checkBuffer();
  }
  onBufferFlushed(e, t) {
    const n = this.playingItem;
    if (n && !this.itemsMatch(n, this.bufferingItem) && !this.isInterstitial(n)) {
      const i = this.timelinePos;
      this.bufferedPos = i, this.checkBuffer();
    }
  }
  onBufferedToEnd(e) {
    const t = this.schedule.events;
    if (this.bufferedPos < Number.MAX_VALUE && t) {
      for (let i = 0; i < t.length; i++) {
        const s = t[i];
        if (s.cue.post) {
          var n;
          const a = this.schedule.findEventIndex(s.identifier), o = (n = this.schedule.items) == null ? void 0 : n[a];
          this.isInterstitial(o) && this.eventItemsMatch(o, this.bufferingItem) && this.bufferedToItem(o, 0);
          break;
        }
      }
      this.bufferedPos = Number.MAX_VALUE;
    }
  }
  onMediaEnded(e) {
    const t = this.playingItem;
    if (!this.playingLastItem && t) {
      const n = this.findItemIndex(t);
      this.setSchedulePosition(n + 1);
    } else
      this.shouldPlay = !1;
  }
  updateItem(e, t) {
    const n = this.schedule.items;
    if (e && n) {
      const i = this.findItemIndex(e, t);
      return n[i] || null;
    }
    return null;
  }
  trimInPlace(e, t) {
    if (this.isInterstitial(e) && e.event.appendInPlace && t.end - e.end > 0.25) {
      e.event.assetList.forEach((s, a) => {
        e.event.isAssetPastPlayoutLimit(a) && this.clearAssetPlayer(s.identifier, null);
      });
      const n = e.end + 0.25, i = ue.bufferInfo(this.primaryMedia, n, 0);
      (i.end > n || (i.nextStart || 0) > n) && (this.attachPrimary(n, null), this.flushFrontBuffer(n));
    }
  }
  itemsMatch(e, t) {
    return !!t && (e === t || e.event && t.event && this.eventItemsMatch(e, t) || !e.event && !t.event && this.findItemIndex(e) === this.findItemIndex(t));
  }
  eventItemsMatch(e, t) {
    var n;
    return !!t && (e === t || e.event.identifier === ((n = t.event) == null ? void 0 : n.identifier));
  }
  findItemIndex(e, t) {
    return e ? this.schedule.findItemIndex(e, t) : -1;
  }
  updateSchedule() {
    const e = this.mediaSelection;
    e && this.schedule.updateSchedule(e, []);
  }
  // Schedule buffer control
  checkBuffer(e) {
    const t = this.schedule.items;
    if (!t)
      return;
    const n = ue.bufferInfo(this.primaryMedia, this.timelinePos, 0);
    e && (this.bufferedPos = this.timelinePos), e || (e = n.len < 1), this.updateBufferedPos(n.end, t, e);
  }
  updateBufferedPos(e, t, n) {
    const i = this.schedule, s = this.bufferingItem;
    if (this.bufferedPos > e)
      return;
    if (t.length === 1 && this.itemsMatch(t[0], s)) {
      this.bufferedPos = e;
      return;
    }
    const a = this.playingItem, o = this.findItemIndex(a);
    let c = i.findItemIndexAtTime(e);
    if (this.bufferedPos < e) {
      var l, u;
      const d = this.findItemIndex(s), f = Math.min(d + 1, t.length - 1), h = t[f];
      if ((c === -1 && s && e >= s.end || (l = h.event) != null && l.appendInPlace && e + 0.01 >= h.start) && (c = f), f - o > 1 && (s == null || (u = s.event) == null ? void 0 : u.appendInPlace) === !1)
        return;
      if (this.bufferedPos = e, c > d && c > o)
        this.bufferedToItem(h);
      else {
        const g = this.primaryDetails;
        this.primaryLive && g && e > g.edge - g.targetduration && h.start < g.edge + this.hls.config.interstitialLiveLookAhead && this.isInterstitial(h) && this.preloadAssets(h.event, 0);
      }
    } else n && a && !this.itemsMatch(a, s) && (c === o ? this.bufferedToItem(a) : c === o + 1 && this.bufferedToItem(t[c]));
  }
  assetsBuffered(e, t) {
    return e.event.assetList.length === 0 ? !1 : !e.event.assetList.some((i) => {
      const s = this.getAssetPlayer(i.identifier);
      return !(s != null && s.bufferedInPlaceToEnd(t));
    });
  }
  setBufferingItem(e) {
    const t = this.bufferingItem, n = this.schedule;
    if (this.itemsMatch(e, t))
      this.bufferingItem !== e && (this.bufferingItem = e);
    else {
      const {
        items: i,
        events: s
      } = n;
      if (!i || !s)
        return t;
      const a = this.isInterstitial(e), o = this.getBufferingPlayer();
      this.bufferingItem = e, this.bufferedPos = Math.max(e.start, Math.min(e.end, this.timelinePos));
      const c = o ? o.remaining : t ? t.end - this.timelinePos : 0;
      this.log(`INTERSTITIALS_BUFFERED_TO_BOUNDARY ${wn(e)}` + (t ? ` (${c.toFixed(2)} remaining)` : "")), this.playbackDisabled || (a ? e.event.assetList.forEach((l) => {
        const u = this.getAssetPlayer(l.identifier);
        u && u.resumeBuffering();
      }) : (this.hls.resumeBuffering(), this.playerQueue.forEach((l) => l.pauseBuffering()))), this.hls.trigger(E.INTERSTITIALS_BUFFERED_TO_BOUNDARY, {
        events: s.slice(0),
        schedule: i.slice(0),
        bufferingIndex: this.findItemIndex(e),
        playingIndex: this.findItemIndex(this.playingItem)
      });
    }
    return t;
  }
  bufferedToItem(e, t = 0) {
    const n = this.setBufferingItem(e);
    if (!this.playbackDisabled) {
      if (this.isInterstitial(e))
        this.bufferedToEvent(e, t);
      else if (n !== null) {
        this.bufferingAsset = null;
        const i = this.detachedData;
        i ? i.mediaSource ? this.attachPrimary(e.start, e, !0) : this.preloadPrimary(e) : this.preloadPrimary(e);
      }
    }
  }
  preloadPrimary(e) {
    const t = this.findItemIndex(e), n = this.getPrimaryResumption(e, t);
    this.startLoadingPrimaryAt(n);
  }
  bufferedToEvent(e, t) {
    const n = e.event, i = n.assetList.length === 0 && !n.assetListLoader, s = n.cue.once;
    if (i || !s) {
      const a = this.preloadAssets(n, t);
      if (a != null && a.interstitial.appendInPlace) {
        const o = n.assetList[t], c = this.primaryMedia;
        o && c && this.bufferAssetPlayer(a, c);
      }
    }
  }
  preloadAssets(e, t) {
    const n = e.assetUrl, i = e.assetList.length, s = i === 0 && !e.assetListLoader, a = e.cue.once;
    if (s) {
      const c = e.timelineStart;
      if (e.appendInPlace) {
        var o;
        const f = this.playingItem;
        !this.isInterstitial(f) && (f == null || (o = f.nextEvent) == null ? void 0 : o.identifier) === e.identifier && this.flushFrontBuffer(c + 0.25);
      }
      let l, u = 0;
      if (!this.playingItem && this.primaryLive && (u = this.hls.startPosition, u === -1 && (u = this.hls.liveSyncPosition || 0)), u && !(e.cue.pre || e.cue.post)) {
        const f = u - c;
        f > 0 && (l = Math.round(f * 1e3) / 1e3);
      }
      if (this.log(`Load interstitial asset ${t + 1}/${n ? 1 : i} ${e}${l ? ` live-start: ${u} start-offset: ${l}` : ""}`), n)
        return this.createAsset(e, 0, 0, c, e.duration, n);
      const d = this.assetListLoader.loadAssetList(e, l);
      d && (e.assetListLoader = d);
    } else if (!a && i) {
      for (let c = t; c < i; c++) {
        const l = e.assetList[c], u = this.getAssetPlayerQueueIndex(l.identifier);
        (u === -1 || this.playerQueue[u].destroyed) && !l.error && this.createAssetPlayer(e, l, c);
      }
      return this.getAssetPlayer(e.assetList[t].identifier);
    }
    return null;
  }
  flushFrontBuffer(e) {
    const t = this.requiredTracks;
    if (!t)
      return;
    this.log(`Removing front buffer starting at ${e}`), Object.keys(t).forEach((i) => {
      this.hls.trigger(E.BUFFER_FLUSHING, {
        startOffset: e,
        endOffset: 1 / 0,
        type: i
      });
    });
  }
  // Interstitial Asset Player control
  getAssetPlayerQueueIndex(e) {
    const t = this.playerQueue;
    for (let n = 0; n < t.length; n++)
      if (e === t[n].assetId)
        return n;
    return -1;
  }
  getAssetPlayer(e) {
    const t = this.getAssetPlayerQueueIndex(e);
    return this.playerQueue[t] || null;
  }
  getBufferingPlayer() {
    const {
      playerQueue: e,
      primaryMedia: t
    } = this;
    if (t) {
      for (let n = 0; n < e.length; n++)
        if (e[n].media === t)
          return e[n];
    }
    return null;
  }
  createAsset(e, t, n, i, s, a) {
    const o = {
      parentIdentifier: e.identifier,
      identifier: U8(e, a, t),
      duration: s,
      startOffset: n,
      timelineStart: i,
      uri: a
    };
    return this.createAssetPlayer(e, o, t);
  }
  createAssetPlayer(e, t, n) {
    const i = this.hls, s = i.userConfig;
    let a = s.videoPreference;
    const o = i.loadLevelObj || i.levels[i.currentLevel];
    (a || o) && (a = Ce({}, a), o.videoCodec && (a.videoCodec = o.videoCodec), o.videoRange && (a.allowedVideoRanges = [o.videoRange]));
    const c = i.audioTracks[i.audioTrack], l = i.subtitleTracks[i.subtitleTrack];
    let u = 0;
    if (this.primaryLive || e.appendInPlace) {
      const b = this.timelinePos - t.timelineStart;
      if (b > 1) {
        const x = t.duration;
        x && b < x && (u = b);
      }
    }
    const d = t.identifier, f = Ne(Ne({}, s), {}, {
      autoStartLoad: !0,
      startFragPrefetch: !0,
      primarySessionId: i.sessionId,
      assetPlayerId: d,
      abrEwmaDefaultEstimate: i.bandwidthEstimate,
      interstitialsController: void 0,
      startPosition: u,
      liveDurationInfinity: !1,
      testBandwidth: !1,
      videoPreference: a,
      audioPreference: c || s.audioPreference,
      subtitlePreference: l || s.subtitlePreference
    });
    e.appendInPlace && (e.appendInPlaceStarted = !0, t.timelineStart && (f.timelineOffset = t.timelineStart));
    const h = f.cmcd;
    h != null && h.sessionId && h.contentId && (f.cmcd = Ce({}, h, {
      contentId: js(t.uri)
    })), this.getAssetPlayer(d) && this.warn(`Duplicate date range identifier ${e} and asset ${d}`);
    const g = new V8(this.HlsPlayerClass, f, e, t);
    this.playerQueue.push(g), e.assetList[n] = t;
    const m = (b) => {
      if (b.live) {
        const A = new Error(`Interstitials MUST be VOD assets ${e}`), T = {
          fatal: !0,
          type: ne.OTHER_ERROR,
          details: k.INTERSTITIAL_ASSET_ITEM_ERROR,
          error: A
        };
        this.handleAssetItemError(T, e, this.schedule.findEventIndex(e.identifier), n, A.message);
        return;
      }
      const x = b.edge - b.fragmentStart, S = t.duration;
      (S === null || x > S) && (this.log(`Interstitial asset "${d}" duration change ${S} > ${x}`), t.duration = x, this.updateSchedule());
    };
    g.on(E.LEVEL_UPDATED, (b, {
      details: x
    }) => m(x)), g.on(E.LEVEL_PTS_UPDATED, (b, {
      details: x
    }) => m(x));
    const p = (b, x) => {
      const S = this.getAssetPlayer(d);
      if (S && x.tracks) {
        S.off(E.BUFFER_CODECS, p), S.tracks = x.tracks;
        const A = this.primaryMedia;
        this.bufferingAsset === S.assetItem && A && !S.media && this.bufferAssetPlayer(S, A);
      }
    };
    g.on(E.BUFFER_CODECS, p);
    const v = () => {
      var b;
      const x = this.getAssetPlayer(d);
      if (this.log(`buffered to end of asset ${x}`), !x)
        return;
      const S = this.schedule.findEventIndex(e.identifier), A = (b = this.schedule.items) == null ? void 0 : b[S];
      if (this.isInterstitial(A)) {
        const I = e.findAssetIndex(t), L = ad(e, I);
        if (!e.isAssetPastPlayoutLimit(L))
          this.bufferedToItem(A, L);
        else {
          var T;
          const _ = (T = this.schedule.items) == null ? void 0 : T[S + 1];
          _ && this.bufferedToItem(_);
        }
      }
    };
    g.on(E.BUFFERED_TO_END, v);
    const y = (b) => () => {
      if (!this.getAssetPlayer(d))
        return;
      this.shouldPlay = !0;
      const S = this.schedule.findEventIndex(e.identifier);
      this.advanceAfterAssetEnded(e, S, b);
    };
    return g.once(E.MEDIA_ENDED, y(n)), g.once(E.PLAYOUT_LIMIT_REACHED, y(1 / 0)), g.on(E.ERROR, (b, x) => {
      const S = this.getAssetPlayer(d);
      if (x.details === k.BUFFER_STALLED_ERROR) {
        if (S != null && S.media) {
          const A = S.currentTime, T = S.duration - A;
          A && e.appendInPlace && T / S.media.playbackRate < 0.5 ? (this.log(`Advancing buffer past end of asset ${d} ${e} at ${S.media.currentTime}`), v()) : (this.warn(`Stalled at ${A} of ${A + T} in asset ${d} ${e}`), this.onTimeupdate(), this.checkBuffer(!0));
        }
        return;
      }
      this.handleAssetItemError(x, e, this.schedule.findEventIndex(e.identifier), n, `Asset player error ${x.error} ${e}`);
    }), g.on(E.DESTROYING, () => {
      if (!this.getAssetPlayer(d))
        return;
      const x = new Error(`Asset player destroyed unexpectedly ${d}`), S = {
        fatal: !0,
        type: ne.OTHER_ERROR,
        details: k.INTERSTITIAL_ASSET_ITEM_ERROR,
        error: x
      };
      this.handleAssetItemError(S, e, this.schedule.findEventIndex(e.identifier), n, x.message);
    }), this.log(`INTERSTITIAL_ASSET_PLAYER_CREATED ${Ri(t)}`), this.hls.trigger(E.INTERSTITIAL_ASSET_PLAYER_CREATED, {
      asset: t,
      assetListIndex: n,
      event: e,
      player: g
    }), g;
  }
  clearInterstitial(e, t) {
    e.assetList.forEach((n) => {
      this.clearAssetPlayer(n.identifier, t);
    }), e.reset();
  }
  resetAssetPlayer(e) {
    const t = this.getAssetPlayerQueueIndex(e);
    if (t !== -1) {
      this.log(`reset asset player "${e}" after error`);
      const n = this.playerQueue[t];
      this.transferMediaFromPlayer(n, null), n.resetDetails();
    }
  }
  clearAssetPlayer(e, t) {
    const n = this.getAssetPlayerQueueIndex(e);
    if (n !== -1) {
      this.log(`clear asset player "${e}" toSegment: ${t && wn(t)}`);
      const i = this.playerQueue[n];
      this.transferMediaFromPlayer(i, t), this.playerQueue.splice(n, 1), i.destroy();
    }
  }
  emptyPlayerQueue() {
    let e;
    for (; e = this.playerQueue.pop(); )
      e.destroy();
    this.playerQueue = [];
  }
  startAssetPlayer(e, t, n, i, s) {
    const {
      interstitial: a,
      assetItem: o,
      assetId: c
    } = e, l = a.assetList.length, u = this.playingAsset;
    this.endedAsset = null, this.playingAsset = o, (!u || u.identifier !== c) && (u && (this.clearAssetPlayer(u.identifier, n[i]), delete u.error), this.log(`INTERSTITIAL_ASSET_STARTED ${t + 1}/${l} ${Ri(o)}`), this.hls.trigger(E.INTERSTITIAL_ASSET_STARTED, {
      asset: o,
      assetListIndex: t,
      event: a,
      schedule: n.slice(0),
      scheduleIndex: i,
      player: e
    })), this.bufferAssetPlayer(e, s);
  }
  bufferAssetPlayer(e, t) {
    var n, i;
    const {
      interstitial: s,
      assetItem: a
    } = e, o = this.schedule.findEventIndex(s.identifier), c = (n = this.schedule.items) == null ? void 0 : n[o];
    if (!c)
      return;
    this.setBufferingItem(c), this.bufferingAsset = a;
    const l = this.getBufferingPlayer();
    if (l === e)
      return;
    const u = s.appendInPlace;
    if (u && (l == null ? void 0 : l.interstitial.appendInPlace) === !1)
      return;
    const d = (l == null ? void 0 : l.tracks) || ((i = this.detachedData) == null ? void 0 : i.tracks) || this.requiredTracks;
    if (u && a !== this.playingAsset) {
      if (!e.tracks)
        return;
      if (d && !MA(d, e.tracks)) {
        const f = new Error(`Asset ${Ri(a)} SourceBuffer tracks ('${Object.keys(e.tracks)}') are not compatible with primary content tracks ('${Object.keys(d)}')`), h = {
          fatal: !0,
          type: ne.OTHER_ERROR,
          details: k.INTERSTITIAL_ASSET_ITEM_ERROR,
          error: f
        }, g = s.findAssetIndex(a);
        this.handleAssetItemError(h, s, o, g, f.message);
        return;
      }
    }
    this.transferMediaTo(e, t);
  }
  handleAssetItemError(e, t, n, i, s) {
    if (e.details === k.BUFFER_STALLED_ERROR)
      return;
    const a = t.assetList[i];
    this.warn(`INTERSTITIAL_ASSET_ERROR ${a && Ri(a)} ${e.error}`);
    const o = a == null ? void 0 : a.identifier, c = this.getAssetPlayerQueueIndex(o), l = this.playerQueue[c] || null, u = this.schedule.items, d = Ce({}, e, {
      fatal: !1,
      errorAction: ra(!0),
      asset: a,
      assetListIndex: i,
      event: t,
      schedule: u,
      scheduleIndex: n,
      player: l
    });
    if (this.hls.trigger(E.INTERSTITIAL_ASSET_ERROR, d), !e.fatal)
      return;
    const f = this.playingAsset, h = new Error(s);
    if (a && (this.clearAssetPlayer(o, null), a.error = h), !t.assetList.some((g) => !g.error))
      t.error = h;
    else {
      for (let g = i; g < t.assetList.length; g++)
        this.resetAssetPlayer(t.assetList[g].identifier);
      this.updateSchedule();
    }
    t.error ? this.primaryFallback(t) : f && f.identifier === o && this.advanceAfterAssetEnded(t, n, i);
  }
  primaryFallback(e) {
    const t = e.timelineStart, n = this.effectivePlayingItem;
    if (this.updateSchedule(), n) {
      this.log(`Fallback to primary from event "${e.identifier}" start: ${t} pos: ${this.timelinePos} playing: ${n ? wn(n) : "<none>"} error: ${e.error}`);
      let i = this.timelinePos;
      i === -1 && (i = this.hls.startPosition);
      const s = this.updateItem(n, i);
      this.itemsMatch(n, s) && this.clearInterstitial(e, null), e.appendInPlace && (this.attachPrimary(t, null), this.flushFrontBuffer(t));
      const a = this.schedule.findItemIndexAtTime(i);
      this.setSchedulePosition(a);
    } else
      this.checkStart();
  }
  // Asset List loading
  onAssetListLoaded(e, t) {
    var n;
    const i = t.event, s = i.identifier, a = t.assetListResponse.ASSETS;
    if (!this.schedule.hasEvent(s))
      return;
    const o = i.timelineStart, c = i.duration;
    let l = 0;
    a.forEach((g, m) => {
      const p = parseFloat(g.DURATION);
      this.createAsset(i, m, l, o + l, p, g.URI), l += p;
    }), i.duration = l, this.log(`Loaded asset-list with duration: ${l} (was: ${c}) ${i}`);
    const u = this.waitingItem, d = (u == null ? void 0 : u.event.identifier) === s;
    this.updateSchedule();
    const f = (n = this.bufferingItem) == null ? void 0 : n.event;
    if (d) {
      var h;
      const g = this.schedule.findEventIndex(s), m = (h = this.schedule.items) == null ? void 0 : h[g];
      if (m) {
        if (!this.playingItem && this.timelinePos > m.end && this.schedule.findItemIndexAtTime(this.timelinePos) !== g) {
          i.error = new Error(`Interstitial no longer within playback range ${this.timelinePos} ${i}`), this.primaryFallback(i);
          return;
        }
        this.setBufferingItem(m);
      }
      this.setSchedulePosition(g);
    } else if ((f == null ? void 0 : f.identifier) === s && f.appendInPlace) {
      const g = i.assetList[0], m = this.getAssetPlayer(g.identifier), p = this.primaryMedia;
      g && m && p && this.bufferAssetPlayer(m, p);
    }
  }
  onError(e, t) {
    switch (t.details) {
      case k.ASSET_LIST_PARSING_ERROR:
      case k.ASSET_LIST_LOAD_ERROR:
      case k.ASSET_LIST_LOAD_TIMEOUT: {
        const n = t.interstitial;
        n && this.primaryFallback(n);
        break;
      }
      case k.BUFFER_STALLED_ERROR: {
        this.onTimeupdate(), this.checkBuffer(!0);
        break;
      }
    }
  }
}
const Lb = 500;
class z8 extends zg {
  constructor(e, t, n) {
    super(e, t, n, "subtitle-stream-controller", ee.SUBTITLE), this.currentTrackId = -1, this.tracksBuffered = [], this.mainDetails = null, this.registerListeners();
  }
  onHandlerDestroying() {
    this.unregisterListeners(), super.onHandlerDestroying(), this.mainDetails = null;
  }
  registerListeners() {
    super.registerListeners();
    const {
      hls: e
    } = this;
    e.on(E.LEVEL_LOADED, this.onLevelLoaded, this), e.on(E.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.on(E.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.on(E.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.on(E.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), e.on(E.BUFFER_FLUSHING, this.onBufferFlushing, this);
  }
  unregisterListeners() {
    super.unregisterListeners();
    const {
      hls: e
    } = this;
    e.off(E.LEVEL_LOADED, this.onLevelLoaded, this), e.off(E.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.off(E.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.off(E.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.off(E.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), e.off(E.BUFFER_FLUSHING, this.onBufferFlushing, this);
  }
  startLoad(e, t) {
    this.stopLoad(), this.state = $.IDLE, this.setInterval(Lb), this.nextLoadPosition = this.lastCurrentTime = e + this.timelineOffset, this.startPosition = t ? -1 : e, this.tick();
  }
  onManifestLoading() {
    super.onManifestLoading(), this.mainDetails = null;
  }
  onMediaDetaching(e, t) {
    this.tracksBuffered = [], super.onMediaDetaching(e, t);
  }
  onLevelLoaded(e, t) {
    this.mainDetails = t.details;
  }
  onSubtitleFragProcessed(e, t) {
    const {
      frag: n,
      success: i
    } = t;
    if (this.fragContextChanged(n) || (it(n) && (this.fragPrevious = n), this.state = $.IDLE), !i)
      return;
    const s = this.tracksBuffered[this.currentTrackId];
    if (!s)
      return;
    let a;
    const o = n.start;
    for (let l = 0; l < s.length; l++)
      if (o >= s[l].start && o <= s[l].end) {
        a = s[l];
        break;
      }
    const c = n.start + n.duration;
    a ? a.end = c : (a = {
      start: o,
      end: c
    }, s.push(a)), this.fragmentTracker.fragBuffered(n), this.fragBufferedComplete(n, null), this.media && this.tick();
  }
  onBufferFlushing(e, t) {
    const {
      startOffset: n,
      endOffset: i
    } = t;
    if (n === 0 && i !== Number.POSITIVE_INFINITY) {
      const s = i - 1;
      if (s <= 0)
        return;
      t.endOffsetSubtitles = Math.max(0, s), this.tracksBuffered.forEach((a) => {
        for (let o = 0; o < a.length; ) {
          if (a[o].end <= s) {
            a.shift();
            continue;
          } else if (a[o].start < s)
            a[o].start = s;
          else
            break;
          o++;
        }
      }), this.fragmentTracker.removeFragmentsInRange(n, s, ee.SUBTITLE);
    }
  }
  // If something goes wrong, proceed to next frag, if we were processing one.
  onError(e, t) {
    const n = t.frag;
    (n == null ? void 0 : n.type) === ee.SUBTITLE && (t.details === k.FRAG_GAP && this.fragmentTracker.fragBuffered(n, !0), this.fragCurrent && this.fragCurrent.abortRequests(), this.state !== $.STOPPED && (this.state = $.IDLE));
  }
  // Got all new subtitle levels.
  onSubtitleTracksUpdated(e, {
    subtitleTracks: t
  }) {
    if (this.levels && Dw(this.levels, t)) {
      this.levels = t.map((n) => new ta(n));
      return;
    }
    this.tracksBuffered = [], this.levels = t.map((n) => {
      const i = new ta(n);
      return this.tracksBuffered[i.id] = [], i;
    }), this.fragmentTracker.removeFragmentsInRange(0, Number.POSITIVE_INFINITY, ee.SUBTITLE), this.fragPrevious = null, this.mediaBuffer = null;
  }
  onSubtitleTrackSwitch(e, t) {
    var n;
    if (this.currentTrackId = t.id, !((n = this.levels) != null && n.length) || this.currentTrackId === -1) {
      this.clearInterval();
      return;
    }
    const i = this.levels[this.currentTrackId];
    i != null && i.details ? this.mediaBuffer = this.mediaBufferTimeRanges : this.mediaBuffer = null, i && this.state !== $.STOPPED && this.setInterval(Lb);
  }
  // Got a new set of subtitle fragments.
  onSubtitleTrackLoaded(e, t) {
    var n;
    const {
      currentTrackId: i,
      levels: s
    } = this, {
      details: a,
      id: o
    } = t;
    if (!s) {
      this.warn(`Subtitle tracks were reset while loading level ${o}`);
      return;
    }
    const c = s[o];
    if (o >= s.length || !c)
      return;
    this.log(`Subtitle track ${o} loaded [${a.startSN},${a.endSN}]${a.lastPartSn ? `[part-${a.lastPartSn}-${a.lastPartIndex}]` : ""},duration:${a.totalduration}`), this.mediaBuffer = this.mediaBufferTimeRanges;
    let l = 0;
    if (a.live || (n = c.details) != null && n.live) {
      if (a.deltaUpdateFailed)
        return;
      const d = this.mainDetails;
      if (!d) {
        this.startFragRequested = !1;
        return;
      }
      const f = d.fragments[0];
      if (!c.details)
        a.hasProgramDateTime && d.hasProgramDateTime ? (fl(a, d), l = a.fragmentStart) : f && (l = f.start, Tf(a, l));
      else {
        var u;
        l = this.alignPlaylists(a, c.details, (u = this.levelLastLoaded) == null ? void 0 : u.details), l === 0 && f && (l = f.start, Tf(a, l));
      }
      d && !this.startFragRequested && this.setStartPosition(d, l);
    }
    c.details = a, this.levelLastLoaded = c, o === i && (this.hls.trigger(E.SUBTITLE_TRACK_UPDATED, {
      details: a,
      id: o,
      groupId: t.groupId
    }), this.tick(), a.live && !this.fragCurrent && this.media && this.state === $.IDLE && (mi(null, a.fragments, this.media.currentTime, 0) || (this.warn("Subtitle playlist not aligned with playback"), c.details = void 0)));
  }
  _handleFragmentLoadComplete(e) {
    const {
      frag: t,
      payload: n
    } = e, i = t.decryptdata, s = this.hls;
    if (!this.fragContextChanged(t) && n && n.byteLength > 0 && i != null && i.key && i.iv && Bi(i.method)) {
      const a = performance.now();
      this.decrypter.decrypt(new Uint8Array(n), i.key.buffer, i.iv.buffer, qg(i.method)).catch((o) => {
        throw s.trigger(E.ERROR, {
          type: ne.MEDIA_ERROR,
          details: k.FRAG_DECRYPT_ERROR,
          fatal: !1,
          error: o,
          reason: o.message,
          frag: t
        }), o;
      }).then((o) => {
        const c = performance.now();
        s.trigger(E.FRAG_DECRYPTED, {
          frag: t,
          payload: o,
          stats: {
            tstart: a,
            tdecrypt: c
          }
        });
      }).catch((o) => {
        this.warn(`${o.name}: ${o.message}`), this.state = $.IDLE;
      });
    }
  }
  doTick() {
    if (!this.media) {
      this.state = $.IDLE;
      return;
    }
    if (this.state === $.IDLE) {
      const {
        currentTrackId: e,
        levels: t
      } = this, n = t == null ? void 0 : t[e];
      if (!n || !t.length || !n.details || this.waitForLive(n))
        return;
      const {
        config: i
      } = this, s = this.getLoadPosition(), a = ue.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], s, i.maxBufferHole), {
        end: o,
        len: c
      } = a, l = n.details, u = this.hls.maxBufferLength + l.levelTargetDuration;
      if (c > u)
        return;
      const d = l.fragments, f = d.length, h = l.edge;
      let g = null;
      const m = this.fragPrevious;
      if (o < h) {
        const y = i.maxFragLookUpTolerance, b = o > h - y ? 0 : y;
        g = mi(m, d, Math.max(d[0].start, o), b), !g && m && m.start < d[0].start && (g = d[0]);
      } else
        g = d[f - 1];
      if (g = this.filterReplacedPrimary(g, n.details), !g)
        return;
      const p = g.sn - l.startSN, v = d[p - 1];
      if (v && v.cc === g.cc && this.fragmentTracker.getState(v) === ct.NOT_LOADED && (g = v), this.fragmentTracker.getState(g) === ct.NOT_LOADED) {
        const y = this.mapToInitFragWhenRequired(g);
        y && this.loadFragment(y, n, o);
      }
    }
  }
  loadFragment(e, t, n) {
    it(e) ? super.loadFragment(e, t, n) : this._loadInitSegment(e, t);
  }
  get mediaBufferTimeRanges() {
    return new Y8(this.tracksBuffered[this.currentTrackId] || []);
  }
}
class Y8 {
  constructor(e) {
    this.buffered = void 0;
    const t = (n, i, s) => {
      if (i = i >>> 0, i > s - 1)
        throw new DOMException(`Failed to execute '${n}' on 'TimeRanges': The index provided (${i}) is greater than the maximum bound (${s})`);
      return e[i][n];
    };
    this.buffered = {
      get length() {
        return e.length;
      },
      end(n) {
        return t("end", n, e.length);
      },
      start(n) {
        return t("start", n, e.length);
      }
    };
  }
}
const X8 = {
  42: 225,
  // lowercase a, acute accent
  92: 233,
  // lowercase e, acute accent
  94: 237,
  // lowercase i, acute accent
  95: 243,
  // lowercase o, acute accent
  96: 250,
  // lowercase u, acute accent
  123: 231,
  // lowercase c with cedilla
  124: 247,
  // division symbol
  125: 209,
  // uppercase N tilde
  126: 241,
  // lowercase n tilde
  127: 9608,
  // Full block
  // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
  // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F
  // THIS MEANS THAT \x50 MUST BE ADDED TO THE VALUES
  128: 174,
  // Registered symbol (R)
  129: 176,
  // degree sign
  130: 189,
  // 1/2 symbol
  131: 191,
  // Inverted (open) question mark
  132: 8482,
  // Trademark symbol (TM)
  133: 162,
  // Cents symbol
  134: 163,
  // Pounds sterling
  135: 9834,
  // Music 8'th note
  136: 224,
  // lowercase a, grave accent
  137: 32,
  // transparent space (regular)
  138: 232,
  // lowercase e, grave accent
  139: 226,
  // lowercase a, circumflex accent
  140: 234,
  // lowercase e, circumflex accent
  141: 238,
  // lowercase i, circumflex accent
  142: 244,
  // lowercase o, circumflex accent
  143: 251,
  // lowercase u, circumflex accent
  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
  // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F
  144: 193,
  // capital letter A with acute
  145: 201,
  // capital letter E with acute
  146: 211,
  // capital letter O with acute
  147: 218,
  // capital letter U with acute
  148: 220,
  // capital letter U with diaresis
  149: 252,
  // lowercase letter U with diaeresis
  150: 8216,
  // opening single quote
  151: 161,
  // inverted exclamation mark
  152: 42,
  // asterisk
  153: 8217,
  // closing single quote
  154: 9473,
  // box drawings heavy horizontal
  155: 169,
  // copyright sign
  156: 8480,
  // Service mark
  157: 8226,
  // (round) bullet
  158: 8220,
  // Left double quotation mark
  159: 8221,
  // Right double quotation mark
  160: 192,
  // uppercase A, grave accent
  161: 194,
  // uppercase A, circumflex
  162: 199,
  // uppercase C with cedilla
  163: 200,
  // uppercase E, grave accent
  164: 202,
  // uppercase E, circumflex
  165: 203,
  // capital letter E with diaresis
  166: 235,
  // lowercase letter e with diaresis
  167: 206,
  // uppercase I, circumflex
  168: 207,
  // uppercase I, with diaresis
  169: 239,
  // lowercase i, with diaresis
  170: 212,
  // uppercase O, circumflex
  171: 217,
  // uppercase U, grave accent
  172: 249,
  // lowercase u, grave accent
  173: 219,
  // uppercase U, circumflex
  174: 171,
  // left-pointing double angle quotation mark
  175: 187,
  // right-pointing double angle quotation mark
  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
  // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F
  176: 195,
  // Uppercase A, tilde
  177: 227,
  // Lowercase a, tilde
  178: 205,
  // Uppercase I, acute accent
  179: 204,
  // Uppercase I, grave accent
  180: 236,
  // Lowercase i, grave accent
  181: 210,
  // Uppercase O, grave accent
  182: 242,
  // Lowercase o, grave accent
  183: 213,
  // Uppercase O, tilde
  184: 245,
  // Lowercase o, tilde
  185: 123,
  // Open curly brace
  186: 125,
  // Closing curly brace
  187: 92,
  // Backslash
  188: 94,
  // Caret
  189: 95,
  // Underscore
  190: 124,
  // Pipe (vertical line)
  191: 8764,
  // Tilde operator
  192: 196,
  // Uppercase A, umlaut
  193: 228,
  // Lowercase A, umlaut
  194: 214,
  // Uppercase O, umlaut
  195: 246,
  // Lowercase o, umlaut
  196: 223,
  // Esszett (sharp S)
  197: 165,
  // Yen symbol
  198: 164,
  // Generic currency sign
  199: 9475,
  // Box drawings heavy vertical
  200: 197,
  // Uppercase A, ring
  201: 229,
  // Lowercase A, ring
  202: 216,
  // Uppercase O, stroke
  203: 248,
  // Lowercase o, strok
  204: 9487,
  // Box drawings heavy down and right
  205: 9491,
  // Box drawings heavy down and left
  206: 9495,
  // Box drawings heavy up and right
  207: 9499
  // Box drawings heavy up and left
}, Kw = (r) => String.fromCharCode(X8[r] || r), Tr = 15, qr = 100, Q8 = {
  17: 1,
  18: 3,
  21: 5,
  22: 7,
  23: 9,
  16: 11,
  19: 12,
  20: 14
}, Z8 = {
  17: 2,
  18: 4,
  21: 6,
  22: 8,
  23: 10,
  19: 13,
  20: 15
}, J8 = {
  25: 1,
  26: 3,
  29: 5,
  30: 7,
  31: 9,
  24: 11,
  27: 12,
  28: 14
}, eW = {
  25: 2,
  26: 4,
  29: 6,
  30: 8,
  31: 10,
  27: 13,
  28: 15
}, tW = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "black", "transparent"];
class rW {
  constructor() {
    this.time = null, this.verboseLevel = 0;
  }
  log(e, t) {
    if (this.verboseLevel >= e) {
      const n = typeof t == "function" ? t() : t;
      Ae.log(`${this.time} [${e}] ${n}`);
    }
  }
}
const Wn = function(e) {
  const t = [];
  for (let n = 0; n < e.length; n++)
    t.push(e[n].toString(16));
  return t;
};
class Vw {
  constructor() {
    this.foreground = "white", this.underline = !1, this.italics = !1, this.background = "black", this.flash = !1;
  }
  reset() {
    this.foreground = "white", this.underline = !1, this.italics = !1, this.background = "black", this.flash = !1;
  }
  setStyles(e) {
    const t = ["foreground", "underline", "italics", "background", "flash"];
    for (let n = 0; n < t.length; n++) {
      const i = t[n];
      e.hasOwnProperty(i) && (this[i] = e[i]);
    }
  }
  isDefault() {
    return this.foreground === "white" && !this.underline && !this.italics && this.background === "black" && !this.flash;
  }
  equals(e) {
    return this.foreground === e.foreground && this.underline === e.underline && this.italics === e.italics && this.background === e.background && this.flash === e.flash;
  }
  copy(e) {
    this.foreground = e.foreground, this.underline = e.underline, this.italics = e.italics, this.background = e.background, this.flash = e.flash;
  }
  toString() {
    return "color=" + this.foreground + ", underline=" + this.underline + ", italics=" + this.italics + ", background=" + this.background + ", flash=" + this.flash;
  }
}
class nW {
  constructor() {
    this.uchar = " ", this.penState = new Vw();
  }
  reset() {
    this.uchar = " ", this.penState.reset();
  }
  setChar(e, t) {
    this.uchar = e, this.penState.copy(t);
  }
  setPenState(e) {
    this.penState.copy(e);
  }
  equals(e) {
    return this.uchar === e.uchar && this.penState.equals(e.penState);
  }
  copy(e) {
    this.uchar = e.uchar, this.penState.copy(e.penState);
  }
  isEmpty() {
    return this.uchar === " " && this.penState.isDefault();
  }
}
class iW {
  constructor(e) {
    this.chars = [], this.pos = 0, this.currPenState = new Vw(), this.cueStartTime = null, this.logger = void 0;
    for (let t = 0; t < qr; t++)
      this.chars.push(new nW());
    this.logger = e;
  }
  equals(e) {
    for (let t = 0; t < qr; t++)
      if (!this.chars[t].equals(e.chars[t]))
        return !1;
    return !0;
  }
  copy(e) {
    for (let t = 0; t < qr; t++)
      this.chars[t].copy(e.chars[t]);
  }
  isEmpty() {
    let e = !0;
    for (let t = 0; t < qr; t++)
      if (!this.chars[t].isEmpty()) {
        e = !1;
        break;
      }
    return e;
  }
  /**
   *  Set the cursor to a valid column.
   */
  setCursor(e) {
    this.pos !== e && (this.pos = e), this.pos < 0 ? (this.logger.log(3, "Negative cursor position " + this.pos), this.pos = 0) : this.pos > qr && (this.logger.log(3, "Too large cursor position " + this.pos), this.pos = qr);
  }
  /**
   * Move the cursor relative to current position.
   */
  moveCursor(e) {
    const t = this.pos + e;
    if (e > 1)
      for (let n = this.pos + 1; n < t + 1; n++)
        this.chars[n].setPenState(this.currPenState);
    this.setCursor(t);
  }
  /**
   * Backspace, move one step back and clear character.
   */
  backSpace() {
    this.moveCursor(-1), this.chars[this.pos].setChar(" ", this.currPenState);
  }
  insertChar(e) {
    e >= 144 && this.backSpace();
    const t = Kw(e);
    if (this.pos >= qr) {
      this.logger.log(0, () => "Cannot insert " + e.toString(16) + " (" + t + ") at position " + this.pos + ". Skipping it!");
      return;
    }
    this.chars[this.pos].setChar(t, this.currPenState), this.moveCursor(1);
  }
  clearFromPos(e) {
    let t;
    for (t = e; t < qr; t++)
      this.chars[t].reset();
  }
  clear() {
    this.clearFromPos(0), this.pos = 0, this.currPenState.reset();
  }
  clearToEndOfRow() {
    this.clearFromPos(this.pos);
  }
  getTextString() {
    const e = [];
    let t = !0;
    for (let n = 0; n < qr; n++) {
      const i = this.chars[n].uchar;
      i !== " " && (t = !1), e.push(i);
    }
    return t ? "" : e.join("");
  }
  setPenStyles(e) {
    this.currPenState.setStyles(e), this.chars[this.pos].setPenState(this.currPenState);
  }
}
class od {
  constructor(e) {
    this.rows = [], this.currRow = Tr - 1, this.nrRollUpRows = null, this.lastOutputScreen = null, this.logger = void 0;
    for (let t = 0; t < Tr; t++)
      this.rows.push(new iW(e));
    this.logger = e;
  }
  reset() {
    for (let e = 0; e < Tr; e++)
      this.rows[e].clear();
    this.currRow = Tr - 1;
  }
  equals(e) {
    let t = !0;
    for (let n = 0; n < Tr; n++)
      if (!this.rows[n].equals(e.rows[n])) {
        t = !1;
        break;
      }
    return t;
  }
  copy(e) {
    for (let t = 0; t < Tr; t++)
      this.rows[t].copy(e.rows[t]);
  }
  isEmpty() {
    let e = !0;
    for (let t = 0; t < Tr; t++)
      if (!this.rows[t].isEmpty()) {
        e = !1;
        break;
      }
    return e;
  }
  backSpace() {
    this.rows[this.currRow].backSpace();
  }
  clearToEndOfRow() {
    this.rows[this.currRow].clearToEndOfRow();
  }
  /**
   * Insert a character (without styling) in the current row.
   */
  insertChar(e) {
    this.rows[this.currRow].insertChar(e);
  }
  setPen(e) {
    this.rows[this.currRow].setPenStyles(e);
  }
  moveCursor(e) {
    this.rows[this.currRow].moveCursor(e);
  }
  setCursor(e) {
    this.logger.log(2, "setCursor: " + e), this.rows[this.currRow].setCursor(e);
  }
  setPAC(e) {
    this.logger.log(2, () => "pacData = " + We(e));
    let t = e.row - 1;
    if (this.nrRollUpRows && t < this.nrRollUpRows - 1 && (t = this.nrRollUpRows - 1), this.nrRollUpRows && this.currRow !== t) {
      for (let o = 0; o < Tr; o++)
        this.rows[o].clear();
      const s = this.currRow + 1 - this.nrRollUpRows, a = this.lastOutputScreen;
      if (a) {
        const o = a.rows[s].cueStartTime, c = this.logger.time;
        if (o !== null && c !== null && o < c)
          for (let l = 0; l < this.nrRollUpRows; l++)
            this.rows[t - this.nrRollUpRows + l + 1].copy(a.rows[s + l]);
      }
    }
    this.currRow = t;
    const n = this.rows[this.currRow];
    if (e.indent !== null) {
      const s = e.indent, a = Math.max(s - 1, 0);
      n.setCursor(e.indent), e.color = n.chars[a].penState.foreground;
    }
    const i = {
      foreground: e.color,
      underline: e.underline,
      italics: e.italics,
      background: "black",
      flash: !1
    };
    this.setPen(i);
  }
  /**
   * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).
   */
  setBkgData(e) {
    this.logger.log(2, () => "bkgData = " + We(e)), this.backSpace(), this.setPen(e), this.insertChar(32);
  }
  setRollUpRows(e) {
    this.nrRollUpRows = e;
  }
  rollUp() {
    if (this.nrRollUpRows === null) {
      this.logger.log(3, "roll_up but nrRollUpRows not set yet");
      return;
    }
    this.logger.log(1, () => this.getDisplayText());
    const e = this.currRow + 1 - this.nrRollUpRows, t = this.rows.splice(e, 1)[0];
    t.clear(), this.rows.splice(this.currRow, 0, t), this.logger.log(2, "Rolling up");
  }
  /**
   * Get all non-empty rows with as unicode text.
   */
  getDisplayText(e) {
    e = e || !1;
    const t = [];
    let n = "", i = -1;
    for (let s = 0; s < Tr; s++) {
      const a = this.rows[s].getTextString();
      a && (i = s + 1, e ? t.push("Row " + i + ": '" + a + "'") : t.push(a.trim()));
    }
    return t.length > 0 && (e ? n = "[" + t.join(" | ") + "]" : n = t.join(`
`)), n;
  }
  getTextAndFormat() {
    return this.rows;
  }
}
class Ob {
  constructor(e, t, n) {
    this.chNr = void 0, this.outputFilter = void 0, this.mode = void 0, this.verbose = void 0, this.displayedMemory = void 0, this.nonDisplayedMemory = void 0, this.lastOutputScreen = void 0, this.currRollUpRow = void 0, this.writeScreen = void 0, this.cueStartTime = void 0, this.logger = void 0, this.chNr = e, this.outputFilter = t, this.mode = null, this.verbose = 0, this.displayedMemory = new od(n), this.nonDisplayedMemory = new od(n), this.lastOutputScreen = new od(n), this.currRollUpRow = this.displayedMemory.rows[Tr - 1], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null, this.logger = n;
  }
  reset() {
    this.mode = null, this.displayedMemory.reset(), this.nonDisplayedMemory.reset(), this.lastOutputScreen.reset(), this.outputFilter.reset(), this.currRollUpRow = this.displayedMemory.rows[Tr - 1], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null;
  }
  getHandler() {
    return this.outputFilter;
  }
  setHandler(e) {
    this.outputFilter = e;
  }
  setPAC(e) {
    this.writeScreen.setPAC(e);
  }
  setBkgData(e) {
    this.writeScreen.setBkgData(e);
  }
  setMode(e) {
    e !== this.mode && (this.mode = e, this.logger.log(2, () => "MODE=" + e), this.mode === "MODE_POP-ON" ? this.writeScreen = this.nonDisplayedMemory : (this.writeScreen = this.displayedMemory, this.writeScreen.reset()), this.mode !== "MODE_ROLL-UP" && (this.displayedMemory.nrRollUpRows = null, this.nonDisplayedMemory.nrRollUpRows = null), this.mode = e);
  }
  insertChars(e) {
    for (let n = 0; n < e.length; n++)
      this.writeScreen.insertChar(e[n]);
    const t = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP";
    this.logger.log(2, () => t + ": " + this.writeScreen.getDisplayText(!0)), (this.mode === "MODE_PAINT-ON" || this.mode === "MODE_ROLL-UP") && (this.logger.log(1, () => "DISPLAYED: " + this.displayedMemory.getDisplayText(!0)), this.outputDataUpdate());
  }
  ccRCL() {
    this.logger.log(2, "RCL - Resume Caption Loading"), this.setMode("MODE_POP-ON");
  }
  ccBS() {
    this.logger.log(2, "BS - BackSpace"), this.mode !== "MODE_TEXT" && (this.writeScreen.backSpace(), this.writeScreen === this.displayedMemory && this.outputDataUpdate());
  }
  ccAOF() {
  }
  ccAON() {
  }
  ccDER() {
    this.logger.log(2, "DER- Delete to End of Row"), this.writeScreen.clearToEndOfRow(), this.outputDataUpdate();
  }
  ccRU(e) {
    this.logger.log(2, "RU(" + e + ") - Roll Up"), this.writeScreen = this.displayedMemory, this.setMode("MODE_ROLL-UP"), this.writeScreen.setRollUpRows(e);
  }
  ccFON() {
    this.logger.log(2, "FON - Flash On"), this.writeScreen.setPen({
      flash: !0
    });
  }
  ccRDC() {
    this.logger.log(2, "RDC - Resume Direct Captioning"), this.setMode("MODE_PAINT-ON");
  }
  ccTR() {
    this.logger.log(2, "TR"), this.setMode("MODE_TEXT");
  }
  ccRTD() {
    this.logger.log(2, "RTD"), this.setMode("MODE_TEXT");
  }
  ccEDM() {
    this.logger.log(2, "EDM - Erase Displayed Memory"), this.displayedMemory.reset(), this.outputDataUpdate(!0);
  }
  ccCR() {
    this.logger.log(2, "CR - Carriage Return"), this.writeScreen.rollUp(), this.outputDataUpdate(!0);
  }
  ccENM() {
    this.logger.log(2, "ENM - Erase Non-displayed Memory"), this.nonDisplayedMemory.reset();
  }
  ccEOC() {
    if (this.logger.log(2, "EOC - End Of Caption"), this.mode === "MODE_POP-ON") {
      const e = this.displayedMemory;
      this.displayedMemory = this.nonDisplayedMemory, this.nonDisplayedMemory = e, this.writeScreen = this.nonDisplayedMemory, this.logger.log(1, () => "DISP: " + this.displayedMemory.getDisplayText());
    }
    this.outputDataUpdate(!0);
  }
  ccTO(e) {
    this.logger.log(2, "TO(" + e + ") - Tab Offset"), this.writeScreen.moveCursor(e);
  }
  ccMIDROW(e) {
    const t = {
      flash: !1
    };
    if (t.underline = e % 2 === 1, t.italics = e >= 46, t.italics)
      t.foreground = "white";
    else {
      const n = Math.floor(e / 2) - 16, i = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"];
      t.foreground = i[n];
    }
    this.logger.log(2, "MIDROW: " + We(t)), this.writeScreen.setPen(t);
  }
  outputDataUpdate(e = !1) {
    const t = this.logger.time;
    t !== null && this.outputFilter && (this.cueStartTime === null && !this.displayedMemory.isEmpty() ? this.cueStartTime = t : this.displayedMemory.equals(this.lastOutputScreen) || (this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen), e && this.outputFilter.dispatchCue && this.outputFilter.dispatchCue(), this.cueStartTime = this.displayedMemory.isEmpty() ? null : t), this.lastOutputScreen.copy(this.displayedMemory));
  }
  cueSplitAtTime(e) {
    this.outputFilter && (this.displayedMemory.isEmpty() || (this.outputFilter.newCue && this.outputFilter.newCue(this.cueStartTime, e, this.displayedMemory), this.cueStartTime = e));
  }
}
class Rb {
  constructor(e, t, n) {
    this.channels = void 0, this.currentChannel = 0, this.cmdHistory = aW(), this.logger = void 0;
    const i = this.logger = new rW();
    this.channels = [null, new Ob(e, t, i), new Ob(e + 1, n, i)];
  }
  getHandler(e) {
    return this.channels[e].getHandler();
  }
  setHandler(e, t) {
    this.channels[e].setHandler(t);
  }
  /**
   * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.
   */
  addData(e, t) {
    this.logger.time = e;
    for (let n = 0; n < t.length; n += 2) {
      const i = t[n] & 127, s = t[n + 1] & 127;
      let a = !1, o = null;
      if (i === 0 && s === 0)
        continue;
      this.logger.log(3, () => "[" + Wn([t[n], t[n + 1]]) + "] -> (" + Wn([i, s]) + ")");
      const c = this.cmdHistory;
      if (i >= 16 && i <= 31) {
        if (sW(i, s, c)) {
          lo(null, null, c), this.logger.log(3, () => "Repeated command (" + Wn([i, s]) + ") is dropped");
          continue;
        }
        lo(i, s, this.cmdHistory), a = this.parseCmd(i, s), a || (a = this.parseMidrow(i, s)), a || (a = this.parsePAC(i, s)), a || (a = this.parseBackgroundAttributes(i, s));
      } else
        lo(null, null, c);
      if (!a && (o = this.parseChars(i, s), o)) {
        const u = this.currentChannel;
        u && u > 0 ? this.channels[u].insertChars(o) : this.logger.log(2, "No channel found yet. TEXT-MODE?");
      }
      !a && !o && this.logger.log(2, () => "Couldn't parse cleaned data " + Wn([i, s]) + " orig: " + Wn([t[n], t[n + 1]]));
    }
  }
  /**
   * Parse Command.
   * @returns True if a command was found
   */
  parseCmd(e, t) {
    const n = (e === 20 || e === 28 || e === 21 || e === 29) && t >= 32 && t <= 47, i = (e === 23 || e === 31) && t >= 33 && t <= 35;
    if (!(n || i))
      return !1;
    const s = e === 20 || e === 21 || e === 23 ? 1 : 2, a = this.channels[s];
    return e === 20 || e === 21 || e === 28 || e === 29 ? t === 32 ? a.ccRCL() : t === 33 ? a.ccBS() : t === 34 ? a.ccAOF() : t === 35 ? a.ccAON() : t === 36 ? a.ccDER() : t === 37 ? a.ccRU(2) : t === 38 ? a.ccRU(3) : t === 39 ? a.ccRU(4) : t === 40 ? a.ccFON() : t === 41 ? a.ccRDC() : t === 42 ? a.ccTR() : t === 43 ? a.ccRTD() : t === 44 ? a.ccEDM() : t === 45 ? a.ccCR() : t === 46 ? a.ccENM() : t === 47 && a.ccEOC() : a.ccTO(t - 32), this.currentChannel = s, !0;
  }
  /**
   * Parse midrow styling command
   */
  parseMidrow(e, t) {
    let n = 0;
    if ((e === 17 || e === 25) && t >= 32 && t <= 47) {
      if (e === 17 ? n = 1 : n = 2, n !== this.currentChannel)
        return this.logger.log(0, "Mismatch channel in midrow parsing"), !1;
      const i = this.channels[n];
      return i ? (i.ccMIDROW(t), this.logger.log(3, () => "MIDROW (" + Wn([e, t]) + ")"), !0) : !1;
    }
    return !1;
  }
  /**
   * Parse Preable Access Codes (Table 53).
   * @returns {Boolean} Tells if PAC found
   */
  parsePAC(e, t) {
    let n;
    const i = (e >= 17 && e <= 23 || e >= 25 && e <= 31) && t >= 64 && t <= 127, s = (e === 16 || e === 24) && t >= 64 && t <= 95;
    if (!(i || s))
      return !1;
    const a = e <= 23 ? 1 : 2;
    t >= 64 && t <= 95 ? n = a === 1 ? Q8[e] : J8[e] : n = a === 1 ? Z8[e] : eW[e];
    const o = this.channels[a];
    return o ? (o.setPAC(this.interpretPAC(n, t)), this.currentChannel = a, !0) : !1;
  }
  /**
   * Interpret the second byte of the pac, and return the information.
   * @returns pacData with style parameters
   */
  interpretPAC(e, t) {
    let n;
    const i = {
      color: null,
      italics: !1,
      indent: null,
      underline: !1,
      row: e
    };
    return t > 95 ? n = t - 96 : n = t - 64, i.underline = (n & 1) === 1, n <= 13 ? i.color = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "white"][Math.floor(n / 2)] : n <= 15 ? (i.italics = !0, i.color = "white") : i.indent = Math.floor((n - 16) / 2) * 4, i;
  }
  /**
   * Parse characters.
   * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.
   */
  parseChars(e, t) {
    let n, i = null, s = null;
    if (e >= 25 ? (n = 2, s = e - 8) : (n = 1, s = e), s >= 17 && s <= 19) {
      let a;
      s === 17 ? a = t + 80 : s === 18 ? a = t + 112 : a = t + 144, this.logger.log(2, () => "Special char '" + Kw(a) + "' in channel " + n), i = [a];
    } else e >= 32 && e <= 127 && (i = t === 0 ? [e] : [e, t]);
    return i && this.logger.log(3, () => "Char codes =  " + Wn(i).join(",")), i;
  }
  /**
   * Parse extended background attributes as well as new foreground color black.
   * @returns True if background attributes are found
   */
  parseBackgroundAttributes(e, t) {
    const n = (e === 16 || e === 24) && t >= 32 && t <= 47, i = (e === 23 || e === 31) && t >= 45 && t <= 47;
    if (!(n || i))
      return !1;
    let s;
    const a = {};
    e === 16 || e === 24 ? (s = Math.floor((t - 32) / 2), a.background = tW[s], t % 2 === 1 && (a.background = a.background + "_semi")) : t === 45 ? a.background = "transparent" : (a.foreground = "black", t === 47 && (a.underline = !0));
    const o = e <= 23 ? 1 : 2;
    return this.channels[o].setBkgData(a), !0;
  }
  /**
   * Reset state of parser and its channels.
   */
  reset() {
    for (let e = 0; e < Object.keys(this.channels).length; e++) {
      const t = this.channels[e];
      t && t.reset();
    }
    lo(null, null, this.cmdHistory);
  }
  /**
   * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.
   */
  cueSplitAtTime(e) {
    for (let t = 0; t < this.channels.length; t++) {
      const n = this.channels[t];
      n && n.cueSplitAtTime(e);
    }
  }
}
function lo(r, e, t) {
  t.a = r, t.b = e;
}
function sW(r, e, t) {
  return t.a === r && t.b === e;
}
function aW() {
  return {
    a: null,
    b: null
  };
}
var sm = function() {
  if (dl != null && dl.VTTCue)
    return self.VTTCue;
  const r = ["", "lr", "rl"], e = ["start", "middle", "end", "left", "right"];
  function t(o, c) {
    if (typeof c != "string" || !Array.isArray(o))
      return !1;
    const l = c.toLowerCase();
    return ~o.indexOf(l) ? l : !1;
  }
  function n(o) {
    return t(r, o);
  }
  function i(o) {
    return t(e, o);
  }
  function s(o, ...c) {
    let l = 1;
    for (; l < arguments.length; l++) {
      const u = arguments[l];
      for (const d in u)
        o[d] = u[d];
    }
    return o;
  }
  function a(o, c, l) {
    const u = this, d = {
      enumerable: !0
    };
    u.hasBeenReset = !1;
    let f = "", h = !1, g = o, m = c, p = l, v = null, y = "", b = !0, x = "auto", S = "start", A = 50, T = "middle", I = 50, L = "middle";
    Object.defineProperty(u, "id", s({}, d, {
      get: function() {
        return f;
      },
      set: function(_) {
        f = "" + _;
      }
    })), Object.defineProperty(u, "pauseOnExit", s({}, d, {
      get: function() {
        return h;
      },
      set: function(_) {
        h = !!_;
      }
    })), Object.defineProperty(u, "startTime", s({}, d, {
      get: function() {
        return g;
      },
      set: function(_) {
        if (typeof _ != "number")
          throw new TypeError("Start time must be set to a number.");
        g = _, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(u, "endTime", s({}, d, {
      get: function() {
        return m;
      },
      set: function(_) {
        if (typeof _ != "number")
          throw new TypeError("End time must be set to a number.");
        m = _, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(u, "text", s({}, d, {
      get: function() {
        return p;
      },
      set: function(_) {
        p = "" + _, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(u, "region", s({}, d, {
      get: function() {
        return v;
      },
      set: function(_) {
        v = _, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(u, "vertical", s({}, d, {
      get: function() {
        return y;
      },
      set: function(_) {
        const R = n(_);
        if (R === !1)
          throw new SyntaxError("An invalid or illegal string was specified.");
        y = R, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(u, "snapToLines", s({}, d, {
      get: function() {
        return b;
      },
      set: function(_) {
        b = !!_, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(u, "line", s({}, d, {
      get: function() {
        return x;
      },
      set: function(_) {
        if (typeof _ != "number" && _ !== "auto")
          throw new SyntaxError("An invalid number or illegal string was specified.");
        x = _, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(u, "lineAlign", s({}, d, {
      get: function() {
        return S;
      },
      set: function(_) {
        const R = i(_);
        if (!R)
          throw new SyntaxError("An invalid or illegal string was specified.");
        S = R, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(u, "position", s({}, d, {
      get: function() {
        return A;
      },
      set: function(_) {
        if (_ < 0 || _ > 100)
          throw new Error("Position must be between 0 and 100.");
        A = _, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(u, "positionAlign", s({}, d, {
      get: function() {
        return T;
      },
      set: function(_) {
        const R = i(_);
        if (!R)
          throw new SyntaxError("An invalid or illegal string was specified.");
        T = R, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(u, "size", s({}, d, {
      get: function() {
        return I;
      },
      set: function(_) {
        if (_ < 0 || _ > 100)
          throw new Error("Size must be between 0 and 100.");
        I = _, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(u, "align", s({}, d, {
      get: function() {
        return L;
      },
      set: function(_) {
        const R = i(_);
        if (!R)
          throw new SyntaxError("An invalid or illegal string was specified.");
        L = R, this.hasBeenReset = !0;
      }
    })), u.displayState = void 0;
  }
  return a.prototype.getCueAsHTML = function() {
    return self.WebVTT.convertCueToDOMTree(self, this.text);
  }, a;
}();
class oW {
  decode(e, t) {
    if (!e)
      return "";
    if (typeof e != "string")
      throw new Error("Error - expected string data.");
    return decodeURIComponent(encodeURIComponent(e));
  }
}
function Ww(r) {
  function e(n, i, s, a) {
    return (n | 0) * 3600 + (i | 0) * 60 + (s | 0) + parseFloat(a || 0);
  }
  const t = r.match(/^(?:(\d+):)?(\d{2}):(\d{2})(\.\d+)?/);
  return t ? parseFloat(t[2]) > 59 ? e(t[2], t[3], 0, t[4]) : e(t[1], t[2], t[3], t[4]) : null;
}
class lW {
  constructor() {
    this.values = /* @__PURE__ */ Object.create(null);
  }
  // Only accept the first assignment to any key.
  set(e, t) {
    !this.get(e) && t !== "" && (this.values[e] = t);
  }
  // Return the value for a key, or a default value.
  // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
  // a number of possible default values as properties where 'defaultKey' is
  // the key of the property that will be chosen; otherwise it's assumed to be
  // a single value.
  get(e, t, n) {
    return n ? this.has(e) ? this.values[e] : t[n] : this.has(e) ? this.values[e] : t;
  }
  // Check whether we have a value for a key.
  has(e) {
    return e in this.values;
  }
  // Accept a setting if its one of the given alternatives.
  alt(e, t, n) {
    for (let i = 0; i < n.length; ++i)
      if (t === n[i]) {
        this.set(e, t);
        break;
      }
  }
  // Accept a setting if its a valid (signed) integer.
  integer(e, t) {
    /^-?\d+$/.test(t) && this.set(e, parseInt(t, 10));
  }
  // Accept a setting if its a valid percentage.
  percent(e, t) {
    if (/^([\d]{1,3})(\.[\d]*)?%$/.test(t)) {
      const n = parseFloat(t);
      if (n >= 0 && n <= 100)
        return this.set(e, n), !0;
    }
    return !1;
  }
}
function Hw(r, e, t, n) {
  const i = n ? r.split(n) : [r];
  for (const s in i) {
    if (typeof i[s] != "string")
      continue;
    const a = i[s].split(t);
    if (a.length !== 2)
      continue;
    const o = a[0], c = a[1];
    e(o, c);
  }
}
const Of = new sm(0, 0, ""), co = Of.align === "middle" ? "middle" : "center";
function cW(r, e, t) {
  const n = r;
  function i() {
    const o = Ww(r);
    if (o === null)
      throw new Error("Malformed timestamp: " + n);
    return r = r.replace(/^[^\sa-zA-Z-]+/, ""), o;
  }
  function s(o, c) {
    const l = new lW();
    Hw(o, function(f, h) {
      let g;
      switch (f) {
        case "region":
          for (let m = t.length - 1; m >= 0; m--)
            if (t[m].id === h) {
              l.set(f, t[m].region);
              break;
            }
          break;
        case "vertical":
          l.alt(f, h, ["rl", "lr"]);
          break;
        case "line":
          g = h.split(","), l.integer(f, g[0]), l.percent(f, g[0]) && l.set("snapToLines", !1), l.alt(f, g[0], ["auto"]), g.length === 2 && l.alt("lineAlign", g[1], ["start", co, "end"]);
          break;
        case "position":
          g = h.split(","), l.percent(f, g[0]), g.length === 2 && l.alt("positionAlign", g[1], ["start", co, "end", "line-left", "line-right", "auto"]);
          break;
        case "size":
          l.percent(f, h);
          break;
        case "align":
          l.alt(f, h, ["start", co, "end", "left", "right"]);
          break;
      }
    }, /:/, /\s/), c.region = l.get("region", null), c.vertical = l.get("vertical", "");
    let u = l.get("line", "auto");
    u === "auto" && Of.line === -1 && (u = -1), c.line = u, c.lineAlign = l.get("lineAlign", "start"), c.snapToLines = l.get("snapToLines", !0), c.size = l.get("size", 100), c.align = l.get("align", co);
    let d = l.get("position", "auto");
    d === "auto" && Of.position === 50 && (d = c.align === "start" || c.align === "left" ? 0 : c.align === "end" || c.align === "right" ? 100 : 50), c.position = d;
  }
  function a() {
    r = r.replace(/^\s+/, "");
  }
  if (a(), e.startTime = i(), a(), r.slice(0, 3) !== "-->")
    throw new Error("Malformed time stamp (time stamps must be separated by '-->'): " + n);
  r = r.slice(3), a(), e.endTime = i(), a(), s(r, e);
}
function qw(r) {
  return r.replace(/<br(?: \/)?>/gi, `
`);
}
class uW {
  constructor() {
    this.state = "INITIAL", this.buffer = "", this.decoder = new oW(), this.regionList = [], this.cue = null, this.oncue = void 0, this.onparsingerror = void 0, this.onflush = void 0;
  }
  parse(e) {
    const t = this;
    e && (t.buffer += t.decoder.decode(e, {
      stream: !0
    }));
    function n() {
      let s = t.buffer, a = 0;
      for (s = qw(s); a < s.length && s[a] !== "\r" && s[a] !== `
`; )
        ++a;
      const o = s.slice(0, a);
      return s[a] === "\r" && ++a, s[a] === `
` && ++a, t.buffer = s.slice(a), o;
    }
    function i(s) {
      Hw(s, function(a, o) {
      }, /:/);
    }
    try {
      let s = "";
      if (t.state === "INITIAL") {
        if (!/\r\n|\n/.test(t.buffer))
          return this;
        s = n();
        const o = s.match(/^(ï»¿)?WEBVTT([ \t].*)?$/);
        if (!(o != null && o[0]))
          throw new Error("Malformed WebVTT signature.");
        t.state = "HEADER";
      }
      let a = !1;
      for (; t.buffer; ) {
        if (!/\r\n|\n/.test(t.buffer))
          return this;
        switch (a ? a = !1 : s = n(), t.state) {
          case "HEADER":
            /:/.test(s) ? i(s) : s || (t.state = "ID");
            continue;
          case "NOTE":
            s || (t.state = "ID");
            continue;
          case "ID":
            if (/^NOTE($|[ \t])/.test(s)) {
              t.state = "NOTE";
              break;
            }
            if (!s)
              continue;
            if (t.cue = new sm(0, 0, ""), t.state = "CUE", s.indexOf("-->") === -1) {
              t.cue.id = s;
              continue;
            }
          // Process line as start of a cue.
          /* falls through */
          case "CUE":
            if (!t.cue) {
              t.state = "BADCUE";
              continue;
            }
            try {
              cW(s, t.cue, t.regionList);
            } catch {
              t.cue = null, t.state = "BADCUE";
              continue;
            }
            t.state = "CUETEXT";
            continue;
          case "CUETEXT":
            {
              const o = s.indexOf("-->") !== -1;
              if (!s || o && (a = !0)) {
                t.oncue && t.cue && t.oncue(t.cue), t.cue = null, t.state = "ID";
                continue;
              }
              if (t.cue === null)
                continue;
              t.cue.text && (t.cue.text += `
`), t.cue.text += s;
            }
            continue;
          case "BADCUE":
            s || (t.state = "ID");
        }
      }
    } catch {
      t.state === "CUETEXT" && t.cue && t.oncue && t.oncue(t.cue), t.cue = null, t.state = t.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
    }
    return this;
  }
  flush() {
    const e = this;
    try {
      if ((e.cue || e.state === "HEADER") && (e.buffer += `

`, e.parse()), e.state === "INITIAL" || e.state === "BADWEBVTT")
        throw new Error("Malformed WebVTT signature.");
    } catch (t) {
      e.onparsingerror && e.onparsingerror(t);
    }
    return e.onflush && e.onflush(), this;
  }
}
const dW = /\r\n|\n\r|\n|\r/g, ld = function(e, t, n = 0) {
  return e.slice(n, n + t.length) === t;
}, fW = function(e) {
  let t = parseInt(e.slice(-3));
  const n = parseInt(e.slice(-6, -4)), i = parseInt(e.slice(-9, -7)), s = e.length > 9 ? parseInt(e.substring(0, e.indexOf(":"))) : 0;
  if (!X(t) || !X(n) || !X(i) || !X(s))
    throw Error(`Malformed X-TIMESTAMP-MAP: Local:${e}`);
  return t += 1e3 * n, t += 60 * 1e3 * i, t += 60 * 60 * 1e3 * s, t;
};
function am(r, e, t) {
  return js(r.toString()) + js(e.toString()) + js(t);
}
const hW = function(e, t, n) {
  let i = e[t], s = e[i.prevCC];
  if (!s || !s.new && i.new) {
    e.ccOffset = e.presentationOffset = i.start, i.new = !1;
    return;
  }
  for (; (a = s) != null && a.new; ) {
    var a;
    e.ccOffset += i.start - s.start, i.new = !1, i = s, s = e[i.prevCC];
  }
  e.presentationOffset = n;
};
function gW(r, e, t, n, i, s, a) {
  const o = new uW(), c = tr(new Uint8Array(r)).trim().replace(dW, `
`).split(`
`), l = [], u = e ? LV(e.baseTime, e.timescale) : 0;
  let d = "00:00.000", f = 0, h = 0, g, m = !0;
  o.oncue = function(p) {
    const v = t[n];
    let y = t.ccOffset;
    const b = (f - u) / 9e4;
    if (v != null && v.new && (h !== void 0 ? y = t.ccOffset = v.start : hW(t, n, b)), b) {
      if (!e) {
        g = new Error("Missing initPTS for VTT MPEGTS");
        return;
      }
      y = b - t.presentationOffset;
    }
    const x = p.endTime - p.startTime, S = dr((p.startTime + y - h) * 9e4, i * 9e4) / 9e4;
    p.startTime = Math.max(S, 0), p.endTime = Math.max(S + x, 0);
    const A = p.text.trim();
    p.text = decodeURIComponent(encodeURIComponent(A)), p.id || (p.id = am(p.startTime, p.endTime, A)), p.endTime > 0 && l.push(p);
  }, o.onparsingerror = function(p) {
    g = p;
  }, o.onflush = function() {
    if (g) {
      a(g);
      return;
    }
    s(l);
  }, c.forEach((p) => {
    if (m)
      if (ld(p, "X-TIMESTAMP-MAP=")) {
        m = !1, p.slice(16).split(",").forEach((v) => {
          ld(v, "LOCAL:") ? d = v.slice(6) : ld(v, "MPEGTS:") && (f = parseInt(v.slice(7)));
        });
        try {
          h = fW(d) / 1e3;
        } catch (v) {
          g = v;
        }
        return;
      } else p === "" && (m = !1);
    o.parse(p + `
`);
  }), o.flush();
}
const cd = "stpp.ttml.im1t", zw = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/, Yw = /^(\d*(?:\.\d*)?)(h|m|s|ms|f|t)$/, mW = {
  left: "start",
  center: "center",
  right: "end",
  start: "start",
  end: "end"
};
function Db(r, e, t, n) {
  const i = ge(new Uint8Array(r), ["mdat"]);
  if (i.length === 0) {
    n(new Error("Could not parse IMSC1 mdat"));
    return;
  }
  const s = i.map((o) => tr(o)), a = _V(e.baseTime, 1, e.timescale);
  try {
    s.forEach((o) => t(pW(o, a)));
  } catch (o) {
    n(o);
  }
}
function pW(r, e) {
  const i = new DOMParser().parseFromString(r, "text/xml").getElementsByTagName("tt")[0];
  if (!i)
    throw new Error("Invalid ttml");
  const s = {
    frameRate: 30,
    subFrameRate: 1,
    frameRateMultiplier: 0,
    tickRate: 0
  }, a = Object.keys(s).reduce((d, f) => (d[f] = i.getAttribute(`ttp:${f}`) || s[f], d), {}), o = i.getAttribute("xml:space") !== "preserve", c = Cb(ud(i, "styling", "style")), l = Cb(ud(i, "layout", "region")), u = ud(i, "body", "[begin]");
  return [].map.call(u, (d) => {
    const f = Xw(d, o);
    if (!f || !d.hasAttribute("begin"))
      return null;
    const h = fd(d.getAttribute("begin"), a), g = fd(d.getAttribute("dur"), a);
    let m = fd(d.getAttribute("end"), a);
    if (h === null)
      throw kb(d);
    if (m === null) {
      if (g === null)
        throw kb(d);
      m = h + g;
    }
    const p = new sm(h - e, m - e, f);
    p.id = am(p.startTime, p.endTime, p.text);
    const v = l[d.getAttribute("region")], y = c[d.getAttribute("style")], b = vW(v, y, c), {
      textAlign: x
    } = b;
    if (x) {
      const S = mW[x];
      S && (p.lineAlign = S), p.align = x;
    }
    return Ce(p, b), p;
  }).filter((d) => d !== null);
}
function ud(r, e, t) {
  const n = r.getElementsByTagName(e)[0];
  return n ? [].slice.call(n.querySelectorAll(t)) : [];
}
function Cb(r) {
  return r.reduce((e, t) => {
    const n = t.getAttribute("xml:id");
    return n && (e[n] = t), e;
  }, {});
}
function Xw(r, e) {
  return [].slice.call(r.childNodes).reduce((t, n, i) => {
    var s;
    return n.nodeName === "br" && i ? t + `
` : (s = n.childNodes) != null && s.length ? Xw(n, e) : e ? t + n.textContent.trim().replace(/\s+/g, " ") : t + n.textContent;
  }, "");
}
function vW(r, e, t) {
  const n = "http://www.w3.org/ns/ttml#styling";
  let i = null;
  const s = [
    "displayAlign",
    "textAlign",
    "color",
    "backgroundColor",
    "fontSize",
    "fontFamily"
    // 'fontWeight',
    // 'lineHeight',
    // 'wrapOption',
    // 'fontStyle',
    // 'direction',
    // 'writingMode'
  ], a = r != null && r.hasAttribute("style") ? r.getAttribute("style") : null;
  return a && t.hasOwnProperty(a) && (i = t[a]), s.reduce((o, c) => {
    const l = dd(e, n, c) || dd(r, n, c) || dd(i, n, c);
    return l && (o[c] = l), o;
  }, {});
}
function dd(r, e, t) {
  return r && r.hasAttributeNS(e, t) ? r.getAttributeNS(e, t) : null;
}
function kb(r) {
  return new Error(`Could not parse ttml timestamp ${r}`);
}
function fd(r, e) {
  if (!r)
    return null;
  let t = Ww(r);
  return t === null && (zw.test(r) ? t = yW(r, e) : Yw.test(r) && (t = bW(r, e))), t;
}
function yW(r, e) {
  const t = zw.exec(r), n = (t[4] | 0) + (t[5] | 0) / e.subFrameRate;
  return (t[1] | 0) * 3600 + (t[2] | 0) * 60 + (t[3] | 0) + n / e.frameRate;
}
function bW(r, e) {
  const t = Yw.exec(r), n = Number(t[1]);
  switch (t[2]) {
    case "h":
      return n * 3600;
    case "m":
      return n * 60;
    case "ms":
      return n * 1e3;
    case "f":
      return n / e.frameRate;
    case "t":
      return n / e.tickRate;
  }
  return n;
}
class uo {
  constructor(e, t) {
    this.timelineController = void 0, this.cueRanges = [], this.trackName = void 0, this.startTime = null, this.endTime = null, this.screen = null, this.timelineController = e, this.trackName = t;
  }
  dispatchCue() {
    this.startTime !== null && (this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges), this.startTime = null);
  }
  newCue(e, t, n) {
    (this.startTime === null || this.startTime > e) && (this.startTime = e), this.endTime = t, this.screen = n, this.timelineController.createCaptionsTrack(this.trackName);
  }
  reset() {
    this.cueRanges = [], this.startTime = null;
  }
}
class xW {
  constructor(e) {
    this.hls = void 0, this.media = null, this.config = void 0, this.enabled = !0, this.Cues = void 0, this.textTracks = [], this.tracks = [], this.initPTS = [], this.unparsedVttFrags = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.cea608Parser1 = void 0, this.cea608Parser2 = void 0, this.lastCc = -1, this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = Nb(), this.captionsProperties = void 0, this.hls = e, this.config = e.config, this.Cues = e.config.cueHandler, this.captionsProperties = {
      textTrack1: {
        label: this.config.captionsTextTrack1Label,
        languageCode: this.config.captionsTextTrack1LanguageCode
      },
      textTrack2: {
        label: this.config.captionsTextTrack2Label,
        languageCode: this.config.captionsTextTrack2LanguageCode
      },
      textTrack3: {
        label: this.config.captionsTextTrack3Label,
        languageCode: this.config.captionsTextTrack3LanguageCode
      },
      textTrack4: {
        label: this.config.captionsTextTrack4Label,
        languageCode: this.config.captionsTextTrack4LanguageCode
      }
    }, e.on(E.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(E.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(E.MANIFEST_LOADING, this.onManifestLoading, this), e.on(E.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(E.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.on(E.FRAG_LOADING, this.onFragLoading, this), e.on(E.FRAG_LOADED, this.onFragLoaded, this), e.on(E.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), e.on(E.FRAG_DECRYPTED, this.onFragDecrypted, this), e.on(E.INIT_PTS_FOUND, this.onInitPtsFound, this), e.on(E.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), e.on(E.BUFFER_FLUSHING, this.onBufferFlushing, this);
  }
  destroy() {
    const {
      hls: e
    } = this;
    e.off(E.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(E.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(E.MANIFEST_LOADING, this.onManifestLoading, this), e.off(E.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(E.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.off(E.FRAG_LOADING, this.onFragLoading, this), e.off(E.FRAG_LOADED, this.onFragLoaded, this), e.off(E.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), e.off(E.FRAG_DECRYPTED, this.onFragDecrypted, this), e.off(E.INIT_PTS_FOUND, this.onInitPtsFound, this), e.off(E.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), e.off(E.BUFFER_FLUSHING, this.onBufferFlushing, this), this.hls = this.config = this.media = null, this.cea608Parser1 = this.cea608Parser2 = void 0;
  }
  initCea608Parsers() {
    const e = new uo(this, "textTrack1"), t = new uo(this, "textTrack2"), n = new uo(this, "textTrack3"), i = new uo(this, "textTrack4");
    this.cea608Parser1 = new Rb(1, e, t), this.cea608Parser2 = new Rb(3, n, i);
  }
  addCues(e, t, n, i, s) {
    let a = !1;
    for (let o = s.length; o--; ) {
      const c = s[o], l = EW(c[0], c[1], t, n);
      if (l >= 0 && (c[0] = Math.min(c[0], t), c[1] = Math.max(c[1], n), a = !0, l / (n - t) > 0.5))
        return;
    }
    if (a || s.push([t, n]), this.config.renderTextTracksNatively) {
      const o = this.captionsTracks[e];
      this.Cues.newCue(o, t, n, i);
    } else {
      const o = this.Cues.newCue(null, t, n, i);
      this.hls.trigger(E.CUES_PARSED, {
        type: "captions",
        cues: o,
        track: e
      });
    }
  }
  // Triggered when an initial PTS is found; used for synchronisation of WebVTT.
  onInitPtsFound(e, {
    frag: t,
    id: n,
    initPTS: i,
    timescale: s
  }) {
    const {
      unparsedVttFrags: a
    } = this;
    n === ee.MAIN && (this.initPTS[t.cc] = {
      baseTime: i,
      timescale: s
    }), a.length && (this.unparsedVttFrags = [], a.forEach((o) => {
      this.initPTS[o.frag.cc] ? this.onFragLoaded(E.FRAG_LOADED, o) : this.hls.trigger(E.SUBTITLE_FRAG_PROCESSED, {
        success: !1,
        frag: o.frag,
        error: new Error("Subtitle discontinuity domain does not match main")
      });
    }));
  }
  getExistingTrack(e, t) {
    const {
      media: n
    } = this;
    if (n)
      for (let i = 0; i < n.textTracks.length; i++) {
        const s = n.textTracks[i];
        if (Mb(s, {
          name: e,
          lang: t,
          characteristics: "transcribes-spoken-dialog,describes-music-and-sound"
        }))
          return s;
      }
    return null;
  }
  createCaptionsTrack(e) {
    this.config.renderTextTracksNatively ? this.createNativeTrack(e) : this.createNonNativeTrack(e);
  }
  createNativeTrack(e) {
    if (this.captionsTracks[e])
      return;
    const {
      captionsProperties: t,
      captionsTracks: n,
      media: i
    } = this, {
      label: s,
      languageCode: a
    } = t[e], o = this.getExistingTrack(s, a);
    if (o)
      n[e] = o, Ni(n[e]), jw(n[e], i);
    else {
      const c = this.createTextTrack("captions", s, a);
      c && (c[e] = !0, n[e] = c);
    }
  }
  createNonNativeTrack(e) {
    if (this.nonNativeCaptionsTracks[e])
      return;
    const t = this.captionsProperties[e];
    if (!t)
      return;
    const n = t.label, i = {
      _id: e,
      label: n,
      kind: "captions",
      default: t.media ? !!t.media.default : !1,
      closedCaptions: t.media
    };
    this.nonNativeCaptionsTracks[e] = i, this.hls.trigger(E.NON_NATIVE_TEXT_TRACKS_FOUND, {
      tracks: [i]
    });
  }
  createTextTrack(e, t, n) {
    const i = this.media;
    if (i)
      return i.addTextTrack(e, t, n);
  }
  onMediaAttaching(e, t) {
    this.media = t.media, t.mediaSource || this._cleanTracks();
  }
  onMediaDetaching(e, t) {
    const n = !!t.transferMedia;
    if (this.media = null, n)
      return;
    const {
      captionsTracks: i
    } = this;
    Object.keys(i).forEach((s) => {
      Ni(i[s]), delete i[s];
    }), this.nonNativeCaptionsTracks = {};
  }
  onManifestLoading() {
    this.lastCc = -1, this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = Nb(), this._cleanTracks(), this.tracks = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.textTracks = [], this.unparsedVttFrags = [], this.initPTS = [], this.cea608Parser1 && this.cea608Parser2 && (this.cea608Parser1.reset(), this.cea608Parser2.reset());
  }
  _cleanTracks() {
    const {
      media: e
    } = this;
    if (!e)
      return;
    const t = e.textTracks;
    if (t)
      for (let n = 0; n < t.length; n++)
        Ni(t[n]);
  }
  onSubtitleTracksUpdated(e, t) {
    const n = t.subtitleTracks || [], i = n.some((s) => s.textCodec === cd);
    if (this.config.enableWebVTT || i && this.config.enableIMSC1) {
      if (Dw(this.tracks, n)) {
        this.tracks = n;
        return;
      }
      if (this.textTracks = [], this.tracks = n, this.config.renderTextTracksNatively) {
        const a = this.media, o = a ? So(a.textTracks) : null;
        if (this.tracks.forEach((c, l) => {
          let u;
          if (o) {
            let d = null;
            for (let f = 0; f < o.length; f++)
              if (o[f] && Mb(o[f], c)) {
                d = o[f], o[f] = null;
                break;
              }
            d && (u = d);
          }
          if (u)
            Ni(u);
          else {
            const d = Qw(c);
            u = this.createTextTrack(d, c.name, c.lang), u && (u.mode = "disabled");
          }
          u && this.textTracks.push(u);
        }), o != null && o.length) {
          const c = o.filter((l) => l !== null).map((l) => l.label);
          c.length && this.hls.logger.warn(`Media element contains unused subtitle tracks: ${c.join(", ")}. Replace media element for each source to clear TextTracks and captions menu.`);
        }
      } else if (this.tracks.length) {
        const a = this.tracks.map((o) => ({
          label: o.name,
          kind: o.type.toLowerCase(),
          default: o.default,
          subtitleTrack: o
        }));
        this.hls.trigger(E.NON_NATIVE_TEXT_TRACKS_FOUND, {
          tracks: a
        });
      }
    }
  }
  onManifestLoaded(e, t) {
    this.config.enableCEA708Captions && t.captions && t.captions.forEach((n) => {
      const i = /(?:CC|SERVICE)([1-4])/.exec(n.instreamId);
      if (!i)
        return;
      const s = `textTrack${i[1]}`, a = this.captionsProperties[s];
      a && (a.label = n.name, n.lang && (a.languageCode = n.lang), a.media = n);
    });
  }
  closedCaptionsForLevel(e) {
    const t = this.hls.levels[e.level];
    return t == null ? void 0 : t.attrs["CLOSED-CAPTIONS"];
  }
  onFragLoading(e, t) {
    if (this.enabled && t.frag.type === ee.MAIN) {
      var n, i;
      const {
        cea608Parser1: s,
        cea608Parser2: a,
        lastSn: o
      } = this, {
        cc: c,
        sn: l
      } = t.frag, u = (n = (i = t.part) == null ? void 0 : i.index) != null ? n : -1;
      s && a && (l !== o + 1 || l === o && u !== this.lastPartIndex + 1 || c !== this.lastCc) && (s.reset(), a.reset()), this.lastCc = c, this.lastSn = l, this.lastPartIndex = u;
    }
  }
  onFragLoaded(e, t) {
    const {
      frag: n,
      payload: i
    } = t;
    if (n.type === ee.SUBTITLE)
      if (i.byteLength) {
        const s = n.decryptdata, a = "stats" in t;
        if (s == null || !s.encrypted || a) {
          const o = this.tracks[n.level], c = this.vttCCs;
          c[n.cc] || (c[n.cc] = {
            start: n.start,
            prevCC: this.prevCC,
            new: !0
          }, this.prevCC = n.cc), o && o.textCodec === cd ? this._parseIMSC1(n, i) : this._parseVTTs(t);
        }
      } else
        this.hls.trigger(E.SUBTITLE_FRAG_PROCESSED, {
          success: !1,
          frag: n,
          error: new Error("Empty subtitle payload")
        });
  }
  _parseIMSC1(e, t) {
    const n = this.hls;
    Db(t, this.initPTS[e.cc], (i) => {
      this._appendCues(i, e.level), n.trigger(E.SUBTITLE_FRAG_PROCESSED, {
        success: !0,
        frag: e
      });
    }, (i) => {
      n.logger.log(`Failed to parse IMSC1: ${i}`), n.trigger(E.SUBTITLE_FRAG_PROCESSED, {
        success: !1,
        frag: e,
        error: i
      });
    });
  }
  _parseVTTs(e) {
    var t;
    const {
      frag: n,
      payload: i
    } = e, {
      initPTS: s,
      unparsedVttFrags: a
    } = this, o = s.length - 1;
    if (!s[n.cc] && o === -1) {
      a.push(e);
      return;
    }
    const c = this.hls, l = (t = n.initSegment) != null && t.data ? yr(n.initSegment.data, new Uint8Array(i)).buffer : i;
    gW(l, this.initPTS[n.cc], this.vttCCs, n.cc, n.start, (u) => {
      this._appendCues(u, n.level), c.trigger(E.SUBTITLE_FRAG_PROCESSED, {
        success: !0,
        frag: n
      });
    }, (u) => {
      const d = u.message === "Missing initPTS for VTT MPEGTS";
      d ? a.push(e) : this._fallbackToIMSC1(n, i), c.logger.log(`Failed to parse VTT cue: ${u}`), !(d && o > n.cc) && c.trigger(E.SUBTITLE_FRAG_PROCESSED, {
        success: !1,
        frag: n,
        error: u
      });
    });
  }
  _fallbackToIMSC1(e, t) {
    const n = this.tracks[e.level];
    n.textCodec || Db(t, this.initPTS[e.cc], () => {
      n.textCodec = cd, this._parseIMSC1(e, t);
    }, () => {
      n.textCodec = "wvtt";
    });
  }
  _appendCues(e, t) {
    const n = this.hls;
    if (this.config.renderTextTracksNatively) {
      const i = this.textTracks[t];
      if (!i || i.mode === "disabled")
        return;
      e.forEach((s) => Uw(i, s));
    } else {
      const i = this.tracks[t];
      if (!i)
        return;
      const s = i.default ? "default" : "subtitles" + t;
      n.trigger(E.CUES_PARSED, {
        type: "subtitles",
        cues: e,
        track: s
      });
    }
  }
  onFragDecrypted(e, t) {
    const {
      frag: n
    } = t;
    n.type === ee.SUBTITLE && this.onFragLoaded(E.FRAG_LOADED, t);
  }
  onSubtitleTracksCleared() {
    this.tracks = [], this.captionsTracks = {};
  }
  onFragParsingUserdata(e, t) {
    if (!this.enabled || !this.config.enableCEA708Captions)
      return;
    const {
      frag: n,
      samples: i
    } = t;
    if (!(n.type === ee.MAIN && this.closedCaptionsForLevel(n) === "NONE"))
      for (let s = 0; s < i.length; s++) {
        const a = i[s].bytes;
        if (a) {
          this.cea608Parser1 || this.initCea608Parsers();
          const o = this.extractCea608Data(a);
          this.cea608Parser1.addData(i[s].pts, o[0]), this.cea608Parser2.addData(i[s].pts, o[1]);
        }
      }
  }
  onBufferFlushing(e, {
    startOffset: t,
    endOffset: n,
    endOffsetSubtitles: i,
    type: s
  }) {
    const {
      media: a
    } = this;
    if (!(!a || a.currentTime < n)) {
      if (!s || s === "video") {
        const {
          captionsTracks: o
        } = this;
        Object.keys(o).forEach((c) => Lf(o[c], t, n));
      }
      if (this.config.renderTextTracksNatively && t === 0 && i !== void 0) {
        const {
          textTracks: o
        } = this;
        Object.keys(o).forEach((c) => Lf(o[c], t, i));
      }
    }
  }
  extractCea608Data(e) {
    const t = [[], []], n = e[0] & 31;
    let i = 2;
    for (let s = 0; s < n; s++) {
      const a = e[i++], o = 127 & e[i++], c = 127 & e[i++];
      if (o === 0 && c === 0)
        continue;
      if ((4 & a) !== 0) {
        const u = 3 & a;
        (u === 0 || u === 1) && (t[u].push(o), t[u].push(c));
      }
    }
    return t;
  }
}
function Qw(r) {
  return r.characteristics && /transcribes-spoken-dialog/gi.test(r.characteristics) && /describes-music-and-sound/gi.test(r.characteristics) ? "captions" : "subtitles";
}
function Mb(r, e) {
  return !!r && r.kind === Qw(e) && If(e, r);
}
function EW(r, e, t, n) {
  return Math.min(e, n) - Math.max(r, t);
}
function Nb() {
  return {
    ccOffset: 0,
    presentationOffset: 0,
    0: {
      start: 0,
      prevCC: -1,
      new: !0
    }
  };
}
const SW = /\s/, TW = {
  newCue(r, e, t, n) {
    const i = [];
    let s, a, o, c, l;
    const u = self.VTTCue || self.TextTrackCue;
    for (let f = 0; f < n.rows.length; f++)
      if (s = n.rows[f], o = !0, c = 0, l = "", !s.isEmpty()) {
        var d;
        for (let m = 0; m < s.chars.length; m++)
          SW.test(s.chars[m].uchar) && o ? c++ : (l += s.chars[m].uchar, o = !1);
        s.cueStartTime = e, e === t && (t += 1e-4), c >= 16 ? c-- : c++;
        const h = qw(l.trim()), g = am(e, t, h);
        r != null && (d = r.cues) != null && d.getCueById(g) || (a = new u(e, t, h), a.id = g, a.line = f + 1, a.align = "left", a.position = 10 + Math.min(80, Math.floor(c * 8 / 32) * 10), i.push(a));
      }
    return r && i.length && (i.sort((f, h) => f.line === "auto" || h.line === "auto" ? 0 : f.line > 8 && h.line > 8 ? h.line - f.line : f.line - h.line), i.forEach((f) => Uw(r, f))), i;
  }
};
function AW() {
  if (
    // @ts-ignore
    self.fetch && self.AbortController && self.ReadableStream && self.Request
  )
    try {
      return new self.ReadableStream({}), !0;
    } catch {
    }
  return !1;
}
const wW = /(\d+)-(\d+)\/(\d+)/;
class Fb {
  constructor(e) {
    this.fetchSetup = void 0, this.requestTimeout = void 0, this.request = null, this.response = null, this.controller = void 0, this.context = null, this.config = null, this.callbacks = null, this.stats = void 0, this.loader = null, this.fetchSetup = e.fetchSetup || LW, this.controller = new self.AbortController(), this.stats = new jg();
  }
  destroy() {
    this.loader = this.callbacks = this.context = this.config = this.request = null, this.abortInternal(), this.response = null, this.fetchSetup = this.controller = this.stats = null;
  }
  abortInternal() {
    this.controller && !this.stats.loading.end && (this.stats.aborted = !0, this.controller.abort());
  }
  abort() {
    var e;
    this.abortInternal(), (e = this.callbacks) != null && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.response);
  }
  load(e, t, n) {
    const i = this.stats;
    if (i.loading.start)
      throw new Error("Loader can only be used once.");
    i.loading.start = self.performance.now();
    const s = IW(e, this.controller.signal), a = e.responseType === "arraybuffer", o = a ? "byteLength" : "length", {
      maxTimeToFirstByteMs: c,
      maxLoadTimeMs: l
    } = t.loadPolicy;
    this.context = e, this.config = t, this.callbacks = n, this.request = this.fetchSetup(e, s), self.clearTimeout(this.requestTimeout), t.timeout = c && X(c) ? c : l, this.requestTimeout = self.setTimeout(() => {
      this.callbacks && (this.abortInternal(), this.callbacks.onTimeout(i, e, this.response));
    }, t.timeout), (sa(this.request) ? this.request.then(self.fetch) : self.fetch(this.request)).then((d) => {
      var f;
      this.response = this.loader = d;
      const h = Math.max(self.performance.now(), i.loading.start);
      if (self.clearTimeout(this.requestTimeout), t.timeout = l, this.requestTimeout = self.setTimeout(() => {
        this.callbacks && (this.abortInternal(), this.callbacks.onTimeout(i, e, this.response));
      }, l - (h - i.loading.start)), !d.ok) {
        const {
          status: m,
          statusText: p
        } = d;
        throw new OW(p || "fetch, bad network response", m, d);
      }
      i.loading.first = h, i.total = _W(d.headers) || i.total;
      const g = (f = this.callbacks) == null ? void 0 : f.onProgress;
      return g && X(t.highWaterMark) ? this.loadProgressively(d, i, e, t.highWaterMark, g) : a ? d.arrayBuffer() : e.responseType === "json" ? d.json() : d.text();
    }).then((d) => {
      var f, h;
      const g = this.response;
      if (!g)
        throw new Error("loader destroyed");
      self.clearTimeout(this.requestTimeout), i.loading.end = Math.max(self.performance.now(), i.loading.first);
      const m = d[o];
      m && (i.loaded = i.total = m);
      const p = {
        url: g.url,
        data: d,
        code: g.status
      }, v = (f = this.callbacks) == null ? void 0 : f.onProgress;
      v && !X(t.highWaterMark) && v(i, e, d, g), (h = this.callbacks) == null || h.onSuccess(p, i, e, g);
    }).catch((d) => {
      var f;
      if (self.clearTimeout(this.requestTimeout), i.aborted)
        return;
      const h = d && d.code || 0, g = d ? d.message : null;
      (f = this.callbacks) == null || f.onError({
        code: h,
        text: g
      }, e, d ? d.details : null, i);
    });
  }
  getCacheAge() {
    let e = null;
    if (this.response) {
      const t = this.response.headers.get("age");
      e = t ? parseFloat(t) : null;
    }
    return e;
  }
  getResponseHeader(e) {
    return this.response ? this.response.headers.get(e) : null;
  }
  loadProgressively(e, t, n, i = 0, s) {
    const a = new fw(), o = e.body.getReader(), c = () => o.read().then((l) => {
      if (l.done)
        return a.dataLength && s(t, n, a.flush().buffer, e), Promise.resolve(new ArrayBuffer(0));
      const u = l.value, d = u.length;
      return t.loaded += d, d < i || a.dataLength ? (a.push(u), a.dataLength >= i && s(t, n, a.flush().buffer, e)) : s(t, n, u.buffer, e), c();
    }).catch(() => Promise.reject());
    return c();
  }
}
function IW(r, e) {
  const t = {
    method: "GET",
    mode: "cors",
    credentials: "same-origin",
    signal: e,
    headers: new self.Headers(Ce({}, r.headers))
  };
  return r.rangeEnd && t.headers.set("Range", "bytes=" + r.rangeStart + "-" + String(r.rangeEnd - 1)), t;
}
function PW(r) {
  const e = wW.exec(r);
  if (e)
    return parseInt(e[2]) - parseInt(e[1]) + 1;
}
function _W(r) {
  const e = r.get("Content-Range");
  if (e) {
    const n = PW(e);
    if (X(n))
      return n;
  }
  const t = r.get("Content-Length");
  if (t)
    return parseInt(t);
}
function LW(r, e) {
  return new self.Request(r.url, e);
}
class OW extends Error {
  constructor(e, t, n) {
    super(e), this.code = void 0, this.details = void 0, this.code = t, this.details = n;
  }
}
const RW = /^age:\s*[\d.]+\s*$/im;
class Zw {
  constructor(e) {
    this.xhrSetup = void 0, this.requestTimeout = void 0, this.retryTimeout = void 0, this.retryDelay = void 0, this.config = null, this.callbacks = null, this.context = null, this.loader = null, this.stats = void 0, this.xhrSetup = e && e.xhrSetup || null, this.stats = new jg(), this.retryDelay = 0;
  }
  destroy() {
    this.callbacks = null, this.abortInternal(), this.loader = null, this.config = null, this.context = null, this.xhrSetup = null;
  }
  abortInternal() {
    const e = this.loader;
    self.clearTimeout(this.requestTimeout), self.clearTimeout(this.retryTimeout), e && (e.onreadystatechange = null, e.onprogress = null, e.readyState !== 4 && (this.stats.aborted = !0, e.abort()));
  }
  abort() {
    var e;
    this.abortInternal(), (e = this.callbacks) != null && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.loader);
  }
  load(e, t, n) {
    if (this.stats.loading.start)
      throw new Error("Loader can only be used once.");
    this.stats.loading.start = self.performance.now(), this.context = e, this.config = t, this.callbacks = n, this.loadInternal();
  }
  loadInternal() {
    const {
      config: e,
      context: t
    } = this;
    if (!e || !t)
      return;
    const n = this.loader = new self.XMLHttpRequest(), i = this.stats;
    i.loading.first = 0, i.loaded = 0, i.aborted = !1;
    const s = this.xhrSetup;
    s ? Promise.resolve().then(() => {
      if (!(this.loader !== n || this.stats.aborted))
        return s(n, t.url);
    }).catch((a) => {
      if (!(this.loader !== n || this.stats.aborted))
        return n.open("GET", t.url, !0), s(n, t.url);
    }).then(() => {
      this.loader !== n || this.stats.aborted || this.openAndSendXhr(n, t, e);
    }).catch((a) => {
      var o;
      (o = this.callbacks) == null || o.onError({
        code: n.status,
        text: a.message
      }, t, n, i);
    }) : this.openAndSendXhr(n, t, e);
  }
  openAndSendXhr(e, t, n) {
    e.readyState || e.open("GET", t.url, !0);
    const i = t.headers, {
      maxTimeToFirstByteMs: s,
      maxLoadTimeMs: a
    } = n.loadPolicy;
    if (i)
      for (const o in i)
        e.setRequestHeader(o, i[o]);
    t.rangeEnd && e.setRequestHeader("Range", "bytes=" + t.rangeStart + "-" + (t.rangeEnd - 1)), e.onreadystatechange = this.readystatechange.bind(this), e.onprogress = this.loadprogress.bind(this), e.responseType = t.responseType, self.clearTimeout(this.requestTimeout), n.timeout = s && X(s) ? s : a, this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), n.timeout), e.send();
  }
  readystatechange() {
    const {
      context: e,
      loader: t,
      stats: n
    } = this;
    if (!e || !t)
      return;
    const i = t.readyState, s = this.config;
    if (!n.aborted && i >= 2 && (n.loading.first === 0 && (n.loading.first = Math.max(self.performance.now(), n.loading.start), s.timeout !== s.loadPolicy.maxLoadTimeMs && (self.clearTimeout(this.requestTimeout), s.timeout = s.loadPolicy.maxLoadTimeMs, this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), s.loadPolicy.maxLoadTimeMs - (n.loading.first - n.loading.start)))), i === 4)) {
      self.clearTimeout(this.requestTimeout), t.onreadystatechange = null, t.onprogress = null;
      const l = t.status, u = t.responseType === "text" ? t.responseText : null;
      if (l >= 200 && l < 300) {
        const g = u ?? t.response;
        if (g != null) {
          var a, o;
          n.loading.end = Math.max(self.performance.now(), n.loading.first);
          const m = t.responseType === "arraybuffer" ? g.byteLength : g.length;
          n.loaded = n.total = m, n.bwEstimate = n.total * 8e3 / (n.loading.end - n.loading.first);
          const p = (a = this.callbacks) == null ? void 0 : a.onProgress;
          p && p(n, e, g, t);
          const v = {
            url: t.responseURL,
            data: g,
            code: l
          };
          (o = this.callbacks) == null || o.onSuccess(v, n, e, t);
          return;
        }
      }
      const d = s.loadPolicy.errorRetry, f = n.retry, h = {
        url: e.url,
        data: void 0,
        code: l
      };
      if (ul(d, f, !1, h))
        this.retry(d);
      else {
        var c;
        Ae.error(`${l} while loading ${e.url}`), (c = this.callbacks) == null || c.onError({
          code: l,
          text: t.statusText
        }, e, t, n);
      }
    }
  }
  loadtimeout() {
    if (!this.config) return;
    const e = this.config.loadPolicy.timeoutRetry, t = this.stats.retry;
    if (ul(e, t, !0))
      this.retry(e);
    else {
      var n;
      Ae.warn(`timeout while loading ${(n = this.context) == null ? void 0 : n.url}`);
      const i = this.callbacks;
      i && (this.abortInternal(), i.onTimeout(this.stats, this.context, this.loader));
    }
  }
  retry(e) {
    const {
      context: t,
      stats: n
    } = this;
    this.retryDelay = Vg(e, n.retry), n.retry++, Ae.warn(`${status ? "HTTP Status " + status : "Timeout"} while loading ${t == null ? void 0 : t.url}, retrying ${n.retry}/${e.maxNumRetry} in ${this.retryDelay}ms`), this.abortInternal(), this.loader = null, self.clearTimeout(this.retryTimeout), this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay);
  }
  loadprogress(e) {
    const t = this.stats;
    t.loaded = e.loaded, e.lengthComputable && (t.total = e.total);
  }
  getCacheAge() {
    let e = null;
    if (this.loader && RW.test(this.loader.getAllResponseHeaders())) {
      const t = this.loader.getResponseHeader("age");
      e = t ? parseFloat(t) : null;
    }
    return e;
  }
  getResponseHeader(e) {
    return this.loader && new RegExp(`^${e}:\\s*[\\d.]+\\s*$`, "im").test(this.loader.getAllResponseHeaders()) ? this.loader.getResponseHeader(e) : null;
  }
}
const DW = {
  maxTimeToFirstByteMs: 8e3,
  maxLoadTimeMs: 2e4,
  timeoutRetry: null,
  errorRetry: null
}, CW = Ne(Ne({
  autoStartLoad: !0,
  // used by stream-controller
  startPosition: -1,
  // used by stream-controller
  defaultAudioCodec: void 0,
  // used by stream-controller
  debug: !1,
  // used by logger
  capLevelOnFPSDrop: !1,
  // used by fps-controller
  capLevelToPlayerSize: !1,
  // used by cap-level-controller
  ignoreDevicePixelRatio: !1,
  // used by cap-level-controller
  maxDevicePixelRatio: Number.POSITIVE_INFINITY,
  // used by cap-level-controller
  preferManagedMediaSource: !0,
  initialLiveManifestSize: 1,
  // used by stream-controller
  maxBufferLength: 30,
  // used by stream-controller
  backBufferLength: 1 / 0,
  // used by buffer-controller
  frontBufferFlushThreshold: 1 / 0,
  startOnSegmentBoundary: !1,
  // used by stream-controller
  maxBufferSize: 60 * 1e3 * 1e3,
  // used by stream-controller
  maxFragLookUpTolerance: 0.25,
  // used by stream-controller
  maxBufferHole: 0.1,
  // used by stream-controller and gap-controller
  detectStallWithCurrentTimeMs: 1250,
  // used by gap-controller
  highBufferWatchdogPeriod: 2,
  // used by gap-controller
  nudgeOffset: 0.1,
  // used by gap-controller
  nudgeMaxRetry: 3,
  // used by gap-controller
  nudgeOnVideoHole: !0,
  // used by gap-controller
  liveSyncMode: "edge",
  // used by stream-controller
  liveSyncDurationCount: 3,
  // used by latency-controller
  liveSyncOnStallIncrease: 1,
  // used by latency-controller
  liveMaxLatencyDurationCount: 1 / 0,
  // used by latency-controller
  liveSyncDuration: void 0,
  // used by latency-controller
  liveMaxLatencyDuration: void 0,
  // used by latency-controller
  maxLiveSyncPlaybackRate: 1,
  // used by latency-controller
  liveDurationInfinity: !1,
  // used by buffer-controller
  /**
   * @deprecated use backBufferLength
   */
  liveBackBufferLength: null,
  // used by buffer-controller
  maxMaxBufferLength: 600,
  // used by stream-controller
  enableWorker: !0,
  // used by transmuxer
  workerPath: null,
  // used by transmuxer
  enableSoftwareAES: !0,
  // used by decrypter
  startLevel: void 0,
  // used by level-controller
  startFragPrefetch: !1,
  // used by stream-controller
  fpsDroppedMonitoringPeriod: 5e3,
  // used by fps-controller
  fpsDroppedMonitoringThreshold: 0.2,
  // used by fps-controller
  appendErrorMaxRetry: 3,
  // used by buffer-controller
  ignorePlaylistParsingErrors: !1,
  loader: Zw,
  // loader: FetchLoader,
  fLoader: void 0,
  // used by fragment-loader
  pLoader: void 0,
  // used by playlist-loader
  xhrSetup: void 0,
  // used by xhr-loader
  licenseXhrSetup: void 0,
  // used by eme-controller
  licenseResponseCallback: void 0,
  // used by eme-controller
  abrController: t3,
  bufferController: VV,
  capLevelController: nm,
  errorController: a3,
  fpsController: N8,
  stretchShortVideoTrack: !1,
  // used by mp4-remuxer
  maxAudioFramesDrift: 1,
  // used by mp4-remuxer
  forceKeyFrameOnDiscontinuity: !0,
  // used by ts-demuxer
  abrEwmaFastLive: 3,
  // used by abr-controller
  abrEwmaSlowLive: 9,
  // used by abr-controller
  abrEwmaFastVoD: 3,
  // used by abr-controller
  abrEwmaSlowVoD: 9,
  // used by abr-controller
  abrEwmaDefaultEstimate: 5e5,
  // 500 kbps  // used by abr-controller
  abrEwmaDefaultEstimateMax: 5e6,
  // 5 mbps
  abrBandWidthFactor: 0.95,
  // used by abr-controller
  abrBandWidthUpFactor: 0.7,
  // used by abr-controller
  abrMaxWithRealBitrate: !1,
  // used by abr-controller
  maxStarvationDelay: 4,
  // used by abr-controller
  maxLoadingDelay: 4,
  // used by abr-controller
  minAutoBitrate: 0,
  // used by hls
  emeEnabled: !1,
  // used by eme-controller
  widevineLicenseUrl: void 0,
  // used by eme-controller
  drmSystems: {},
  // used by eme-controller
  drmSystemOptions: {},
  // used by eme-controller
  requestMediaKeySystemAccessFunc: rw,
  // used by eme-controller
  requireKeySystemAccessOnStart: !1,
  // used by eme-controller
  testBandwidth: !0,
  progressive: !1,
  lowLatencyMode: !0,
  cmcd: void 0,
  enableDateRangeMetadataCues: !0,
  enableEmsgMetadataCues: !0,
  enableEmsgKLVMetadata: !1,
  enableID3MetadataCues: !0,
  enableInterstitialPlayback: !0,
  interstitialAppendInPlace: !0,
  interstitialLiveLookAhead: 10,
  useMediaCapabilities: !0,
  preserveManualLevelOnError: !1,
  certLoadPolicy: {
    default: DW
  },
  keyLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 8e3,
      maxLoadTimeMs: 2e4,
      timeoutRetry: {
        maxNumRetry: 1,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 2e4,
        backoff: "linear"
      },
      errorRetry: {
        maxNumRetry: 8,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 2e4,
        backoff: "linear"
      }
    }
  },
  manifestLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 1 / 0,
      maxLoadTimeMs: 2e4,
      timeoutRetry: {
        maxNumRetry: 2,
        retryDelayMs: 0,
        maxRetryDelayMs: 0
      },
      errorRetry: {
        maxNumRetry: 1,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 8e3
      }
    }
  },
  playlistLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 1e4,
      maxLoadTimeMs: 2e4,
      timeoutRetry: {
        maxNumRetry: 2,
        retryDelayMs: 0,
        maxRetryDelayMs: 0
      },
      errorRetry: {
        maxNumRetry: 2,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 8e3
      }
    }
  },
  fragLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 1e4,
      maxLoadTimeMs: 12e4,
      timeoutRetry: {
        maxNumRetry: 4,
        retryDelayMs: 0,
        maxRetryDelayMs: 0
      },
      errorRetry: {
        maxNumRetry: 6,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 8e3
      }
    }
  },
  steeringManifestLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 1e4,
      maxLoadTimeMs: 2e4,
      timeoutRetry: {
        maxNumRetry: 2,
        retryDelayMs: 0,
        maxRetryDelayMs: 0
      },
      errorRetry: {
        maxNumRetry: 1,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 8e3
      }
    }
  },
  interstitialAssetListLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 1e4,
      maxLoadTimeMs: 3e4,
      timeoutRetry: {
        maxNumRetry: 0,
        retryDelayMs: 0,
        maxRetryDelayMs: 0
      },
      errorRetry: {
        maxNumRetry: 0,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 8e3
      }
    }
  },
  // These default settings are deprecated in favor of the above policies
  // and are maintained for backwards compatibility
  manifestLoadingTimeOut: 1e4,
  manifestLoadingMaxRetry: 1,
  manifestLoadingRetryDelay: 1e3,
  manifestLoadingMaxRetryTimeout: 64e3,
  levelLoadingTimeOut: 1e4,
  levelLoadingMaxRetry: 4,
  levelLoadingRetryDelay: 1e3,
  levelLoadingMaxRetryTimeout: 64e3,
  fragLoadingTimeOut: 2e4,
  fragLoadingMaxRetry: 6,
  fragLoadingRetryDelay: 1e3,
  fragLoadingMaxRetryTimeout: 64e3
}, kW()), {}, {
  subtitleStreamController: z8,
  subtitleTrackController: B8,
  timelineController: xW,
  audioStreamController: jV,
  audioTrackController: UV,
  emeController: ji,
  cmcdController: C8,
  contentSteeringController: M8,
  interstitialsController: q8
});
function kW() {
  return {
    cueHandler: TW,
    // used by timeline-controller
    enableWebVTT: !0,
    // used by timeline-controller
    enableIMSC1: !0,
    // used by timeline-controller
    enableCEA708Captions: !0,
    // used by timeline-controller
    captionsTextTrack1Label: "English",
    // used by timeline-controller
    captionsTextTrack1LanguageCode: "en",
    // used by timeline-controller
    captionsTextTrack2Label: "Spanish",
    // used by timeline-controller
    captionsTextTrack2LanguageCode: "es",
    // used by timeline-controller
    captionsTextTrack3Label: "Unknown CC",
    // used by timeline-controller
    captionsTextTrack3LanguageCode: "",
    // used by timeline-controller
    captionsTextTrack4Label: "Unknown CC",
    // used by timeline-controller
    captionsTextTrack4LanguageCode: "",
    // used by timeline-controller
    renderTextTracksNatively: !0
  };
}
function MW(r, e, t) {
  if ((e.liveSyncDurationCount || e.liveMaxLatencyDurationCount) && (e.liveSyncDuration || e.liveMaxLatencyDuration))
    throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");
  if (e.liveMaxLatencyDurationCount !== void 0 && (e.liveSyncDurationCount === void 0 || e.liveMaxLatencyDurationCount <= e.liveSyncDurationCount))
    throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be greater than "liveSyncDurationCount"');
  if (e.liveMaxLatencyDuration !== void 0 && (e.liveSyncDuration === void 0 || e.liveMaxLatencyDuration <= e.liveSyncDuration))
    throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be greater than "liveSyncDuration"');
  const n = Rf(r), i = ["manifest", "level", "frag"], s = ["TimeOut", "MaxRetry", "RetryDelay", "MaxRetryTimeout"];
  return i.forEach((a) => {
    const o = `${a === "level" ? "playlist" : a}LoadPolicy`, c = e[o] === void 0, l = [];
    s.forEach((u) => {
      const d = `${a}Loading${u}`, f = e[d];
      if (f !== void 0 && c) {
        l.push(d);
        const h = n[o].default;
        switch (e[o] = {
          default: h
        }, u) {
          case "TimeOut":
            h.maxLoadTimeMs = f, h.maxTimeToFirstByteMs = f;
            break;
          case "MaxRetry":
            h.errorRetry.maxNumRetry = f, h.timeoutRetry.maxNumRetry = f;
            break;
          case "RetryDelay":
            h.errorRetry.retryDelayMs = f, h.timeoutRetry.retryDelayMs = f;
            break;
          case "MaxRetryTimeout":
            h.errorRetry.maxRetryDelayMs = f, h.timeoutRetry.maxRetryDelayMs = f;
            break;
        }
      }
    }), l.length && t.warn(`hls.js config: "${l.join('", "')}" setting(s) are deprecated, use "${o}": ${We(e[o])}`);
  }), Ne(Ne({}, n), e);
}
function Rf(r) {
  return r && typeof r == "object" ? Array.isArray(r) ? r.map(Rf) : Object.keys(r).reduce((e, t) => (e[t] = Rf(r[t]), e), {}) : r;
}
function NW(r, e) {
  const t = r.loader;
  t !== Fb && t !== Zw ? (e.log("[config]: Custom loader detected, cannot enable progressive streaming"), r.progressive = !1) : AW() && (r.loader = Fb, r.progressive = !0, r.enableSoftwareAES = !0, e.log("[config]: Progressive streaming enabled, using FetchLoader"));
}
const To = 2, FW = 0.1, $W = 0.05, BW = 100;
class jW extends ZA {
  constructor(e, t) {
    super("gap-controller", e.logger), this.hls = null, this.fragmentTracker = null, this.media = null, this.mediaSource = void 0, this.nudgeRetry = 0, this.stallReported = !1, this.stalled = null, this.moved = !1, this.seeking = !1, this.buffered = {}, this.lastCurrentTime = 0, this.ended = 0, this.waiting = 0, this.onMediaPlaying = () => {
      this.ended = 0, this.waiting = 0;
    }, this.onMediaWaiting = () => {
      var n;
      (n = this.media) != null && n.seeking || (this.waiting = self.performance.now(), this.tick());
    }, this.onMediaEnded = () => {
      if (this.hls) {
        var n;
        this.ended = ((n = this.media) == null ? void 0 : n.currentTime) || 1, this.hls.trigger(E.MEDIA_ENDED, {
          stalled: !1
        });
      }
    }, this.hls = e, this.fragmentTracker = t, this.registerListeners();
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e && (e.on(E.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(E.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(E.BUFFER_APPENDED, this.onBufferAppended, this));
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e && (e.off(E.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(E.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(E.BUFFER_APPENDED, this.onBufferAppended, this));
  }
  destroy() {
    super.destroy(), this.unregisterListeners(), this.media = this.hls = this.fragmentTracker = null, this.mediaSource = void 0;
  }
  onMediaAttached(e, t) {
    this.setInterval(BW), this.mediaSource = t.mediaSource;
    const n = this.media = t.media;
    gr(n, "playing", this.onMediaPlaying), gr(n, "waiting", this.onMediaWaiting), gr(n, "ended", this.onMediaEnded);
  }
  onMediaDetaching(e, t) {
    this.clearInterval();
    const {
      media: n
    } = this;
    n && (Pr(n, "playing", this.onMediaPlaying), Pr(n, "waiting", this.onMediaWaiting), Pr(n, "ended", this.onMediaEnded), this.media = null), this.mediaSource = void 0;
  }
  onBufferAppended(e, t) {
    this.buffered = t.timeRanges;
  }
  get hasBuffered() {
    return Object.keys(this.buffered).length > 0;
  }
  tick() {
    var e;
    if (!((e = this.media) != null && e.readyState) || !this.hasBuffered)
      return;
    const t = this.media.currentTime;
    this.poll(t, this.lastCurrentTime), this.lastCurrentTime = t;
  }
  /**
   * Checks if the playhead is stuck within a gap, and if so, attempts to free it.
   * A gap is an unbuffered range between two buffered ranges (or the start and the first buffered range).
   *
   * @param lastCurrentTime - Previously read playhead position
   */
  poll(e, t) {
    var n, i;
    const s = (n = this.hls) == null ? void 0 : n.config;
    if (!s)
      return;
    const a = this.media;
    if (!a)
      return;
    const {
      seeking: o
    } = a, c = this.seeking && !o, l = !this.seeking && o, u = a.paused && !o || a.ended || a.playbackRate === 0;
    if (this.seeking = o, e !== t) {
      t && (this.ended = 0), this.moved = !0, o || (this.nudgeRetry = 0, s.nudgeOnVideoHole && !u && e > t && this.nudgeOnVideoHole(e, t)), this.waiting === 0 && this.stallResolved(e);
      return;
    }
    if (l || c) {
      c && this.stallResolved(e);
      return;
    }
    if (u) {
      this.nudgeRetry = 0, this.stallResolved(e), !this.ended && a.ended && this.hls && (this.ended = e || 1, this.hls.trigger(E.MEDIA_ENDED, {
        stalled: !1
      }));
      return;
    }
    if (!ue.getBuffered(a).length) {
      this.nudgeRetry = 0;
      return;
    }
    const d = ue.bufferInfo(a, e, 0), f = d.nextStart || 0, h = this.fragmentTracker;
    if (o && h && this.hls) {
      const A = $b(this.hls.inFlightFragments, e), T = d.len > To, I = !f || A || f - e > To && !h.getPartialFragment(e);
      if (T || I)
        return;
      this.moved = !1;
    }
    const g = (i = this.hls) == null ? void 0 : i.latestLevelDetails;
    if (!this.moved && this.stalled !== null && h) {
      if (!(d.len > 0) && !f)
        return;
      const T = Math.max(f, d.start || 0) - e, L = !!(g != null && g.live) ? g.targetduration * 2 : To, _ = h.getPartialFragment(e);
      if (T > 0 && (T <= L || _)) {
        a.paused || this._trySkipBufferHole(_);
        return;
      }
    }
    const m = s.detectStallWithCurrentTimeMs, p = self.performance.now(), v = this.waiting;
    let y = this.stalled;
    if (y === null)
      if (v > 0 && p - v < m)
        y = this.stalled = v;
      else {
        this.stalled = p;
        return;
      }
    const b = p - y;
    if (!o && (b >= m || v) && this.hls) {
      var x;
      if (((x = this.mediaSource) == null ? void 0 : x.readyState) === "ended" && !(g != null && g.live) && Math.abs(e - ((g == null ? void 0 : g.edge) || 0)) < 1) {
        if (this.ended)
          return;
        this.ended = e || 1, this.hls.trigger(E.MEDIA_ENDED, {
          stalled: !0
        });
        return;
      }
      if (this._reportStall(d), !this.media || !this.hls)
        return;
    }
    const S = ue.bufferInfo(a, e, s.maxBufferHole);
    this._tryFixBufferStall(S, b, e);
  }
  stallResolved(e) {
    const t = this.stalled;
    if (t && this.hls && (this.stalled = null, this.stallReported)) {
      const n = self.performance.now() - t;
      this.log(`playback not stuck anymore @${e}, after ${Math.round(n)}ms`), this.stallReported = !1, this.waiting = 0, this.hls.trigger(E.STALL_RESOLVED, {});
    }
  }
  nudgeOnVideoHole(e, t) {
    var n;
    const i = this.buffered.video;
    if (this.hls && this.media && this.fragmentTracker && (n = this.buffered.audio) != null && n.length && i && i.length > 1 && e > i.end(0)) {
      const s = ue.bufferedInfo(ue.timeRangesToArray(this.buffered.audio), e, 0);
      if (s.len > 1 && t >= s.start) {
        const a = ue.timeRangesToArray(i), o = ue.bufferedInfo(a, t, 0).bufferedIndex;
        if (o > -1 && o < a.length - 1) {
          const c = ue.bufferedInfo(a, e, 0).bufferedIndex, l = a[o].end, u = a[o + 1].start;
          if ((c === -1 || c > o) && u - l < 1 && // `maxBufferHole` may be too small and setting it to 0 should not disable this feature
          e - l < 2) {
            const d = new Error(`nudging playhead to flush pipeline after video hole. currentTime: ${e} hole: ${l} -> ${u} buffered index: ${c}`);
            this.warn(d.message), this.media.currentTime += 1e-6;
            const f = this.fragmentTracker.getPartialFragment(e) || void 0, h = ue.bufferInfo(this.media, e, 0);
            this.hls.trigger(E.ERROR, {
              type: ne.MEDIA_ERROR,
              details: k.BUFFER_SEEK_OVER_HOLE,
              fatal: !1,
              error: d,
              reason: d.message,
              frag: f,
              buffer: h.len,
              bufferInfo: h
            });
          }
        }
      }
    }
  }
  /**
   * Detects and attempts to fix known buffer stalling issues.
   * @param bufferInfo - The properties of the current buffer.
   * @param stalledDurationMs - The amount of time Hls.js has been stalling for.
   * @private
   */
  _tryFixBufferStall(e, t, n) {
    var i, s;
    const {
      fragmentTracker: a,
      media: o
    } = this, c = (i = this.hls) == null ? void 0 : i.config;
    if (!o || !a || !c)
      return;
    const l = (s = this.hls) == null ? void 0 : s.latestLevelDetails, u = a.getPartialFragment(n);
    if ((u || l != null && l.live && n < l.fragmentStart) && (this._trySkipBufferHole(u) || !this.media))
      return;
    const d = e.buffered, f = this.adjacentTraversal(e, n);
    (d && d.length > 1 && e.len > c.maxBufferHole || e.nextStart && (e.nextStart - n < c.maxBufferHole || f)) && (t > c.highBufferWatchdogPeriod * 1e3 || this.waiting) && (this.warn("Trying to nudge playhead over buffer-hole"), this._tryNudgeBuffer(e));
  }
  adjacentTraversal(e, t) {
    const n = this.fragmentTracker, i = e.nextStart;
    if (n && i) {
      const s = n.getFragAtPos(t, ee.MAIN), a = n.getFragAtPos(i, ee.MAIN);
      if (s && a)
        return a.sn - s.sn < 2;
    }
    return !1;
  }
  /**
   * Triggers a BUFFER_STALLED_ERROR event, but only once per stall period.
   * @param bufferLen - The playhead distance from the end of the current buffer segment.
   * @private
   */
  _reportStall(e) {
    const {
      hls: t,
      media: n,
      stallReported: i,
      stalled: s
    } = this;
    if (!i && s !== null && n && t) {
      this.stallReported = !0;
      const a = new Error(`Playback stalling at @${n.currentTime} due to low buffer (${We(e)})`);
      this.warn(a.message), t.trigger(E.ERROR, {
        type: ne.MEDIA_ERROR,
        details: k.BUFFER_STALLED_ERROR,
        fatal: !1,
        error: a,
        buffer: e.len,
        bufferInfo: e,
        stalled: {
          start: s
        }
      });
    }
  }
  /**
   * Attempts to fix buffer stalls by jumping over known gaps caused by partial fragments
   * @param partial - The partial fragment found at the current time (where playback is stalling).
   * @private
   */
  _trySkipBufferHole(e) {
    var t;
    const {
      fragmentTracker: n,
      media: i
    } = this, s = (t = this.hls) == null ? void 0 : t.config;
    if (!i || !n || !s)
      return 0;
    const a = i.currentTime, o = ue.bufferInfo(i, a, 0), c = a < o.start ? o.start : o.nextStart;
    if (c && this.hls) {
      const u = o.len <= s.maxBufferHole, d = o.len > 0 && o.len < 1 && i.readyState < 3, f = c - a;
      if (f > 0 && (u || d)) {
        if (f > s.maxBufferHole) {
          let g = !1;
          if (a === 0) {
            const m = n.getAppendedFrag(0, ee.MAIN);
            m && c < m.end && (g = !0);
          }
          if (!g) {
            const m = e || n.getAppendedFrag(a, ee.MAIN);
            if (m) {
              var l;
              if (!((l = this.hls.loadLevelObj) != null && l.details) || $b(this.hls.inFlightFragments, c))
                return 0;
              let v = !1, y = m.end;
              for (; y < c; ) {
                const b = n.getAppendedFrag(y, ee.MAIN) || n.getPartialFragment(y);
                if (b)
                  y += b.duration;
                else {
                  v = !0;
                  break;
                }
              }
              if (v)
                return 0;
            }
          }
        }
        const h = Math.max(c + $W, a + FW);
        if (this.warn(`skipping hole, adjusting currentTime from ${a} to ${h}`), this.moved = !0, i.currentTime = h, !(e != null && e.gap)) {
          const g = new Error(`fragment loaded with buffer holes, seeking from ${a} to ${h}`);
          this.hls.trigger(E.ERROR, {
            type: ne.MEDIA_ERROR,
            details: k.BUFFER_SEEK_OVER_HOLE,
            fatal: !1,
            error: g,
            reason: g.message,
            frag: e || void 0,
            buffer: o.len,
            bufferInfo: o
          });
        }
        return h;
      }
    }
    return 0;
  }
  /**
   * Attempts to fix buffer stalls by advancing the mediaElement's current time by a small amount.
   * @private
   */
  _tryNudgeBuffer(e) {
    const {
      hls: t,
      media: n,
      nudgeRetry: i
    } = this, s = t == null ? void 0 : t.config;
    if (!n || !s)
      return 0;
    const a = n.currentTime;
    if (this.nudgeRetry++, i < s.nudgeMaxRetry) {
      const o = a + (i + 1) * s.nudgeOffset, c = new Error(`Nudging 'currentTime' from ${a} to ${o}`);
      this.warn(c.message), n.currentTime = o, t.trigger(E.ERROR, {
        type: ne.MEDIA_ERROR,
        details: k.BUFFER_NUDGE_ON_STALL,
        error: c,
        fatal: !1,
        buffer: e.len,
        bufferInfo: e
      });
    } else {
      const o = new Error(`Playhead still not moving while enough data buffered @${a} after ${s.nudgeMaxRetry} nudges`);
      this.error(o.message), t.trigger(E.ERROR, {
        type: ne.MEDIA_ERROR,
        details: k.BUFFER_STALLED_ERROR,
        error: o,
        fatal: !0,
        buffer: e.len,
        bufferInfo: e
      });
    }
  }
}
function $b(r, e) {
  const t = Bb(r.main);
  if (t && t.start <= e)
    return t;
  const n = Bb(r.audio);
  return n && n.start <= e ? n : null;
}
function Bb(r) {
  if (!r)
    return null;
  switch (r.state) {
    case $.IDLE:
    case $.STOPPED:
    case $.ENDED:
    case $.ERROR:
      return null;
  }
  return r.frag;
}
const UW = 0.25;
function Df() {
  if (!(typeof self > "u"))
    return self.VTTCue || self.TextTrackCue;
}
function jb(r, e, t, n, i) {
  let s = new r(e, t, "");
  try {
    s.value = n, i && (s.type = i);
  } catch {
    s = new r(e, t, We(i ? Ne({
      type: i
    }, n) : n));
  }
  return s;
}
const fo = (() => {
  const r = Df();
  try {
    r && new r(0, Number.POSITIVE_INFINITY, "");
  } catch {
    return Number.MAX_VALUE;
  }
  return Number.POSITIVE_INFINITY;
})();
class GW {
  constructor(e) {
    this.hls = void 0, this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.removeCues = !0, this.onEventCueEnter = () => {
      this.hls && this.hls.trigger(E.EVENT_CUE_ENTER, {});
    }, this.hls = e, this._registerListeners();
  }
  destroy() {
    this._unregisterListeners(), this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.hls = this.onEventCueEnter = null;
  }
  _registerListeners() {
    const {
      hls: e
    } = this;
    e.on(E.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(E.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(E.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(E.MANIFEST_LOADING, this.onManifestLoading, this), e.on(E.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), e.on(E.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(E.LEVEL_UPDATED, this.onLevelUpdated, this), e.on(E.LEVEL_PTS_UPDATED, this.onLevelPtsUpdated, this);
  }
  _unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off(E.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(E.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(E.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(E.MANIFEST_LOADING, this.onManifestLoading, this), e.off(E.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), e.off(E.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(E.LEVEL_UPDATED, this.onLevelUpdated, this), e.off(E.LEVEL_PTS_UPDATED, this.onLevelPtsUpdated, this);
  }
  // Add ID3 metatadata text track.
  onMediaAttaching(e, t) {
    var n;
    this.media = t.media, ((n = t.overrides) == null ? void 0 : n.cueRemoval) === !1 && (this.removeCues = !1);
  }
  onMediaAttached() {
    const e = this.hls.latestLevelDetails;
    e && this.updateDateRangeCues(e);
  }
  onMediaDetaching(e, t) {
    this.media = null, !t.transferMedia && (this.id3Track && (this.removeCues && Ni(this.id3Track, this.onEventCueEnter), this.id3Track = null), this.dateRangeCuesAppended = {});
  }
  onManifestLoading() {
    this.dateRangeCuesAppended = {};
  }
  createTrack(e) {
    const t = this.getID3Track(e.textTracks);
    return t.mode = "hidden", t;
  }
  getID3Track(e) {
    if (this.media) {
      for (let t = 0; t < e.length; t++) {
        const n = e[t];
        if (n.kind === "metadata" && n.label === "id3")
          return jw(n, this.media), n;
      }
      return this.media.addTextTrack("metadata", "id3");
    }
  }
  onFragParsingMetadata(e, t) {
    if (!this.media)
      return;
    const {
      hls: {
        config: {
          enableEmsgMetadataCues: n,
          enableID3MetadataCues: i
        }
      }
    } = this;
    if (!n && !i)
      return;
    const {
      samples: s
    } = t;
    this.id3Track || (this.id3Track = this.createTrack(this.media));
    const a = Df();
    if (a)
      for (let o = 0; o < s.length; o++) {
        const c = s[o].type;
        if (c === Qt.emsg && !n || !i)
          continue;
        const l = bw(s[o].data);
        if (l) {
          const u = s[o].pts;
          let d = u + s[o].duration;
          d > fo && (d = fo), d - u <= 0 && (d = u + UW);
          for (let h = 0; h < l.length; h++) {
            const g = l[h];
            if (!xw(g)) {
              this.updateId3CueEnds(u, c);
              const m = jb(a, u, d, g, c);
              m && this.id3Track.addCue(m);
            }
          }
        }
      }
  }
  updateId3CueEnds(e, t) {
    var n;
    const i = (n = this.id3Track) == null ? void 0 : n.cues;
    if (i)
      for (let s = i.length; s--; ) {
        const a = i[s];
        a.type === t && a.startTime < e && a.endTime === fo && (a.endTime = e);
      }
  }
  onBufferFlushing(e, {
    startOffset: t,
    endOffset: n,
    type: i
  }) {
    const {
      id3Track: s,
      hls: a
    } = this;
    if (!a)
      return;
    const {
      config: {
        enableEmsgMetadataCues: o,
        enableID3MetadataCues: c
      }
    } = a;
    if (s && (o || c)) {
      let l;
      i === "audio" ? l = (u) => u.type === Qt.audioId3 && c : i === "video" ? l = (u) => u.type === Qt.emsg && o : l = (u) => u.type === Qt.audioId3 && c || u.type === Qt.emsg && o, Lf(s, t, n, l);
    }
  }
  onLevelUpdated(e, {
    details: t
  }) {
    this.updateDateRangeCues(t, !0);
  }
  onLevelPtsUpdated(e, t) {
    Math.abs(t.drift) > 0.01 && this.updateDateRangeCues(t.details);
  }
  updateDateRangeCues(e, t) {
    if (!this.media || !e.hasProgramDateTime || !this.hls.config.enableDateRangeMetadataCues)
      return;
    const {
      id3Track: n
    } = this, {
      dateRanges: i
    } = e, s = Object.keys(i);
    let a = this.dateRangeCuesAppended;
    if (n && t) {
      var o;
      if ((o = n.cues) != null && o.length) {
        const u = Object.keys(a).filter((d) => !s.includes(d));
        for (let d = u.length; d--; ) {
          const f = u[d], h = a[f].cues;
          delete a[f], Object.keys(h).forEach((g) => {
            try {
              const m = h[g];
              m.removeEventListener("enter", this.onEventCueEnter), n.removeCue(m);
            } catch {
            }
          });
        }
      } else
        a = this.dateRangeCuesAppended = {};
    }
    const c = e.fragments[e.fragments.length - 1];
    if (s.length === 0 || !X(c == null ? void 0 : c.programDateTime))
      return;
    this.id3Track || (this.id3Track = this.createTrack(this.media));
    const l = Df();
    for (let u = 0; u < s.length; u++) {
      const d = s[u], f = i[d], h = f.startTime, g = a[d], m = (g == null ? void 0 : g.cues) || {};
      let p = (g == null ? void 0 : g.durationKnown) || !1, v = fo;
      const {
        duration: y,
        endDate: b
      } = f;
      if (b && y !== null)
        v = h + y, p = !0;
      else if (f.endOnNext && !p) {
        const S = s.reduce((A, T) => {
          if (T !== f.id) {
            const I = i[T];
            if (I.class === f.class && I.startDate > f.startDate && (!A || f.startDate < A.startDate))
              return I;
          }
          return A;
        }, null);
        S && (v = S.startTime, p = !0);
      }
      const x = Object.keys(f.attr);
      for (let S = 0; S < x.length; S++) {
        const A = x[S];
        if (!b3(A))
          continue;
        const T = m[A];
        if (T)
          p && !g.durationKnown ? T.endTime = v : Math.abs(T.startTime - h) > 0.01 && (T.startTime = h, T.endTime = v);
        else if (l) {
          let I = f.attr[A];
          x3(A) && (I = NA(I));
          const _ = jb(l, h, v, {
            key: A,
            data: I
          }, Qt.dateRange);
          _ && (_.id = d, this.id3Track.addCue(_), m[A] = _, this.hls.config.interstitialsController && (A === "X-ASSET-LIST" || A === "X-ASSET-URL") && _.addEventListener("enter", this.onEventCueEnter));
        }
      }
      a[d] = {
        cues: m,
        dateRange: f,
        durationKnown: p
      };
    }
  }
}
class KW {
  constructor(e) {
    this.hls = void 0, this.config = void 0, this.media = null, this.currentTime = 0, this.stallCount = 0, this._latency = null, this._targetLatencyUpdated = !1, this.onTimeupdate = () => {
      const {
        media: t
      } = this, n = this.levelDetails;
      if (!t || !n)
        return;
      this.currentTime = t.currentTime;
      const i = this.computeLatency();
      if (i === null)
        return;
      this._latency = i;
      const {
        lowLatencyMode: s,
        maxLiveSyncPlaybackRate: a
      } = this.config;
      if (!s || a === 1 || !n.live)
        return;
      const o = this.targetLatency;
      if (o === null)
        return;
      const c = i - o, l = Math.min(this.maxLatency, o + n.targetduration);
      if (c < l && c > 0.05 && this.forwardBufferLength > 1) {
        const d = Math.min(2, Math.max(1, a)), f = Math.round(2 / (1 + Math.exp(-0.75 * c - this.edgeStalled)) * 20) / 20, h = Math.min(d, Math.max(1, f));
        this.changeMediaPlaybackRate(t, h);
      } else t.playbackRate !== 1 && t.playbackRate !== 0 && this.changeMediaPlaybackRate(t, 1);
    }, this.hls = e, this.config = e.config, this.registerListeners();
  }
  get levelDetails() {
    var e;
    return ((e = this.hls) == null ? void 0 : e.latestLevelDetails) || null;
  }
  get latency() {
    return this._latency || 0;
  }
  get maxLatency() {
    const {
      config: e
    } = this;
    if (e.liveMaxLatencyDuration !== void 0)
      return e.liveMaxLatencyDuration;
    const t = this.levelDetails;
    return t ? e.liveMaxLatencyDurationCount * t.targetduration : 0;
  }
  get targetLatency() {
    const e = this.levelDetails;
    if (e === null || this.hls === null)
      return null;
    const {
      holdBack: t,
      partHoldBack: n,
      targetduration: i
    } = e, {
      liveSyncDuration: s,
      liveSyncDurationCount: a,
      lowLatencyMode: o
    } = this.config, c = this.hls.userConfig;
    let l = o && n || t;
    (this._targetLatencyUpdated || c.liveSyncDuration || c.liveSyncDurationCount || l === 0) && (l = s !== void 0 ? s : a * i);
    const u = i;
    return l + Math.min(this.stallCount * this.config.liveSyncOnStallIncrease, u);
  }
  set targetLatency(e) {
    this.stallCount = 0, this.config.liveSyncDuration = e, this._targetLatencyUpdated = !0;
  }
  get liveSyncPosition() {
    const e = this.estimateLiveEdge(), t = this.targetLatency;
    if (e === null || t === null)
      return null;
    const n = this.levelDetails;
    if (n === null)
      return null;
    const i = n.edge, s = e - t - this.edgeStalled, a = i - n.totalduration, o = i - (this.config.lowLatencyMode && n.partTarget || n.targetduration);
    return Math.min(Math.max(a, s), o);
  }
  get drift() {
    const e = this.levelDetails;
    return e === null ? 1 : e.drift;
  }
  get edgeStalled() {
    const e = this.levelDetails;
    if (e === null)
      return 0;
    const t = (this.config.lowLatencyMode && e.partTarget || e.targetduration) * 3;
    return Math.max(e.age - t, 0);
  }
  get forwardBufferLength() {
    const {
      media: e
    } = this, t = this.levelDetails;
    if (!e || !t)
      return 0;
    const n = e.buffered.length;
    return (n ? e.buffered.end(n - 1) : t.edge) - this.currentTime;
  }
  destroy() {
    this.unregisterListeners(), this.onMediaDetaching(), this.hls = null;
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e && (e.on(E.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(E.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(E.MANIFEST_LOADING, this.onManifestLoading, this), e.on(E.LEVEL_UPDATED, this.onLevelUpdated, this), e.on(E.ERROR, this.onError, this));
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e && (e.off(E.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(E.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(E.MANIFEST_LOADING, this.onManifestLoading, this), e.off(E.LEVEL_UPDATED, this.onLevelUpdated, this), e.off(E.ERROR, this.onError, this));
  }
  onMediaAttached(e, t) {
    this.media = t.media, this.media.addEventListener("timeupdate", this.onTimeupdate);
  }
  onMediaDetaching() {
    this.media && (this.media.removeEventListener("timeupdate", this.onTimeupdate), this.media = null);
  }
  onManifestLoading() {
    this._latency = null, this.stallCount = 0;
  }
  onLevelUpdated(e, {
    details: t
  }) {
    t.advanced && this.onTimeupdate(), !t.live && this.media && this.media.removeEventListener("timeupdate", this.onTimeupdate);
  }
  onError(e, t) {
    var n;
    t.details === k.BUFFER_STALLED_ERROR && (this.stallCount++, this.hls && (n = this.levelDetails) != null && n.live && this.hls.logger.warn("[latency-controller]: Stall detected, adjusting target latency"));
  }
  changeMediaPlaybackRate(e, t) {
    var n, i;
    e.playbackRate !== t && ((n = this.hls) == null || n.logger.debug(`[latency-controller]: latency=${this.latency.toFixed(3)}, targetLatency=${(i = this.targetLatency) == null ? void 0 : i.toFixed(3)}, forwardBufferLength=${this.forwardBufferLength.toFixed(3)}: adjusting playback rate from ${e.playbackRate} to ${t}`), e.playbackRate = t);
  }
  estimateLiveEdge() {
    const e = this.levelDetails;
    return e === null ? null : e.edge + e.age;
  }
  computeLatency() {
    const e = this.estimateLiveEdge();
    return e === null ? null : e - this.currentTime;
  }
}
class VW extends rm {
  constructor(e, t) {
    super(e, "level-controller"), this._levels = [], this._firstLevel = -1, this._maxAutoLevel = -1, this._startLevel = void 0, this.currentLevel = null, this.currentLevelIndex = -1, this.manualLevelIndex = -1, this.steering = void 0, this.onParsedComplete = void 0, this.steering = t, this._registerListeners();
  }
  _registerListeners() {
    const {
      hls: e
    } = this;
    e.on(E.MANIFEST_LOADING, this.onManifestLoading, this), e.on(E.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(E.LEVEL_LOADED, this.onLevelLoaded, this), e.on(E.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(E.FRAG_BUFFERED, this.onFragBuffered, this), e.on(E.ERROR, this.onError, this);
  }
  _unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off(E.MANIFEST_LOADING, this.onManifestLoading, this), e.off(E.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(E.LEVEL_LOADED, this.onLevelLoaded, this), e.off(E.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(E.FRAG_BUFFERED, this.onFragBuffered, this), e.off(E.ERROR, this.onError, this);
  }
  destroy() {
    this._unregisterListeners(), this.steering = null, this.resetLevels(), super.destroy();
  }
  stopLoad() {
    this._levels.forEach((t) => {
      t.loadError = 0, t.fragmentError = 0;
    }), super.stopLoad();
  }
  resetLevels() {
    this._startLevel = void 0, this.manualLevelIndex = -1, this.currentLevelIndex = -1, this.currentLevel = null, this._levels = [], this._maxAutoLevel = -1;
  }
  onManifestLoading(e, t) {
    this.resetLevels();
  }
  onManifestLoaded(e, t) {
    const n = this.hls.config.preferManagedMediaSource, i = [], s = {}, a = {};
    let o = !1, c = !1, l = !1;
    t.levels.forEach((u) => {
      const d = u.attrs;
      let {
        audioCodec: f,
        videoCodec: h
      } = u;
      f && (u.audioCodec = f = al(f, n) || void 0), h && (h = u.videoCodec = $K(h));
      const {
        width: g,
        height: m,
        unknownCodecs: p
      } = u;
      let v = p ? p.length : 0;
      if (p)
        for (let _ = v; _--; ) {
          const R = p[_];
          this.isAudioSupported(R) ? (u.audioCodec = f = f ? `${f},${R}` : R, v--, Ji.audio[f.substring(0, 4)] = 2) : this.isVideoSupported(R) && (u.videoCodec = h = h ? `${h},${R}` : R, v--, Ji.video[h.substring(0, 4)] = 2);
        }
      if (o || (o = !!(g && m)), c || (c = !!h), l || (l = !!f), v || f && !this.isAudioSupported(f) || h && !this.isVideoSupported(h)) {
        this.log(`Some or all CODECS not supported "${d.CODECS}"`);
        return;
      }
      const {
        CODECS: y,
        "FRAME-RATE": b,
        "HDCP-LEVEL": x,
        "PATHWAY-ID": S,
        RESOLUTION: A,
        "VIDEO-RANGE": T
      } = d, L = `${`${S || "."}-`}${u.bitrate}-${A}-${b}-${y}-${T}-${x}`;
      if (s[L])
        if (s[L].uri !== u.url && !u.attrs["PATHWAY-ID"]) {
          const _ = a[L] += 1;
          u.attrs["PATHWAY-ID"] = new Array(_ + 1).join(".");
          const R = this.createLevel(u);
          s[L] = R, i.push(R);
        } else
          s[L].addGroupId("audio", d.AUDIO), s[L].addGroupId("text", d.SUBTITLES);
      else {
        const _ = this.createLevel(u);
        s[L] = _, a[L] = 1, i.push(_);
      }
    }), this.filterAndSortMediaOptions(i, t, o, c, l);
  }
  createLevel(e) {
    const t = new ta(e), n = e.supplemental;
    if (n != null && n.videoCodec && !this.isVideoSupported(n.videoCodec)) {
      const i = new Error(`SUPPLEMENTAL-CODECS not supported "${n.videoCodec}"`);
      this.log(i.message), t.supportedResult = HA(i, []);
    }
    return t;
  }
  isAudioSupported(e) {
    return pf(e, "audio", this.hls.config.preferManagedMediaSource);
  }
  isVideoSupported(e) {
    return pf(e, "video", this.hls.config.preferManagedMediaSource);
  }
  filterAndSortMediaOptions(e, t, n, i, s) {
    let a = [], o = [], c = e;
    if ((n || i) && s && (c = c.filter(({
      videoCodec: p,
      videoRange: v,
      width: y,
      height: b
    }) => (!!p || !!(y && b)) && HK(v))), c.length === 0) {
      Promise.resolve().then(() => {
        if (this.hls) {
          let p = "no level with compatible codecs found in manifest", v = p;
          t.levels.length && (v = `one or more CODECS in variant not supported: ${We(t.levels.map((b) => b.attrs.CODECS).filter((b, x, S) => S.indexOf(b) === x))}`, this.warn(v), p += ` (${v})`);
          const y = new Error(p);
          this.hls.trigger(E.ERROR, {
            type: ne.MEDIA_ERROR,
            details: k.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
            fatal: !0,
            url: t.url,
            error: y,
            reason: v
          });
        }
      });
      return;
    }
    t.audioTracks && (a = t.audioTracks.filter((p) => !p.audioCodec || this.isAudioSupported(p.audioCodec)), Ub(a)), t.subtitles && (o = t.subtitles, Ub(o));
    const l = c.slice(0);
    c.sort((p, v) => {
      if (p.attrs["HDCP-LEVEL"] !== v.attrs["HDCP-LEVEL"])
        return (p.attrs["HDCP-LEVEL"] || "") > (v.attrs["HDCP-LEVEL"] || "") ? 1 : -1;
      if (n && p.height !== v.height)
        return p.height - v.height;
      if (p.frameRate !== v.frameRate)
        return p.frameRate - v.frameRate;
      if (p.videoRange !== v.videoRange)
        return ol.indexOf(p.videoRange) - ol.indexOf(v.videoRange);
      if (p.videoCodec !== v.videoCodec) {
        const y = Cy(p.videoCodec), b = Cy(v.videoCodec);
        if (y !== b)
          return b - y;
      }
      if (p.uri === v.uri && p.codecSet !== v.codecSet) {
        const y = sl(p.codecSet), b = sl(v.codecSet);
        if (y !== b)
          return b - y;
      }
      return p.averageBitrate !== v.averageBitrate ? p.averageBitrate - v.averageBitrate : 0;
    });
    let u = l[0];
    if (this.steering && (c = this.steering.filterParsedLevels(c), c.length !== l.length)) {
      for (let p = 0; p < l.length; p++)
        if (l[p].pathwayId === c[0].pathwayId) {
          u = l[p];
          break;
        }
    }
    this._levels = c;
    for (let p = 0; p < c.length; p++)
      if (c[p] === u) {
        var d;
        this._firstLevel = p;
        const v = u.bitrate, y = this.hls.bandwidthEstimate;
        if (this.log(`manifest loaded, ${c.length} level(s) found, first bitrate: ${v}`), ((d = this.hls.userConfig) == null ? void 0 : d.abrEwmaDefaultEstimate) === void 0) {
          const b = Math.min(v, this.hls.config.abrEwmaDefaultEstimateMax);
          b > y && y === this.hls.abrEwmaDefaultEstimate && (this.hls.bandwidthEstimate = b);
        }
        break;
      }
    const f = s && !i, h = this.hls.config, g = !!(h.audioStreamController && h.audioTrackController), m = {
      levels: c,
      audioTracks: a,
      subtitleTracks: o,
      sessionData: t.sessionData,
      sessionKeys: t.sessionKeys,
      firstLevel: this._firstLevel,
      stats: t.stats,
      audio: s,
      video: i,
      altAudio: g && !f && a.some((p) => !!p.url)
    };
    this.hls.trigger(E.MANIFEST_PARSED, m);
  }
  get levels() {
    return this._levels.length === 0 ? null : this._levels;
  }
  get loadLevelObj() {
    return this.currentLevel;
  }
  get level() {
    return this.currentLevelIndex;
  }
  set level(e) {
    const t = this._levels;
    if (t.length === 0)
      return;
    if (e < 0 || e >= t.length) {
      const u = new Error("invalid level idx"), d = e < 0;
      if (this.hls.trigger(E.ERROR, {
        type: ne.OTHER_ERROR,
        details: k.LEVEL_SWITCH_ERROR,
        level: e,
        fatal: d,
        error: u,
        reason: u.message
      }), d)
        return;
      e = Math.min(e, t.length - 1);
    }
    const n = this.currentLevelIndex, i = this.currentLevel, s = i ? i.attrs["PATHWAY-ID"] : void 0, a = t[e], o = a.attrs["PATHWAY-ID"];
    if (this.currentLevelIndex = e, this.currentLevel = a, n === e && i && s === o)
      return;
    this.log(`Switching to level ${e} (${a.height ? a.height + "p " : ""}${a.videoRange ? a.videoRange + " " : ""}${a.codecSet ? a.codecSet + " " : ""}@${a.bitrate})${o ? " with Pathway " + o : ""} from level ${n}${s ? " with Pathway " + s : ""}`);
    const c = {
      level: e,
      attrs: a.attrs,
      details: a.details,
      bitrate: a.bitrate,
      averageBitrate: a.averageBitrate,
      maxBitrate: a.maxBitrate,
      realBitrate: a.realBitrate,
      width: a.width,
      height: a.height,
      codecSet: a.codecSet,
      audioCodec: a.audioCodec,
      videoCodec: a.videoCodec,
      audioGroups: a.audioGroups,
      subtitleGroups: a.subtitleGroups,
      loaded: a.loaded,
      loadError: a.loadError,
      fragmentError: a.fragmentError,
      name: a.name,
      id: a.id,
      uri: a.uri,
      url: a.url,
      urlId: 0,
      audioGroupIds: a.audioGroupIds,
      textGroupIds: a.textGroupIds
    };
    this.hls.trigger(E.LEVEL_SWITCHING, c);
    const l = a.details;
    if (!l || l.live) {
      const u = this.switchParams(a.uri, i == null ? void 0 : i.details, l);
      this.loadPlaylist(u);
    }
  }
  get manualLevel() {
    return this.manualLevelIndex;
  }
  set manualLevel(e) {
    this.manualLevelIndex = e, this._startLevel === void 0 && (this._startLevel = e), e !== -1 && (this.level = e);
  }
  get firstLevel() {
    return this._firstLevel;
  }
  set firstLevel(e) {
    this._firstLevel = e;
  }
  get startLevel() {
    if (this._startLevel === void 0) {
      const e = this.hls.config.startLevel;
      return e !== void 0 ? e : this.hls.firstAutoLevel;
    }
    return this._startLevel;
  }
  set startLevel(e) {
    this._startLevel = e;
  }
  get pathways() {
    return this.steering ? this.steering.pathways() : [];
  }
  get pathwayPriority() {
    return this.steering ? this.steering.pathwayPriority : null;
  }
  set pathwayPriority(e) {
    if (this.steering) {
      const t = this.steering.pathways(), n = e.filter((i) => t.indexOf(i) !== -1);
      if (e.length < 1) {
        this.warn(`pathwayPriority ${e} should contain at least one pathway from list: ${t}`);
        return;
      }
      this.steering.pathwayPriority = n;
    }
  }
  onError(e, t) {
    t.fatal || !t.context || t.context.type === me.LEVEL && t.context.level === this.level && this.checkRetry(t);
  }
  // reset errors on the successful load of a fragment
  onFragBuffered(e, {
    frag: t
  }) {
    if (t !== void 0 && t.type === ee.MAIN) {
      const n = t.elementaryStreams;
      if (!Object.keys(n).some((s) => !!n[s]))
        return;
      const i = this._levels[t.level];
      i != null && i.loadError && (this.log(`Resetting level error count of ${i.loadError} on frag buffered`), i.loadError = 0);
    }
  }
  onLevelLoaded(e, t) {
    var n;
    const {
      level: i,
      details: s
    } = t, a = t.levelInfo;
    if (!a) {
      var o;
      this.warn(`Invalid level index ${i}`), (o = t.deliveryDirectives) != null && o.skip && (s.deltaUpdateFailed = !0);
      return;
    }
    if (a === this.currentLevel || t.withoutMultiVariant) {
      a.fragmentError === 0 && (a.loadError = 0);
      let c = a.details;
      c === t.details && c.advanced && (c = void 0), this.playlistLoaded(i, t, c);
    } else (n = t.deliveryDirectives) != null && n.skip && (s.deltaUpdateFailed = !0);
  }
  loadPlaylist(e) {
    super.loadPlaylist(), this.shouldLoadPlaylist(this.currentLevel) && this.scheduleLoading(this.currentLevel, e);
  }
  loadingPlaylist(e, t) {
    super.loadingPlaylist(e, t);
    const n = this.getUrlWithDirectives(e.uri, t), i = this.currentLevelIndex, s = e.attrs["PATHWAY-ID"], a = e.details, o = a == null ? void 0 : a.age;
    this.log(`Loading level index ${i}${(t == null ? void 0 : t.msn) !== void 0 ? " at sn " + t.msn + " part " + t.part : ""}${s ? " Pathway " + s : ""}${o && a.live ? " age " + o.toFixed(1) + (a.type && " " + a.type || "") : ""} ${n}`), this.hls.trigger(E.LEVEL_LOADING, {
      url: n,
      level: i,
      levelInfo: e,
      pathwayId: e.attrs["PATHWAY-ID"],
      id: 0,
      // Deprecated Level urlId
      deliveryDirectives: t || null
    });
  }
  get nextLoadLevel() {
    return this.manualLevelIndex !== -1 ? this.manualLevelIndex : this.hls.nextAutoLevel;
  }
  set nextLoadLevel(e) {
    this.level = e, this.manualLevelIndex === -1 && (this.hls.nextAutoLevel = e);
  }
  removeLevel(e) {
    var t;
    if (this._levels.length === 1)
      return;
    const n = this._levels.filter((s, a) => a !== e ? !0 : (this.steering && this.steering.removeLevel(s), s === this.currentLevel && (this.currentLevel = null, this.currentLevelIndex = -1, s.details && s.details.fragments.forEach((o) => o.level = -1)), !1));
    cw(n), this._levels = n, this.currentLevelIndex > -1 && (t = this.currentLevel) != null && t.details && (this.currentLevelIndex = this.currentLevel.details.fragments[0].level), this.manualLevelIndex > -1 && (this.manualLevelIndex = this.currentLevelIndex);
    const i = n.length - 1;
    this._firstLevel = Math.min(this._firstLevel, i), this._startLevel && (this._startLevel = Math.min(this._startLevel, i)), this.hls.trigger(E.LEVELS_UPDATED, {
      levels: n
    });
  }
  onLevelsUpdated(e, {
    levels: t
  }) {
    this._levels = t;
  }
  checkMaxAutoUpdated() {
    const {
      autoLevelCapping: e,
      maxAutoLevel: t,
      maxHdcpLevel: n
    } = this.hls;
    this._maxAutoLevel !== t && (this._maxAutoLevel = t, this.hls.trigger(E.MAX_AUTO_LEVEL_UPDATED, {
      autoLevelCapping: e,
      levels: this.levels,
      maxAutoLevel: t,
      minAutoLevel: this.hls.minAutoLevel,
      maxHdcpLevel: n
    }));
  }
}
function Ub(r) {
  const e = {};
  r.forEach((t) => {
    const n = t.groupId || "";
    t.id = e[n] = e[n] || 0, e[n]++;
  });
}
function Jw() {
  return self.SourceBuffer || self.WebKitSourceBuffer;
}
function eI() {
  if (!Nn())
    return !1;
  const e = Jw();
  return !e || e.prototype && typeof e.prototype.appendBuffer == "function" && typeof e.prototype.remove == "function";
}
function WW() {
  if (!eI())
    return !1;
  const r = Nn();
  return typeof (r == null ? void 0 : r.isTypeSupported) == "function" && (["avc1.42E01E,mp4a.40.2", "av01.0.01M.08", "vp09.00.50.08"].some((e) => r.isTypeSupported(ea(e, "video"))) || ["mp4a.40.2", "fLaC"].some((e) => r.isTypeSupported(ea(e, "audio"))));
}
function HW() {
  var r;
  const e = Jw();
  return typeof (e == null || (r = e.prototype) == null ? void 0 : r.changeType) == "function";
}
const qW = 100;
class zW extends zg {
  constructor(e, t, n) {
    super(e, t, n, "stream-controller", ee.MAIN), this.audioCodecSwap = !1, this.level = -1, this._forceStartLoad = !1, this._hasEnoughToStart = !1, this.altAudio = 0, this.audioOnly = !1, this.fragPlaying = null, this.fragLastKbps = 0, this.couldBacktrack = !1, this.backtrackFragment = null, this.audioCodecSwitch = !1, this.videoBuffer = null, this.onMediaPlaying = () => {
      this.tick();
    }, this.onMediaSeeked = () => {
      const i = this.media, s = i ? i.currentTime : null;
      if (s === null || !X(s) || (this.log(`Media seeked to ${s.toFixed(3)}`), !this.getBufferedFrag(s)))
        return;
      const a = this.getFwdBufferInfoAtPos(i, s, ee.MAIN, 0);
      if (a === null || a.len === 0) {
        this.warn(`Main forward buffer length at ${s} on "seeked" event ${a ? a.len : "empty"})`);
        return;
      }
      this.tick();
    }, this.registerListeners();
  }
  registerListeners() {
    super.registerListeners();
    const {
      hls: e
    } = this;
    e.on(E.MANIFEST_PARSED, this.onManifestParsed, this), e.on(E.LEVEL_LOADING, this.onLevelLoading, this), e.on(E.LEVEL_LOADED, this.onLevelLoaded, this), e.on(E.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), e.on(E.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on(E.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.on(E.BUFFER_CREATED, this.onBufferCreated, this), e.on(E.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on(E.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(E.FRAG_BUFFERED, this.onFragBuffered, this);
  }
  unregisterListeners() {
    super.unregisterListeners();
    const {
      hls: e
    } = this;
    e.off(E.MANIFEST_PARSED, this.onManifestParsed, this), e.off(E.LEVEL_LOADED, this.onLevelLoaded, this), e.off(E.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), e.off(E.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off(E.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.off(E.BUFFER_CREATED, this.onBufferCreated, this), e.off(E.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off(E.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(E.FRAG_BUFFERED, this.onFragBuffered, this);
  }
  onHandlerDestroying() {
    this.onMediaPlaying = this.onMediaSeeked = null, this.unregisterListeners(), super.onHandlerDestroying();
  }
  startLoad(e, t) {
    if (this.levels) {
      const {
        lastCurrentTime: n,
        hls: i
      } = this;
      if (this.stopLoad(), this.setInterval(qW), this.level = -1, !this.startFragRequested) {
        let s = i.startLevel;
        s === -1 && (i.config.testBandwidth && this.levels.length > 1 ? (s = 0, this.bitrateTest = !0) : s = i.firstAutoLevel), i.nextLoadLevel = s, this.level = i.loadLevel, this._hasEnoughToStart = !!t;
      }
      n > 0 && e === -1 && !t && (this.log(`Override startPosition with lastCurrentTime @${n.toFixed(3)}`), e = n), this.state = $.IDLE, this.nextLoadPosition = this.lastCurrentTime = e + this.timelineOffset, this.startPosition = t ? -1 : e, this.tick();
    } else
      this._forceStartLoad = !0, this.state = $.STOPPED;
  }
  stopLoad() {
    this._forceStartLoad = !1, super.stopLoad();
  }
  doTick() {
    switch (this.state) {
      case $.WAITING_LEVEL: {
        const {
          levels: t,
          level: n
        } = this, i = t == null ? void 0 : t[n], s = i == null ? void 0 : i.details;
        if (s && (!s.live || this.levelLastLoaded === i && !this.waitForLive(i))) {
          if (this.waitForCdnTuneIn(s))
            break;
          this.state = $.IDLE;
          break;
        } else if (this.hls.nextLoadLevel !== this.level) {
          this.state = $.IDLE;
          break;
        }
        break;
      }
      case $.FRAG_LOADING_WAITING_RETRY:
        {
          var e;
          const t = self.performance.now(), n = this.retryDate;
          if (!n || t >= n || (e = this.media) != null && e.seeking) {
            const {
              levels: i,
              level: s
            } = this, a = i == null ? void 0 : i[s];
            this.resetStartWhenNotLoaded(a || null), this.state = $.IDLE;
          }
        }
        break;
    }
    this.state === $.IDLE && this.doTickIdle(), this.onTickEnd();
  }
  onTickEnd() {
    var e;
    super.onTickEnd(), (e = this.media) != null && e.readyState && this.media.seeking === !1 && (this.lastCurrentTime = this.media.currentTime), this.checkFragmentChanged();
  }
  doTickIdle() {
    const {
      hls: e,
      levelLastLoaded: t,
      levels: n,
      media: i
    } = this;
    if (t === null || !i && !this.primaryPrefetch && (this.startFragRequested || !e.config.startFragPrefetch) || this.altAudio && this.audioOnly)
      return;
    const s = this.buffering ? e.nextLoadLevel : e.loadLevel;
    if (!(n != null && n[s]))
      return;
    const a = n[s], o = this.getMainFwdBufferInfo();
    if (o === null)
      return;
    const c = this.getLevelDetails();
    if (c && this._streamEnded(o, c)) {
      const m = {};
      this.altAudio === 2 && (m.type = "video"), this.hls.trigger(E.BUFFER_EOS, m), this.state = $.ENDED;
      return;
    }
    if (!this.buffering)
      return;
    e.loadLevel !== s && e.manualLevel === -1 && this.log(`Adapting to level ${s} from level ${this.level}`), this.level = e.nextLoadLevel = s;
    const l = a.details;
    if (!l || this.state === $.WAITING_LEVEL || this.waitForLive(a)) {
      this.level = s, this.state = $.WAITING_LEVEL, this.startFragRequested = !1;
      return;
    }
    const u = o.len, d = this.getMaxBufferLength(a.maxBitrate);
    if (u >= d)
      return;
    this.backtrackFragment && this.backtrackFragment.start > o.end && (this.backtrackFragment = null);
    const f = this.backtrackFragment ? this.backtrackFragment.start : o.end;
    let h = this.getNextFragment(f, l);
    if (this.couldBacktrack && !this.fragPrevious && h && it(h) && this.fragmentTracker.getState(h) !== ct.OK) {
      var g;
      const p = ((g = this.backtrackFragment) != null ? g : h).sn - l.startSN, v = l.fragments[p - 1];
      v && h.cc === v.cc && (h = v, this.fragmentTracker.removeFragment(v));
    } else this.backtrackFragment && o.len && (this.backtrackFragment = null);
    if (h && this.isLoopLoading(h, f)) {
      if (!h.gap) {
        const p = this.audioOnly && !this.altAudio ? je.AUDIO : je.VIDEO, v = (p === je.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
        v && this.afterBufferFlushed(v, p, ee.MAIN);
      }
      h = this.getNextFragmentLoopLoading(h, l, o, ee.MAIN, d);
    }
    h && (h.initSegment && !h.initSegment.data && !this.bitrateTest && (h = h.initSegment), this.loadFragment(h, a, f));
  }
  loadFragment(e, t, n) {
    const i = this.fragmentTracker.getState(e);
    i === ct.NOT_LOADED || i === ct.PARTIAL ? it(e) ? this.bitrateTest ? (this.log(`Fragment ${e.sn} of level ${e.level} is being downloaded to test bitrate and will not be buffered`), this._loadBitrateTestFrag(e, t)) : super.loadFragment(e, t, n) : this._loadInitSegment(e, t) : this.clearTrackerIfNeeded(e);
  }
  getBufferedFrag(e) {
    return this.fragmentTracker.getBufferedFrag(e, ee.MAIN);
  }
  followingBufferedFrag(e) {
    return e ? this.getBufferedFrag(e.end + 0.5) : null;
  }
  /*
    on immediate level switch :
     - pause playback if playing
     - cancel any pending load request
     - and trigger a buffer flush
  */
  immediateLevelSwitch() {
    this.abortCurrentFrag(), this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
  }
  /**
   * try to switch ASAP without breaking video playback:
   * in order to ensure smooth but quick level switching,
   * we need to find the next flushable buffer range
   * we should take into account new segment fetch time
   */
  nextLevelSwitch() {
    const {
      levels: e,
      media: t
    } = this;
    if (t != null && t.readyState) {
      let n;
      const i = this.getAppendedFrag(t.currentTime);
      i && i.start > 1 && this.flushMainBuffer(0, i.start - 1);
      const s = this.getLevelDetails();
      if (s != null && s.live) {
        const o = this.getMainFwdBufferInfo();
        if (!o || o.len < s.targetduration * 2)
          return;
      }
      if (!t.paused && e) {
        const o = this.hls.nextLoadLevel, c = e[o], l = this.fragLastKbps;
        l && this.fragCurrent ? n = this.fragCurrent.duration * c.maxBitrate / (1e3 * l) + 1 : n = 0;
      } else
        n = 0;
      const a = this.getBufferedFrag(t.currentTime + n);
      if (a) {
        const o = this.followingBufferedFrag(a);
        if (o) {
          this.abortCurrentFrag();
          const c = o.maxStartPTS ? o.maxStartPTS : o.start, l = o.duration, u = Math.max(a.end, c + Math.min(Math.max(l - this.config.maxFragLookUpTolerance, l * (this.couldBacktrack ? 0.5 : 0.125)), l * (this.couldBacktrack ? 0.75 : 0.25)));
          this.flushMainBuffer(u, Number.POSITIVE_INFINITY);
        }
      }
    }
  }
  abortCurrentFrag() {
    const e = this.fragCurrent;
    switch (this.fragCurrent = null, this.backtrackFragment = null, e && (e.abortRequests(), this.fragmentTracker.removeFragment(e)), this.state) {
      case $.KEY_LOADING:
      case $.FRAG_LOADING:
      case $.FRAG_LOADING_WAITING_RETRY:
      case $.PARSING:
      case $.PARSED:
        this.state = $.IDLE;
        break;
    }
    this.nextLoadPosition = this.getLoadPosition();
  }
  flushMainBuffer(e, t) {
    super.flushMainBuffer(e, t, this.altAudio === 2 ? "video" : null);
  }
  onMediaAttached(e, t) {
    super.onMediaAttached(e, t);
    const n = t.media;
    gr(n, "playing", this.onMediaPlaying), gr(n, "seeked", this.onMediaSeeked);
  }
  onMediaDetaching(e, t) {
    const {
      media: n
    } = this;
    n && (Pr(n, "playing", this.onMediaPlaying), Pr(n, "seeked", this.onMediaSeeked)), this.videoBuffer = null, this.fragPlaying = null, super.onMediaDetaching(e, t), !t.transferMedia && (this._hasEnoughToStart = !1);
  }
  onManifestLoading() {
    super.onManifestLoading(), this.log("Trigger BUFFER_RESET"), this.hls.trigger(E.BUFFER_RESET, void 0), this.couldBacktrack = !1, this.fragLastKbps = 0, this.fragPlaying = this.backtrackFragment = null, this.altAudio = 0, this.audioOnly = !1;
  }
  onManifestParsed(e, t) {
    let n = !1, i = !1;
    t.levels.forEach((s) => {
      const a = s.audioCodec;
      a && (n = n || a.indexOf("mp4a.40.2") !== -1, i = i || a.indexOf("mp4a.40.5") !== -1);
    }), this.audioCodecSwitch = n && i && !HW(), this.audioCodecSwitch && this.log("Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC"), this.levels = t.levels, this.startFragRequested = !1;
  }
  onLevelLoading(e, t) {
    const {
      levels: n
    } = this;
    if (!n || this.state !== $.IDLE)
      return;
    const i = t.levelInfo;
    (!i.details || i.details.live && (this.levelLastLoaded !== i || i.details.expired) || this.waitForCdnTuneIn(i.details)) && (this.state = $.WAITING_LEVEL);
  }
  onLevelLoaded(e, t) {
    var n;
    const {
      levels: i,
      startFragRequested: s
    } = this, a = t.level, o = t.details, c = o.totalduration;
    if (!i) {
      this.warn(`Levels were reset while loading level ${a}`);
      return;
    }
    this.log(`Level ${a} loaded [${o.startSN},${o.endSN}]${o.lastPartSn ? `[part-${o.lastPartSn}-${o.lastPartIndex}]` : ""}, cc [${o.startCC}, ${o.endCC}] duration:${c}`);
    const l = t.levelInfo, u = this.fragCurrent;
    u && (this.state === $.FRAG_LOADING || this.state === $.FRAG_LOADING_WAITING_RETRY) && u.level !== t.level && u.loader && this.abortCurrentFrag();
    let d = 0;
    if (o.live || (n = l.details) != null && n.live) {
      var f;
      if (this.checkLiveUpdate(o), o.deltaUpdateFailed)
        return;
      d = this.alignPlaylists(o, l.details, (f = this.levelLastLoaded) == null ? void 0 : f.details);
    }
    if (l.details = o, this.levelLastLoaded = l, s || this.setStartPosition(o, d), this.hls.trigger(E.LEVEL_UPDATED, {
      details: o,
      level: a
    }), this.state === $.WAITING_LEVEL) {
      if (this.waitForCdnTuneIn(o))
        return;
      this.state = $.IDLE;
    }
    s && o.live && this.synchronizeToLiveEdge(o), this.tick();
  }
  synchronizeToLiveEdge(e) {
    const {
      config: t,
      media: n
    } = this;
    if (!n)
      return;
    const i = this.hls.liveSyncPosition, s = this.getLoadPosition(), a = e.fragmentStart, o = e.edge, c = s >= a - t.maxFragLookUpTolerance && s <= o;
    if (i !== null && n.duration > i && (s < i || !c)) {
      const u = t.liveMaxLatencyDuration !== void 0 ? t.liveMaxLatencyDuration : t.liveMaxLatencyDurationCount * e.targetduration;
      if ((!c && n.readyState < 4 || s < o - u) && (this._hasEnoughToStart || (this.nextLoadPosition = i), n.readyState))
        if (this.warn(`Playback: ${s.toFixed(3)} is located too far from the end of live sliding playlist: ${o}, reset currentTime to : ${i.toFixed(3)}`), this.config.liveSyncMode === "buffered") {
          var l;
          const d = ue.bufferInfo(n, i, 0);
          if (!(d != null && (l = d.buffered) != null && l.length)) {
            n.currentTime = i;
            return;
          }
          if (d.start <= s) {
            n.currentTime = i;
            return;
          }
          const {
            nextStart: h
          } = ue.bufferedInfo(d.buffered, s, 0);
          h && (n.currentTime = h);
        } else
          n.currentTime = i;
    }
  }
  _handleFragmentLoadProgress(e) {
    var t;
    const n = e.frag, {
      part: i,
      payload: s
    } = e, {
      levels: a
    } = this;
    if (!a) {
      this.warn(`Levels were reset while fragment load was in progress. Fragment ${n.sn} of level ${n.level} will not be buffered`);
      return;
    }
    const o = a[n.level];
    if (!o) {
      this.warn(`Level ${n.level} not found on progress`);
      return;
    }
    const c = o.details;
    if (!c) {
      this.warn(`Dropping fragment ${n.sn} of level ${n.level} after level details were reset`), this.fragmentTracker.removeFragment(n);
      return;
    }
    const l = o.videoCodec, u = c.PTSKnown || !c.live, d = (t = n.initSegment) == null ? void 0 : t.data, f = this._getAudioCodec(o), h = this.transmuxer = this.transmuxer || new Rw(this.hls, ee.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)), g = i ? i.index : -1, m = g !== -1, p = new Hg(n.level, n.sn, n.stats.chunkCount, s.byteLength, g, m), v = this.initPTS[n.cc];
    h.push(s, d, f, l, n, i, c.totalduration, u, p, v);
  }
  onAudioTrackSwitching(e, t) {
    const n = this.hls, i = this.altAudio === 2;
    if (ll(t.url, n))
      this.altAudio = 1;
    else {
      if (this.mediaBuffer !== this.media) {
        this.log("Switching on main audio, use media.buffered to schedule main fragment loading"), this.mediaBuffer = this.media;
        const a = this.fragCurrent;
        a && (this.log("Switching to main audio track, cancel main fragment load"), a.abortRequests(), this.fragmentTracker.removeFragment(a)), this.resetTransmuxer(), this.resetLoadingState();
      } else this.audioOnly && this.resetTransmuxer();
      if (i) {
        this.fragmentTracker.removeAllFragments(), n.once(E.BUFFER_FLUSHED, () => {
          var a;
          (a = this.hls) == null || a.trigger(E.AUDIO_TRACK_SWITCHED, t);
        }), n.trigger(E.BUFFER_FLUSHING, {
          startOffset: 0,
          endOffset: Number.POSITIVE_INFINITY,
          type: null
        });
        return;
      }
      n.trigger(E.AUDIO_TRACK_SWITCHED, t);
    }
  }
  onAudioTrackSwitched(e, t) {
    const n = ll(t.url, this.hls);
    if (n) {
      const i = this.videoBuffer;
      i && this.mediaBuffer !== i && (this.log("Switching on alternate audio, use video.buffered to schedule main fragment loading"), this.mediaBuffer = i);
    }
    this.altAudio = n ? 2 : 0, this.tick();
  }
  onBufferCreated(e, t) {
    const n = t.tracks;
    let i, s, a = !1;
    for (const o in n) {
      const c = n[o];
      if (c.id === "main") {
        if (s = o, i = c, o === "video") {
          const l = n[o];
          l && (this.videoBuffer = l.buffer);
        }
      } else
        a = !0;
    }
    a && i ? (this.log(`Alternate track found, use ${s}.buffered to schedule main fragment loading`), this.mediaBuffer = i.buffer) : this.mediaBuffer = this.media;
  }
  onFragBuffered(e, t) {
    const {
      frag: n,
      part: i
    } = t, s = n.type === ee.MAIN;
    if (s) {
      if (this.fragContextChanged(n)) {
        this.warn(`Fragment ${n.sn}${i ? " p: " + i.index : ""} of level ${n.level} finished buffering, but was aborted. state: ${this.state}`), this.state === $.PARSED && (this.state = $.IDLE);
        return;
      }
      const o = i ? i.stats : n.stats;
      this.fragLastKbps = Math.round(8 * o.total / (o.buffering.end - o.loading.first)), it(n) && (this.fragPrevious = n), this.fragBufferedComplete(n, i);
    }
    const a = this.media;
    a && (!this._hasEnoughToStart && ue.getBuffered(a).length && (this._hasEnoughToStart = !0, this.seekToStartPos()), s && this.tick());
  }
  get hasEnoughToStart() {
    return this._hasEnoughToStart;
  }
  onError(e, t) {
    var n;
    if (t.fatal) {
      this.state = $.ERROR;
      return;
    }
    switch (t.details) {
      case k.FRAG_GAP:
      case k.FRAG_PARSING_ERROR:
      case k.FRAG_DECRYPT_ERROR:
      case k.FRAG_LOAD_ERROR:
      case k.FRAG_LOAD_TIMEOUT:
      case k.KEY_LOAD_ERROR:
      case k.KEY_LOAD_TIMEOUT:
        this.onFragmentOrKeyLoadError(ee.MAIN, t);
        break;
      case k.LEVEL_LOAD_ERROR:
      case k.LEVEL_LOAD_TIMEOUT:
      case k.LEVEL_PARSING_ERROR:
        !t.levelRetry && this.state === $.WAITING_LEVEL && ((n = t.context) == null ? void 0 : n.type) === me.LEVEL && (this.state = $.IDLE);
        break;
      case k.BUFFER_ADD_CODEC_ERROR:
      case k.BUFFER_APPEND_ERROR:
        if (t.parent !== "main")
          return;
        this.reduceLengthAndFlushBuffer(t) && this.resetLoadingState();
        break;
      case k.BUFFER_FULL_ERROR:
        if (t.parent !== "main")
          return;
        this.reduceLengthAndFlushBuffer(t) && this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
        break;
      case k.INTERNAL_EXCEPTION:
        this.recoverWorkerError(t);
        break;
    }
  }
  onFragLoadEmergencyAborted() {
    this.state = $.IDLE, this._hasEnoughToStart || (this.startFragRequested = !1, this.nextLoadPosition = this.lastCurrentTime), this.tickImmediate();
  }
  onBufferFlushed(e, {
    type: t
  }) {
    if (t !== je.AUDIO || !this.altAudio) {
      const n = (t === je.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
      n && (this.afterBufferFlushed(n, t, ee.MAIN), this.tick());
    }
  }
  onLevelsUpdated(e, t) {
    this.level > -1 && this.fragCurrent && (this.level = this.fragCurrent.level, this.level === -1 && this.resetWhenMissingContext(this.fragCurrent)), this.levels = t.levels;
  }
  swapAudioCodec() {
    this.audioCodecSwap = !this.audioCodecSwap;
  }
  /**
   * Seeks to the set startPosition if not equal to the mediaElement's current time.
   */
  seekToStartPos() {
    const {
      media: e
    } = this;
    if (!e)
      return;
    const t = e.currentTime;
    let n = this.startPosition;
    if (n >= 0 && t < n) {
      if (e.seeking) {
        this.log(`could not seek to ${n}, already seeking at ${t}`);
        return;
      }
      const i = this.timelineOffset;
      i && n && (n += i);
      const s = this.getLevelDetails(), a = ue.getBuffered(e), o = a.length ? a.start(0) : 0, c = o - n, l = Math.max(this.config.maxBufferHole, this.config.maxFragLookUpTolerance);
      (this.config.startOnSegmentBoundary || c > 0 && (c < l || this.loadingParts && c < 2 * ((s == null ? void 0 : s.partTarget) || 0))) && (this.log(`adjusting start position by ${c} to match buffer start`), n += c, this.startPosition = n), t < n && (this.log(`seek to target start position ${n} from current time ${t} buffer start ${o}`), e.currentTime = n);
    }
  }
  _getAudioCodec(e) {
    let t = this.config.defaultAudioCodec || e.audioCodec;
    return this.audioCodecSwap && t && (this.log("Swapping audio codec"), t.indexOf("mp4a.40.5") !== -1 ? t = "mp4a.40.2" : t = "mp4a.40.5"), t;
  }
  _loadBitrateTestFrag(e, t) {
    e.bitrateTest = !0, this._doFragLoad(e, t).then((n) => {
      const {
        hls: i
      } = this, s = n == null ? void 0 : n.frag;
      if (!s || this.fragContextChanged(s))
        return;
      t.fragmentError = 0, this.state = $.IDLE, this.startFragRequested = !1, this.bitrateTest = !1;
      const a = s.stats;
      a.parsing.start = a.parsing.end = a.buffering.start = a.buffering.end = self.performance.now(), i.trigger(E.FRAG_LOADED, n), s.bitrateTest = !1;
    });
  }
  _handleTransmuxComplete(e) {
    var t;
    const n = this.playlistType, {
      hls: i
    } = this, {
      remuxResult: s,
      chunkMeta: a
    } = e, o = this.getCurrentContext(a);
    if (!o) {
      this.resetWhenMissingContext(a);
      return;
    }
    const {
      frag: c,
      part: l,
      level: u
    } = o, {
      video: d,
      text: f,
      id3: h,
      initSegment: g
    } = s, {
      details: m
    } = u, p = this.altAudio ? void 0 : s.audio;
    if (this.fragContextChanged(c)) {
      this.fragmentTracker.removeFragment(c);
      return;
    }
    if (this.state = $.PARSING, g) {
      if (g != null && g.tracks) {
        const x = c.initSegment || c;
        this._bufferInitSegment(u, g.tracks, x, a), i.trigger(E.FRAG_PARSING_INIT_SEGMENT, {
          frag: x,
          id: n,
          tracks: g.tracks
        });
      }
      const v = g.initPTS, y = g.timescale, b = this.initPTS[c.cc];
      X(v) && (!b || b.baseTime !== v || b.timescale !== y) && (this.initPTS[c.cc] = {
        baseTime: v,
        timescale: y
      }, i.trigger(E.INIT_PTS_FOUND, {
        frag: c,
        id: n,
        initPTS: v,
        timescale: y
      }));
    }
    if (d && m) {
      p && d.type === "audiovideo" && this.logMuxedErr(c);
      const v = m.fragments[c.sn - 1 - m.startSN], y = c.sn === m.startSN, b = !v || c.cc > v.cc;
      if (s.independent !== !1) {
        const {
          startPTS: x,
          endPTS: S,
          startDTS: A,
          endDTS: T
        } = d;
        if (l)
          l.elementaryStreams[d.type] = {
            startPTS: x,
            endPTS: S,
            startDTS: A,
            endDTS: T
          };
        else if (d.firstKeyFrame && d.independent && a.id === 1 && !b && (this.couldBacktrack = !0), d.dropped && d.independent) {
          const I = this.getMainFwdBufferInfo(), L = (I ? I.end : this.getLoadPosition()) + this.config.maxBufferHole, _ = d.firstKeyFramePTS ? d.firstKeyFramePTS : x;
          if (!y && L < _ - this.config.maxBufferHole && !b) {
            this.backtrack(c);
            return;
          } else b && (c.gap = !0);
          c.setElementaryStreamInfo(d.type, c.start, S, c.start, T, !0);
        } else y && x - (m.appliedTimelineOffset || 0) > To && (c.gap = !0);
        c.setElementaryStreamInfo(d.type, x, S, A, T), this.backtrackFragment && (this.backtrackFragment = c), this.bufferFragmentData(d, c, l, a, y || b);
      } else if (y || b)
        c.gap = !0;
      else {
        this.backtrack(c);
        return;
      }
    }
    if (p) {
      const {
        startPTS: v,
        endPTS: y,
        startDTS: b,
        endDTS: x
      } = p;
      l && (l.elementaryStreams[je.AUDIO] = {
        startPTS: v,
        endPTS: y,
        startDTS: b,
        endDTS: x
      }), c.setElementaryStreamInfo(je.AUDIO, v, y, b, x), this.bufferFragmentData(p, c, l, a);
    }
    if (m && h != null && (t = h.samples) != null && t.length) {
      const v = {
        id: n,
        frag: c,
        details: m,
        samples: h.samples
      };
      i.trigger(E.FRAG_PARSING_METADATA, v);
    }
    if (m && f) {
      const v = {
        id: n,
        frag: c,
        details: m,
        samples: f.samples
      };
      i.trigger(E.FRAG_PARSING_USERDATA, v);
    }
  }
  logMuxedErr(e) {
    this.warn(`${it(e) ? "Media" : "Init"} segment with muxed audiovideo where only video expected: ${e.url}`);
  }
  _bufferInitSegment(e, t, n, i) {
    if (this.state !== $.PARSING)
      return;
    this.audioOnly = !!t.audio && !t.video, this.altAudio && !this.audioOnly && (delete t.audio, t.audiovideo && this.logMuxedErr(n));
    const {
      audio: s,
      video: a,
      audiovideo: o
    } = t;
    if (s) {
      const l = e.audioCodec;
      let u = po(s.codec, l);
      u === "mp4a" && (u = "mp4a.40.5");
      const d = navigator.userAgent.toLowerCase();
      if (this.audioCodecSwitch) {
        u && (u.indexOf("mp4a.40.5") !== -1 ? u = "mp4a.40.2" : u = "mp4a.40.5");
        const f = s.metadata;
        f && "channelCount" in f && (f.channelCount || 1) !== 1 && d.indexOf("firefox") === -1 && (u = "mp4a.40.5");
      }
      u && u.indexOf("mp4a.40.5") !== -1 && d.indexOf("android") !== -1 && s.container !== "audio/mpeg" && (u = "mp4a.40.2", this.log(`Android: force audio codec to ${u}`)), l && l !== u && this.log(`Swapping manifest audio codec "${l}" for "${u}"`), s.levelCodec = u, s.id = ee.MAIN, this.log(`Init audio buffer, container:${s.container}, codecs[selected/level/parsed]=[${u || ""}/${l || ""}/${s.codec}]`), delete t.audiovideo;
    }
    if (a) {
      a.levelCodec = e.videoCodec, a.id = ee.MAIN;
      const l = a.codec;
      if ((l == null ? void 0 : l.length) === 4)
        switch (l) {
          case "hvc1":
          case "hev1":
            a.codec = "hvc1.1.6.L120.90";
            break;
          case "av01":
            a.codec = "av01.0.04M.08";
            break;
          case "avc1":
            a.codec = "avc1.42e01e";
            break;
        }
      this.log(`Init video buffer, container:${a.container}, codecs[level/parsed]=[${e.videoCodec || ""}/${l}]${a.codec !== l ? " parsed-corrected=" + a.codec : ""}${a.supplemental ? " supplemental=" + a.supplemental : ""}`), delete t.audiovideo;
    }
    o && (this.log(`Init audiovideo buffer, container:${o.container}, codecs[level/parsed]=[${e.codecs}/${o.codec}]`), delete t.video, delete t.audio);
    const c = Object.keys(t);
    if (c.length) {
      if (this.hls.trigger(E.BUFFER_CODECS, t), !this.hls)
        return;
      c.forEach((l) => {
        const d = t[l].initSegment;
        d != null && d.byteLength && this.hls.trigger(E.BUFFER_APPENDING, {
          type: l,
          data: d,
          frag: n,
          part: null,
          chunkMeta: i,
          parent: n.type
        });
      });
    }
    this.tickImmediate();
  }
  getMainFwdBufferInfo() {
    const e = this.mediaBuffer && this.altAudio === 2 ? this.mediaBuffer : this.media;
    return this.getFwdBufferInfo(e, ee.MAIN);
  }
  get maxBufferLength() {
    const {
      levels: e,
      level: t
    } = this, n = e == null ? void 0 : e[t];
    return n ? this.getMaxBufferLength(n.maxBitrate) : this.config.maxBufferLength;
  }
  backtrack(e) {
    this.couldBacktrack = !0, this.backtrackFragment = e, this.resetTransmuxer(), this.flushBufferGap(e), this.fragmentTracker.removeFragment(e), this.fragPrevious = null, this.nextLoadPosition = e.start, this.state = $.IDLE;
  }
  checkFragmentChanged() {
    const e = this.media;
    let t = null;
    if (e && e.readyState > 1 && e.seeking === !1) {
      const n = e.currentTime;
      if (ue.isBuffered(e, n) ? t = this.getAppendedFrag(n) : ue.isBuffered(e, n + 0.1) && (t = this.getAppendedFrag(n + 0.1)), t) {
        this.backtrackFragment = null;
        const i = this.fragPlaying, s = t.level;
        (!i || t.sn !== i.sn || i.level !== s) && (this.fragPlaying = t, this.hls.trigger(E.FRAG_CHANGED, {
          frag: t
        }), (!i || i.level !== s) && this.hls.trigger(E.LEVEL_SWITCHED, {
          level: s
        }));
      }
    }
  }
  get nextLevel() {
    const e = this.nextBufferedFrag;
    return e ? e.level : -1;
  }
  get currentFrag() {
    var e;
    if (this.fragPlaying)
      return this.fragPlaying;
    const t = ((e = this.media) == null ? void 0 : e.currentTime) || this.lastCurrentTime;
    return X(t) ? this.getAppendedFrag(t) : null;
  }
  get currentProgramDateTime() {
    var e;
    const t = ((e = this.media) == null ? void 0 : e.currentTime) || this.lastCurrentTime;
    if (X(t)) {
      const n = this.getLevelDetails(), i = this.currentFrag || (n ? mi(null, n.fragments, t) : null);
      if (i) {
        const s = i.programDateTime;
        if (s !== null) {
          const a = s + (t - i.start) * 1e3;
          return new Date(a);
        }
      }
    }
    return null;
  }
  get currentLevel() {
    const e = this.currentFrag;
    return e ? e.level : -1;
  }
  get nextBufferedFrag() {
    const e = this.currentFrag;
    return e ? this.followingBufferedFrag(e) : null;
  }
  get forceStartLoad() {
    return this._forceStartLoad;
  }
}
class YW {
  constructor(e) {
    this.config = void 0, this.keyUriToKeyInfo = {}, this.emeController = null, this.config = e;
  }
  abort(e) {
    for (const n in this.keyUriToKeyInfo) {
      const i = this.keyUriToKeyInfo[n].loader;
      if (i) {
        var t;
        if (e && e !== ((t = i.context) == null ? void 0 : t.frag.type))
          return;
        i.abort();
      }
    }
  }
  detach() {
    for (const e in this.keyUriToKeyInfo) {
      const t = this.keyUriToKeyInfo[e];
      (t.mediaKeySessionContext || t.decryptdata.isCommonEncryption) && delete this.keyUriToKeyInfo[e];
    }
  }
  destroy() {
    this.detach();
    for (const e in this.keyUriToKeyInfo) {
      const t = this.keyUriToKeyInfo[e].loader;
      t && t.destroy();
    }
    this.keyUriToKeyInfo = {};
  }
  createKeyLoadError(e, t = k.KEY_LOAD_ERROR, n, i, s) {
    return new zr({
      type: ne.NETWORK_ERROR,
      details: t,
      fatal: !1,
      frag: e,
      response: s,
      error: n,
      networkDetails: i
    });
  }
  loadClear(e, t, n) {
    if (this.emeController && this.config.emeEnabled && !this.emeController.getSelectedKeySystemFormats().length) {
      if (t.length)
        for (let i = 0, s = t.length; i < s; i++) {
          const a = t[i];
          if (e.cc <= a.cc && (!it(e) || !it(a) || e.sn < a.sn) || !n && i == s - 1)
            return this.emeController.selectKeySystemFormat(a).then((o) => {
              if (!this.emeController)
                return;
              a.setKeyFormat(o);
              const c = Ef(o);
              if (c)
                return this.emeController.getKeySystemAccess([c]);
            });
        }
      if (this.config.requireKeySystemAccessOnStart) {
        const i = yo(this.config);
        if (i.length)
          return this.emeController.getKeySystemAccess(i);
      }
    }
    return null;
  }
  load(e) {
    return !e.decryptdata && e.encrypted && this.emeController && this.config.emeEnabled ? this.emeController.selectKeySystemFormat(e).then((t) => this.loadInternal(e, t)) : this.loadInternal(e);
  }
  loadInternal(e, t) {
    var n, i;
    t && e.setKeyFormat(t);
    const s = e.decryptdata;
    if (!s) {
      const l = new Error(t ? `Expected frag.decryptdata to be defined after setting format ${t}` : "Missing decryption data on fragment in onKeyLoading");
      return Promise.reject(this.createKeyLoadError(e, k.KEY_LOAD_ERROR, l));
    }
    const a = s.uri;
    if (!a)
      return Promise.reject(this.createKeyLoadError(e, k.KEY_LOAD_ERROR, new Error(`Invalid key URI: "${a}"`)));
    let o = this.keyUriToKeyInfo[a];
    if ((n = o) != null && n.decryptdata.key)
      return s.key = o.decryptdata.key, Promise.resolve({
        frag: e,
        keyInfo: o
      });
    if ((i = o) != null && i.keyLoadPromise) {
      var c;
      switch ((c = o.mediaKeySessionContext) == null ? void 0 : c.keyStatus) {
        case void 0:
        case "status-pending":
        case "usable":
        case "usable-in-future":
          return o.keyLoadPromise.then((l) => (s.key = l.keyInfo.decryptdata.key, {
            frag: e,
            keyInfo: o
          }));
      }
    }
    switch (o = this.keyUriToKeyInfo[a] = {
      decryptdata: s,
      keyLoadPromise: null,
      loader: null,
      mediaKeySessionContext: null
    }, s.method) {
      case "ISO-23001-7":
      case "SAMPLE-AES":
      case "SAMPLE-AES-CENC":
      case "SAMPLE-AES-CTR":
        return s.keyFormat === "identity" ? this.loadKeyHTTP(o, e) : this.loadKeyEME(o, e);
      case "AES-128":
      case "AES-256":
      case "AES-256-CTR":
        return this.loadKeyHTTP(o, e);
      default:
        return Promise.reject(this.createKeyLoadError(e, k.KEY_LOAD_ERROR, new Error(`Key supplied with unsupported METHOD: "${s.method}"`)));
    }
  }
  loadKeyEME(e, t) {
    const n = {
      frag: t,
      keyInfo: e
    };
    if (this.emeController && this.config.emeEnabled) {
      const i = this.emeController.loadKey(n);
      if (i)
        return (e.keyLoadPromise = i.then((s) => (e.mediaKeySessionContext = s, n))).catch((s) => {
          throw e.keyLoadPromise = null, s;
        });
    }
    return Promise.resolve(n);
  }
  loadKeyHTTP(e, t) {
    const n = this.config, i = n.loader, s = new i(n);
    return t.keyLoader = e.loader = s, e.keyLoadPromise = new Promise((a, o) => {
      const c = {
        keyInfo: e,
        frag: t,
        responseType: "arraybuffer",
        url: e.decryptdata.uri
      }, l = n.keyLoadPolicy.default, u = {
        loadPolicy: l,
        timeout: l.maxLoadTimeMs,
        maxRetry: 0,
        retryDelay: 0,
        maxRetryDelay: 0
      }, d = {
        onSuccess: (f, h, g, m) => {
          const {
            frag: p,
            keyInfo: v,
            url: y
          } = g;
          if (!p.decryptdata || v !== this.keyUriToKeyInfo[y])
            return o(this.createKeyLoadError(p, k.KEY_LOAD_ERROR, new Error("after key load, decryptdata unset or changed"), m));
          v.decryptdata.key = p.decryptdata.key = new Uint8Array(f.data), p.keyLoader = null, v.loader = null, a({
            frag: p,
            keyInfo: v
          });
        },
        onError: (f, h, g, m) => {
          this.resetLoader(h), o(this.createKeyLoadError(t, k.KEY_LOAD_ERROR, new Error(`HTTP Error ${f.code} loading key ${f.text}`), g, Ne({
            url: c.url,
            data: void 0
          }, f)));
        },
        onTimeout: (f, h, g) => {
          this.resetLoader(h), o(this.createKeyLoadError(t, k.KEY_LOAD_TIMEOUT, new Error("key loading timed out"), g));
        },
        onAbort: (f, h, g) => {
          this.resetLoader(h), o(this.createKeyLoadError(t, k.INTERNAL_ABORTED, new Error("key loading aborted"), g));
        }
      };
      s.load(c, u, d);
    });
  }
  resetLoader(e) {
    const {
      frag: t,
      keyInfo: n,
      url: i
    } = e, s = n.loader;
    t.keyLoader === s && (t.keyLoader = null, n.loader = null), delete this.keyUriToKeyInfo[i], s && s.destroy();
  }
}
function Gb(r) {
  const {
    type: e
  } = r;
  switch (e) {
    case me.AUDIO_TRACK:
      return ee.AUDIO;
    case me.SUBTITLE_TRACK:
      return ee.SUBTITLE;
    default:
      return ee.MAIN;
  }
}
function hd(r, e) {
  let t = r.url;
  return (t === void 0 || t.indexOf("data:") === 0) && (t = e.url), t;
}
class XW {
  constructor(e) {
    this.hls = void 0, this.loaders = /* @__PURE__ */ Object.create(null), this.variableList = null, this.onManifestLoaded = this.checkAutostartLoad, this.hls = e, this.registerListeners();
  }
  startLoad(e) {
  }
  stopLoad() {
    this.destroyInternalLoaders();
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e.on(E.MANIFEST_LOADING, this.onManifestLoading, this), e.on(E.LEVEL_LOADING, this.onLevelLoading, this), e.on(E.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), e.on(E.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this), e.on(E.LEVELS_UPDATED, this.onLevelsUpdated, this);
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off(E.MANIFEST_LOADING, this.onManifestLoading, this), e.off(E.LEVEL_LOADING, this.onLevelLoading, this), e.off(E.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), e.off(E.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this), e.off(E.LEVELS_UPDATED, this.onLevelsUpdated, this);
  }
  /**
   * Returns defaults or configured loader-type overloads (pLoader and loader config params)
   */
  createInternalLoader(e) {
    const t = this.hls.config, n = t.pLoader, i = t.loader, s = n || i, a = new s(t);
    return this.loaders[e.type] = a, a;
  }
  getInternalLoader(e) {
    return this.loaders[e.type];
  }
  resetInternalLoader(e) {
    this.loaders[e] && delete this.loaders[e];
  }
  /**
   * Call `destroy` on all internal loader instances mapped (one per context type)
   */
  destroyInternalLoaders() {
    for (const e in this.loaders) {
      const t = this.loaders[e];
      t && t.destroy(), this.resetInternalLoader(e);
    }
  }
  destroy() {
    this.variableList = null, this.unregisterListeners(), this.destroyInternalLoaders();
  }
  onManifestLoading(e, t) {
    const {
      url: n
    } = t;
    this.variableList = null, this.load({
      id: null,
      level: 0,
      responseType: "text",
      type: me.MANIFEST,
      url: n,
      deliveryDirectives: null,
      levelOrTrack: null
    });
  }
  onLevelLoading(e, t) {
    const {
      id: n,
      level: i,
      pathwayId: s,
      url: a,
      deliveryDirectives: o,
      levelInfo: c
    } = t;
    this.load({
      id: n,
      level: i,
      pathwayId: s,
      responseType: "text",
      type: me.LEVEL,
      url: a,
      deliveryDirectives: o,
      levelOrTrack: c
    });
  }
  onAudioTrackLoading(e, t) {
    const {
      id: n,
      groupId: i,
      url: s,
      deliveryDirectives: a,
      track: o
    } = t;
    this.load({
      id: n,
      groupId: i,
      level: null,
      responseType: "text",
      type: me.AUDIO_TRACK,
      url: s,
      deliveryDirectives: a,
      levelOrTrack: o
    });
  }
  onSubtitleTrackLoading(e, t) {
    const {
      id: n,
      groupId: i,
      url: s,
      deliveryDirectives: a,
      track: o
    } = t;
    this.load({
      id: n,
      groupId: i,
      level: null,
      responseType: "text",
      type: me.SUBTITLE_TRACK,
      url: s,
      deliveryDirectives: a,
      levelOrTrack: o
    });
  }
  onLevelsUpdated(e, t) {
    const n = this.loaders[me.LEVEL];
    if (n) {
      const i = n.context;
      i && !t.levels.some((s) => s === i.levelOrTrack) && (n.abort(), delete this.loaders[me.LEVEL]);
    }
  }
  load(e) {
    var t;
    const n = this.hls.config;
    let i = this.getInternalLoader(e);
    if (i) {
      const l = this.hls.logger, u = i.context;
      if (u && u.levelOrTrack === e.levelOrTrack && (u.url === e.url || u.deliveryDirectives && !e.deliveryDirectives)) {
        u.url === e.url ? l.log(`[playlist-loader]: ignore ${e.url} ongoing request`) : l.log(`[playlist-loader]: ignore ${e.url} in favor of ${u.url}`);
        return;
      }
      l.log(`[playlist-loader]: aborting previous loader for type: ${e.type}`), i.abort();
    }
    let s;
    if (e.type === me.MANIFEST ? s = n.manifestLoadPolicy.default : s = Ce({}, n.playlistLoadPolicy.default, {
      timeoutRetry: null,
      errorRetry: null
    }), i = this.createInternalLoader(e), X((t = e.deliveryDirectives) == null ? void 0 : t.part)) {
      let l;
      if (e.type === me.LEVEL && e.level !== null ? l = this.hls.levels[e.level].details : e.type === me.AUDIO_TRACK && e.id !== null ? l = this.hls.audioTracks[e.id].details : e.type === me.SUBTITLE_TRACK && e.id !== null && (l = this.hls.subtitleTracks[e.id].details), l) {
        const u = l.partTarget, d = l.targetduration;
        if (u && d) {
          const f = Math.max(u * 3, d * 0.8) * 1e3;
          s = Ce({}, s, {
            maxTimeToFirstByteMs: Math.min(f, s.maxTimeToFirstByteMs),
            maxLoadTimeMs: Math.min(f, s.maxTimeToFirstByteMs)
          });
        }
      }
    }
    const a = s.errorRetry || s.timeoutRetry || {}, o = {
      loadPolicy: s,
      timeout: s.maxLoadTimeMs,
      maxRetry: a.maxNumRetry || 0,
      retryDelay: a.retryDelayMs || 0,
      maxRetryDelay: a.maxRetryDelayMs || 0
    }, c = {
      onSuccess: (l, u, d, f) => {
        const h = this.getInternalLoader(d);
        this.resetInternalLoader(d.type);
        const g = l.data;
        if (g.indexOf("#EXTM3U") !== 0) {
          this.handleManifestParsingError(l, d, new Error("no EXTM3U delimiter"), f || null, u);
          return;
        }
        u.parsing.start = performance.now(), Nr.isMediaPlaylist(g) || d.type !== me.MANIFEST ? this.handleTrackOrLevelPlaylist(l, u, d, f || null, h) : this.handleMasterPlaylist(l, u, d, f);
      },
      onError: (l, u, d, f) => {
        this.handleNetworkError(u, d, !1, l, f);
      },
      onTimeout: (l, u, d) => {
        this.handleNetworkError(u, d, !0, void 0, l);
      }
    };
    i.load(e, o, c);
  }
  checkAutostartLoad() {
    if (!this.hls)
      return;
    const {
      config: {
        autoStartLoad: e,
        startPosition: t
      },
      forceStartLoad: n
    } = this.hls;
    (e || n) && (this.hls.logger.log(`${e ? "auto" : "force"} startLoad with configured startPosition ${t}`), this.hls.startLoad(t));
  }
  handleMasterPlaylist(e, t, n, i) {
    const s = this.hls, a = e.data, o = hd(e, n), c = Nr.parseMasterPlaylist(a, o);
    if (c.playlistParsingError) {
      this.handleManifestParsingError(e, n, c.playlistParsingError, i, t);
      return;
    }
    const {
      contentSteering: l,
      levels: u,
      sessionData: d,
      sessionKeys: f,
      startTimeOffset: h,
      variableList: g
    } = c;
    this.variableList = g;
    const {
      AUDIO: m = [],
      SUBTITLES: p,
      "CLOSED-CAPTIONS": v
    } = Nr.parseMasterPlaylistMedia(a, o, c);
    m.length && !m.some((b) => !b.url) && u[0].audioCodec && !u[0].attrs.AUDIO && (this.hls.logger.log("[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one"), m.unshift({
      type: "main",
      name: "main",
      groupId: "main",
      default: !1,
      autoselect: !1,
      forced: !1,
      id: -1,
      attrs: new ze({}),
      bitrate: 0,
      url: ""
    })), s.trigger(E.MANIFEST_LOADED, {
      levels: u,
      audioTracks: m,
      subtitles: p,
      captions: v,
      contentSteering: l,
      url: o,
      stats: t,
      networkDetails: i,
      sessionData: d,
      sessionKeys: f,
      startTimeOffset: h,
      variableList: g
    });
  }
  handleTrackOrLevelPlaylist(e, t, n, i, s) {
    const a = this.hls, {
      id: o,
      level: c,
      type: l
    } = n, u = hd(e, n), d = X(c) ? c : X(o) ? o : 0, f = Gb(n), h = Nr.parseLevelPlaylist(e.data, u, d, f, 0, this.variableList);
    if (l === me.MANIFEST) {
      const g = {
        attrs: new ze({}),
        bitrate: 0,
        details: h,
        name: "",
        url: u
      };
      h.requestScheduled = t.loading.start + aw(h, 0), a.trigger(E.MANIFEST_LOADED, {
        levels: [g],
        audioTracks: [],
        url: u,
        stats: t,
        networkDetails: i,
        sessionData: null,
        sessionKeys: null,
        contentSteering: null,
        startTimeOffset: null,
        variableList: null
      });
    }
    t.parsing.end = performance.now(), n.levelDetails = h, this.handlePlaylistLoaded(h, e, t, n, i, s);
  }
  handleManifestParsingError(e, t, n, i, s) {
    this.hls.trigger(E.ERROR, {
      type: ne.NETWORK_ERROR,
      details: k.MANIFEST_PARSING_ERROR,
      fatal: t.type === me.MANIFEST,
      url: e.url,
      err: n,
      error: n,
      reason: n.message,
      response: e,
      context: t,
      networkDetails: i,
      stats: s
    });
  }
  handleNetworkError(e, t, n = !1, i, s) {
    let a = `A network ${n ? "timeout" : "error" + (i ? " (status " + i.code + ")" : "")} occurred while loading ${e.type}`;
    e.type === me.LEVEL ? a += `: ${e.level} id: ${e.id}` : (e.type === me.AUDIO_TRACK || e.type === me.SUBTITLE_TRACK) && (a += ` id: ${e.id} group-id: "${e.groupId}"`);
    const o = new Error(a);
    this.hls.logger.warn(`[playlist-loader]: ${a}`);
    let c = k.UNKNOWN, l = !1;
    const u = this.getInternalLoader(e);
    switch (e.type) {
      case me.MANIFEST:
        c = n ? k.MANIFEST_LOAD_TIMEOUT : k.MANIFEST_LOAD_ERROR, l = !0;
        break;
      case me.LEVEL:
        c = n ? k.LEVEL_LOAD_TIMEOUT : k.LEVEL_LOAD_ERROR, l = !1;
        break;
      case me.AUDIO_TRACK:
        c = n ? k.AUDIO_TRACK_LOAD_TIMEOUT : k.AUDIO_TRACK_LOAD_ERROR, l = !1;
        break;
      case me.SUBTITLE_TRACK:
        c = n ? k.SUBTITLE_TRACK_LOAD_TIMEOUT : k.SUBTITLE_LOAD_ERROR, l = !1;
        break;
    }
    u && this.resetInternalLoader(e.type);
    const d = {
      type: ne.NETWORK_ERROR,
      details: c,
      fatal: l,
      url: e.url,
      loader: u,
      context: e,
      error: o,
      networkDetails: t,
      stats: s
    };
    if (i) {
      const f = (t == null ? void 0 : t.url) || e.url;
      d.response = Ne({
        url: f,
        data: void 0
      }, i);
    }
    this.hls.trigger(E.ERROR, d);
  }
  handlePlaylistLoaded(e, t, n, i, s, a) {
    const o = this.hls, {
      type: c,
      level: l,
      id: u,
      groupId: d,
      deliveryDirectives: f
    } = i, h = hd(t, i), g = Gb(i), m = typeof i.level == "number" && g === ee.MAIN ? l : void 0;
    if (!e.fragments.length) {
      const v = e.playlistParsingError = new Error("No Segments found in Playlist");
      o.trigger(E.ERROR, {
        type: ne.NETWORK_ERROR,
        details: k.LEVEL_EMPTY_ERROR,
        fatal: !1,
        url: h,
        error: v,
        reason: v.message,
        response: t,
        context: i,
        level: m,
        parent: g,
        networkDetails: s,
        stats: n
      });
      return;
    }
    e.targetduration || (e.playlistParsingError = new Error("Missing Target Duration"));
    const p = e.playlistParsingError;
    if (p) {
      if (this.hls.logger.warn(p), !o.config.ignorePlaylistParsingErrors) {
        o.trigger(E.ERROR, {
          type: ne.NETWORK_ERROR,
          details: k.LEVEL_PARSING_ERROR,
          fatal: !1,
          url: h,
          error: p,
          reason: p.message,
          response: t,
          context: i,
          level: m,
          parent: g,
          networkDetails: s,
          stats: n
        });
        return;
      }
      e.playlistParsingError = null;
    }
    switch (e.live && a && (a.getCacheAge && (e.ageHeader = a.getCacheAge() || 0), (!a.getCacheAge || isNaN(e.ageHeader)) && (e.ageHeader = 0)), c) {
      case me.MANIFEST:
      case me.LEVEL:
        o.trigger(E.LEVEL_LOADED, {
          details: e,
          levelInfo: i.levelOrTrack || o.levels[0],
          level: m || 0,
          id: u || 0,
          stats: n,
          networkDetails: s,
          deliveryDirectives: f,
          withoutMultiVariant: c === me.MANIFEST
        });
        break;
      case me.AUDIO_TRACK:
        o.trigger(E.AUDIO_TRACK_LOADED, {
          details: e,
          track: i.levelOrTrack,
          id: u || 0,
          groupId: d || "",
          stats: n,
          networkDetails: s,
          deliveryDirectives: f
        });
        break;
      case me.SUBTITLE_TRACK:
        o.trigger(E.SUBTITLE_TRACK_LOADED, {
          details: e,
          track: i.levelOrTrack,
          id: u || 0,
          groupId: d || "",
          stats: n,
          networkDetails: s,
          deliveryDirectives: f
        });
        break;
    }
  }
}
class Zr {
  /**
   * Get the video-dev/hls.js package version.
   */
  static get version() {
    return na;
  }
  /**
   * Check if the required MediaSource Extensions are available.
   */
  static isMSESupported() {
    return eI();
  }
  /**
   * Check if MediaSource Extensions are available and isTypeSupported checks pass for any baseline codecs.
   */
  static isSupported() {
    return WW();
  }
  /**
   * Get the MediaSource global used for MSE playback (ManagedMediaSource, MediaSource, or WebKitMediaSource).
   */
  static getMediaSource() {
    return Nn();
  }
  static get Events() {
    return E;
  }
  static get MetadataSchema() {
    return Qt;
  }
  static get ErrorTypes() {
    return ne;
  }
  static get ErrorDetails() {
    return k;
  }
  /**
   * Get the default configuration applied to new instances.
   */
  static get DefaultConfig() {
    return Zr.defaultConfig ? Zr.defaultConfig : CW;
  }
  /**
   * Replace the default configuration applied to new instances.
   */
  static set DefaultConfig(e) {
    Zr.defaultConfig = e;
  }
  /**
   * Creates an instance of an HLS client that can attach to exactly one `HTMLMediaElement`.
   * @param userConfig - Configuration options applied over `Hls.DefaultConfig`
   */
  constructor(e = {}) {
    this.config = void 0, this.userConfig = void 0, this.logger = void 0, this.coreComponents = void 0, this.networkControllers = void 0, this._emitter = new Yg(), this._autoLevelCapping = -1, this._maxHdcpLevel = null, this.abrController = void 0, this.bufferController = void 0, this.capLevelController = void 0, this.latencyController = void 0, this.levelController = void 0, this.streamController = void 0, this.audioStreamController = void 0, this.subtititleStreamController = void 0, this.audioTrackController = void 0, this.subtitleTrackController = void 0, this.interstitialsController = void 0, this.gapController = void 0, this.emeController = void 0, this.cmcdController = void 0, this._media = null, this._url = null, this._sessionId = void 0, this.triggeringException = void 0, this.started = !1;
    const t = this.logger = pK(e.debug || !1, "Hls instance", e.assetPlayerId), n = this.config = MW(Zr.DefaultConfig, e, t);
    this.userConfig = e, n.progressive && NW(n, t);
    const {
      abrController: i,
      bufferController: s,
      capLevelController: a,
      errorController: o,
      fpsController: c
    } = n, l = new o(this), u = this.abrController = new i(this), d = new o3(this), f = n.interstitialsController, h = f ? this.interstitialsController = new f(this, Zr) : null, g = this.bufferController = new s(this, d), m = this.capLevelController = new a(this), p = new c(this), v = new XW(this), y = n.contentSteeringController, b = y ? new y(this) : null, x = this.levelController = new VW(this, b), S = new GW(this), A = new YW(this.config), T = this.streamController = new zW(this, d, A), I = this.gapController = new jW(this, d);
    m.setStreamController(T), p.setStreamController(T);
    const L = [v, x, T];
    h && L.splice(1, 0, h), b && L.splice(1, 0, b), this.networkControllers = L;
    const _ = [u, g, I, m, p, S, d];
    this.audioTrackController = this.createController(n.audioTrackController, L);
    const R = n.audioStreamController;
    R && L.push(this.audioStreamController = new R(this, d, A)), this.subtitleTrackController = this.createController(n.subtitleTrackController, L);
    const D = n.subtitleStreamController;
    D && L.push(this.subtititleStreamController = new D(this, d, A)), this.createController(n.timelineController, _), A.emeController = this.emeController = this.createController(n.emeController, _), this.cmcdController = this.createController(n.cmcdController, _), this.latencyController = this.createController(KW, _), this.coreComponents = _, L.push(l);
    const F = l.onErrorOut;
    typeof F == "function" && this.on(E.ERROR, F, l), this.on(E.MANIFEST_LOADED, v.onManifestLoaded, v);
  }
  createController(e, t) {
    if (e) {
      const n = new e(this);
      return t && t.push(n), n;
    }
    return null;
  }
  // Delegate the EventEmitter through the public API of Hls.js
  on(e, t, n = this) {
    this._emitter.on(e, t, n);
  }
  once(e, t, n = this) {
    this._emitter.once(e, t, n);
  }
  removeAllListeners(e) {
    this._emitter.removeAllListeners(e);
  }
  off(e, t, n = this, i) {
    this._emitter.off(e, t, n, i);
  }
  listeners(e) {
    return this._emitter.listeners(e);
  }
  emit(e, t, n) {
    return this._emitter.emit(e, t, n);
  }
  trigger(e, t) {
    if (this.config.debug)
      return this.emit(e, e, t);
    try {
      return this.emit(e, e, t);
    } catch (n) {
      if (this.logger.error("An internal error happened while handling event " + e + '. Error message: "' + n.message + '". Here is a stacktrace:', n), !this.triggeringException) {
        this.triggeringException = !0;
        const i = e === E.ERROR;
        this.trigger(E.ERROR, {
          type: ne.OTHER_ERROR,
          details: k.INTERNAL_EXCEPTION,
          fatal: i,
          event: e,
          error: n
        }), this.triggeringException = !1;
      }
    }
    return !1;
  }
  listenerCount(e) {
    return this._emitter.listenerCount(e);
  }
  /**
   * Dispose of the instance
   */
  destroy() {
    this.logger.log("destroy"), this.trigger(E.DESTROYING, void 0), this.detachMedia(), this.removeAllListeners(), this._autoLevelCapping = -1, this._url = null, this.networkControllers.forEach((t) => t.destroy()), this.networkControllers.length = 0, this.coreComponents.forEach((t) => t.destroy()), this.coreComponents.length = 0;
    const e = this.config;
    e.xhrSetup = e.fetchSetup = void 0, this.userConfig = null;
  }
  /**
   * Attaches Hls.js to a media element
   */
  attachMedia(e) {
    if (!e || "media" in e && !e.media) {
      const s = new Error(`attachMedia failed: invalid argument (${e})`);
      this.trigger(E.ERROR, {
        type: ne.OTHER_ERROR,
        details: k.ATTACH_MEDIA_ERROR,
        fatal: !0,
        error: s
      });
      return;
    }
    this.logger.log("attachMedia"), this._media && (this.logger.warn("media must be detached before attaching"), this.detachMedia());
    const t = "media" in e, n = t ? e.media : e, i = t ? e : {
      media: n
    };
    this._media = n, this.trigger(E.MEDIA_ATTACHING, i);
  }
  /**
   * Detach Hls.js from the media
   */
  detachMedia() {
    this.logger.log("detachMedia"), this.trigger(E.MEDIA_DETACHING, {}), this._media = null;
  }
  /**
   * Detach HTMLMediaElement, MediaSource, and SourceBuffers without reset, for attaching to another instance
   */
  transferMedia() {
    this._media = null;
    const e = this.bufferController.transferMedia();
    return this.trigger(E.MEDIA_DETACHING, {
      transferMedia: e
    }), e;
  }
  /**
   * Set the source URL. Can be relative or absolute.
   */
  loadSource(e) {
    this.stopLoad();
    const t = this.media, n = this._url, i = this._url = Bg.buildAbsoluteURL(self.location.href, e, {
      alwaysNormalize: !0
    });
    this._autoLevelCapping = -1, this._maxHdcpLevel = null, this.logger.log(`loadSource:${i}`), t && n && (n !== i || this.bufferController.hasSourceTypes()) && (this.detachMedia(), this.attachMedia(t)), this.trigger(E.MANIFEST_LOADING, {
      url: e
    });
  }
  /**
   * Gets the currently loaded URL
   */
  get url() {
    return this._url;
  }
  /**
   * Whether or not enough has been buffered to seek to start position or use `media.currentTime` to determine next load position
   */
  get hasEnoughToStart() {
    return this.streamController.hasEnoughToStart;
  }
  /**
   * Get the startPosition set on startLoad(position) or on autostart with config.startPosition
   */
  get startPosition() {
    return this.streamController.startPositionValue;
  }
  /**
   * Start loading data from the stream source.
   * Depending on default config, client starts loading automatically when a source is set.
   *
   * @param startPosition - Set the start position to stream from.
   * Defaults to -1 (None: starts from earliest point)
   */
  startLoad(e = -1, t) {
    this.logger.log(`startLoad(${e + (t ? ", <skip seek to start>" : "")})`), this.started = !0, this.resumeBuffering();
    for (let n = 0; n < this.networkControllers.length && (this.networkControllers[n].startLoad(e, t), !(!this.started || !this.networkControllers)); n++)
      ;
  }
  /**
   * Stop loading of any stream data.
   */
  stopLoad() {
    this.logger.log("stopLoad"), this.started = !1;
    for (let e = 0; e < this.networkControllers.length && (this.networkControllers[e].stopLoad(), !(this.started || !this.networkControllers)); e++)
      ;
  }
  /**
   * Returns whether loading, toggled with `startLoad()` and `stopLoad()`, is active or not`.
   */
  get loadingEnabled() {
    return this.started;
  }
  /**
   * Returns state of fragment loading toggled by calling `pauseBuffering()` and `resumeBuffering()`.
   */
  get bufferingEnabled() {
    return this.streamController.bufferingEnabled;
  }
  /**
   * Resumes stream controller segment loading after `pauseBuffering` has been called.
   */
  resumeBuffering() {
    this.bufferingEnabled || (this.logger.log("resume buffering"), this.networkControllers.forEach((e) => {
      e.resumeBuffering && e.resumeBuffering();
    }));
  }
  /**
   * Prevents stream controller from loading new segments until `resumeBuffering` is called.
   * This allows for media buffering to be paused without interupting playlist loading.
   */
  pauseBuffering() {
    this.bufferingEnabled && (this.logger.log("pause buffering"), this.networkControllers.forEach((e) => {
      e.pauseBuffering && e.pauseBuffering();
    }));
  }
  get inFlightFragments() {
    const e = {
      [ee.MAIN]: this.streamController.inFlightFrag
    };
    return this.audioStreamController && (e[ee.AUDIO] = this.audioStreamController.inFlightFrag), this.subtititleStreamController && (e[ee.SUBTITLE] = this.subtititleStreamController.inFlightFrag), e;
  }
  /**
   * Swap through possible audio codecs in the stream (for example to switch from stereo to 5.1)
   */
  swapAudioCodec() {
    this.logger.log("swapAudioCodec"), this.streamController.swapAudioCodec();
  }
  /**
   * When the media-element fails, this allows to detach and then re-attach it
   * as one call (convenience method).
   *
   * Automatic recovery of media-errors by this process is configurable.
   */
  recoverMediaError() {
    this.logger.log("recoverMediaError");
    const e = this._media, t = e == null ? void 0 : e.currentTime;
    this.detachMedia(), e && (this.attachMedia(e), t && this.startLoad(t));
  }
  removeLevel(e) {
    this.levelController.removeLevel(e);
  }
  /**
   * @returns a UUID for this player instance
   */
  get sessionId() {
    let e = this._sessionId;
    return e || (e = this._sessionId = j8()), e;
  }
  /**
   * @returns an array of levels (variants) sorted by HDCP-LEVEL, RESOLUTION (height), FRAME-RATE, CODECS, VIDEO-RANGE, and BANDWIDTH
   */
  get levels() {
    const e = this.levelController.levels;
    return e || [];
  }
  /**
   * @returns LevelDetails of last loaded level (variant) or `null` prior to loading a media playlist.
   */
  get latestLevelDetails() {
    return this.streamController.getLevelDetails() || null;
  }
  /**
   * @returns Level object of selected level (variant) or `null` prior to selecting a level or once the level is removed.
   */
  get loadLevelObj() {
    return this.levelController.loadLevelObj;
  }
  /**
   * Index of quality level (variant) currently played
   */
  get currentLevel() {
    return this.streamController.currentLevel;
  }
  /**
   * Set quality level index immediately. This will flush the current buffer to replace the quality asap. That means playback will interrupt at least shortly to re-buffer and re-sync eventually. Set to -1 for automatic level selection.
   */
  set currentLevel(e) {
    this.logger.log(`set currentLevel:${e}`), this.levelController.manualLevel = e, this.streamController.immediateLevelSwitch();
  }
  /**
   * Index of next quality level loaded as scheduled by stream controller.
   */
  get nextLevel() {
    return this.streamController.nextLevel;
  }
  /**
   * Set quality level index for next loaded data.
   * This will switch the video quality asap, without interrupting playback.
   * May abort current loading of data, and flush parts of buffer (outside currently played fragment region).
   * @param newLevel - Pass -1 for automatic level selection
   */
  set nextLevel(e) {
    this.logger.log(`set nextLevel:${e}`), this.levelController.manualLevel = e, this.streamController.nextLevelSwitch();
  }
  /**
   * Return the quality level of the currently or last (of none is loaded currently) segment
   */
  get loadLevel() {
    return this.levelController.level;
  }
  /**
   * Set quality level index for next loaded data in a conservative way.
   * This will switch the quality without flushing, but interrupt current loading.
   * Thus the moment when the quality switch will appear in effect will only be after the already existing buffer.
   * @param newLevel - Pass -1 for automatic level selection
   */
  set loadLevel(e) {
    this.logger.log(`set loadLevel:${e}`), this.levelController.manualLevel = e;
  }
  /**
   * get next quality level loaded
   */
  get nextLoadLevel() {
    return this.levelController.nextLoadLevel;
  }
  /**
   * Set quality level of next loaded segment in a fully "non-destructive" way.
   * Same as `loadLevel` but will wait for next switch (until current loading is done).
   */
  set nextLoadLevel(e) {
    this.levelController.nextLoadLevel = e;
  }
  /**
   * Return "first level": like a default level, if not set,
   * falls back to index of first level referenced in manifest
   */
  get firstLevel() {
    return Math.max(this.levelController.firstLevel, this.minAutoLevel);
  }
  /**
   * Sets "first-level", see getter.
   */
  set firstLevel(e) {
    this.logger.log(`set firstLevel:${e}`), this.levelController.firstLevel = e;
  }
  /**
   * Return the desired start level for the first fragment that will be loaded.
   * The default value of -1 indicates automatic start level selection.
   * Setting hls.nextAutoLevel without setting a startLevel will result in
   * the nextAutoLevel value being used for one fragment load.
   */
  get startLevel() {
    const e = this.levelController.startLevel;
    return e === -1 && this.abrController.forcedAutoLevel > -1 ? this.abrController.forcedAutoLevel : e;
  }
  /**
   * set  start level (level of first fragment that will be played back)
   * if not overrided by user, first level appearing in manifest will be used as start level
   * if -1 : automatic start level selection, playback will start from level matching download bandwidth
   * (determined from download of first segment)
   */
  set startLevel(e) {
    this.logger.log(`set startLevel:${e}`), e !== -1 && (e = Math.max(e, this.minAutoLevel)), this.levelController.startLevel = e;
  }
  /**
   * Whether level capping is enabled.
   * Default value is set via `config.capLevelToPlayerSize`.
   */
  get capLevelToPlayerSize() {
    return this.config.capLevelToPlayerSize;
  }
  /**
   * Enables or disables level capping. If disabled after previously enabled, `nextLevelSwitch` will be immediately called.
   */
  set capLevelToPlayerSize(e) {
    const t = !!e;
    t !== this.config.capLevelToPlayerSize && (t ? this.capLevelController.startCapping() : (this.capLevelController.stopCapping(), this.autoLevelCapping = -1, this.streamController.nextLevelSwitch()), this.config.capLevelToPlayerSize = t);
  }
  /**
   * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)
   */
  get autoLevelCapping() {
    return this._autoLevelCapping;
  }
  /**
   * Returns the current bandwidth estimate in bits per second, when available. Otherwise, `NaN` is returned.
   */
  get bandwidthEstimate() {
    const {
      bwEstimator: e
    } = this.abrController;
    return e ? e.getEstimate() : NaN;
  }
  set bandwidthEstimate(e) {
    this.abrController.resetEstimator(e);
  }
  get abrEwmaDefaultEstimate() {
    const {
      bwEstimator: e
    } = this.abrController;
    return e ? e.defaultEstimate : NaN;
  }
  /**
   * get time to first byte estimate
   * @type {number}
   */
  get ttfbEstimate() {
    const {
      bwEstimator: e
    } = this.abrController;
    return e ? e.getEstimateTTFB() : NaN;
  }
  /**
   * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)
   */
  set autoLevelCapping(e) {
    this._autoLevelCapping !== e && (this.logger.log(`set autoLevelCapping:${e}`), this._autoLevelCapping = e, this.levelController.checkMaxAutoUpdated());
  }
  get maxHdcpLevel() {
    return this._maxHdcpLevel;
  }
  set maxHdcpLevel(e) {
    WK(e) && this._maxHdcpLevel !== e && (this._maxHdcpLevel = e, this.levelController.checkMaxAutoUpdated());
  }
  /**
   * True when automatic level selection enabled
   */
  get autoLevelEnabled() {
    return this.levelController.manualLevel === -1;
  }
  /**
   * Level set manually (if any)
   */
  get manualLevel() {
    return this.levelController.manualLevel;
  }
  /**
   * min level selectable in auto mode according to config.minAutoBitrate
   */
  get minAutoLevel() {
    const {
      levels: e,
      config: {
        minAutoBitrate: t
      }
    } = this;
    if (!e) return 0;
    const n = e.length;
    for (let i = 0; i < n; i++)
      if (e[i].maxBitrate >= t)
        return i;
    return 0;
  }
  /**
   * max level selectable in auto mode according to autoLevelCapping
   */
  get maxAutoLevel() {
    const {
      levels: e,
      autoLevelCapping: t,
      maxHdcpLevel: n
    } = this;
    let i;
    if (t === -1 && e != null && e.length ? i = e.length - 1 : i = t, n)
      for (let s = i; s--; ) {
        const a = e[s].attrs["HDCP-LEVEL"];
        if (a && a <= n)
          return s;
      }
    return i;
  }
  get firstAutoLevel() {
    return this.abrController.firstAutoLevel;
  }
  /**
   * next automatically selected quality level
   */
  get nextAutoLevel() {
    return this.abrController.nextAutoLevel;
  }
  /**
   * this setter is used to force next auto level.
   * this is useful to force a switch down in auto mode:
   * in case of load error on level N, hls.js can set nextAutoLevel to N-1 for example)
   * forced value is valid for one fragment. upon successful frag loading at forced level,
   * this value will be resetted to -1 by ABR controller.
   */
  set nextAutoLevel(e) {
    this.abrController.nextAutoLevel = e;
  }
  /**
   * get the datetime value relative to media.currentTime for the active level Program Date Time if present
   */
  get playingDate() {
    return this.streamController.currentProgramDateTime;
  }
  get mainForwardBufferInfo() {
    return this.streamController.getMainFwdBufferInfo();
  }
  get maxBufferLength() {
    return this.streamController.maxBufferLength;
  }
  /**
   * Find and select the best matching audio track, making a level switch when a Group change is necessary.
   * Updates `hls.config.audioPreference`. Returns the selected track, or null when no matching track is found.
   */
  setAudioOption(e) {
    var t;
    return ((t = this.audioTrackController) == null ? void 0 : t.setAudioOption(e)) || null;
  }
  /**
   * Find and select the best matching subtitle track, making a level switch when a Group change is necessary.
   * Updates `hls.config.subtitlePreference`. Returns the selected track, or null when no matching track is found.
   */
  setSubtitleOption(e) {
    var t;
    return ((t = this.subtitleTrackController) == null ? void 0 : t.setSubtitleOption(e)) || null;
  }
  /**
   * Get the complete list of audio tracks across all media groups
   */
  get allAudioTracks() {
    const e = this.audioTrackController;
    return e ? e.allAudioTracks : [];
  }
  /**
   * Get the list of selectable audio tracks
   */
  get audioTracks() {
    const e = this.audioTrackController;
    return e ? e.audioTracks : [];
  }
  /**
   * index of the selected audio track (index in audio track lists)
   */
  get audioTrack() {
    const e = this.audioTrackController;
    return e ? e.audioTrack : -1;
  }
  /**
   * selects an audio track, based on its index in audio track lists
   */
  set audioTrack(e) {
    const t = this.audioTrackController;
    t && (t.audioTrack = e);
  }
  /**
   * get the complete list of subtitle tracks across all media groups
   */
  get allSubtitleTracks() {
    const e = this.subtitleTrackController;
    return e ? e.allSubtitleTracks : [];
  }
  /**
   * get alternate subtitle tracks list from playlist
   */
  get subtitleTracks() {
    const e = this.subtitleTrackController;
    return e ? e.subtitleTracks : [];
  }
  /**
   * index of the selected subtitle track (index in subtitle track lists)
   */
  get subtitleTrack() {
    const e = this.subtitleTrackController;
    return e ? e.subtitleTrack : -1;
  }
  get media() {
    return this._media;
  }
  /**
   * select an subtitle track, based on its index in subtitle track lists
   */
  set subtitleTrack(e) {
    const t = this.subtitleTrackController;
    t && (t.subtitleTrack = e);
  }
  /**
   * Whether subtitle display is enabled or not
   */
  get subtitleDisplay() {
    const e = this.subtitleTrackController;
    return e ? e.subtitleDisplay : !1;
  }
  /**
   * Enable/disable subtitle display rendering
   */
  set subtitleDisplay(e) {
    const t = this.subtitleTrackController;
    t && (t.subtitleDisplay = e);
  }
  /**
   * get mode for Low-Latency HLS loading
   */
  get lowLatencyMode() {
    return this.config.lowLatencyMode;
  }
  /**
   * Enable/disable Low-Latency HLS part playlist and segment loading, and start live streams at playlist PART-HOLD-BACK rather than HOLD-BACK.
   */
  set lowLatencyMode(e) {
    this.config.lowLatencyMode = e;
  }
  /**
   * Position (in seconds) of live sync point (ie edge of live position minus safety delay defined by ```hls.config.liveSyncDuration```)
   * @returns null prior to loading live Playlist
   */
  get liveSyncPosition() {
    return this.latencyController.liveSyncPosition;
  }
  /**
   * Estimated position (in seconds) of live edge (ie edge of live playlist plus time sync playlist advanced)
   * @returns 0 before first playlist is loaded
   */
  get latency() {
    return this.latencyController.latency;
  }
  /**
   * maximum distance from the edge before the player seeks forward to ```hls.liveSyncPosition```
   * configured using ```liveMaxLatencyDurationCount``` (multiple of target duration) or ```liveMaxLatencyDuration```
   * @returns 0 before first playlist is loaded
   */
  get maxLatency() {
    return this.latencyController.maxLatency;
  }
  /**
   * target distance from the edge as calculated by the latency controller
   */
  get targetLatency() {
    return this.latencyController.targetLatency;
  }
  set targetLatency(e) {
    this.latencyController.targetLatency = e;
  }
  /**
   * the rate at which the edge of the current live playlist is advancing or 1 if there is none
   */
  get drift() {
    return this.latencyController.drift;
  }
  /**
   * set to true when startLoad is called before MANIFEST_PARSED event
   */
  get forceStartLoad() {
    return this.streamController.forceStartLoad;
  }
  /**
   * ContentSteering pathways getter
   */
  get pathways() {
    return this.levelController.pathways;
  }
  /**
   * ContentSteering pathwayPriority getter/setter
   */
  get pathwayPriority() {
    return this.levelController.pathwayPriority;
  }
  set pathwayPriority(e) {
    this.levelController.pathwayPriority = e;
  }
  /**
   * returns true when all SourceBuffers are buffered to the end
   */
  get bufferedToEnd() {
    var e;
    return !!((e = this.bufferController) != null && e.bufferedToEnd);
  }
  /**
   * returns Interstitials Program Manager
   */
  get interstitialsManager() {
    var e;
    return ((e = this.interstitialsController) == null ? void 0 : e.interstitialsManager) || null;
  }
  /**
   * returns mediaCapabilities.decodingInfo for a variant/rendition
   */
  getMediaDecodingInfo(e, t = this.allAudioTracks) {
    const n = YA(t);
    return qA(e, n, navigator.mediaCapabilities);
  }
}
Zr.defaultConfig = void 0;
function St(r, e, t, n) {
  return new (t || (t = Promise))(function(i, s) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (u) {
        s(u);
      }
    }
    function o(l) {
      try {
        c(n.throw(l));
      } catch (u) {
        s(u);
      }
    }
    function c(l) {
      var u;
      l.done ? i(l.value) : (u = l.value, u instanceof t ? u : new t(function(d) {
        d(u);
      })).then(a, o);
    }
    c((n = n.apply(r, e || [])).next());
  });
}
class La {
  constructor() {
    this.listeners = {};
  }
  on(e, t, n) {
    if (this.listeners[e] || (this.listeners[e] = /* @__PURE__ */ new Set()), this.listeners[e].add(t), n == null ? void 0 : n.once) {
      const i = () => {
        this.un(e, i), this.un(e, t);
      };
      return this.on(e, i), i;
    }
    return () => this.un(e, t);
  }
  un(e, t) {
    var n;
    (n = this.listeners[e]) === null || n === void 0 || n.delete(t);
  }
  once(e, t) {
    return this.on(e, t, { once: !0 });
  }
  unAll() {
    this.listeners = {};
  }
  emit(e, ...t) {
    this.listeners[e] && this.listeners[e].forEach((n) => n(...t));
  }
}
const ho = { decode: function(r, e) {
  return St(this, void 0, void 0, function* () {
    const t = new AudioContext({ sampleRate: e });
    return t.decodeAudioData(r).finally(() => t.close());
  });
}, createBuffer: function(r, e) {
  return typeof r[0] == "number" && (r = [r]), function(t) {
    const n = t[0];
    if (n.some((i) => i > 1 || i < -1)) {
      const i = n.length;
      let s = 0;
      for (let a = 0; a < i; a++) {
        const o = Math.abs(n[a]);
        o > s && (s = o);
      }
      for (const a of t) for (let o = 0; o < i; o++) a[o] /= s;
    }
  }(r), { duration: e, length: r[0].length, sampleRate: r[0].length / e, numberOfChannels: r.length, getChannelData: (t) => r == null ? void 0 : r[t], copyFromChannel: AudioBuffer.prototype.copyFromChannel, copyToChannel: AudioBuffer.prototype.copyToChannel };
} };
function tI(r, e) {
  const t = e.xmlns ? document.createElementNS(e.xmlns, r) : document.createElement(r);
  for (const [n, i] of Object.entries(e)) if (n === "children" && i) for (const [s, a] of Object.entries(i)) a instanceof Node ? t.appendChild(a) : typeof a == "string" ? t.appendChild(document.createTextNode(a)) : t.appendChild(tI(s, a));
  else n === "style" ? Object.assign(t.style, i) : n === "textContent" ? t.textContent = i : t.setAttribute(n, i.toString());
  return t;
}
function Kb(r, e, t) {
  const n = tI(r, e || {});
  return t == null || t.appendChild(n), n;
}
var QW = Object.freeze({ __proto__: null, createElement: Kb, default: Kb });
const ZW = { fetchBlob: function(r, e, t) {
  return St(this, void 0, void 0, function* () {
    const n = yield fetch(r, t);
    if (n.status >= 400) throw new Error(`Failed to fetch ${r}: ${n.status} (${n.statusText})`);
    return function(i, s) {
      St(this, void 0, void 0, function* () {
        if (!i.body || !i.headers) return;
        const a = i.body.getReader(), o = Number(i.headers.get("Content-Length")) || 0;
        let c = 0;
        const l = (d) => St(this, void 0, void 0, function* () {
          c += (d == null ? void 0 : d.length) || 0;
          const f = Math.round(c / o * 100);
          s(f);
        }), u = () => St(this, void 0, void 0, function* () {
          let d;
          try {
            d = yield a.read();
          } catch {
            return;
          }
          d.done || (l(d.value), yield u());
        });
        u();
      });
    }(n.clone(), e), n.blob();
  });
} };
class JW extends La {
  constructor(e) {
    super(), this.isExternalMedia = !1, e.media ? (this.media = e.media, this.isExternalMedia = !0) : this.media = document.createElement("audio"), e.mediaControls && (this.media.controls = !0), e.autoplay && (this.media.autoplay = !0), e.playbackRate != null && this.onMediaEvent("canplay", () => {
      e.playbackRate != null && (this.media.playbackRate = e.playbackRate);
    }, { once: !0 });
  }
  onMediaEvent(e, t, n) {
    return this.media.addEventListener(e, t, n), () => this.media.removeEventListener(e, t, n);
  }
  getSrc() {
    return this.media.currentSrc || this.media.src || "";
  }
  revokeSrc() {
    const e = this.getSrc();
    e.startsWith("blob:") && URL.revokeObjectURL(e);
  }
  canPlayType(e) {
    return this.media.canPlayType(e) !== "";
  }
  setSrc(e, t) {
    const n = this.getSrc();
    if (e && n === e) return;
    this.revokeSrc();
    const i = t instanceof Blob && (this.canPlayType(t.type) || !e) ? URL.createObjectURL(t) : e;
    if (n && this.media.removeAttribute("src"), i || e) try {
      this.media.src = i;
    } catch {
      this.media.src = e;
    }
  }
  destroy() {
    this.isExternalMedia || (this.media.pause(), this.media.remove(), this.revokeSrc(), this.media.removeAttribute("src"), this.media.load());
  }
  setMediaElement(e) {
    this.media = e;
  }
  play() {
    return St(this, void 0, void 0, function* () {
      return this.media.play();
    });
  }
  pause() {
    this.media.pause();
  }
  isPlaying() {
    return !this.media.paused && !this.media.ended;
  }
  setTime(e) {
    this.media.currentTime = Math.max(0, Math.min(e, this.getDuration()));
  }
  getDuration() {
    return this.media.duration;
  }
  getCurrentTime() {
    return this.media.currentTime;
  }
  getVolume() {
    return this.media.volume;
  }
  setVolume(e) {
    this.media.volume = e;
  }
  getMuted() {
    return this.media.muted;
  }
  setMuted(e) {
    this.media.muted = e;
  }
  getPlaybackRate() {
    return this.media.playbackRate;
  }
  isSeeking() {
    return this.media.seeking;
  }
  setPlaybackRate(e, t) {
    t != null && (this.media.preservesPitch = t), this.media.playbackRate = e;
  }
  getMediaElement() {
    return this.media;
  }
  setSinkId(e) {
    return this.media.setSinkId(e);
  }
}
class rs extends La {
  constructor(e, t) {
    super(), this.timeouts = [], this.isScrollable = !1, this.audioData = null, this.resizeObserver = null, this.lastContainerWidth = 0, this.isDragging = !1, this.subscriptions = [], this.unsubscribeOnScroll = [], this.subscriptions = [], this.options = e;
    const n = this.parentFromOptionsContainer(e.container);
    this.parent = n;
    const [i, s] = this.initHtml();
    n.appendChild(i), this.container = i, this.scrollContainer = s.querySelector(".scroll"), this.wrapper = s.querySelector(".wrapper"), this.canvasWrapper = s.querySelector(".canvases"), this.progressWrapper = s.querySelector(".progress"), this.cursor = s.querySelector(".cursor"), t && s.appendChild(t), this.initEvents();
  }
  parentFromOptionsContainer(e) {
    let t;
    if (typeof e == "string" ? t = document.querySelector(e) : e instanceof HTMLElement && (t = e), !t) throw new Error("Container not found");
    return t;
  }
  initEvents() {
    const e = (t) => {
      const n = this.wrapper.getBoundingClientRect(), i = t.clientX - n.left, s = t.clientY - n.top;
      return [i / n.width, s / n.height];
    };
    if (this.wrapper.addEventListener("click", (t) => {
      const [n, i] = e(t);
      this.emit("click", n, i);
    }), this.wrapper.addEventListener("dblclick", (t) => {
      const [n, i] = e(t);
      this.emit("dblclick", n, i);
    }), this.options.dragToSeek !== !0 && typeof this.options.dragToSeek != "object" || this.initDrag(), this.scrollContainer.addEventListener("scroll", () => {
      const { scrollLeft: t, scrollWidth: n, clientWidth: i } = this.scrollContainer, s = t / n, a = (t + i) / n;
      this.emit("scroll", s, a, t, t + i);
    }), typeof ResizeObserver == "function") {
      const t = this.createDelay(100);
      this.resizeObserver = new ResizeObserver(() => {
        t().then(() => this.onContainerResize()).catch(() => {
        });
      }), this.resizeObserver.observe(this.scrollContainer);
    }
  }
  onContainerResize() {
    const e = this.parent.clientWidth;
    e === this.lastContainerWidth && this.options.height !== "auto" || (this.lastContainerWidth = e, this.reRender());
  }
  initDrag() {
    this.subscriptions.push(function(e, t, n, i, s = 3, a = 0, o = 100) {
      if (!e) return () => {
      };
      const c = matchMedia("(pointer: coarse)").matches;
      let l = () => {
      };
      const u = (d) => {
        if (d.button !== a) return;
        d.preventDefault(), d.stopPropagation();
        let f = d.clientX, h = d.clientY, g = !1;
        const m = Date.now(), p = (S) => {
          if (S.preventDefault(), S.stopPropagation(), c && Date.now() - m < o) return;
          const A = S.clientX, T = S.clientY, I = A - f, L = T - h;
          if (g || Math.abs(I) > s || Math.abs(L) > s) {
            const _ = e.getBoundingClientRect(), { left: R, top: D } = _;
            g || (n == null || n(f - R, h - D), g = !0), t(I, L, A - R, T - D), f = A, h = T;
          }
        }, v = (S) => {
          if (g) {
            const A = S.clientX, T = S.clientY, I = e.getBoundingClientRect(), { left: L, top: _ } = I;
            i == null || i(A - L, T - _);
          }
          l();
        }, y = (S) => {
          S.relatedTarget && S.relatedTarget !== document.documentElement || v(S);
        }, b = (S) => {
          g && (S.stopPropagation(), S.preventDefault());
        }, x = (S) => {
          g && S.preventDefault();
        };
        document.addEventListener("pointermove", p), document.addEventListener("pointerup", v), document.addEventListener("pointerout", y), document.addEventListener("pointercancel", y), document.addEventListener("touchmove", x, { passive: !1 }), document.addEventListener("click", b, { capture: !0 }), l = () => {
          document.removeEventListener("pointermove", p), document.removeEventListener("pointerup", v), document.removeEventListener("pointerout", y), document.removeEventListener("pointercancel", y), document.removeEventListener("touchmove", x), setTimeout(() => {
            document.removeEventListener("click", b, { capture: !0 });
          }, 10);
        };
      };
      return e.addEventListener("pointerdown", u), () => {
        l(), e.removeEventListener("pointerdown", u);
      };
    }(this.wrapper, (e, t, n) => {
      this.emit("drag", Math.max(0, Math.min(1, n / this.wrapper.getBoundingClientRect().width)));
    }, (e) => {
      this.isDragging = !0, this.emit("dragstart", Math.max(0, Math.min(1, e / this.wrapper.getBoundingClientRect().width)));
    }, (e) => {
      this.isDragging = !1, this.emit("dragend", Math.max(0, Math.min(1, e / this.wrapper.getBoundingClientRect().width)));
    }));
  }
  getHeight(e, t) {
    var n;
    const i = ((n = this.audioData) === null || n === void 0 ? void 0 : n.numberOfChannels) || 1;
    if (e == null) return 128;
    if (!isNaN(Number(e))) return Number(e);
    if (e === "auto") {
      const s = this.parent.clientHeight || 128;
      return t != null && t.every((a) => !a.overlay) ? s / i : s;
    }
    return 128;
  }
  initHtml() {
    const e = document.createElement("div"), t = e.attachShadow({ mode: "open" }), n = this.options.cspNonce && typeof this.options.cspNonce == "string" ? this.options.cspNonce.replace(/"/g, "") : "";
    return t.innerHTML = `
      <style${n ? ` nonce="${n}"` : ""}>
        :host {
          user-select: none;
          min-width: 1px;
        }
        :host audio {
          display: block;
          width: 100%;
        }
        :host .scroll {
          overflow-x: auto;
          overflow-y: hidden;
          width: 100%;
          position: relative;
        }
        :host .noScrollbar {
          scrollbar-color: transparent;
          scrollbar-width: none;
        }
        :host .noScrollbar::-webkit-scrollbar {
          display: none;
          -webkit-appearance: none;
        }
        :host .wrapper {
          position: relative;
          overflow: visible;
          z-index: 2;
        }
        :host .canvases {
          min-height: ${this.getHeight(this.options.height, this.options.splitChannels)}px;
        }
        :host .canvases > div {
          position: relative;
        }
        :host canvas {
          display: block;
          position: absolute;
          top: 0;
          image-rendering: pixelated;
        }
        :host .progress {
          pointer-events: none;
          position: absolute;
          z-index: 2;
          top: 0;
          left: 0;
          width: 0;
          height: 100%;
          overflow: hidden;
        }
        :host .progress > div {
          position: relative;
        }
        :host .cursor {
          pointer-events: none;
          position: absolute;
          z-index: 5;
          top: 0;
          left: 0;
          height: 100%;
          border-radius: 2px;
        }
      </style>

      <div class="scroll" part="scroll">
        <div class="wrapper" part="wrapper">
          <div class="canvases" part="canvases"></div>
          <div class="progress" part="progress"></div>
          <div class="cursor" part="cursor"></div>
        </div>
      </div>
    `, [e, t];
  }
  setOptions(e) {
    if (this.options.container !== e.container) {
      const t = this.parentFromOptionsContainer(e.container);
      t.appendChild(this.container), this.parent = t;
    }
    e.dragToSeek !== !0 && typeof this.options.dragToSeek != "object" || this.initDrag(), this.options = e, this.reRender();
  }
  getWrapper() {
    return this.wrapper;
  }
  getWidth() {
    return this.scrollContainer.clientWidth;
  }
  getScroll() {
    return this.scrollContainer.scrollLeft;
  }
  setScroll(e) {
    this.scrollContainer.scrollLeft = e;
  }
  setScrollPercentage(e) {
    const { scrollWidth: t } = this.scrollContainer, n = t * e;
    this.setScroll(n);
  }
  destroy() {
    var e, t;
    this.subscriptions.forEach((n) => n()), this.container.remove(), (e = this.resizeObserver) === null || e === void 0 || e.disconnect(), (t = this.unsubscribeOnScroll) === null || t === void 0 || t.forEach((n) => n()), this.unsubscribeOnScroll = [];
  }
  createDelay(e = 10) {
    let t, n;
    const i = () => {
      t && clearTimeout(t), n && n();
    };
    return this.timeouts.push(i), () => new Promise((s, a) => {
      i(), n = a, t = setTimeout(() => {
        t = void 0, n = void 0, s();
      }, e);
    });
  }
  convertColorValues(e) {
    if (!Array.isArray(e)) return e || "";
    if (e.length < 2) return e[0] || "";
    const t = document.createElement("canvas"), n = t.getContext("2d"), i = t.height * (window.devicePixelRatio || 1), s = n.createLinearGradient(0, 0, 0, i), a = 1 / (e.length - 1);
    return e.forEach((o, c) => {
      const l = c * a;
      s.addColorStop(l, o);
    }), s;
  }
  getPixelRatio() {
    return Math.max(1, window.devicePixelRatio || 1);
  }
  renderBarWaveform(e, t, n, i) {
    const s = e[0], a = e[1] || e[0], o = s.length, { width: c, height: l } = n.canvas, u = l / 2, d = this.getPixelRatio(), f = t.barWidth ? t.barWidth * d : 1, h = t.barGap ? t.barGap * d : t.barWidth ? f / 2 : 0, g = t.barRadius || 0, m = c / (f + h) / o, p = g && "roundRect" in n ? "roundRect" : "rect";
    n.beginPath();
    let v = 0, y = 0, b = 0;
    for (let x = 0; x <= o; x++) {
      const S = Math.round(x * m);
      if (S > v) {
        const I = Math.round(y * u * i), L = I + Math.round(b * u * i) || 1;
        let _ = u - I;
        t.barAlign === "top" ? _ = 0 : t.barAlign === "bottom" && (_ = l - L), n[p](v * (f + h), _, f, L, g), v = S, y = 0, b = 0;
      }
      const A = Math.abs(s[x] || 0), T = Math.abs(a[x] || 0);
      A > y && (y = A), T > b && (b = T);
    }
    n.fill(), n.closePath();
  }
  renderLineWaveform(e, t, n, i) {
    const s = (a) => {
      const o = e[a] || e[0], c = o.length, { height: l } = n.canvas, u = l / 2, d = n.canvas.width / c;
      n.moveTo(0, u);
      let f = 0, h = 0;
      for (let g = 0; g <= c; g++) {
        const m = Math.round(g * d);
        if (m > f) {
          const v = u + (Math.round(h * u * i) || 1) * (a === 0 ? -1 : 1);
          n.lineTo(f, v), f = m, h = 0;
        }
        const p = Math.abs(o[g] || 0);
        p > h && (h = p);
      }
      n.lineTo(f, u);
    };
    n.beginPath(), s(0), s(1), n.fill(), n.closePath();
  }
  renderWaveform(e, t, n) {
    if (n.fillStyle = this.convertColorValues(t.waveColor), t.renderFunction) return void t.renderFunction(e, n);
    let i = t.barHeight || 1;
    if (t.normalize) {
      const s = Array.from(e[0]).reduce((a, o) => Math.max(a, Math.abs(o)), 0);
      i = s ? 1 / s : 1;
    }
    t.barWidth || t.barGap || t.barAlign ? this.renderBarWaveform(e, t, n, i) : this.renderLineWaveform(e, t, n, i);
  }
  renderSingleCanvas(e, t, n, i, s, a, o) {
    const c = this.getPixelRatio(), l = document.createElement("canvas");
    l.width = Math.round(n * c), l.height = Math.round(i * c), l.style.width = `${n}px`, l.style.height = `${i}px`, l.style.left = `${Math.round(s)}px`, a.appendChild(l);
    const u = l.getContext("2d");
    if (this.renderWaveform(e, t, u), l.width > 0 && l.height > 0) {
      const d = l.cloneNode(), f = d.getContext("2d");
      f.drawImage(l, 0, 0), f.globalCompositeOperation = "source-in", f.fillStyle = this.convertColorValues(t.progressColor), f.fillRect(0, 0, l.width, l.height), o.appendChild(d);
    }
  }
  renderMultiCanvas(e, t, n, i, s, a) {
    const o = this.getPixelRatio(), { clientWidth: c } = this.scrollContainer, l = n / o;
    let u = Math.min(rs.MAX_CANVAS_WIDTH, c, l), d = {};
    if (t.barWidth || t.barGap) {
      const p = t.barWidth || 0.5, v = p + (t.barGap || p / 2);
      u % v != 0 && (u = Math.floor(u / v) * v);
    }
    if (u === 0) return;
    const f = (p) => {
      if (p < 0 || p >= h || d[p]) return;
      d[p] = !0;
      const v = p * u;
      let y = Math.min(l - v, u);
      if (t.barWidth || t.barGap) {
        const x = t.barWidth || 0.5, S = x + (t.barGap || x / 2);
        y = Math.floor(y / S) * S;
      }
      if (y <= 0) return;
      const b = e.map((x) => {
        const S = Math.floor(v / l * x.length), A = Math.floor((v + y) / l * x.length);
        return x.slice(S, A);
      });
      this.renderSingleCanvas(b, t, y, i, v, s, a);
    }, h = Math.ceil(l / u);
    if (!this.isScrollable) {
      for (let p = 0; p < h; p++) f(p);
      return;
    }
    const g = this.scrollContainer.scrollLeft / l, m = Math.floor(g * h);
    if (f(m - 1), f(m), f(m + 1), h > 1) {
      const p = this.on("scroll", () => {
        const { scrollLeft: v } = this.scrollContainer, y = Math.floor(v / l * h);
        Object.keys(d).length > rs.MAX_NODES && (s.innerHTML = "", a.innerHTML = "", d = {}), f(y - 1), f(y), f(y + 1);
      });
      this.unsubscribeOnScroll.push(p);
    }
  }
  renderChannel(e, t, n, i) {
    var { overlay: s } = t, a = function(u, d) {
      var f = {};
      for (var h in u) Object.prototype.hasOwnProperty.call(u, h) && d.indexOf(h) < 0 && (f[h] = u[h]);
      if (u != null && typeof Object.getOwnPropertySymbols == "function") {
        var g = 0;
        for (h = Object.getOwnPropertySymbols(u); g < h.length; g++) d.indexOf(h[g]) < 0 && Object.prototype.propertyIsEnumerable.call(u, h[g]) && (f[h[g]] = u[h[g]]);
      }
      return f;
    }(t, ["overlay"]);
    const o = document.createElement("div"), c = this.getHeight(a.height, a.splitChannels);
    o.style.height = `${c}px`, s && i > 0 && (o.style.marginTop = `-${c}px`), this.canvasWrapper.style.minHeight = `${c}px`, this.canvasWrapper.appendChild(o);
    const l = o.cloneNode();
    this.progressWrapper.appendChild(l), this.renderMultiCanvas(e, a, n, c, o, l);
  }
  render(e) {
    return St(this, void 0, void 0, function* () {
      var t;
      this.timeouts.forEach((c) => c()), this.timeouts = [], this.canvasWrapper.innerHTML = "", this.progressWrapper.innerHTML = "", this.options.width != null && (this.scrollContainer.style.width = typeof this.options.width == "number" ? `${this.options.width}px` : this.options.width);
      const n = this.getPixelRatio(), i = this.scrollContainer.clientWidth, s = Math.ceil(e.duration * (this.options.minPxPerSec || 0));
      this.isScrollable = s > i;
      const a = this.options.fillParent && !this.isScrollable, o = (a ? i : s) * n;
      if (this.wrapper.style.width = a ? "100%" : `${s}px`, this.scrollContainer.style.overflowX = this.isScrollable ? "auto" : "hidden", this.scrollContainer.classList.toggle("noScrollbar", !!this.options.hideScrollbar), this.cursor.style.backgroundColor = `${this.options.cursorColor || this.options.progressColor}`, this.cursor.style.width = `${this.options.cursorWidth}px`, this.audioData = e, this.emit("render"), this.options.splitChannels) for (let c = 0; c < e.numberOfChannels; c++) {
        const l = Object.assign(Object.assign({}, this.options), (t = this.options.splitChannels) === null || t === void 0 ? void 0 : t[c]);
        this.renderChannel([e.getChannelData(c)], l, o, c);
      }
      else {
        const c = [e.getChannelData(0)];
        e.numberOfChannels > 1 && c.push(e.getChannelData(1)), this.renderChannel(c, this.options, o, 0);
      }
      Promise.resolve().then(() => this.emit("rendered"));
    });
  }
  reRender() {
    if (this.unsubscribeOnScroll.forEach((n) => n()), this.unsubscribeOnScroll = [], !this.audioData) return;
    const { scrollWidth: e } = this.scrollContainer, { right: t } = this.progressWrapper.getBoundingClientRect();
    if (this.render(this.audioData), this.isScrollable && e !== this.scrollContainer.scrollWidth) {
      const { right: n } = this.progressWrapper.getBoundingClientRect();
      let i = n - t;
      i *= 2, i = i < 0 ? Math.floor(i) : Math.ceil(i), i /= 2, this.scrollContainer.scrollLeft += i;
    }
  }
  zoom(e) {
    this.options.minPxPerSec = e, this.reRender();
  }
  scrollIntoView(e, t = !1) {
    const { scrollLeft: n, scrollWidth: i, clientWidth: s } = this.scrollContainer, a = e * i, o = n, c = n + s, l = s / 2;
    if (this.isDragging)
      a + 30 > c ? this.scrollContainer.scrollLeft += 30 : a - 30 < o && (this.scrollContainer.scrollLeft -= 30);
    else {
      (a < o || a > c) && (this.scrollContainer.scrollLeft = a - (this.options.autoCenter ? l : 0));
      const u = a - n - l;
      t && this.options.autoCenter && u > 0 && (this.scrollContainer.scrollLeft += Math.min(u, 10));
    }
    {
      const u = this.scrollContainer.scrollLeft, d = u / i, f = (u + s) / i;
      this.emit("scroll", d, f, u, u + s);
    }
  }
  renderProgress(e, t) {
    if (isNaN(e)) return;
    const n = 100 * e;
    this.canvasWrapper.style.clipPath = `polygon(${n}% 0%, 100% 0%, 100% 100%, ${n}% 100%)`, this.progressWrapper.style.width = `${n}%`, this.cursor.style.left = `${n}%`, this.cursor.style.transform = `translateX(-${Math.round(n) === 100 ? this.options.cursorWidth : 0}px)`, this.isScrollable && this.options.autoScroll && this.scrollIntoView(e, t);
  }
  exportImage(e, t, n) {
    return St(this, void 0, void 0, function* () {
      const i = this.canvasWrapper.querySelectorAll("canvas");
      if (!i.length) throw new Error("No waveform data");
      if (n === "dataURL") {
        const s = Array.from(i).map((a) => a.toDataURL(e, t));
        return Promise.resolve(s);
      }
      return Promise.all(Array.from(i).map((s) => new Promise((a, o) => {
        s.toBlob((c) => {
          c ? a(c) : o(new Error("Could not export image"));
        }, e, t);
      })));
    });
  }
}
rs.MAX_CANVAS_WIDTH = 8e3, rs.MAX_NODES = 10;
class e4 extends La {
  constructor() {
    super(...arguments), this.unsubscribe = () => {
    };
  }
  start() {
    this.unsubscribe = this.on("tick", () => {
      requestAnimationFrame(() => {
        this.emit("tick");
      });
    }), this.emit("tick");
  }
  stop() {
    this.unsubscribe();
  }
  destroy() {
    this.unsubscribe();
  }
}
class gd extends La {
  constructor(e = new AudioContext()) {
    super(), this.bufferNode = null, this.playStartTime = 0, this.playedDuration = 0, this._muted = !1, this._playbackRate = 1, this._duration = void 0, this.buffer = null, this.currentSrc = "", this.paused = !0, this.crossOrigin = null, this.seeking = !1, this.autoplay = !1, this.addEventListener = this.on, this.removeEventListener = this.un, this.audioContext = e, this.gainNode = this.audioContext.createGain(), this.gainNode.connect(this.audioContext.destination);
  }
  load() {
    return St(this, void 0, void 0, function* () {
    });
  }
  get src() {
    return this.currentSrc;
  }
  set src(e) {
    if (this.currentSrc = e, this._duration = void 0, !e) return this.buffer = null, void this.emit("emptied");
    fetch(e).then((t) => {
      if (t.status >= 400) throw new Error(`Failed to fetch ${e}: ${t.status} (${t.statusText})`);
      return t.arrayBuffer();
    }).then((t) => this.currentSrc !== e ? null : this.audioContext.decodeAudioData(t)).then((t) => {
      this.currentSrc === e && (this.buffer = t, this.emit("loadedmetadata"), this.emit("canplay"), this.autoplay && this.play());
    });
  }
  _play() {
    var e;
    if (!this.paused) return;
    this.paused = !1, (e = this.bufferNode) === null || e === void 0 || e.disconnect(), this.bufferNode = this.audioContext.createBufferSource(), this.buffer && (this.bufferNode.buffer = this.buffer), this.bufferNode.playbackRate.value = this._playbackRate, this.bufferNode.connect(this.gainNode);
    let t = this.playedDuration * this._playbackRate;
    (t >= this.duration || t < 0) && (t = 0, this.playedDuration = 0), this.bufferNode.start(this.audioContext.currentTime, t), this.playStartTime = this.audioContext.currentTime, this.bufferNode.onended = () => {
      this.currentTime >= this.duration && (this.pause(), this.emit("ended"));
    };
  }
  _pause() {
    var e;
    this.paused = !0, (e = this.bufferNode) === null || e === void 0 || e.stop(), this.playedDuration += this.audioContext.currentTime - this.playStartTime;
  }
  play() {
    return St(this, void 0, void 0, function* () {
      this.paused && (this._play(), this.emit("play"));
    });
  }
  pause() {
    this.paused || (this._pause(), this.emit("pause"));
  }
  stopAt(e) {
    const t = e - this.currentTime, n = this.bufferNode;
    n == null || n.stop(this.audioContext.currentTime + t), n == null || n.addEventListener("ended", () => {
      n === this.bufferNode && (this.bufferNode = null, this.pause());
    }, { once: !0 });
  }
  setSinkId(e) {
    return St(this, void 0, void 0, function* () {
      return this.audioContext.setSinkId(e);
    });
  }
  get playbackRate() {
    return this._playbackRate;
  }
  set playbackRate(e) {
    this._playbackRate = e, this.bufferNode && (this.bufferNode.playbackRate.value = e);
  }
  get currentTime() {
    return (this.paused ? this.playedDuration : this.playedDuration + (this.audioContext.currentTime - this.playStartTime)) * this._playbackRate;
  }
  set currentTime(e) {
    const t = !this.paused;
    t && this._pause(), this.playedDuration = e / this._playbackRate, t && this._play(), this.emit("seeking"), this.emit("timeupdate");
  }
  get duration() {
    var e, t;
    return (e = this._duration) !== null && e !== void 0 ? e : ((t = this.buffer) === null || t === void 0 ? void 0 : t.duration) || 0;
  }
  set duration(e) {
    this._duration = e;
  }
  get volume() {
    return this.gainNode.gain.value;
  }
  set volume(e) {
    this.gainNode.gain.value = e, this.emit("volumechange");
  }
  get muted() {
    return this._muted;
  }
  set muted(e) {
    this._muted !== e && (this._muted = e, this._muted ? this.gainNode.disconnect() : this.gainNode.connect(this.audioContext.destination));
  }
  canPlayType(e) {
    return /^(audio|video)\//.test(e);
  }
  getGainNode() {
    return this.gainNode;
  }
  getChannelData() {
    const e = [];
    if (!this.buffer) return e;
    const t = this.buffer.numberOfChannels;
    for (let n = 0; n < t; n++) e.push(this.buffer.getChannelData(n));
    return e;
  }
}
const t4 = { waveColor: "#999", progressColor: "#555", cursorWidth: 1, minPxPerSec: 0, fillParent: !0, interact: !0, dragToSeek: !1, autoScroll: !0, autoCenter: !0, sampleRate: 8e3 };
class oa extends JW {
  static create(e) {
    return new oa(e);
  }
  constructor(e) {
    const t = e.media || (e.backend === "WebAudio" ? new gd() : void 0);
    super({ media: t, mediaControls: e.mediaControls, autoplay: e.autoplay, playbackRate: e.audioRate }), this.plugins = [], this.decodedData = null, this.stopAtPosition = null, this.subscriptions = [], this.mediaSubscriptions = [], this.abortController = null, this.options = Object.assign({}, t4, e), this.timer = new e4();
    const n = t ? void 0 : this.getMediaElement();
    this.renderer = new rs(this.options, n), this.initPlayerEvents(), this.initRendererEvents(), this.initTimerEvents(), this.initPlugins();
    const i = this.options.url || this.getSrc() || "";
    Promise.resolve().then(() => {
      this.emit("init");
      const { peaks: s, duration: a } = this.options;
      (i || s && a) && this.load(i, s, a).catch(() => null);
    });
  }
  updateProgress(e = this.getCurrentTime()) {
    return this.renderer.renderProgress(e / this.getDuration(), this.isPlaying()), e;
  }
  initTimerEvents() {
    this.subscriptions.push(this.timer.on("tick", () => {
      if (!this.isSeeking()) {
        const e = this.updateProgress();
        this.emit("timeupdate", e), this.emit("audioprocess", e), this.stopAtPosition != null && this.isPlaying() && e >= this.stopAtPosition && this.pause();
      }
    }));
  }
  initPlayerEvents() {
    this.isPlaying() && (this.emit("play"), this.timer.start()), this.mediaSubscriptions.push(this.onMediaEvent("timeupdate", () => {
      const e = this.updateProgress();
      this.emit("timeupdate", e);
    }), this.onMediaEvent("play", () => {
      this.emit("play"), this.timer.start();
    }), this.onMediaEvent("pause", () => {
      this.emit("pause"), this.timer.stop(), this.stopAtPosition = null;
    }), this.onMediaEvent("emptied", () => {
      this.timer.stop(), this.stopAtPosition = null;
    }), this.onMediaEvent("ended", () => {
      this.emit("timeupdate", this.getDuration()), this.emit("finish"), this.stopAtPosition = null;
    }), this.onMediaEvent("seeking", () => {
      this.emit("seeking", this.getCurrentTime());
    }), this.onMediaEvent("error", () => {
      var e;
      this.emit("error", (e = this.getMediaElement().error) !== null && e !== void 0 ? e : new Error("Media error")), this.stopAtPosition = null;
    }));
  }
  initRendererEvents() {
    this.subscriptions.push(this.renderer.on("click", (e, t) => {
      this.options.interact && (this.seekTo(e), this.emit("interaction", e * this.getDuration()), this.emit("click", e, t));
    }), this.renderer.on("dblclick", (e, t) => {
      this.emit("dblclick", e, t);
    }), this.renderer.on("scroll", (e, t, n, i) => {
      const s = this.getDuration();
      this.emit("scroll", e * s, t * s, n, i);
    }), this.renderer.on("render", () => {
      this.emit("redraw");
    }), this.renderer.on("rendered", () => {
      this.emit("redrawcomplete");
    }), this.renderer.on("dragstart", (e) => {
      this.emit("dragstart", e);
    }), this.renderer.on("dragend", (e) => {
      this.emit("dragend", e);
    }));
    {
      let e;
      this.subscriptions.push(this.renderer.on("drag", (t) => {
        if (!this.options.interact) return;
        let n;
        this.renderer.renderProgress(t), clearTimeout(e), this.isPlaying() ? n = 0 : this.options.dragToSeek === !0 ? n = 200 : typeof this.options.dragToSeek == "object" && this.options.dragToSeek !== void 0 && (n = this.options.dragToSeek.debounceTime), e = setTimeout(() => {
          this.seekTo(t);
        }, n), this.emit("interaction", t * this.getDuration()), this.emit("drag", t);
      }));
    }
  }
  initPlugins() {
    var e;
    !((e = this.options.plugins) === null || e === void 0) && e.length && this.options.plugins.forEach((t) => {
      this.registerPlugin(t);
    });
  }
  unsubscribePlayerEvents() {
    this.mediaSubscriptions.forEach((e) => e()), this.mediaSubscriptions = [];
  }
  setOptions(e) {
    this.options = Object.assign({}, this.options, e), e.duration && !e.peaks && (this.decodedData = ho.createBuffer(this.exportPeaks(), e.duration)), e.peaks && e.duration && (this.decodedData = ho.createBuffer(e.peaks, e.duration)), this.renderer.setOptions(this.options), e.audioRate && this.setPlaybackRate(e.audioRate), e.mediaControls != null && (this.getMediaElement().controls = e.mediaControls);
  }
  registerPlugin(e) {
    e._init(this), this.plugins.push(e);
    const t = e.once("destroy", () => {
      this.plugins = this.plugins.filter((n) => n !== e), this.subscriptions = this.subscriptions.filter((n) => n !== t);
    });
    return this.subscriptions.push(t), e;
  }
  getWrapper() {
    return this.renderer.getWrapper();
  }
  getWidth() {
    return this.renderer.getWidth();
  }
  getScroll() {
    return this.renderer.getScroll();
  }
  setScroll(e) {
    return this.renderer.setScroll(e);
  }
  setScrollTime(e) {
    const t = e / this.getDuration();
    this.renderer.setScrollPercentage(t);
  }
  getActivePlugins() {
    return this.plugins;
  }
  loadAudio(e, t, n, i) {
    return St(this, void 0, void 0, function* () {
      var s;
      if (this.emit("load", e), !this.options.media && this.isPlaying() && this.pause(), this.decodedData = null, this.stopAtPosition = null, !t && !n) {
        const o = this.options.fetchParams || {};
        window.AbortController && !o.signal && (this.abortController = new AbortController(), o.signal = (s = this.abortController) === null || s === void 0 ? void 0 : s.signal);
        const c = (u) => this.emit("loading", u);
        t = yield ZW.fetchBlob(e, c, o);
        const l = this.options.blobMimeType;
        l && (t = new Blob([t], { type: l }));
      }
      this.setSrc(e, t);
      const a = yield new Promise((o) => {
        const c = i || this.getDuration();
        c ? o(c) : this.mediaSubscriptions.push(this.onMediaEvent("loadedmetadata", () => o(this.getDuration()), { once: !0 }));
      });
      if (!e && !t) {
        const o = this.getMediaElement();
        o instanceof gd && (o.duration = a);
      }
      if (n) this.decodedData = ho.createBuffer(n, a || 0);
      else if (t) {
        const o = yield t.arrayBuffer();
        this.decodedData = yield ho.decode(o, this.options.sampleRate);
      }
      this.decodedData && (this.emit("decode", this.getDuration()), this.renderer.render(this.decodedData)), this.emit("ready", this.getDuration());
    });
  }
  load(e, t, n) {
    return St(this, void 0, void 0, function* () {
      try {
        return yield this.loadAudio(e, void 0, t, n);
      } catch (i) {
        throw this.emit("error", i), i;
      }
    });
  }
  loadBlob(e, t, n) {
    return St(this, void 0, void 0, function* () {
      try {
        return yield this.loadAudio("", e, t, n);
      } catch (i) {
        throw this.emit("error", i), i;
      }
    });
  }
  zoom(e) {
    if (!this.decodedData) throw new Error("No audio loaded");
    this.renderer.zoom(e), this.emit("zoom", e);
  }
  getDecodedData() {
    return this.decodedData;
  }
  exportPeaks({ channels: e = 2, maxLength: t = 8e3, precision: n = 1e4 } = {}) {
    if (!this.decodedData) throw new Error("The audio has not been decoded yet");
    const i = Math.min(e, this.decodedData.numberOfChannels), s = [];
    for (let a = 0; a < i; a++) {
      const o = this.decodedData.getChannelData(a), c = [], l = o.length / t;
      for (let u = 0; u < t; u++) {
        const d = o.slice(Math.floor(u * l), Math.ceil((u + 1) * l));
        let f = 0;
        for (let h = 0; h < d.length; h++) {
          const g = d[h];
          Math.abs(g) > Math.abs(f) && (f = g);
        }
        c.push(Math.round(f * n) / n);
      }
      s.push(c);
    }
    return s;
  }
  getDuration() {
    let e = super.getDuration() || 0;
    return e !== 0 && e !== 1 / 0 || !this.decodedData || (e = this.decodedData.duration), e;
  }
  toggleInteraction(e) {
    this.options.interact = e;
  }
  setTime(e) {
    this.stopAtPosition = null, super.setTime(e), this.updateProgress(e), this.emit("timeupdate", e);
  }
  seekTo(e) {
    const t = this.getDuration() * e;
    this.setTime(t);
  }
  play(e, t) {
    const n = Object.create(null, { play: { get: () => super.play } });
    return St(this, void 0, void 0, function* () {
      e != null && this.setTime(e);
      const i = yield n.play.call(this);
      return t != null && (this.media instanceof gd ? this.media.stopAt(t) : this.stopAtPosition = t), i;
    });
  }
  playPause() {
    return St(this, void 0, void 0, function* () {
      return this.isPlaying() ? this.pause() : this.play();
    });
  }
  stop() {
    this.pause(), this.setTime(0);
  }
  skip(e) {
    this.setTime(this.getCurrentTime() + e);
  }
  empty() {
    this.load("", [[0]], 1e-3);
  }
  setMediaElement(e) {
    this.unsubscribePlayerEvents(), super.setMediaElement(e), this.initPlayerEvents();
  }
  exportImage() {
    return St(this, arguments, void 0, function* (e = "image/png", t = 1, n = "dataURL") {
      return this.renderer.exportImage(e, t, n);
    });
  }
  destroy() {
    var e;
    this.emit("destroy"), (e = this.abortController) === null || e === void 0 || e.abort(), this.plugins.forEach((t) => t.destroy()), this.subscriptions.forEach((t) => t()), this.unsubscribePlayerEvents(), this.timer.destroy(), this.renderer.destroy(), super.destroy();
  }
}
oa.BasePlugin = class extends La {
  constructor(r) {
    super(), this.subscriptions = [], this.options = r;
  }
  onInit() {
  }
  _init(r) {
    this.wavesurfer = r, this.onInit();
  }
  destroy() {
    this.emit("destroy"), this.subscriptions.forEach((r) => r());
  }
}, oa.dom = QW;
const C4 = ({ media: r }) => {
  const e = Ke(null), t = Ke(null), n = Ke(null), [i, s] = _e(0);
  we(() => {
    if (r.type === "audio" && e.current) {
      t.current && t.current.destroy(), t.current = oa.create({
        container: e.current,
        waveColor: "violet",
        progressColor: "purple",
        barWidth: 2,
        cursorWidth: 1,
        height: 100
      }), t.current.load(r.src);
      const o = document.createElement("button");
      for (o.innerText = "Play/Pause", o.onclick = () => {
        var c;
        return (c = t.current) == null ? void 0 : c.playPause();
      }; e.current.firstChild; )
        e.current.removeChild(e.current.firstChild);
      return e.current.appendChild(o), () => {
        var c;
        (c = t.current) == null || c.destroy();
      };
    } else if (r.type === "video" && n.current && Zr.isSupported()) {
      const o = new Zr();
      o.loadSource(r.src), o.attachMedia(n.current);
    }
  }, [r.src, r.type]);
  const a = () => {
    var o, c;
    switch (r.type) {
      case "video":
        return /* @__PURE__ */ P.jsx("video", { ref: n, src: r.src, controls: !0, className: "w-full" });
      case "audio":
        return /* @__PURE__ */ P.jsx("div", { ref: e });
      case "presentation":
        return /* @__PURE__ */ P.jsxs("div", { children: [
          /* @__PURE__ */ P.jsx("img", { src: (o = r.slides) == null ? void 0 : o[i], alt: `Slide ${i + 1}` }),
          /* @__PURE__ */ P.jsxs("div", { className: "flex justify-between mt-2", children: [
            /* @__PURE__ */ P.jsx(
              xe,
              {
                onClick: () => s((l) => Math.max(0, l - 1)),
                disabled: i === 0,
                children: "Previous"
              }
            ),
            /* @__PURE__ */ P.jsx(
              xe,
              {
                onClick: () => s((l) => {
                  var u;
                  return Math.min(((u = r.slides) == null ? void 0 : u.length) || -1, l + 1);
                }),
                disabled: i === (((c = r.slides) == null ? void 0 : c.length) || 0) - 1,
                children: "Next"
              }
            )
          ] })
        ] });
      default:
        return null;
    }
  };
  return /* @__PURE__ */ P.jsxs(br, { children: [
    r.title && /* @__PURE__ */ P.jsx("h3", { className: "text-lg font-bold", children: r.title }),
    a(),
    r.description && /* @__PURE__ */ P.jsx("p", { className: "mt-2", children: r.description })
  ] });
}, k4 = ({
  notification: r,
  context: e = "neutral",
  compact: t = !1
}) => /* @__PURE__ */ P.jsxs(
  br,
  {
    className: `notification-card--${e} notification-card--${r.type} ${t ? "notification-card--compact" : ""}`,
    children: [
      /* @__PURE__ */ P.jsx("div", { className: "font-bold", children: r.title }),
      /* @__PURE__ */ P.jsx("div", { children: r.message })
    ]
  }
), M4 = ({
  title: r,
  status: e,
  statusHistory: t = [],
  context: n = "neutral",
  showHistory: i = !1,
  showActions: s = !1,
  onStatusChange: a,
  onActionClick: o,
  permissions: c = [],
  size: l = "md"
}) => /* @__PURE__ */ P.jsxs(
  br,
  {
    className: `status-card--${n} status-card--${l}`,
    children: [
      /* @__PURE__ */ P.jsxs("div", { className: "flex items-center justify-between", children: [
        /* @__PURE__ */ P.jsx("div", { className: "text-lg font-bold", children: r }),
        /* @__PURE__ */ P.jsx(
          "div",
          {
            className: "w-4 h-4 rounded-full",
            style: { backgroundColor: e.color }
          }
        )
      ] }),
      /* @__PURE__ */ P.jsx("div", { className: "mt-2", children: e.name }),
      i && /* @__PURE__ */ P.jsxs("div", { className: "mt-4", children: [
        /* @__PURE__ */ P.jsx("h4", { className: "font-bold", children: "History" }),
        t.map((u) => /* @__PURE__ */ P.jsx("div", { children: u.name }, u.id))
      ] }),
      s && /* @__PURE__ */ P.jsx("div", { className: "mt-4", children: c.includes("change_status") && /* @__PURE__ */ P.jsx(xe, { onClick: () => a == null ? void 0 : a(e), children: "Change Status" }) })
    ]
  }
), N4 = ({
  user: r,
  context: e = "neutral",
  showPresence: t = !1,
  showStatus: n = !1,
  showActions: i = !1,
  onUserClick: s,
  onActionClick: a,
  permissions: o = [],
  size: c = "md",
  layout: l = "vertical"
}) => {
  const u = (f) => {
    a && a(f, r);
  }, d = o.includes("view_role");
  return /* @__PURE__ */ P.jsxs(
    br,
    {
      className: `user-card--${e} user-card--${c} user-card--${l}`,
      onClick: () => s == null ? void 0 : s(r),
      children: [
        /* @__PURE__ */ P.jsxs("div", { className: "flex items-center", children: [
          /* @__PURE__ */ P.jsx(ml, { src: r.avatarUrl, alt: r.name }),
          t && r.status && /* @__PURE__ */ P.jsx(TI, { status: r.status }),
          /* @__PURE__ */ P.jsxs("div", { className: "ml-4", children: [
            /* @__PURE__ */ P.jsx("div", { className: "text-lg font-bold", children: r.name }),
            n && r.role && d && /* @__PURE__ */ P.jsx(AI, { children: r.role })
          ] })
        ] }),
        i && /* @__PURE__ */ P.jsxs("div", { className: "mt-4", children: [
          o.includes("edit") && /* @__PURE__ */ P.jsx(xe, { onClick: () => u("edit"), children: "Edit" }),
          o.includes("delete") && /* @__PURE__ */ P.jsx(xe, { onClick: () => u("delete"), variant: "danger", children: "Delete" })
        ] })
      ]
    }
  );
}, F4 = ({
  actions: r,
  context: e = "neutral",
  trigger: t,
  align: n = "center",
  onActionClick: i,
  onMenuOpen: s,
  onMenuClose: a,
  permissions: o = [],
  showSuggestions: c = !1,
  actionHistory: l = []
}) => {
  const [u, d] = Ct.useState(l), f = (v) => v.permission ? o.includes(v.permission) : !0, h = (v) => v.workspaceContext ? v.workspaceContext.includes(e) : !0, g = r.filter(
    (v) => f(v) && h(v)
  ), m = c ? g.filter((v) => {
    var y;
    return (y = v.metadata) == null ? void 0 : y.suggested;
  }) : [], p = (v) => {
    i && i(v), v.onClick(), d((y) => [v, ...y].slice(0, 5));
  };
  return /* @__PURE__ */ P.jsxs(Cf, { onOpenChange: (v) => v ? s == null ? void 0 : s() : a == null ? void 0 : a(), children: [
    /* @__PURE__ */ P.jsx(kf, { asChild: !0, children: t || /* @__PURE__ */ P.jsx(xe, { variant: "ghost", children: "Open Menu" }) }),
    /* @__PURE__ */ P.jsxs(Mf, { align: n, children: [
      m.length > 0 && /* @__PURE__ */ P.jsxs(P.Fragment, { children: [
        m.map((v) => /* @__PURE__ */ P.jsxs(
          Dn,
          {
            disabled: v.disabled,
            onSelect: () => p(v),
            children: [
              /* @__PURE__ */ P.jsx(er, { name: "Star", className: "mr-2" }),
              v.label
            ]
          },
          `suggested-${v.id}`
        )),
        /* @__PURE__ */ P.jsx("hr", { className: "my-1" })
      ] }),
      g.map((v) => /* @__PURE__ */ P.jsxs(
        Dn,
        {
          disabled: v.disabled,
          onSelect: () => p(v),
          children: [
            v.icon && /* @__PURE__ */ P.jsx(er, { name: v.icon, className: "mr-2" }),
            v.label
          ]
        },
        v.id
      ))
    ] })
  ] });
}, $4 = ({
  actions: r,
  context: e = "neutral",
  orientation: t = "horizontal",
  size: n = "md",
  variant: i = "primary",
  onActionClick: s,
  permissions: a = [],
  maxVisible: o,
  showOverflow: c = !0,
  hasBulkActions: l = !1,
  responsive: u = !1
}) => {
  const [d, f] = Ct.useState([]), h = (x) => {
    f(
      (S) => S.includes(x) ? S.filter((A) => A !== x) : [...S, x]
    );
  }, g = (x) => x.permission ? a.includes(x.permission) : !0, m = (x) => x.workspaceContext ? x.workspaceContext.includes(e) : !0, p = r.filter(
    (x) => g(x) && m(x)
  ), v = o && c ? p.slice(0, o) : p, y = o && c ? p.slice(o) : [], b = (x) => {
    s && s(x), x.onClick();
  };
  return /* @__PURE__ */ P.jsxs(
    "div",
    {
      className: Hb(
        "inline-flex",
        t === "vertical" ? "flex-col" : "flex-row",
        u && "flex-wrap",
        "items-center"
      ),
      children: [
        l && /* @__PURE__ */ P.jsx("div", { className: "p-2", children: /* @__PURE__ */ P.jsx(
          "input",
          {
            type: "checkbox",
            onChange: (x) => f(
              x.target.checked ? v.map((S) => S.id) : []
            )
          }
        ) }),
        v.map((x) => /* @__PURE__ */ P.jsxs(
          xe,
          {
            variant: x.variant || i,
            size: n,
            disabled: x.disabled || l && d.length === 0,
            onClick: () => b(x),
            className: "first:rounded-l-md last:rounded-r-md",
            children: [
              l && /* @__PURE__ */ P.jsx(
                "input",
                {
                  type: "checkbox",
                  className: "mr-2",
                  checked: d.includes(x.id),
                  onChange: () => h(x.id)
                }
              ),
              x.icon && /* @__PURE__ */ P.jsx(er, { name: x.icon, className: "mr-2" }),
              x.label
            ]
          },
          x.id
        )),
        y.length > 0 && // Overflow menu will be implemented later
        /* @__PURE__ */ P.jsx(xe, { variant: i, size: n, className: "rounded-r-md", children: "..." })
      ]
    }
  );
}, B4 = ({
  tools: r,
  context: e = "neutral",
  layout: t = "horizontal",
  onToolClick: n,
  permissions: i = [],
  customizable: s = !1,
  onLayoutChange: a,
  persistent: o = !1,
  responsive: c = !1
}) => {
  const [l, u] = Ct.useState(() => o && localStorage.getItem("toolbar-layout") || t), d = (v) => {
    u(v), a && a(v), o && localStorage.setItem("toolbar-layout", v);
  }, f = (v) => v.permission ? i.includes(v.permission) : !0, h = (v) => v.workspaceContext ? v.workspaceContext.includes(e) : !0, m = r.filter(
    (v) => f(v) && h(v)
  ).reduce((v, y) => {
    const b = y.group || "default";
    return v[b] || (v[b] = []), v[b].push(y), v;
  }, {}), p = (v) => {
    n && n(v), v.onClick();
  };
  return /* @__PURE__ */ P.jsxs(
    "div",
    {
      className: Hb(
        "flex p-1 bg-gray-100 rounded-md",
        l === "vertical" ? "flex-col" : "flex-row",
        l === "grid" && "grid grid-cols-4",
        c && "flex-wrap",
        "gap-1"
      ),
      children: [
        s && /* @__PURE__ */ P.jsxs("div", { className: "flex items-center", children: [
          /* @__PURE__ */ P.jsx(xe, { variant: "ghost", size: "sm", onClick: () => d("horizontal"), children: "H" }),
          /* @__PURE__ */ P.jsx(xe, { variant: "ghost", size: "sm", onClick: () => d("vertical"), children: "V" }),
          /* @__PURE__ */ P.jsx(xe, { variant: "ghost", size: "sm", onClick: () => d("grid"), children: "G" })
        ] }),
        Object.entries(m).map(([v, y]) => /* @__PURE__ */ P.jsx("div", { className: "flex items-center", children: y.map((b) => /* @__PURE__ */ P.jsx(
          xe,
          {
            variant: "ghost",
            size: "sm",
            disabled: b.disabled,
            onClick: () => p(b),
            "aria-label": b.label,
            children: b.icon && /* @__PURE__ */ P.jsx(er, { name: b.icon })
          },
          b.id
        )) }, v))
      ]
    }
  );
}, j4 = ({
  onInvoiceGenerate: r,
  onPaymentProcess: e,
  onReportGenerate: t,
  showAnalytics: n = !1
}) => {
  const i = () => {
    r({
      id: "1",
      amount: 1e3,
      currency: "USD",
      dueDate: /* @__PURE__ */ new Date()
    });
  }, s = () => {
    e({
      id: "1",
      amount: 1e3,
      currency: "USD",
      date: /* @__PURE__ */ new Date()
    });
  };
  return /* @__PURE__ */ P.jsxs("div", { className: "flex space-x-2", children: [
    /* @__PURE__ */ P.jsx(xe, { onClick: i, children: "Generate Invoice" }),
    /* @__PURE__ */ P.jsx(xe, { onClick: s, children: "Process Payment" }),
    /* @__PURE__ */ P.jsx(xe, { onClick: () => t("billing"), children: "Generate Billing Report" }),
    n && /* @__PURE__ */ P.jsxs("div", { className: "mt-4", children: [
      /* @__PURE__ */ P.jsx("h3", { className: "text-lg font-bold", children: "Revenue Analytics" }),
      /* @__PURE__ */ P.jsx("p", { children: "Total Revenue: $10,000" }),
      /* @__PURE__ */ P.jsx("p", { children: "Monthly Recurring Revenue: $2,000" })
    ] })
  ] });
}, U4 = ({
  clients: r,
  selectedClient: e,
  onClientSelect: t,
  onClientCreate: n,
  showRecent: i = !1,
  maxRecent: s = 5,
  filters: a = [],
  onFilterChange: o,
  showFilters: c = !1,
  permissions: l = []
}) => {
  const [u, d] = Ct.useState([]), f = (m) => {
    t(m), d(
      (p) => [m, ...p.filter((v) => v.id !== m.id)].slice(0, s)
    );
  }, h = (m) => l.includes(m), g = r.filter((m) => a.length === 0 ? !0 : a.some((p) => p.isActive));
  return /* @__PURE__ */ P.jsxs(Cf, { children: [
    /* @__PURE__ */ P.jsx(kf, { asChild: !0, children: /* @__PURE__ */ P.jsxs(xe, { variant: "ghost", children: [
      /* @__PURE__ */ P.jsx(er, { name: "User", className: "mr-2" }),
      e ? e.name : "Select Client",
      /* @__PURE__ */ P.jsx(er, { name: "ChevronDown", className: "ml-2" })
    ] }) }),
    /* @__PURE__ */ P.jsxs(Mf, { children: [
      i && u.length > 0 && /* @__PURE__ */ P.jsxs(P.Fragment, { children: [
        /* @__PURE__ */ P.jsx("div", { className: "p-2 text-xs text-gray-500", children: "Recent" }),
        u.map((m) => /* @__PURE__ */ P.jsx(
          Dn,
          {
            onSelect: () => f(m),
            children: m.name
          },
          `recent-${m.id}`
        )),
        /* @__PURE__ */ P.jsx("hr", { className: "my-1" })
      ] }),
      c && /* @__PURE__ */ P.jsx("div", { className: "p-2", children: a.map((m) => /* @__PURE__ */ P.jsxs("div", { className: "flex items-center", children: [
        /* @__PURE__ */ P.jsx(
          "input",
          {
            type: "checkbox",
            checked: m.isActive,
            onChange: () => {
              const p = a.map(
                (v) => v.id === m.id ? { ...v, isActive: !v.isActive } : v
              );
              o == null || o(p);
            }
          }
        ),
        /* @__PURE__ */ P.jsx("span", { className: "ml-2", children: m.label })
      ] }, m.id)) }),
      g.map((m) => /* @__PURE__ */ P.jsx(
        Dn,
        {
          onSelect: () => f(m),
          children: m.name
        },
        m.id
      )),
      n && h("create-client") && /* @__PURE__ */ P.jsxs(P.Fragment, { children: [
        /* @__PURE__ */ P.jsx("hr", { className: "my-1" }),
        /* @__PURE__ */ P.jsxs(Dn, { onSelect: n, children: [
          /* @__PURE__ */ P.jsx(er, { name: "Plus", className: "mr-2" }),
          "Create Client"
        ] })
      ] })
    ] })
  ] });
}, G4 = ({
  onSessionStart: r,
  onSessionStop: e,
  onSessionPause: t,
  onTimeEntry: n,
  projects: i,
  showHistory: s = !1
}) => {
  const [a, o] = _e(!1), [c, l] = _e(0), [u, d] = _e(null), [f, h] = _e([]);
  we(() => {
    let b = null;
    return a ? b = setInterval(() => {
      l((x) => x + 1);
    }, 1e3) : !a && c !== 0 && b && clearInterval(b), () => {
      b && clearInterval(b);
    };
  }, [a, c]);
  const g = () => {
    o(!0), d(/* @__PURE__ */ new Date()), r(i[0]);
  }, m = (b) => !(b.endTime.getTime() - b.startTime.getTime() < 1e3), p = () => {
    if (o(!1), u) {
      const b = {
        id: (/* @__PURE__ */ new Date()).toISOString(),
        startTime: u,
        endTime: /* @__PURE__ */ new Date(),
        project: i[0]
      };
      m(b) ? (n(b), h((x) => [b, ...x])) : alert("Invalid time entry");
    }
    e();
  }, v = () => {
    o(!1), t();
  }, y = (b) => {
    const x = Math.floor(b / 3600), S = Math.floor(b % 3600 / 60), A = b % 60;
    return `${String(x).padStart(2, "0")}:${String(S).padStart(
      2,
      "0"
    )}:${String(A).padStart(2, "0")}`;
  };
  return /* @__PURE__ */ P.jsxs("div", { className: "flex items-center space-x-2", children: [
    /* @__PURE__ */ P.jsx("div", { children: y(c) }),
    a ? /* @__PURE__ */ P.jsxs(P.Fragment, { children: [
      /* @__PURE__ */ P.jsx(xe, { onClick: v, children: /* @__PURE__ */ P.jsx(er, { name: "Pause" }) }),
      /* @__PURE__ */ P.jsx(xe, { onClick: p, children: /* @__PURE__ */ P.jsx(er, { name: "Square" }) })
    ] }) : /* @__PURE__ */ P.jsx(xe, { onClick: g, children: /* @__PURE__ */ P.jsx(er, { name: "Play" }) }),
    s && /* @__PURE__ */ P.jsxs("div", { className: "mt-4", children: [
      /* @__PURE__ */ P.jsx("h3", { className: "text-lg font-bold", children: "Time Entries" }),
      /* @__PURE__ */ P.jsx("ul", { children: f.map((b) => /* @__PURE__ */ P.jsxs("li", { children: [
        b.project.name,
        ": ",
        y(Math.floor((b.endTime.getTime() - b.startTime.getTime()) / 1e3))
      ] }, b.id)) }),
      /* @__PURE__ */ P.jsx(xe, { onClick: () => alert("Exporting time entries..."), children: "Export" })
    ] })
  ] });
}, K4 = ({
  workspaces: r,
  currentWorkspace: e,
  onWorkspaceChange: t,
  onWorkspaceCreate: n,
  showSearch: i = !1,
  showRecent: s = !1,
  maxRecent: a = 5
}) => {
  const [o, c] = Ct.useState(""), [l, u] = Ct.useState([]), d = (h) => {
    t(h), u(
      (g) => [h, ...g.filter((m) => m.id !== h.id)].slice(0, a)
    );
  }, f = r.filter(
    (h) => h.name.toLowerCase().includes(o.toLowerCase())
  );
  return /* @__PURE__ */ P.jsxs(Cf, { children: [
    /* @__PURE__ */ P.jsx(kf, { asChild: !0, children: /* @__PURE__ */ P.jsxs(xe, { variant: "ghost", children: [
      /* @__PURE__ */ P.jsx(er, { name: "Users", className: "mr-2" }),
      e.name,
      /* @__PURE__ */ P.jsx(er, { name: "ChevronDown", className: "ml-2" })
    ] }) }),
    /* @__PURE__ */ P.jsxs(Mf, { children: [
      i && /* @__PURE__ */ P.jsx("div", { className: "p-2", children: /* @__PURE__ */ P.jsx(
        "input",
        {
          type: "text",
          placeholder: "Search...",
          className: "w-full p-1 border rounded",
          value: o,
          onChange: (h) => c(h.target.value)
        }
      ) }),
      s && l.length > 0 && /* @__PURE__ */ P.jsxs(P.Fragment, { children: [
        /* @__PURE__ */ P.jsx("div", { className: "p-2 text-xs text-gray-500", children: "Recent" }),
        l.map((h) => /* @__PURE__ */ P.jsx(
          Dn,
          {
            onSelect: () => d(h),
            children: h.name
          },
          `recent-${h.id}`
        )),
        /* @__PURE__ */ P.jsx("hr", { className: "my-1" })
      ] }),
      f.map((h) => /* @__PURE__ */ P.jsx(
        Dn,
        {
          onSelect: () => d(h),
          children: h.name
        },
        h.id
      )),
      n && /* @__PURE__ */ P.jsxs(P.Fragment, { children: [
        /* @__PURE__ */ P.jsx("hr", { className: "my-1" }),
        /* @__PURE__ */ P.jsxs(Dn, { onSelect: n, children: [
          /* @__PURE__ */ P.jsx(er, { name: "Plus", className: "mr-2" }),
          "Create Workspace"
        ] })
      ] })
    ] })
  ] });
}, Oa = (r) => r.message.includes("Network") ? {
  type: "network",
  severity: "high",
  recoverable: !0,
  userMessage: "A network error occurred. Please check your connection and try again.",
  technicalMessage: r.message,
  suggestedActions: [{ label: "Retry", action: () => window.location.reload(), type: "primary" }]
} : r.message.includes("Permission") ? {
  type: "permission",
  severity: "medium",
  recoverable: !1,
  userMessage: "You don't have permission to perform this action.",
  technicalMessage: r.message,
  suggestedActions: []
} : {
  type: "unknown",
  severity: "critical",
  recoverable: !1,
  userMessage: "An unexpected error occurred.",
  technicalMessage: r.message,
  suggestedActions: []
}, V4 = ({
  error: r,
  severity: e,
  context: t,
  dismissible: n,
  onDismiss: i,
  showDetails: s,
  showErrorCode: a,
  actions: o,
  ...c
}) => {
  const l = r instanceof Error ? r : new Error("An error occurred"), u = Oa(l), d = {
    low: "info",
    medium: "warning",
    high: "error",
    critical: "error"
  }[e || u.severity];
  return /* @__PURE__ */ P.jsxs(
    wI,
    {
      variant: d,
      title: u.userMessage,
      context: t,
      dismissible: n,
      onClose: i,
      ...c,
      children: [
        s && /* @__PURE__ */ P.jsxs("details", { children: [
          /* @__PURE__ */ P.jsx("summary", { children: "Error Details" }),
          /* @__PURE__ */ P.jsx("pre", { children: u.technicalMessage })
        ] }),
        a && /* @__PURE__ */ P.jsxs("code", { children: [
          "Error Code: ",
          l.name
        ] }),
        /* @__PURE__ */ P.jsx("div", { children: o == null ? void 0 : o.map((f, h) => /* @__PURE__ */ P.jsx(xe, { onClick: f.action, variant: f.type, children: f.label }, h)) })
      ]
    }
  );
};
class r4 {
  report(e, t) {
    console.group("Error Reporter"), console.error("Caught an error:", e), console.log("Additional info:", t), console.groupEnd();
  }
}
const n4 = new r4();
class W4 extends $n {
  constructor(t) {
    super(t);
    Da(this, "resetError", () => {
      this.setState({ hasError: !1, error: null });
    });
    this.state = { hasError: !1, error: null };
  }
  static getDerivedStateFromError(t) {
    return { hasError: !0, error: t };
  }
  componentDidCatch(t, n) {
    n4.report(t, n), this.props.onError && this.props.onError(t, n);
  }
  render() {
    const { hasError: t, error: n } = this.state, { fallback: i, children: s, context: a, level: o } = this.props;
    return t && n ? i ? /* @__PURE__ */ P.jsx(
      i,
      {
        error: n,
        resetError: this.resetError,
        context: a,
        level: o
      }
    ) : /* @__PURE__ */ P.jsx("h1", { children: "Something went wrong." }) : s;
  }
}
const H4 = ({
  error: r,
  onSubmit: e,
  fields: t = ["description", "contactInfo"],
  showErrorDetails: n = !0,
  anonymous: i = !1
}) => {
  const [s, a] = _e({ description: "" }), [o, c] = _e(!1), l = async (d) => {
    d.preventDefault(), c(!0), await e(s), c(!1);
  }, u = (d) => {
    a({ ...s, [d.target.name]: d.target.value });
  };
  return /* @__PURE__ */ P.jsxs("form", { onSubmit: l, className: "space-y-4", children: [
    n && /* @__PURE__ */ P.jsxs("div", { children: [
      /* @__PURE__ */ P.jsx("h3", { className: "font-bold", children: "Error Details" }),
      /* @__PURE__ */ P.jsx("pre", { className: "text-sm bg-gray-100 p-2 rounded", children: r instanceof Error ? r.message : "An error occurred" })
    ] }),
    t.includes("description") && /* @__PURE__ */ P.jsxs("div", { children: [
      /* @__PURE__ */ P.jsx(ys, { htmlFor: "description", children: "Description" }),
      /* @__PURE__ */ P.jsx(gm, { id: "description", name: "description", value: s.description, onChange: u, required: !0 })
    ] }),
    t.includes("steps") && /* @__PURE__ */ P.jsxs("div", { children: [
      /* @__PURE__ */ P.jsx(ys, { htmlFor: "steps", children: "Steps to Reproduce" }),
      /* @__PURE__ */ P.jsx(gm, { id: "steps", name: "steps", value: s.steps || "", onChange: u })
    ] }),
    t.includes("impact") && /* @__PURE__ */ P.jsxs("div", { children: [
      /* @__PURE__ */ P.jsx(ys, { htmlFor: "impact", children: "Impact" }),
      /* @__PURE__ */ P.jsxs("select", { id: "impact", name: "impact", value: s.impact || "low", onChange: u, children: [
        /* @__PURE__ */ P.jsx("option", { value: "low", children: "Low" }),
        /* @__PURE__ */ P.jsx("option", { value: "medium", children: "Medium" }),
        /* @__PURE__ */ P.jsx("option", { value: "high", children: "High" })
      ] })
    ] }),
    t.includes("frequency") && /* @__PURE__ */ P.jsxs("div", { children: [
      /* @__PURE__ */ P.jsx(ys, { htmlFor: "frequency", children: "Frequency" }),
      /* @__PURE__ */ P.jsxs("select", { id: "frequency", name: "frequency", value: s.frequency || "once", onChange: u, children: [
        /* @__PURE__ */ P.jsx("option", { value: "once", children: "Once" }),
        /* @__PURE__ */ P.jsx("option", { value: "intermittent", children: "Intermittent" }),
        /* @__PURE__ */ P.jsx("option", { value: "frequent", children: "Frequent" })
      ] })
    ] }),
    !i && t.includes("contactInfo") && /* @__PURE__ */ P.jsxs("div", { children: [
      /* @__PURE__ */ P.jsx(ys, { htmlFor: "contactInfo", children: "Contact Info" }),
      /* @__PURE__ */ P.jsx(II, { id: "contactInfo", name: "contactInfo", value: s.contactInfo || "", onChange: u })
    ] }),
    /* @__PURE__ */ P.jsx(xe, { type: "submit", disabled: o, children: o ? "Submitting..." : "Submit Feedback" })
  ] });
}, q4 = ({
  error: r,
  context: e,
  showDetails: t,
  actions: n,
  severity: i,
  ...s
}) => {
  const a = r instanceof Error ? r : new Error("An error occurred"), o = Oa(a);
  return /* @__PURE__ */ P.jsx(PI, { ...s, children: /* @__PURE__ */ P.jsxs("div", { className: "p-4", children: [
    /* @__PURE__ */ P.jsx("h2", { className: "text-lg font-bold", children: o.userMessage }),
    t && /* @__PURE__ */ P.jsxs("details", { className: "mt-2", children: [
      /* @__PURE__ */ P.jsx("summary", { children: "Error Details" }),
      /* @__PURE__ */ P.jsx("pre", { className: "mt-2 text-sm bg-gray-100 p-2 rounded", children: o.technicalMessage })
    ] }),
    /* @__PURE__ */ P.jsx("div", { className: "mt-4 space-x-2", children: n == null ? void 0 : n.map((c, l) => /* @__PURE__ */ P.jsx(xe, { onClick: c.action, variant: c.type, children: c.label }, l)) })
  ] }) });
}, z4 = ({
  error: r,
  title: e,
  description: t,
  context: n = "neutral",
  illustration: i,
  actions: s,
  showHomeButton: a = !0,
  showSupportContact: o = !0
}) => {
  const c = r instanceof Error ? r : new Error("An error occurred"), l = Oa(c);
  return /* @__PURE__ */ P.jsxs("div", { className: "flex flex-col items-center justify-center min-h-screen bg-gray-100 text-center p-4", children: [
    i,
    /* @__PURE__ */ P.jsx("h1", { className: "text-4xl font-bold mt-4", children: e || l.userMessage }),
    /* @__PURE__ */ P.jsx("p", { className: "text-lg mt-2", children: t || l.technicalMessage }),
    /* @__PURE__ */ P.jsxs("div", { className: "mt-6 space-x-4", children: [
      s == null ? void 0 : s.map((u, d) => /* @__PURE__ */ P.jsx(xe, { onClick: u.action, variant: u.type, children: u.label }, d)),
      a && /* @__PURE__ */ P.jsx(xe, { onClick: () => window.location.href = "/", children: "Go Home" })
    ] }),
    o && /* @__PURE__ */ P.jsx("p", { className: "mt-4 text-sm text-gray-600", children: "If the problem persists, please contact support." })
  ] });
}, Y4 = () => {
  const { show: r } = _I();
  return { showErrorToast: (t) => {
    const n = t.error instanceof Error ? t.error : new Error("An error occurred"), i = Oa(n), s = {
      variant: "error",
      title: i.userMessage,
      description: i.technicalMessage,
      duration: t.duration,
      context: t.context,
      actions: t.action ? [{ label: t.action.label, onClick: t.action.action }] : []
    };
    r(s);
  } };
}, X4 = ({
  primaryContent: r,
  fallbackContent: e,
  error: t,
  showError: n = !1,
  onContentSwitch: i
}) => {
  const [s, a] = _e(!!t), o = () => {
    const c = !s;
    a(c), i && i(c);
  };
  return /* @__PURE__ */ P.jsxs("div", { children: [
    s ? e : r,
    n && t && /* @__PURE__ */ P.jsx("button", { onClick: o, className: "text-sm text-blue-500 mt-2", children: s ? "Show Primary Content" : "Show Fallback Content" })
  ] });
}, Q4 = ({ error: r, resetError: e, context: t, level: n }) => {
  const i = Oa(r);
  return /* @__PURE__ */ P.jsxs("div", { role: "alert", children: [
    /* @__PURE__ */ P.jsx("h2", { children: i.userMessage }),
    /* @__PURE__ */ P.jsxs("p", { children: [
      "Context: ",
      t
    ] }),
    /* @__PURE__ */ P.jsxs("p", { children: [
      "Level: ",
      n
    ] }),
    /* @__PURE__ */ P.jsxs("details", { children: [
      /* @__PURE__ */ P.jsx("summary", { children: "Error Details" }),
      /* @__PURE__ */ P.jsx("pre", { children: i.technicalMessage })
    ] }),
    i.suggestedActions.map((s, a) => /* @__PURE__ */ P.jsx(xe, { onClick: s.action, variant: s.type, children: s.label }, a)),
    /* @__PURE__ */ P.jsx(xe, { onClick: e, children: "Try again" })
  ] });
}, Z4 = ({
  message: r,
  fieldName: e,
  context: t = "neutral",
  icon: n = !0,
  animate: i = !0,
  className: s
}) => {
  const o = zb(
    "text-sm",
    {
      consultant: "text-blue-600",
      client: "text-green-600",
      admin: "text-gray-600",
      neutral: "text-red-600"
    }[t],
    { "transition-opacity duration-300 ease-in-out": i },
    s
  );
  return /* @__PURE__ */ P.jsxs("div", { className: o, role: "alert", "aria-label": `Error for ${e}`, children: [
    n && /* @__PURE__ */ P.jsx("span", { className: "mr-1", children: "!" }),
    r
  ] });
}, J4 = ({
  steps: r,
  onRecoveryComplete: e,
  onRecoveryFail: t,
  onStepComplete: n
}) => {
  const [i, s] = _e(0), [a, o] = _e(null);
  we(() => {
    (async () => {
      for (let u = 0; u < r.length; u++) {
        s(u);
        try {
          await r[u].action(), n && n(r[u]);
        } catch (d) {
          o(d), t && t(d);
          return;
        }
      }
      e && e();
    })();
  }, [r, e, t, n]);
  const c = i / r.length * 100;
  return a ? /* @__PURE__ */ P.jsxs("div", { children: [
    "Recovery failed: ",
    a.message
  ] }) : /* @__PURE__ */ P.jsxs("div", { children: [
    /* @__PURE__ */ P.jsx(Wb, { value: c }),
    /* @__PURE__ */ P.jsxs("p", { children: [
      "Step ",
      i + 1,
      " of ",
      r.length,
      ": ",
      r[i].label
    ] })
  ] });
}, eH = ({
  preserveState: r = !1,
  confirmBeforeRefresh: e = !1,
  customMessage: t = "Are you sure you want to refresh the page?",
  onBeforeRefresh: n
}) => {
  const i = () => {
    e ? window.confirm(t) && (n && n(), r || window.location.reload()) : (n && n(), r || window.location.reload());
  };
  return /* @__PURE__ */ P.jsx(xe, { onClick: i, children: "Refresh Page" });
}, tH = ({
  onRetry: r,
  maxRetries: e = 3,
  backoffMs: t = 1e3,
  exponential: n = !0,
  label: i = "Retry",
  loadingLabel: s = "Retrying...",
  failureLabel: a = "Failed"
}) => {
  const [o, c] = _e(!1), [l, u] = _e(0), d = async () => {
    c(!0), u(l + 1);
    try {
      await r(), c(!1), u(0);
    } catch {
      if (l < e) {
        const h = n ? t * 2 ** l : t;
        setTimeout(d, h);
      } else
        c(!1);
    }
  };
  return /* @__PURE__ */ P.jsx(xe, { onClick: d, disabled: o, children: o ? s : l > 0 ? `${i} (${l})` : i });
};
export {
  F4 as ActionMenu,
  CI as ActivityCard,
  h4 as BillingCard,
  j4 as BillingControls,
  $4 as ButtonGroup,
  O4 as Chart,
  u4 as ClientCard,
  U4 as ClientSelector,
  V4 as ErrorAlert,
  W4 as ErrorBoundary,
  H4 as ErrorFeedback,
  q4 as ErrorModal,
  z4 as ErrorPage,
  X4 as FallbackContent,
  Q4 as FallbackUI,
  Z4 as InlineError,
  C4 as MediaPlayer,
  m4 as ModalPortal,
  k4 as NotificationCard,
  kI as ProgressCard,
  f4 as ProjectCard,
  J4 as RecoveryProgress,
  eH as RefreshPage,
  tH as RetryButton,
  Yb as StatCard,
  M4 as StatusCard,
  g4 as TimeCard,
  G4 as TimeTracker,
  B4 as Toolbar,
  v4 as Tooltip,
  N4 as UserCard,
  d4 as WorkspaceCard,
  K4 as WorkspaceSwitcher,
  Oa as categorizeError,
  n4 as errorReporter,
  p4 as toast,
  Y4 as useErrorToast
};
